// src/types/student.types.ts - Add this new file
import { Room, Chatbot } from './database.types';

export interface StudentRoom extends Room {
  joined_at: string;
  chatbots: Chatbot[];
}// src/types/knowledge-base.types.ts
export type DocumentType = 'pdf' | 'docx' | 'txt';

export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error';

export type ChunkStatus = 'pending' | 'embedded' | 'error';

export interface Document {
  document_id: string;
  chatbot_id: string;
  file_name: string;
  file_path: string;
  file_type: DocumentType;
  file_size: number;
  status: DocumentStatus;
  error_message?: string;
  created_at: string;
  updated_at: string;
}

export interface DocumentChunk {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
  created_at: string;
}

export interface DocumentUploadResponse {
  document: Document;
  uploadUrl?: string;
}

export interface ProcessingStats {
  totalChunks: number;
  processedChunks: number;
  errorChunks: number;
}// src/types/pdf-parse.d.ts
declare module 'pdf-parse';
declare module 'pdf-parse/lib/pdf-parse.js';
declare module 'mammoth';// src/types/database.types.ts

// Base common fields for all tables
export interface BaseTable {
  created_at: string;
  updated_at?: string;
}

// User roles enum
export type UserRole = 'teacher' | 'student' | 'school_admin';

// Concern status enum/type
export type ConcernStatus = 'pending' | 'reviewing' | 'resolved' | 'false_positive';

// Knowledge Base Types
export type DocumentType = 'pdf' | 'docx' | 'txt';
export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error';
export type ChunkStatus = 'pending' | 'embedded' | 'error';

// Bot Type Enum
export type BotTypeEnum = 'learning' | 'assessment';

// Assessment Status Enum
export type AssessmentStatusEnum = 'ai_processing' | 'ai_completed' | 'teacher_reviewed';


// --- Table Interfaces ---

export interface School extends BaseTable {
  school_id: string;
  name: string;
  magic_link_token?: string;
  token_expires_at?: string;
}

export interface Chatbot extends BaseTable {
  chatbot_id: string;
  name: string;
  description?: string;
  system_prompt: string;
  teacher_id: string;
  model?: string;
  max_tokens?: number | null;
  temperature?: number | null;
  enable_rag?: boolean;
  bot_type?: BotTypeEnum;
  assessment_criteria_text?: string | null;
}

export interface Room extends BaseTable {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id?: string | null;
  is_active: boolean;
}

export interface RoomChatbot extends BaseTable {
  room_id: string;
  chatbot_id: string;
}

export interface RoomMembership extends BaseTable {
  room_id: string;
  student_id: string;
  joined_at: string;
}

export interface ChatMessage extends BaseTable {
    message_id: string;
    room_id: string;
    user_id: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    tokens_used?: number;
    metadata?: {
        chatbotId?: string | null;
        error?: unknown;
        isAssessmentFeedback?: boolean;
        isAssessmentPlaceholder?: boolean;
        assessmentId?: string | null;
        [key: string]: unknown;
    } | null;
}

export interface Profile extends BaseTable {
  user_id: string;
  full_name?: string;
  email: string;
  role: UserRole;
  school_id?: string | null;
}

export interface Document extends BaseTable {
  document_id: string;
  chatbot_id: string;
  file_name: string;
  file_path: string;
  file_type: DocumentType;
  file_size: number;
  status: DocumentStatus;
  error_message?: string;
}

export interface DocumentChunk extends BaseTable {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
}

export interface FlaggedMessage extends BaseTable {
  flag_id: string;
  message_id: string;
  student_id: string;
  teacher_id: string;
  room_id: string;
  concern_type: string;
  concern_level: number;
  analysis_explanation?: string;
  context_messages?: Record<string, unknown>;
  status: ConcernStatus;
  reviewed_at?: string;
  reviewer_id?: string | null;
  notes?: string;
}

export interface StudentAssessment extends BaseTable {
    assessment_id: string;
    student_id: string;
    chatbot_id: string;
    room_id: string;
    assessed_message_ids?: string[];
    teacher_id?: string | null;
    teacher_assessment_criteria_snapshot?: string | null;
    ai_feedback_student?: string | null;
    ai_assessment_details_raw?: string | null;
    ai_grade_raw?: string | null;
    ai_assessment_details_teacher?: {
        summary?: string;
        strengths?: string[];
        areas_for_improvement?: string[];
        grading_rationale?: string;
        [key: string]: unknown;
    } | null;
    teacher_override_grade?: string | null;
    teacher_override_notes?: string | null;
    status?: AssessmentStatusEnum;
    assessed_at: string;
}


// --- Database Schema Type ---
export interface Database {
  schools: School;
  profiles: Profile;
  chatbots: Chatbot;
  rooms: Room;
  room_chatbots: RoomChatbot;
  room_memberships: RoomMembership;
  chat_messages: ChatMessage;
  documents: Document;
  document_chunks: DocumentChunk;
  flagged_messages: FlaggedMessage;
  student_assessments: StudentAssessment;
}

// --- API Payload Types ---
export interface CreateSchoolPayload {
  name: string;
}

export interface CreateChatbotPayload {
  name: string;
  description?: string;
  system_prompt: string;
  model?: string;
  max_tokens?: number | null;
  temperature?: number | null;
  enable_rag?: boolean;
  bot_type?: BotTypeEnum;
  assessment_criteria_text?: string | null;
}

export interface CreateRoomPayload {
  room_name: string;
  chatbot_ids: string[];
}

export interface UpdateRoomChatbotsPayload {
  chatbot_ids: string[];
}

export interface JoinRoomPayload {
  room_code: string;
}

export interface SendMessagePayload {
  content: string;
  room_id: string;
  chatbot_id: string;
}

// Payload for updating an assessment (teacher review)
export interface UpdateAssessmentPayload {
    teacher_override_grade?: string | null;
    teacher_override_notes?: string | null;
    status?: AssessmentStatusEnum;
}


// --- API Response Detail Types ---

export interface FlaggedConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

export interface StudentRoom extends Room {
  joined_at: string;
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'description' | 'bot_type'>[];
}

export interface TeacherRoom extends Room {
   room_chatbots: {
       chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type'> | null;
   }[] | null;
}

// For single student assessment detail API
export interface DetailedAssessmentResponse extends StudentAssessment {
    student_name?: string | null;
    student_email?: string | null;
    chatbot_name?: string | null;
    assessed_conversation?: ChatMessage[]; // Changed DbChatMessage to ChatMessage for consistency
}

// For the list of assessments for a teacher
export interface AssessmentListSummary extends Pick<
    StudentAssessment,
    'assessment_id' | 'student_id' | 'chatbot_id' | 'room_id' | 'teacher_id' |
    'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'
> {
    student_name?: string | null;
    chatbot_name?: string | null;
    room_name?: string | null;
}

// For the paginated response of assessment lists
export interface PaginatedAssessmentsResponse {
    assessments: AssessmentListSummary[];
    pagination: {
        currentPage: number;
        pageSize: number;
        totalCount: number;
        totalPages: number;
    };
}

// This might be redundant if DetailedAssessmentResponse is sufficient.
// If used, ensure ChatMessage is defined or imported as DbChatMessage
// export interface StudentAssessmentDetails extends StudentAssessment {
//     chatbot_name?: string;
//     room_name?: string; 
// }// src/types/auth.types.ts
import { User, Session } from '@supabase/supabase-js';
import { UserRole } from './database.types';

export interface AuthUser extends User {
  role?: UserRole;
  school_id?: string;
}

export interface AuthSession extends Session {
  user: AuthUser;
}

export interface SignUpData {
  email: string;
  password: string;
  fullName?: string;
  role: UserRole;
  schoolId?: string;
}

export interface SignInData {
  email: string;
  password: string;
}

export interface MagicLinkData {
  email: string;
  schoolId: string;
}// src/types/chatbot.types.ts
import type { ChatMessage as DatabaseChatMessage } from './database.types'; // Import the corrected type

// ChatMessage is now imported and used as DatabaseChatMessage or aliased if needed.
// REMOVE the old definition:
// export interface ChatMessage { ... }

export interface ChatbotConfig {
  name: string;
  description?: string;
  systemPrompt: string;
  model?: 'x-ai/grok-3-mini-beta' | 'qwen/qwen3-235b-a22b' | 'google/gemini-2.5-flash-preview'; // Updated model options
  maxTokens?: number;
  temperature?: number;
}

export interface ChatContext {
  chatbotId: string;
  roomId: string;
  systemPrompt: string;
  conversationHistory: DatabaseChatMessage[]; // Use the imported type
}

export interface ChatResponse {
  message: string;
  tokensUsed?: number;
  error?: string;
}// src/app/room/[roomId]/student/[studentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import StudentChatHistory from '@/components/teacher/StudentChatHistory';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    align-items: flex-start;
  }
`;

const StudentInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
  }
`;

const BackButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

// Define explicit types
interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

// Define a more specific type for the chatbots nested object
interface RoomChatbotResponse {
  chatbot_id: string;
  chatbots: {
    chatbot_id: string;
    name: string;
  } | Array<{
    chatbot_id: string;
    name: string;
  }>;
}

export default function StudentChatPage() {
  const params = useParams();
  const roomId = params?.roomId as string;
  const studentId = params?.studentId as string;
  const [studentName, setStudentName] = useState<string>('Student');
  const [chatbots, setChatbots] = useState<ChatbotOption[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const supabase = createClient();

  const fetchPageData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Get user info
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }
      
      // Get student info - handle missing columns gracefully
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', studentId)
        .single();
        
      if (profile) {
        // Try different fields that might contain the name
        // The error suggests profiles.name doesn't exist, so check other fields
        if (profile.full_name) {
          setStudentName(profile.full_name);
        } else if (profile.email) {
          setStudentName(profile.email.split('@')[0]);
        } else if (profile.user_id) {
          // Last resort - use a generic label
          setStudentName('Student');
        }
      }
      
      // Get chatbots in this room
      const { data: roomChatbots } = await supabase
        .from('room_chatbots')
        .select(`
          chatbot_id,
          chatbots:chatbots!inner(
            chatbot_id,
            name
          )
        `)
        .eq('room_id', roomId);
        
      if (roomChatbots && roomChatbots.length > 0) {
        // Extract chatbot data with proper typing
        const chatbotList: ChatbotOption[] = [];
        
        // Type assertion to help TypeScript understand the structure
        const typedRoomChatbots = roomChatbots as unknown as RoomChatbotResponse[];
        
        typedRoomChatbots.forEach(item => {
          // Safely check and extract chatbot data
          if (item.chatbots) {
            if (Array.isArray(item.chatbots)) {
              item.chatbots.forEach(cb => {
                chatbotList.push({
                  chatbot_id: cb.chatbot_id,
                  name: cb.name
                });
              });
            } else {
              // It's a single object, not an array
              const cb = item.chatbots;
              chatbotList.push({
                chatbot_id: cb.chatbot_id,
                name: cb.name
              });
            }
          }
        });
        
        setChatbots(chatbotList);
      }
    } catch (err) {
      console.error('Error loading page data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load page data');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, router, supabase]);

  useEffect(() => {
    fetchPageData();
  }, [fetchPageData]);

  const handleBack = () => {
    router.push(`/room/${roomId}`);
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <Card>
            <p>Loading...</p>
          </Card>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Room
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <StudentInfo>
            <h1>{studentName}</h1>
            <p>Chat History</p>
          </StudentInfo>
          <BackButton 
            variant="outline" 
            onClick={handleBack}
          >
            ← Back to Room
          </BackButton>
        </Header>
        
        <StudentChatHistory
          roomId={roomId}
          studentId={studentId}
          studentName={studentName}
          chatbots={chatbots}
        />
      </Container>
    </PageWrapper>
  );
}// src/app/room/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Alert, Button } from '@/styles/StyledComponents';
import StudentList from '@/components/teacher/StudentList';
import type { Chatbot } from '@/types/database.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md} 0;
  }
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    gap: ${({ theme }) => theme.spacing.md};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1.5rem;
      text-align: center;
    }
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1rem;
      text-align: center;
    }
  }
  
  .room-code {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-top: ${({ theme }) => theme.spacing.xs};
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      text-align: center;
    }
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    justify-content: center;
  }
`;

const ChatbotGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  margin-top: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  cursor: pointer;
  
  &:hover {
    transform: translateY(-4px);
    box-shadow: ${({ theme }) => theme.shadows.lg};
  }
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.5rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    min-height: 3rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }
  
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    display: inline-block;
  }
  
  .chat-button {
    width: 100%;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: 44px;
    }
  }
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: {
    chatbots: Chatbot;
  }[] | null;
}

export default function RoomPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  
  const params = useParams();
  const roomId = params?.roomId as string;
  const router = useRouter();
  const supabase = createClient();

  const fetchRoomData = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Get user role
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (!profile) throw new Error('User profile not found');
      setUserRole(profile.role);

      // First, ensure we have access to this room
      let hasAccess = false;
      if (profile.role === 'teacher') {
        // For teachers, check if they own the room
        const { data: teacherRoom } = await supabase
          .from('rooms')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('teacher_id', user.id)
          .single();
        
        hasAccess = !!teacherRoom;
      } else if (profile.role === 'student') {
        // For students, check if they're a member of the room
        const { data: membership } = await supabase
          .from('room_memberships')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('student_id', user.id)
          .single();
        
        hasAccess = !!membership;
      }

      if (!hasAccess) {
        throw new Error('You do not have access to this room');
      }

      // Get basic room info
      const { data: roomData, error: roomError } = await supabase
        .from('rooms')
        .select('*')
        .eq('room_id', roomId)
        .single();

      if (roomError || !roomData) {
        throw new Error('Room not found');
      }

      // Retrieve chatbots using a two-step process to bypass potential RLS issues
      // Step 1: Get chatbot IDs for this room
      const { data: roomChatbots, error: rcError } = await supabase
        .from('room_chatbots')
        .select('chatbot_id')
        .eq('room_id', roomId);

      if (rcError) {
        console.error('Error fetching room-chatbot relations:', rcError);
        throw new Error('Failed to retrieve chatbot information');
      }

      // Step 2: Get the chatbot details
      const extractedChatbots: Chatbot[] = [];
      
      if (roomChatbots && roomChatbots.length > 0) {
        const chatbotIds = roomChatbots.map(rc => rc.chatbot_id);
        
        const { data: chatbots, error: chatbotsError } = await supabase
          .from('chatbots')
          .select('*')
          .in('chatbot_id', chatbotIds);

        if (chatbotsError) {
          console.error('Error fetching chatbots:', chatbotsError);
          throw new Error('Failed to retrieve chatbot information');
        }
        
        extractedChatbots.push(...(chatbots || []));
      }
      
      // Set the state variables
      setRoom({
        ...roomData,
        room_chatbots: []
      } as RoomQueryResult);
      setChatbots(extractedChatbots);
    } catch (err) {
      console.error('Error in fetchRoomData:', err);
      setError(err instanceof Error ? err.message : 'Failed to load room');
    } finally {
      setLoading(false);
    }
  }, [roomId, supabase]);

  useEffect(() => {
    if (roomId) {
      fetchRoomData();
    }
  }, [roomId, fetchRoomData]);

  const handleBack = () => {
    if (userRole === 'teacher') {
      router.push('/teacher-dashboard');
    } else {
      router.push('/student');
    }
  };

  const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
      'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
      'google/gemma-3-27b-it:free': 'Gemma 3 27B',
      'microsoft/phi-4-reasoning-plus:free': 'Phi 4 Reasoning',
      'qwen/qwen3-32b:free': 'Qwen3 32B',
      'qwen/qwen3-235b-a22b:free': 'Qwen3 235B'
    };
    return modelNames[model] || model;
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <Card>Loading room...</Card>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Dashboard
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!room) {
    return null;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>
              {chatbots.length === 0 ? 'No chatbots available' : 
               chatbots.length === 1 ? '1 chatbot available' :
               `${chatbots.length} chatbots available`}
            </p>
            <div className="room-code">Room Code: {room.room_code}</div>
          </RoomInfo>
          <BackButton onClick={handleBack}>
            ← Back
          </BackButton>
        </Header>

        {chatbots.length === 0 ? (
          <EmptyState>
            <h3>No Chatbots Available</h3>
            <p>This room doesn&apos;t have any chatbots assigned yet.</p>
            {userRole === 'teacher' && (
              <p>Go back to the dashboard to assign chatbots to this room.</p>
            )}
          </EmptyState>
        ) : (
          <ChatbotGrid>
            {chatbots.map((chatbot) => (
              <Link 
                key={chatbot.chatbot_id} 
                href={`/chat/${roomId}?chatbot=${chatbot.chatbot_id}`}
                style={{ textDecoration: 'none' }}
              >
                <ChatbotCard>
                  <h3>{chatbot.name}</h3>
                  <p>{chatbot.description || 'No description'}</p>
                  
                  <div className="model-info">
                    {getModelDisplayName(chatbot.model)}
                  </div>
                  
                  <Button 
                    className="chat-button"
                    as="div"  // Prevent double link
                  >
                    Start Chat
                  </Button>
                </ChatbotCard>
              </Link>
            ))}
          </ChatbotGrid>
        )}
        
        {/* Student list section - only visible to teachers */}
        {userRole === 'teacher' && (
          <StudentList roomId={roomId} />
        )}
      </Container>
    </PageWrapper>
  );
}// src/app/magic-link/page.tsx
'use client';

import MagicLink from '@/components/auth/MagicLink';
import { Container } from '@/styles/StyledComponents';

export default function MagicLinkPage() {
  return (
    <Container>
      <MagicLink />
    </Container>
  );
}// src/app/join/page.tsx
'use client';

import { useState, useEffect, useCallback, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Input, Alert } from '@/styles/StyledComponents';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const JoinCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

function JoinPageContent() {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userRole, setUserRole] = useState<string | null>(null);
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const checkAuthentication = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      setIsAuthenticated(true);
      
      // Get user role
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
      
      if (profile) {
        setUserRole(profile.role);
      }
    }
  }, [supabase]);

  useEffect(() => {
    // Get room code from URL parameter
    const codeFromUrl = searchParams?.get('code');
    if (codeFromUrl) {
      setRoomCode(codeFromUrl.toUpperCase());
    }
    
    checkAuthentication();
  }, [searchParams, checkAuthentication]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    const formattedCode = roomCode.toUpperCase();

    try {
      // Check if the room exists first
      const { data: room, error: roomError } = await supabase
        .from('rooms')
        .select('room_id, is_active')
        .eq('room_code', formattedCode)
        .single();

      if (roomError || !room) {
        throw new Error('Room not found');
      }

      if (!room.is_active) {
        throw new Error('Room is inactive');
      }

      if (isAuthenticated && userRole === 'student') {
        // If already authenticated as student, try to join directly
        const response = await fetch('/api/student/join-room', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ room_code: formattedCode }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to join room');
        }

        // Redirect to student dashboard
        router.push('/student');
      } else if (!isAuthenticated) {
        // If not authenticated, redirect to student signup with room code
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
      } else {
        // If authenticated but not a student, show error
        throw new Error('You need to log in with a student account to join this room.');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to join room');
    } finally {
      setIsLoading(false);
    }
  };

  if (!isAuthenticated) {
    return (
      <PageWrapper>
        <Container>
          <JoinCard>
            <Title>Join Your Class</Title>
            <Text>You need to create a student account to join this classroom.</Text>
            
            <Button 
              onClick={() => router.push(`/auth?type=student&redirect=/join?code=${roomCode}`)}
              style={{ width: '100%' }}
            >
              Create Student Account
            </Button>
            
            {roomCode && (
              <Text style={{ marginTop: '1rem', fontSize: '0.875rem' }}>
                Room code: <strong>{roomCode}</strong>
              </Text>
            )}
          </JoinCard>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <JoinCard>
          <Title>Join Your Class</Title>
          <Text>Enter the room code your teacher provided</Text>
          
          {error && <Alert variant="error">{error}</Alert>}
          
          <Form onSubmit={handleSubmit}>
            <RoomCodeInput
              type="text"
              value={roomCode}
              onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
              placeholder="ROOM CODE"
              maxLength={6}
              required
            />
            <Button type="submit" disabled={isLoading} style={{ width: '100%' }}>
              {isLoading ? 'Joining...' : 'Join Class'}
            </Button>
          </Form>
        </JoinCard>
      </Container>
    </PageWrapper>
  );
}

export default function JoinPage() {
  return (
    <Suspense fallback={<LoadingFallback>Loading...</LoadingFallback>}>
      <JoinPageContent />
    </Suspense>
  );
}// src/app/chat/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Alert } from '@/styles/StyledComponents';
import Chat from '@/components/shared/Chat'; // << UNCOMMENT THIS IMPORT
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.75rem;
  }

  p {
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};

  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string | null;
  is_active: boolean;
  created_at: string;
  updated_at?: string;
  room_chatbots: {
    chatbots: Chatbot;
  }[] | null;
}

export default function ChatPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const params = useParams();
  const searchParams = useSearchParams();
  const router = useRouter();
  const supabase = createClient();

  const roomId = params?.roomId as string;
  const chatbotIdFromUrl = searchParams.get('chatbot');
  const initialFetchDoneRef = useRef(false);

  useEffect(() => {
    console.log('[ChatPage] Initializing/Params Update. Room ID:', roomId, 'Chatbot ID:', chatbotIdFromUrl);
    if (initialFetchDoneRef.current && (params?.roomId !== roomId || searchParams.get('chatbot') !== chatbotIdFromUrl)) {
        initialFetchDoneRef.current = false;
    }
  }, [roomId, chatbotIdFromUrl, params?.roomId, searchParams]);

  const fetchRoomData = useCallback(async () => {
    if (!roomId || !chatbotIdFromUrl) {
      console.warn("[ChatPage] fetchRoomData: Aborting fetch - RoomID or ChatbotID is missing.", { roomId, chatbotIdFromUrl });
      if (roomId && chatbotIdFromUrl === null) {
          setError("Chatbot ID is required in the URL (e.g., ?chatbot=...).");
      } else if (!roomId && chatbotIdFromUrl){
          setError("Room ID is missing from the URL path.");
      } else if (!roomId && !chatbotIdFromUrl) {
          setError("Both Room ID and Chatbot ID are missing from the URL.");
      }
      setLoading(false);
      return;
    }
    console.log(`[ChatPage] fetchRoomData: Attempting fetch. RoomID: ${roomId}, ChatbotID: ${chatbotIdFromUrl}`);
    setLoading(true);
    setError(null);
    initialFetchDoneRef.current = true;

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
      if (!profile) throw new Error('User profile not found');

      const { data: roomData, error: roomError } = await supabase.from('rooms')
        .select(`*, room_chatbots!inner(chatbots!inner(chatbot_id, name, description, system_prompt, model, max_tokens, temperature, enable_rag, bot_type, assessment_criteria_text))`)
        .eq('room_id', roomId).eq('room_chatbots.chatbot_id', chatbotIdFromUrl).single();

      if (roomError) throw new Error(roomError.message || 'Data not found. Check room/chatbot association or permissions.');
      if (!roomData) throw new Error('No data returned for room/chatbot. Check IDs and permissions.');

      if (profile.role === 'student') {
        const { data: membership } = await supabase.from('room_memberships').select('room_id').eq('room_id', roomId).eq('student_id', user.id).single();
        if (!membership) throw new Error('You do not have access to this room');
      } else if (profile.role === 'teacher') {
        if (roomData.teacher_id !== user.id) throw new Error('You do not own this room');
      }

      const typedRoomData = roomData as RoomQueryResult;
      setRoom(typedRoomData);
      if (typedRoomData.room_chatbots && typedRoomData.room_chatbots.length > 0) {
        setChatbot(typedRoomData.room_chatbots[0].chatbots);
      } else { throw new Error('Chatbot details missing in fetched room data.'); }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load chat page data');
      setChatbot(null); setRoom(null);
    } finally {
      setLoading(false);
    }
  }, [roomId, chatbotIdFromUrl, supabase, router]);

  useEffect(() => {
    if (roomId && chatbotIdFromUrl && !initialFetchDoneRef.current) {
      fetchRoomData();
    }
  }, [roomId, chatbotIdFromUrl, fetchRoomData]);

  const handleBack = () => { if (roomId) router.push(`/room/${roomId}`); else router.push('/'); };

  if (loading) {
    return <PageWrapper><Container><LoadingContainer><LoadingSpinner size="large" /><p>Loading chat environment...</p></LoadingContainer></Container></PageWrapper>;
  }
  if (error) {
    return <PageWrapper><Container><Alert variant="error">{error}</Alert><BackButton onClick={handleBack} style={{ marginTop: '16px' }}>{'< Back to Room'}</BackButton></Container></PageWrapper>;
  }
  if (!room || !chatbot) {
    return <PageWrapper><Container><Alert variant="info">Chatbot or room information is unavailable. Ensure Chatbot ID is in URL.</Alert><BackButton onClick={handleBack} style={{ marginTop: '16px' }}>{'< Back to Room'}</BackButton></Container></PageWrapper>;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>Chatting with: <strong>{chatbot.name}</strong></p>
            {chatbot.bot_type === 'assessment' && <p style={{fontSize: '0.9em', fontStyle: 'italic', color: '#555'}}>This is an Assessment Bot.</p>}
          </RoomInfo>
          <BackButton onClick={handleBack}>
            {'< Back to Room'}
          </BackButton>
        </Header>
        {/* UNCOMMENTING THE CHAT COMPONENT */}
        <Chat roomId={roomId} chatbot={chatbot} />
        {/* REMOVE THE PLACEHOLDER DIV
        <div style={{ padding: '20px', border: '2px dashed blue', textAlign: 'center', marginTop: '20px' }}>
          <p>Chat Component is temporarily removed for debugging the page load.</p>
          <p>If you see this, ChatPage itself is rendering correctly.</p>
          <p>Room: {room.room_name} (ID: {room.room_id})</p>
          <p>Chatbot: {chatbot.name} (ID: {chatbot.chatbot_id}, Type: {chatbot.bot_type})</p>
        </div>
        */}
      </Container>
    </PageWrapper>
  );
}// src/app/auth/callback/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const code = searchParams.get('code');

  if (code) {
    const supabase = await createServerSupabaseClient();
    const { error } = await supabase.auth.exchangeCodeForSession(code);
    
    if (error) {
      console.error('Error exchanging code for session:', error);
      return NextResponse.redirect(new URL('/auth', request.url));
    }
    
    // Get user data to determine redirect
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      // Wait for profile to be created by trigger
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
      
      // Get redirect URL from query params or use role-based default
      const redirectTo = searchParams.get('redirect');
      
      if (redirectTo) {
        return NextResponse.redirect(new URL(redirectTo, request.url));
      }
      
      // Role-based redirect
      if (profile?.role === 'teacher') {
        return NextResponse.redirect(new URL('/teacher-dashboard', request.url));
      } else if (profile?.role === 'student') {
        return NextResponse.redirect(new URL('/student', request.url));
      }
    }
  }

  // Default redirect if no specific route
  return NextResponse.redirect(new URL('/', request.url));
}// src/app/auth/page.tsx
'use client';

import { useState, Suspense } from 'react';
import styled from 'styled-components';
import { useSearchParams } from 'next/navigation';
import AuthForm from '@/components/auth/AuthForm';
import { Container } from '@/styles/StyledComponents';

const AuthPage = styled.div`
  padding: ${({ theme }) => theme.spacing.xl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const ToggleButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  margin-top: ${({ theme }) => theme.spacing.md};
  text-align: center;
  display: block;
  width: 100%;

  &:hover {
    text-decoration: underline;
  }
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

// Separate component for content that uses search params
function AuthContent() {
  const searchParams = useSearchParams();
  const isStudentSignup = searchParams?.get('type') === 'student';
  const [authType, setAuthType] = useState<'login' | 'signup'>(isStudentSignup ? 'signup' : 'login');

  return (
    <>
      <AuthForm type={authType} />
      <ToggleButton onClick={() => setAuthType(authType === 'login' ? 'signup' : 'login')}>
        {authType === 'login' ? 'Need an account? Sign up' : 'Already have an account? Login'}
      </ToggleButton>
    </>
  );
}

export default function Auth() {
  return (
    <AuthPage>
      <Container>
        <Suspense fallback={<LoadingFallback>Loading...</LoadingFallback>}>
          <AuthContent />
        </Suspense>
      </Container>
    </AuthPage>
  );
}// src/app/student/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';

const StudentLayout = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`;

export default function StudentLayoutWrapper({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkAccess = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
          router.push('/join');
          return;
        }

        // Fetch user profile to check role
        const { data: profile, error } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', user.id)
          .single();

        if (error || !profile || profile.role !== 'student') {
          router.push('/');
          return;
        }

        setIsAuthorized(true);
      } catch (error) {
        console.error('Error checking access:', error);
        router.push('/join');
      } finally {
        setIsLoading(false);
      }
    };

    checkAccess();
  }, [router, supabase]);

  if (isLoading) {
    return (
      <LoadingOverlay>
        <div>Loading...</div>
      </LoadingOverlay>
    );
  }

  if (!isAuthorized) {
    return null; // Will redirect
  }

  return (
    <StudentLayout>
      <MainContent>
        <Container>
          {children}
        </Container>
      </MainContent>
      <Footer />
    </StudentLayout>
  );
}// src/app/student/page.tsx - Modified version
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import RoomList from '@/components/student/RoomList';
import JoinRoom from '@/components/student/JoinRoom';
import type { StudentRoom } from '@/types/student.types';
import type { User } from '@supabase/supabase-js';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const Hero = styled.section`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl} 0;
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.primary};
  font-size: 3rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const CTAButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const Actions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
`;

export default function StudentPage() {
  const [user, setUser] = useState<User | null>(null);
  const [rooms, setRooms] = useState<StudentRoom[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showJoinRoom, setShowJoinRoom] = useState(false);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  const fetchRooms = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Check if user is a teacher, if so redirect
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
      
      // If user is a teacher, redirect to teacher dashboard
      if (profile?.role === 'teacher') {
        setIsRedirecting(true);
        router.push('/teacher-dashboard');
        return;
      }

      const response = await fetch('/api/student/rooms');
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch rooms');
      }

      setRooms(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch rooms');
    } finally {
      setLoading(false);
    }
  }, [supabase, router]);

  useEffect(() => {
    const checkUserAndRedirect = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        setUser(user);
        
        if (user) {
          setIsRedirecting(true);
          
          // Get user profile to check role
          const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
          
          if (profile?.role === 'teacher') {
            router.push('/teacher-dashboard');
          } else {
            fetchRooms();
          }
        }
      } catch (error) {
        console.error('Error checking user:', error);
      } finally {
        setLoading(false);
        setIsRedirecting(false);
      }
    };

    checkUserAndRedirect();
  }, [router, supabase, fetchRooms]);

  if (loading || isRedirecting) {
    return (
      <PageWrapper>
        <Container>
          <Hero>
            <Title>Loading...</Title>
          </Hero>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Hero>
          <Title>ClassBots AI</Title>
          <Subtitle>AI-powered chatbots for modern classrooms</Subtitle>
          
          {!user && (
            <CTAButtons>
              <Button size="large" onClick={() => router.push('/auth')}>
                Teacher Sign In
              </Button>
              <Button size="large" variant="secondary" onClick={() => router.push('/join')}>
                Student: Join Class
              </Button>
            </CTAButtons>
          )}
        </Hero>

        {error && <Alert variant="error">{error}</Alert>}

        {user && (
          <Actions>
            <Button onClick={() => setShowJoinRoom(true)}>
              Join New Room
            </Button>
          </Actions>
        )}

        {showJoinRoom && (
          <JoinRoom 
            onClose={() => setShowJoinRoom(false)}
            onSuccess={fetchRooms}
          />
        )}

        {user && rooms.length > 0 ? (
          <RoomList rooms={rooms} />
        ) : user ? (
          <EmptyState>
            <h3>No Rooms Yet</h3>
            <p>You haven&apos;t joined any classrooms yet.</p>
            <Button onClick={() => setShowJoinRoom(true)}>
              Join Your First Room
            </Button>
          </EmptyState>
        ) : null}
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/assessments/[assessmentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// createClient is not strictly needed here anymore if PATCH is via API route,
// but keeping it in case you want direct client-side Supabase calls for other things.
// import { createClient } from '@/lib/supabase/client'; 
import {
    Container, Card, Button, Alert, Badge,
    FormGroup, Label, Input, TextArea,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type {
    StudentAssessment,
    ChatMessage as DbChatMessage,
    AssessmentStatusEnum
} from '@/types/database.types';

interface DetailedAssessmentData extends StudentAssessment {
    student_name?: string | null;
    student_email?: string | null;
    chatbot_name?: string | null;
    assessed_conversation?: DbChatMessage[];
}

// ... (Styled Components: PageWrapper, Header, PageTitle, BackButton, MainGrid, etc. remain THE SAME as in content-reply-032)
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const PageTitle = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.8rem;
`;

const BackButton = styled(Button)``;

const MainGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr; 
  gap: ${({ theme }) => theme.spacing.xl};
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    grid-template-columns: 1fr; 
  }
`;

const ConversationContextCard = styled(Card)`
  max-height: 75vh; 
  display: flex;
  flex-direction: column;
  overflow: hidden; 
`;

const CardHeader = styled.h2`
  padding-bottom: ${({ theme }) => theme.spacing.md};
  margin: 0 0 ${({ theme }) => theme.spacing.md} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  font-size: 1.3rem;
  color: ${({ theme }) => theme.colors.text};
`;

const MessagesList = styled.div`
  flex-grow: 1;
  overflow-y: auto;
  padding-right: ${({ theme }) => theme.spacing.sm}; 
`;

const AssessmentDetailsCard = styled(Card)`
  align-self: start; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    margin-top: ${({ theme }) => theme.spacing.xl};
  }
`;

const DetailItem = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-size: 0.9rem;
  line-height: 1.5;
  strong { 
    display: block; font-weight: 600; color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.xs}; font-size: 0.8rem;
    text-transform: uppercase; letter-spacing: 0.03em;
  }
  span, p, div.content { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; }
  p { margin: 0; }
`;

const AnalysisBlock = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  font-size: 0.875rem;
  margin-top: ${({ theme }) => theme.spacing.xs};
  ul { list-style-position: inside; padding-left: ${({ theme }) => theme.spacing.sm}; margin-top: ${({ theme }) => theme.spacing.xs}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }
`;

const TeacherReviewForm = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;

// Simple Divider styled-component
const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.lg} 0;
`;


export default function AssessmentDetailPage() {
  const [assessment, setAssessment] = useState<DetailedAssessmentData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [teacherGrade, setTeacherGrade] = useState('');
  const [teacherNotes, setTeacherNotes] = useState('');
  const [currentStatus, setCurrentStatus] = useState<AssessmentStatusEnum>('ai_processing'); // Default
  const [isSubmittingReview, setIsSubmittingReview] = useState(false);
  const [reviewError, setReviewError] = useState<string | null>(null);
  const [reviewSuccess, setReviewSuccess] = useState<string | null>(null);

  const params = useParams();
  const router = useRouter();
  // const supabase = createClient(); // Not needed if PATCH is through API route
  const assessmentId = params?.assessmentId as string;

  const fetchAssessmentDetails = useCallback(async () => {
    if (!assessmentId) { /* ... */ setError("Assessment ID is missing."); setLoading(false); return; }
    setLoading(true); setError(null);
    try {
      const response = await fetch(`/api/teacher/assessments?assessmentId=${assessmentId}`);
      if (!response.ok) { /* ... error handling ... */ throw new Error('Failed to fetch assessment details'); }
      const data: DetailedAssessmentData = await response.json();
      setAssessment(data);
      setTeacherGrade(data.teacher_override_grade || data.ai_grade_raw || '');
      setTeacherNotes(data.teacher_override_notes || '');
      setCurrentStatus(data.status || 'ai_completed'); // Default to ai_completed if status is null
    } catch (err) { /* ... error handling ... */ setError(err instanceof Error ? err.message : 'Could not load details.'); }
    finally { setLoading(false); }
  }, [assessmentId]);

  useEffect(() => {
    if (assessmentId) { // Ensure assessmentId is present before fetching
        fetchAssessmentDetails();
    } else {
        setError("Assessment ID not found in URL.");
        setLoading(false);
    }
  }, [assessmentId, fetchAssessmentDetails]); // fetchAssessmentDetails is stable due to useCallback

  // ***** UPDATED handleReviewSubmit *****
  const handleReviewSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!assessment) return;

    setIsSubmittingReview(true);
    setReviewError(null);
    setReviewSuccess(null);

    const payload = {
        teacher_override_grade: teacherGrade.trim() === '' ? null : teacherGrade.trim(),
        teacher_override_notes: teacherNotes.trim() === '' ? null : teacherNotes.trim(),
        status: currentStatus,
    };

    try {
        const response = await fetch(`/api/teacher/assessments?assessmentId=${assessment.assessment_id}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
        });

        const responseData = await response.json();

        if (!response.ok) {
            throw new Error(responseData.error || 'Failed to save teacher review.');
        }

        setReviewSuccess("Teacher review saved successfully!");
        // Update local assessment state with the successfully saved data from the API response
        setAssessment(prev => prev ? ({ ...prev, ...responseData }) : null); 
        // Or, if you prefer to update fields directly from form state:
        // setAssessment(prev => prev ? ({
        //     ...prev,
        //     teacher_override_grade: payload.teacher_override_grade,
        //     teacher_override_notes: payload.teacher_override_notes,
        //     status: payload.status,
        //     updated_at: new Date().toISOString() // Or use updated_at from responseData
        // }) : null);

    } catch (err) {
        setReviewError(err instanceof Error ? err.message : 'An unknown error occurred.');
    } finally {
        setIsSubmittingReview(false);
    }
  };
  // ***** END OF UPDATED handleReviewSubmit *****


  if (loading) { /* ... loading UI ... */ }
  if (error) { /* ... error UI ... */ }
  if (!assessment) { /* ... no assessment UI ... */ }

  // (Make sure to destructure all fields you need from assessment)
  const student_name = assessment?.student_name;
  const student_email = assessment?.student_email;
  const chatbot_name = assessment?.chatbot_name;
  const assessed_at = assessment?.assessed_at;
  const teacher_assessment_criteria_snapshot = assessment?.teacher_assessment_criteria_snapshot;
  const ai_feedback_student = assessment?.ai_feedback_student;
  const ai_grade_raw = assessment?.ai_grade_raw;
  const ai_assessment_details_teacher = assessment?.ai_assessment_details_teacher;
  const assessed_conversation = assessment?.assessed_conversation;


  return (
    <PageWrapper>
      <Container>
        <Header>
          <PageTitle>Review Assessment: {student_name || 'Student'}</PageTitle>
          <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard/assessments')}>
            {'<'} All Assessments
          </BackButton>
        </Header>

        <MainGrid>
          <ConversationContextCard>
            {/* ... Conversation display ... */}
            <CardHeader>Assessed Conversation Snippet</CardHeader>
            <MessagesList>
              {assessed_conversation && assessed_conversation.length > 0 ? (
                assessed_conversation.map(msg => (
                  <ChatMessageComponent
                    key={msg.message_id}
                    message={msg}
                    chatbotName={chatbot_name || 'Assessment Bot'}
                  />
                ))
              ) : (
                <p>No conversation snippet available for this assessment.</p>
              )}
            </MessagesList>
          </ConversationContextCard>

          <AssessmentDetailsCard>
            <CardHeader>AI Assessment & Teacher Review</CardHeader>
            {/* ... Display of assessment details (student, bot, criteria, AI grade, AI feedback, AI analysis) ... */}
            {/* This part remains largely the same as in content-reply-032 */}
            <DetailItem><strong>Student:</strong> <span>{student_name || 'N/A'} ({student_email || 'No email'})</span></DetailItem>
            <DetailItem><strong>Assessment Bot:</strong> <span>{chatbot_name || 'N/A'}</span></DetailItem>
            <DetailItem>
              <strong>Assessed On:</strong>
              <span>
                {assessed_at ? new Date(assessed_at).toLocaleString() : 'N/A'}
              </span>
            </DetailItem>
            <DetailItem><strong>Teacher&apos;s Criteria Used:</strong> <p style={{whiteSpace: 'pre-wrap', fontStyle: 'italic', color: '#555'}}>{teacher_assessment_criteria_snapshot || 'N/A'}</p></DetailItem>
            
            <Divider />
            <CardHeader style={{fontSize: '1.1rem', marginTop:'1rem', borderBottom: 'none'}}>AI Generated Assessment</CardHeader>
            <DetailItem><strong>AI Suggested Grade:</strong> <Badge variant={ai_grade_raw?.toLowerCase().includes('error') ? 'error' : 'default'}>{ai_grade_raw || 'Not graded by AI'}</Badge></DetailItem>
            <DetailItem><strong>AI Feedback to Student:</strong> <p>{ai_feedback_student || 'No AI feedback provided.'}</p></DetailItem>
            
            {ai_assessment_details_teacher && (
              <DetailItem>
                <strong>AI Analysis for Teacher:</strong>
                <AnalysisBlock>
                  {ai_assessment_details_teacher.summary && <p><strong>Summary:</strong> {ai_assessment_details_teacher.summary}</p>}
                  {ai_assessment_details_teacher.strengths && ai_assessment_details_teacher.strengths.length > 0 && ( <> <p style={{marginTop: '8px'}}><strong>Strengths:</strong></p> <ul>{ai_assessment_details_teacher.strengths.map((s, i) => <li key={`s-${i}`}>{s}</li>)}</ul> </> )}
                  {ai_assessment_details_teacher.areas_for_improvement && ai_assessment_details_teacher.areas_for_improvement.length > 0 && ( <> <p style={{marginTop: '8px'}}><strong>Areas for Improvement:</strong></p> <ul>{ai_assessment_details_teacher.areas_for_improvement.map((a, i) => <li key={`a-${i}`}>{a}</li>)}</ul> </> )}
                  {ai_assessment_details_teacher.grading_rationale && <p style={{marginTop: '8px'}}><strong>Rationale:</strong> {ai_assessment_details_teacher.grading_rationale}</p>}
                </AnalysisBlock>
              </DetailItem>
            )}

            <TeacherReviewForm onSubmit={handleReviewSubmit}>
              <CardHeader style={{fontSize: '1.1rem', borderBottom: 'none'}}>Teacher&apos;s Review & Override</CardHeader>
              {reviewError && <Alert variant="error">{reviewError}</Alert>}
              {reviewSuccess && <Alert variant="success">{reviewSuccess}</Alert>}
              <FormGroup>
                <Label htmlFor="teacherGrade">Override Grade (optional)</Label>
                <Input type="text" id="teacherGrade" value={teacherGrade} onChange={(e) => setTeacherGrade(e.target.value)} placeholder="e.g., B+, 9/10, Meets Standard" />
              </FormGroup>
              <FormGroup>
                <Label htmlFor="teacherNotes">Teacher Notes/Feedback (optional)</Label>
                <TextArea id="teacherNotes" value={teacherNotes} onChange={(e) => setTeacherNotes(e.target.value)} rows={4} placeholder="Your observations, final feedback, or notes for records..." />
              </FormGroup>
              <FormGroup>
                <Label htmlFor="assessmentStatus">Update Status</Label>
                <StyledSelect id="assessmentStatus" value={currentStatus} onChange={(e) => setCurrentStatus(e.target.value as AssessmentStatusEnum)}>
                    {/* Keep ai_processing if you want teachers to manually move it out of this state */}
                    {/* <option value="ai_processing">AI Processing</option>  */}
                    <option value="ai_completed">AI Completed (Ready for Review)</option>
                    <option value="teacher_reviewed">Teacher Reviewed</option>
                </StyledSelect>
              </FormGroup>
              <Button type="submit" disabled={isSubmittingReview} style={{width: '100%'}}>
                {isSubmittingReview ? 'Saving Review...' : 'Save Teacher Review'}
              </Button>
            </TeacherReviewForm>
          </AssessmentDetailsCard>
        </MainGrid>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/assessments/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation'; // For linking to detail page
import {
    Container, Card, Button, Alert, Badge,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types from your database.types.ts
import type { AssessmentListSummary, PaginatedAssessmentsResponse, AssessmentStatusEnum } from '@/types/database.types';

// Styled Components for this page
const PageWrapper = styled(Container)` // Use Container as base
  padding-top: ${({ theme }) => theme.spacing.xl};
  padding-bottom: ${({ theme }) => theme.spacing.xl};
`;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;



const PageTitle = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto; /* Enable horizontal scrolling on smaller viewports */
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; /* Ensure table has a minimum width */
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    white-space: nowrap; /* Prevent text wrapping in cells initially */
  }

  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
  }

  td {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.text};
  }

  td.actions {
    white-space: nowrap;
    width: 1%; /* Allow this column to be just wide enough for content */
  }
  
  .truncate {
    max-width: 150px; /* Adjust as needed */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const PaginationControls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const EmptyStateCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
`;

// Helper to get display text for status
const getStatusText = (status?: AssessmentStatusEnum): string => {
    if (!status) return 'N/A';
    switch (status) {
        case 'ai_processing': return 'AI Processing';
        case 'ai_completed': return 'AI Completed (Ready for Review)';
        case 'teacher_reviewed': return 'Teacher Reviewed';
        default: return status;
    }
};
const getStatusBadgeVariant = (status?: AssessmentStatusEnum): 'success' | 'warning' | 'error' | 'default' => {
    if (!status) return 'default';
    switch (status) {
        case 'ai_processing': return 'default';
        case 'ai_completed': return 'warning'; // Yellow/Orange indicating action needed
        case 'teacher_reviewed': return 'success';
        default: return 'default';
    }
};


export default function AssessmentsListPage() {
  const [assessments, setAssessments] = useState<AssessmentListSummary[]>([]);
  const [pagination, setPagination] = useState({
    currentPage: 0,
    pageSize: 10,
    totalCount: 0,
    totalPages: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [statusFilter, setStatusFilter] = useState<AssessmentStatusEnum | ''>(''); // Empty string for 'all'

  const router = useRouter();

  const fetchAssessments = useCallback(async (pageToFetch: number, currentStatusFilter: AssessmentStatusEnum | '') => {
    setLoading(true);
    setError(null);
    console.log(`[AssessmentsPage] Fetching assessments. Page: ${pageToFetch}, Status: ${currentStatusFilter || 'all'}`);

    try {
      const queryParams = new URLSearchParams({
        page: pageToFetch.toString(),
        limit: pagination.pageSize.toString(),
      });
      if (currentStatusFilter) {
        queryParams.append('status', currentStatusFilter);
      }

      const response = await fetch(`/api/teacher/assessments?${queryParams.toString()}`);
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch assessments (status ${response.status})`);
      }
      const data: PaginatedAssessmentsResponse = await response.json();
      setAssessments(data.assessments || []);
      setPagination(data.pagination || { currentPage: 0, pageSize: 10, totalCount: 0, totalPages: 0 });
    } catch (err) {
      console.error("Error fetching assessments:", err);
      setError(err instanceof Error ? err.message : 'Could not load assessments.');
      setAssessments([]); // Clear on error
    } finally {
      setLoading(false);
    }
  }, [pagination.pageSize]); // pageSize can be a dependency if you allow changing it

  useEffect(() => {
    fetchAssessments(0, statusFilter); // Fetch initial page on mount or when filter changes
  }, [statusFilter, fetchAssessments]); // fetchAssessments is stable due to useCallback

  const handlePageChange = (newPage: number) => {
    if (newPage >= 0 && newPage < pagination.totalPages) {
      fetchAssessments(newPage, statusFilter);
    }
  };

  const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setStatusFilter(e.target.value as AssessmentStatusEnum | '');
    // useEffect will trigger refetch due to statusFilter change
  };

  const handleViewDetails = (assessmentId: string) => {
    router.push(`/teacher-dashboard/assessments/${assessmentId}`);
  };

  if (loading && assessments.length === 0) { // Show full page loader only on initial load
    return (
      <PageWrapper>
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner size="large" />
          <p>Loading assessments...</p>
        </Card>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <PageHeader>
        <PageTitle>Student Assessments</PageTitle>
        {/* Add a button to create new assessment type or similar if needed in future */}
      </PageHeader>

      <FilterControls>
        <label htmlFor="statusFilter">Filter by Status:</label>
        <StyledSelect id="statusFilter" value={statusFilter} onChange={handleFilterChange} disabled={loading}>
          <option value="">All Statuses</option>
          <option value="ai_processing">AI Processing</option>
          <option value="ai_completed">AI Completed (Ready for Review)</option>
          <option value="teacher_reviewed">Teacher Reviewed</option>
        </StyledSelect>
      </FilterControls>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      
      {loading && assessments.length > 0 && <Alert variant='info' style={{textAlign:'center'}}>Loading more...</Alert>} {/* Subtle loading more indicator */}


      {!loading && assessments.length === 0 && !error ? (
        <EmptyStateCard>
          <h3>No Assessments Found</h3>
          <p>There are no assessments matching your current filters, or no assessments have been processed yet.</p>
        </EmptyStateCard>
      ) : assessments.length > 0 ? (
        <Card> {/* Wrap table in a card for consistent styling */}
          <TableContainer>
            <Table>
              <thead>
                <tr>
                  <th>Student</th>
                  <th>Room</th>
                  <th>Assessment Bot</th>
                  <th>AI Grade</th>
                  <th>Teacher Grade</th>
                  <th>Status</th>
                  <th>Date Assessed</th>
                  <th className="actions">Actions</th>
                </tr>
              </thead>
              <tbody>
                {assessments.map((asmnt) => (
                  <tr key={asmnt.assessment_id}>
                    <td className="truncate" title={asmnt.student_name || undefined}>{asmnt.student_name || 'N/A'}</td>
                    <td className="truncate" title={asmnt.room_name || undefined}>{asmnt.room_name || 'N/A'}</td>
                    <td className="truncate" title={asmnt.chatbot_name || undefined}>{asmnt.chatbot_name || 'N/A'}</td>
                    <td>{asmnt.ai_grade_raw || '-'}</td>
                    <td>{asmnt.teacher_override_grade || '-'}</td>
                    <td>
                      <Badge variant={getStatusBadgeVariant(asmnt.status)}>
                        {getStatusText(asmnt.status)}
                      </Badge>
                    </td>
                    <td>{new Date(asmnt.assessed_at).toLocaleDateString()}</td>
                    <td className="actions">
                      <Button size="small" onClick={() => handleViewDetails(asmnt.assessment_id)}>
                        Review Details
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </Table>
          </TableContainer>
        </Card>
      ) : null}

      {pagination.totalPages > 1 && (
        <PaginationControls>
          <Button
            onClick={() => handlePageChange(pagination.currentPage - 1)}
            disabled={pagination.currentPage === 0 || loading}
            variant="outline"
          >
            Previous
          </Button>
          <span>
            Page {pagination.currentPage + 1} of {pagination.totalPages}
          </span>
          <Button
            onClick={() => handlePageChange(pagination.currentPage + 1)}
            disabled={pagination.currentPage >= pagination.totalPages - 1 || loading}
            variant="outline"
          >
            Next
          </Button>
        </PaginationControls>
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient as createStandardSupabaseClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';
import TeacherNav from '@/components/teacher/TeacherNav';

const DashboardLayoutContainer = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0; 
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.textLight};
  z-index: 1000;
`;

type AuthStatus = 'loading' | 'authorized' | 'unauthorized';

export default function TeacherDashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [authStatus, setAuthStatus] = useState<AuthStatus>('loading');
  const router = useRouter();
  const supabase = createStandardSupabaseClient();

  useEffect(() => {
    console.log('[TDL] useEffect for auth check triggered.');

    const checkAuth = async (sessionUser: User | null) => {
      if (sessionUser) {
        console.log('[TDL] User found. Fetching profile for user_id:', sessionUser.id);
        try {
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', sessionUser.id)
            .single();

          if (profileError) {
            console.error('[TDL] Profile fetch error:', profileError.message, 'Redirecting to /auth.');
            setAuthStatus('unauthorized');
            router.push('/auth');
          } else if (profile && profile.role === 'teacher') {
            console.log('[TDL] User is teacher. Authorized.');
            setAuthStatus('authorized');
          } else {
            console.log('[TDL] User is not teacher or profile missing. Unauthorized. Redirecting to /.');
            setAuthStatus('unauthorized');
            router.push('/');
          }
        } catch (e) {
          console.error('[TDL] Exception during profile fetch:', e, 'Redirecting to /auth.');
          setAuthStatus('unauthorized');
          router.push('/auth');
        }
      } else {
        console.log('[TDL] No user in session. Unauthorized. Redirecting to /auth.');
        setAuthStatus('unauthorized');
        router.push('/auth');
      }
    };

    // Initial check
    supabase.auth.getSession().then(({ data: { session } }) => {
        console.log('[TDL] Initial getSession result:', session);
        // Only process if onAuthStateChange hasn't already set a definitive state
        if (authStatus === 'loading') { // Check current authStatus
            checkAuth(session?.user || null);
        }
    });
    
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log(`[TDL] onAuthStateChange event: ${event}`, session);
        // Re-check auth whenever the state changes
        // This will also handle the INITIAL_SESSION event which is often the first one on load
        checkAuth(session?.user || null);
      }
    );

    return () => {
      console.log('[TDL] Unsubscribing from onAuthStateChange.');
      authListener.subscription?.unsubscribe();
    };
  }, [router, supabase, authStatus]); // Added authStatus to deps to re-evaluate if it changes to loading by another means

  console.log('[TDL] Render. AuthStatus:', authStatus);

  if (authStatus === 'loading') {
    return (
      <LoadingOverlay>
        <div>Loading Teacher Dashboard (Auth)...</div>
      </LoadingOverlay>
    );
  }

  if (authStatus === 'unauthorized') {
    console.log('[TDL] Rendering null because unauthorized (redirect initiated).');
    return null; 
  }

  // authStatus === 'authorized'
  console.log('[TDL] Rendering dashboard content.');
  return (
    <DashboardLayoutContainer>
      <Container>
        <TeacherNav />
        <MainContent>
            {children}
        </MainContent>
      </Container>
      <Footer />
    </DashboardLayoutContainer>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/edit/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react'; // Removed unused useRef
import { useParams, useRouter } from 'next/navigation';
import styled from 'styled-components';
import {
    Container, Card, Button, FormGroup, Label, Input, TextArea, Alert,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Chatbot, Document as KnowledgeDocument, BotTypeEnum as BotType } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const HeaderControls = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const BackButton = styled(Button)`
  margin-right: ${({ theme }) => theme.spacing.lg};
`;

const MainTitle = styled.h1`
    font-size: 1.8rem;
    color: ${({ theme }) => theme.colors.text};
`;


const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  input[type="checkbox"] {
    width: 1.15em;
    height: 1.15em;
    cursor: pointer;
  }
`;

const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.xl} 0;
`;

const SectionTitle = styled.h2`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 1.5rem;
`;

const LoadingCard = styled(Card)`
    text-align: center;
    padding: ${({ theme }) => theme.spacing.xl};
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: ${({ theme }) => theme.spacing.md};
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const AssessmentCriteriaSection = styled(FormGroup)`
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
`;

const RubricInfoText = styled(HelpText)`
  font-style: italic;
  margin-top: ${({ theme }) => theme.spacing.md};
`;

const LoadingStateContainer = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
    padding: ${({ theme }) => theme.spacing.lg};
    color: ${({ theme }) => theme.colors.textLight};
`;

const initialChatbotState: Chatbot = {
    chatbot_id: '',
    name: '',
    description: '',
    system_prompt: `You are a helpful AI assistant.`,
    teacher_id: '',
    model: 'qwen/qwen3-235b-a22b',
    max_tokens: 1000,
    temperature: 0.7,
    enable_rag: false,
    bot_type: 'learning',
    assessment_criteria_text: null,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
};

export default function ConfigureChatbotPage() {
  const [chatbot, setChatbot] = useState<Chatbot>(initialChatbotState);
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [isCreateMode, setIsCreateMode] = useState(false);
  const [pageLoading, setPageLoading] = useState(true);
  const [docsLoading, setDocsLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);
  const [docsError, setDocsError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotIdFromParams = params?.chatbotId as string;

  useEffect(() => {
    const initializePage = async () => {
        setPageLoading(true);
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
            router.push('/auth');
            return;
        }
        setCurrentUserId(user.id);

        if (chatbotIdFromParams === 'new') {
            setIsCreateMode(true);
            setChatbot({ ...initialChatbotState, teacher_id: user.id });
            setDocuments([]);
            setPageLoading(false);
        } else {
            setIsCreateMode(false);
            await fetchChatbotData(chatbotIdFromParams, user.id);
        }
    };
    initializePage();
  }, [chatbotIdFromParams, router, supabase]); // Added supabase to deps

  const fetchChatbotData = useCallback(async (id: string, teacherId: string) => {
    setFormError(null);
    try {
      const { data, error } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', id)
        .eq('teacher_id', teacherId)
        .single();

      if (error) throw error;
      if (!data) throw new Error('Chatbot not found or you do not have permission.');

      const fetchedData = data as Chatbot;
      if (!fetchedData.bot_type) {
        fetchedData.bot_type = 'learning';
      }
      setChatbot(fetchedData);

      if (fetchedData.bot_type === 'learning' && fetchedData.enable_rag) {
          await fetchDocumentsData(id); // This was correct
      } else {
          setDocuments([]);
      }
    } catch (err) {
      setFormError(err instanceof Error ? err.message : 'Failed to load chatbot data.');
      setChatbot(initialChatbotState);
    } finally {
      setPageLoading(false);
    }
  }, [supabase]); // fetchDocumentsData will be a dependency of the other useEffect

  const fetchDocumentsData = useCallback(async (currentChatbotId: string) => {
    if (!currentChatbotId) return;
    setDocsLoading(true);
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/documents?chatbotId=${currentChatbotId}`);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
        throw new Error(errorData.error || `Failed to fetch documents (status ${response.status})`);
      }
      const dataResult: KnowledgeDocument[] = await response.json();
      setDocuments(dataResult);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not load documents.');
    } finally {
      setDocsLoading(false);
    }
  }, []);


  useEffect(() => {
    if (!isCreateMode && chatbot.chatbot_id && chatbot.bot_type === 'learning' && chatbot.enable_rag) {
        fetchDocumentsData(chatbot.chatbot_id);
    }
  }, [chatbot.chatbot_id, chatbot.bot_type, chatbot.enable_rag, isCreateMode, fetchDocumentsData]);


  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!currentUserId) {
        setFormError("User session expired. Please refresh.");
        return;
    }

    setSaving(true);
    setFormError(null);
    setSuccessMessage(null);

    const currentBotType = chatbot.bot_type || 'learning';
    const payload: Partial<Chatbot> = {
        name: chatbot.name,
        description: chatbot.description || undefined,
        system_prompt: chatbot.system_prompt,
        teacher_id: currentUserId,
        model: chatbot.model,
        max_tokens: (chatbot.max_tokens === undefined || String(chatbot.max_tokens).trim() === ``) ? null : Number(chatbot.max_tokens),
        temperature: (chatbot.temperature === undefined || String(chatbot.temperature).trim() === ``) ? null : Number(chatbot.temperature),
        enable_rag: currentBotType === 'learning' ? (chatbot.enable_rag || false) : false,
        bot_type: currentBotType,
        assessment_criteria_text: currentBotType === 'assessment' ? (chatbot.assessment_criteria_text || null) : null,
    };
    // Clean up undefined optional fields that should be null or absent from payload
    if (payload.description === undefined) delete payload.description;
    if (payload.max_tokens === null && (chatbot.max_tokens === undefined || String(chatbot.max_tokens).trim() === '')) {
        // If user cleared it, send null or delete based on DB preference
        // For now, if it resolves to null, it's fine. If DB has default, delete might be better.
    } else if (payload.max_tokens === undefined) {
        delete payload.max_tokens;
    }
    if (payload.temperature === null && (chatbot.temperature === undefined || String(chatbot.temperature).trim() === '')) {
        // same logic
    } else if (payload.temperature === undefined) {
        delete payload.temperature;
    }


    try {
        if (isCreateMode) {
            const response = await fetch('/api/teacher/chatbots', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });
            const responseData = await response.json();
            if (!response.ok) throw new Error(responseData.error || 'Failed to create chatbot');

            setSuccessMessage('Chatbot created successfully! You can now continue configuring or manage documents if RAG is enabled.');
            const newBotData = responseData as Chatbot;
            if (!newBotData.bot_type) newBotData.bot_type = 'learning';
            setChatbot(newBotData);
            setIsCreateMode(false);
            router.replace(`/teacher-dashboard/chatbots/${responseData.chatbot_id}/edit`, { scroll: false });

        } else { // Editing existing bot
            const { error: updateError } = await supabase
                .from('chatbots')
                .update({ ...payload, updated_at: new Date().toISOString() })
                .eq('chatbot_id', chatbot.chatbot_id)
                .eq('teacher_id', currentUserId);

            if (updateError) throw updateError;
            setSuccessMessage('Chatbot updated successfully! Redirecting...'); // Updated message
            
            // ADD NAVIGATION HERE
            setTimeout(() => {
                router.push('/teacher-dashboard/chatbots');
            }, 1500); // 1.5 second delay
        }
    } catch (err) {
        setFormError(err instanceof Error ? err.message : (isCreateMode ? 'Failed to create chatbot.' : 'Failed to update chatbot.'));
    } finally {
        setSaving(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    let processedValue: string | number | undefined | BotType = value;

    if (name === "max_tokens" || name === "temperature") {
        processedValue = value === `` ? undefined : Number(value);
    } else if (name === "bot_type") {
        processedValue = value as BotType;
    }
    setChatbot(prev => ({ ...prev, [name]: processedValue } as Chatbot));
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setChatbot(prev => ({ ...prev, [name]: checked } as Chatbot));
  };

  const handleProcessDocument = async (documentId: string) => {
    if (isCreateMode || !chatbot.chatbot_id) return;
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/chatbots/${chatbot.chatbot_id}/vectorize`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ documentId }),
      });
      if (!response.ok) { const data = await response.json().catch(() => ({})); throw new Error(data.error || 'Failed to start document processing'); }
      setDocuments(prevDocs => prevDocs.map(doc => doc.document_id === documentId ? { ...doc, status: 'processing' } : doc));
      setViewingDocumentId(documentId);
    } catch (err) { setDocsError(err instanceof Error ? err.message : 'Could not process document.'); }
  };

  const handleDeleteDocument = async (documentId: string) => {
    if (isCreateMode || !chatbot.chatbot_id) return;
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/documents?documentId=${documentId}`, { method: 'DELETE' });
      if (!response.ok) { const data = await response.json().catch(() => ({})); throw new Error(data.error || 'Failed to delete document'); }
      setDocuments(prevDocs => prevDocs.filter(doc => doc.document_id !== documentId));
      if (viewingDocumentId === documentId) { setViewingDocumentId(null); }
    } catch (err) { setDocsError(err instanceof Error ? err.message : 'Could not delete document.'); }
  };

  const getViewingDocument = (): KnowledgeDocument | null => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  if (pageLoading) {
    return ( <PageWrapper><Container><LoadingCard><LoadingSpinner size="large" /><p>{`Loading configuration page...`}</p></LoadingCard></Container></PageWrapper> );
  }
  if (!chatbot && !isCreateMode) {
     return ( <PageWrapper><Container><Alert variant="error">{formError || `Chatbot data could not be initialized.`}</Alert></Container></PageWrapper> );
  }

  const displayBotType = chatbot.bot_type || 'learning';

  return (
    <PageWrapper>
      <Container>
        <HeaderControls>
          <MainTitle>{isCreateMode ? `Create New Chatbot` : `Edit Chatbot: ${chatbot.name}`}</MainTitle>
          <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard/chatbots')}>
            {`<`} Back to Chatbots
          </BackButton>
        </HeaderControls>

        <Card>
          {formError && <Alert variant="error" style={{ marginBottom: '16px'}}>{formError}</Alert>}
          {successMessage && <Alert variant="success" style={{ marginBottom: '16px'}}>{successMessage}</Alert>}

          {/* The form element should wrap all FormGroups */}
          <form onSubmit={handleSubmit}> {/* Ensure this is <form>, not <Form> unless Form is a styled form */}
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input id="name" name="name" value={chatbot.name || ``} onChange={handleChange} required />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input id="description" name="description" value={chatbot.description || ``} onChange={handleChange} />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="bot_type">Bot Type</Label>
              <StyledSelect id="bot_type" name="bot_type" value={displayBotType} onChange={handleChange}>
                <option value="learning">Learning Bot</option>
                <option value="assessment">Assessment Bot</option>
              </StyledSelect>
              <HelpText>{`'Learning' bots are for general interaction. 'Assessment' bots can evaluate student responses based on criteria you define.`}</HelpText>
            </FormGroup>
            {displayBotType === 'assessment' && (
              <AssessmentCriteriaSection>
                <Label htmlFor="assessment_criteria_text">Define Assessment Rubric / Criteria</Label>
                <TextArea id="assessment_criteria_text" name="assessment_criteria_text" value={chatbot.assessment_criteria_text || ``} onChange={handleChange} rows={5} placeholder={`Clearly describe what the AI should assess. For example:\n1. Accuracy of answers to key concepts.\n2. Clarity of student's explanations.\n3. Use of specific examples or evidence.\n4. Critical thinking demonstrated.`} required={displayBotType === 'assessment'} />
                <HelpText>This text will guide the AI in evaluating student responses. Be specific.</HelpText>
                <RubricInfoText>{`For now, provide a text-based summary here. In the future, you may be able to upload structured rubric documents after saving.`}</RubricInfoText>
              </AssessmentCriteriaSection>
            )}
            <FormGroup>
              <Label htmlFor="system_prompt">{`System Prompt (AI's Persona & Core Instructions)`}</Label>
              <TextArea id="system_prompt" name="system_prompt" value={chatbot.system_prompt || ``} onChange={handleChange} required rows={displayBotType === 'assessment' ? 3 : 5} placeholder={ displayBotType === 'assessment' ? `e.g., 'You are an assessment assistant...'` : `e.g., 'You are a friendly history tutor...'` }/>
              <HelpText>{`This defines the AI's general behavior.`}{displayBotType === 'assessment' && ` For Assessment Bots, instructions from 'Assessment Criteria' are key.`}</HelpText>
            </FormGroup>
            <FormGroup>
              <Label htmlFor="model">AI Model (for Chatting)</Label>
              <StyledSelect id="model" name="model" value={chatbot.model || 'qwen/qwen3-235b-a22b'} onChange={handleChange}>
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta (Paid)</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B (Free)</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
              </StyledSelect>
              <HelpText>This model is used for general chat. Assessment evaluation will use Qwen3 235B.</HelpText>
            </FormGroup>
            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens (Chat Response Length)</Label>
              <Input id="max_tokens" name="max_tokens" type="number" value={chatbot.max_tokens === null ? `` : (chatbot.max_tokens ?? ``)} onChange={handleChange} min="100" max="8000" placeholder="e.g., 1000" />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="temperature">Temperature (Chat Creativity)</Label>
              <Input id="temperature" name="temperature" type="number" value={chatbot.temperature === null ? `` : (chatbot.temperature ?? ``)} onChange={handleChange} min="0" max="2" step="0.1" placeholder="e.g., 0.7"/>
               <HelpText>{`0.0 = most deterministic, 2.0 = most creative. Default is 0.7.`}</HelpText>
            </FormGroup>
            {displayBotType === 'learning' && (
                <FormGroup>
                <Label htmlFor="enable_rag">Knowledge Base (RAG)</Label>
                <CheckboxGroup>
                    <input id="enable_rag" name="enable_rag" type="checkbox" checked={!!chatbot.enable_rag} onChange={handleCheckboxChange} />
                    <span>Enable RAG: Allow chatbot to use uploaded documents to answer questions.</span>
                </CheckboxGroup>
                <HelpText>If enabled, this learning bot can use documents you upload below. (Save first to enable uploads if creating a new bot).</HelpText>
                </FormGroup>
            )}
            <Button type="submit" disabled={saving || pageLoading} style={{ width: `100%`, marginTop: `16px` }}>
              {saving ? (isCreateMode ? 'Creating...' : 'Saving...') : (isCreateMode ? 'Create & Configure Chatbot' : 'Save Changes')}
            </Button>
          </form> {/* Closing form tag */}

          {/* RAG Document Management Section */}
          {!isCreateMode && displayBotType === 'learning' && chatbot.enable_rag && chatbot.chatbot_id && (
            <>
                <Divider />
                <SectionTitle>Knowledge Base Documents (for RAG)</SectionTitle>
                <HelpText>{`Upload PDF, Word, or TXT files. These will be processed and embedded for this chatbot's knowledge base.`}</HelpText>
                {docsError && <Alert variant="error">{docsError}</Alert>}
                <DocumentUploader chatbotId={chatbot.chatbot_id} onUploadSuccess={() => { setSuccessMessage("Document uploaded. Refreshing list..."); fetchDocumentsData(chatbot.chatbot_id!); }} />
                {viewingDocumentId && getViewingDocument() && (
                    <EmbeddingStatus 
                      document={{ ...getViewingDocument()!, updated_at: getViewingDocument()!.updated_at ?? new Date().toISOString() }} // Ensure updated_at is always a string
                      chatbotId={chatbot.chatbot_id!} 
                      onRefresh={() => { setSuccessMessage("Document status refreshed."); fetchDocumentsData(chatbot.chatbot_id!); }} 
                    />
                )}
                {docsLoading ? ( <LoadingStateContainer><LoadingSpinner size="small"/><span>Loading documents...</span></LoadingStateContainer> ) : (
                    <DocumentList 
                      documents={documents.map(doc => ({ ...doc, updated_at: doc.updated_at ?? new Date().toISOString() }))} // Ensure updated_at for list
                      onProcessDocument={handleProcessDocument} 
                      onDeleteDocument={handleDeleteDocument} 
                      onViewStatus={setViewingDocumentId} 
                    />
                )}
            </>
          )}
          {isCreateMode && displayBotType === 'learning' && (
            <HelpText style={{marginTop: '20px', textAlign: 'center', fontStyle: 'italic'}}>Save this chatbot first to enable RAG document uploads.</HelpText>
          )}
        </Card>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/knowledge-base/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Document as KnowledgeDocument } from '@/types/knowledge-base.types'; // Ensure path

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  gap: ${({ theme }) => theme.spacing.md};
`;

const BackButton = styled(Button)`
  /* Add specific styles if BackButton needs to differ from general Button */
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.7rem; // Slightly smaller if needed
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  text-align: center; // Center text if using p tag
`;

const Section = styled(Card)` // Use Card as base for sections
    margin-bottom: ${({ theme }) => theme.spacing.xl};
    h2 {
        margin-top: 0;
        margin-bottom: ${({ theme }) => theme.spacing.sm};
    }
    p {
        color: ${({ theme }) => theme.colors.textLight};
        font-size: 0.9rem;
        margin-bottom: ${({ theme }) => theme.spacing.lg};
    }
`;


export default function KnowledgeBasePage() {
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [chatbotName, setChatbotName] = useState<string>('');
  const [loading, setLoading] = useState(true); // For initial page load (chatbot name + initial docs)
  const [docsLoading, setDocsLoading] = useState(false); // For subsequent document list refreshes
  const [pageError, setPageError] = useState<string | null>(null); // Renamed from error
  const [docsError, setDocsError] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  const fetchChatbotInfo = useCallback(async () => {
    if(!chatbotId) return;
    try {
      const { data: chatbot, error: chatbotError } = await supabase
        .from('chatbots')
        .select('name, teacher_id') // Also get teacher_id for auth check
        .eq('chatbot_id', chatbotId)
        .single();

      if (chatbotError) throw chatbotError;
      if (!chatbot) throw new Error("Chatbot not found.");

      // Authorization check: ensure current user owns this chatbot
      const { data: { user } } = await supabase.auth.getUser();
      if (!user || user.id !== chatbot.teacher_id) {
        throw new Error("You are not authorized to manage this chatbot's knowledge base.");
      }
      setChatbotName(chatbot.name);
    } catch (err) {
      console.error('Error fetching chatbot info:', err);
      setPageError(err instanceof Error ? err.message : 'Failed to fetch chatbot information');
    }
  }, [chatbotId, supabase]);

  const fetchDocuments = useCallback(async () => {
    if (!chatbotId) return;
    setDocsLoading(true);
    setDocsError(null);
    try {
      // << MODIFICATION: Use new API endpoint >>
      const response = await fetch(`/api/teacher/documents?chatbotId=${chatbotId}`);
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to fetch documents');
      }
      const data: KnowledgeDocument[] = await response.json();
      setDocuments(data);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not load documents.');
    } finally {
      setDocsLoading(false);
    }
  }, [chatbotId]);

  useEffect(() => {
    const loadInitialData = async () => {
        setLoading(true);
        await fetchChatbotInfo();
        await fetchDocuments();
        setLoading(false);
    }
    if (chatbotId) {
        loadInitialData();
    } else {
        setPageError("Chatbot ID is missing from the URL.");
        setLoading(false);
    }
  }, [chatbotId, fetchChatbotInfo, fetchDocuments]);

  const handleProcessDocument = async (documentId: string) => {
    setDocsError(null);
    setSuccessMessage(null);
    try {
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, { // Assuming vectorize endpoint remains nested
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId }),
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to start document processing');
      }
      setSuccessMessage("Document processing started.");
      setDocuments(prevDocs => 
        prevDocs.map(doc => 
          doc.document_id === documentId ? { ...doc, status: 'processing' } : doc
        )
      );
      setViewingDocumentId(documentId);
    } catch (err) {
      console.error('Error processing document:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not process document.');
    }
  };

  const handleDeleteDocument = async (documentId: string) => {
    setDocsError(null);
    setSuccessMessage(null);
    try {
      // << MODIFICATION: Use new API endpoint >>
      const response = await fetch(`/api/teacher/documents?documentId=${documentId}`, { 
          method: 'DELETE' 
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to delete document');
      }
      setSuccessMessage("Document deleted successfully.");
      setDocuments(prevDocs => prevDocs.filter(doc => doc.document_id !== documentId));
      if (viewingDocumentId === documentId) {
        setViewingDocumentId(null);
      }
    } catch (err) {
      console.error('Error deleting document:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not delete document.');
    }
  };

  const getViewingDocument = (): KnowledgeDocument | null => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  if (loading) {
    return (
        <PageWrapper>
            <Container>
                <LoadingContainer><p>Loading knowledge base...</p></LoadingContainer>
            </Container>
        </PageWrapper>
    );
  }

  if (pageError) {
    return (
        <PageWrapper>
            <Container>
                <Alert variant="error" style={{marginTop: '20px'}}>{pageError}</Alert>
                <Button onClick={() => router.push('/teacher-dashboard/chatbots')} style={{marginTop: '16px'}}>
                    Back to Chatbots
                </Button>
            </Container>
        </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <Title>Knowledge Base: {chatbotName || "Chatbot"}</Title>
          <BackButton 
            variant="outline" 
            onClick={() => router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`)} // Link back to edit page
          >
            ← Back to Chatbot Config
          </BackButton>
        </Header>
        
        {successMessage && <Alert variant="success" style={{marginBottom: '16px'}}>{successMessage}</Alert>}
        {docsError && <Alert variant="error" style={{marginBottom: '16px'}}>{docsError}</Alert>}
        
        <Section>
          <h2>Add Documents</h2>
          <p>Upload PDF, Word, or TXT files. These will be processed and made available for your chatbot to use when RAG is enabled.</p>
          <DocumentUploader 
            chatbotId={chatbotId} 
            onUploadSuccess={() => {
                setSuccessMessage("Document uploaded! Refreshing list...");
                fetchDocuments();
            }}
          />
        </Section>
        
        <Section>
            <h2>Uploaded Documents</h2>
            {getViewingDocument() && (
              <EmbeddingStatus 
                document={getViewingDocument()!} 
                chatbotId={chatbotId}
                onRefresh={() => {
                    setSuccessMessage("Document status refreshed.");
                    fetchDocuments();
                }}
              />
            )}
            
            {docsLoading && documents.length === 0 ? ( // Show loading only if no docs are displayed yet
              <LoadingContainer><p>Loading documents...</p></LoadingContainer>
            ) : (
              <DocumentList 
                documents={documents}
                onProcessDocument={handleProcessDocument}
                onDeleteDocument={handleDeleteDocument}
                onViewStatus={setViewingDocumentId}
              />
            )}
        </Section>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/test-chat/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Alert, Button as StyledButton } from '@/styles/StyledComponents'; // Renamed Button to avoid conflict
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: calc(100vh - 120px); // Adjust based on your header/footer height
  display: flex;
  flex-direction: column;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const ChatbotInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.75rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
    margin: 0;
  }
`;

const BackButton = styled(StyledButton)`
  // specific styles if needed
`;


export default function TestChatPage() {
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  // Define a consistent "dummy" room ID for teacher test chats for this chatbot
  // This allows message history to be segmented per chatbot test.
  const testRoomId = `teacher_test_room_for_${chatbotId}`;

  const fetchChatbotData = useCallback(async () => {
    if (!chatbotId) {
      setError("Chatbot ID is missing.");
      setLoading(false);
      return;
    }
    console.log(`[TestChatPage] Fetching chatbot data for ID: ${chatbotId}`);
    setLoading(true);
    setError(null);
    try {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        throw new Error('Not authenticated. Please log in.');
      }

      // Fetch the specific chatbot details, ensuring the teacher owns it
      const { data: chatbotData, error: chatbotError } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', chatbotId)
        .eq('teacher_id', user.id) // Important: Ensure teacher owns this chatbot
        .single();

      if (chatbotError) {
        console.error('[TestChatPage] Error fetching chatbot:', chatbotError);
        throw new Error(chatbotError.message || 'Failed to fetch chatbot details.');
      }
      if (!chatbotData) {
        throw new Error('Chatbot not found or you do not have permission to access it.');
      }
      console.log('[TestChatPage] Chatbot data fetched:', chatbotData);
      setChatbot(chatbotData);
    } catch (err) {
      console.error('[TestChatPage] CATCH Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to load chatbot for testing.');
    } finally {
      setLoading(false);
    }
  }, [chatbotId, supabase]);

  useEffect(() => {
    fetchChatbotData();
  }, [fetchChatbotData]);

  const handleBack = () => {
    router.push('/teacher-dashboard/chatbots'); // Go back to the chatbots list
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
          <LoadingSpinner size="large" />
          <p style={{ marginTop: '16px' }}>Loading chatbot for testing...</p>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!chatbot) {
    // This case should ideally be caught by the error state if fetch fails
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Chatbot not available for testing.</Alert>
           <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
        <Header>
          <ChatbotInfo>
            <h1>Test: {chatbot.name}</h1>
            <p>You are interacting with your chatbot for testing purposes.</p>
          </ChatbotInfo>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Header>
        
        {/* 
          The Chat component needs a roomId. We'll use our dummy testRoomId.
          The Chat component also expects a full Chatbot object.
        */}
        <Chat 
          roomId={testRoomId} 
          chatbot={chatbot} 
        />
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Button, Alert, Card } from '@/styles/StyledComponents';
import ChatbotList from '@/components/teacher/ChatbotList';
import ChatbotForm from '@/components/teacher/ChatbotForm'; // For the modal
// import DeleteModal from '@/components/teacher/DeleteModal'; // We'll integrate delete later
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  font-size: 1.8rem;
`;

export default function ChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  // const [deleteInfo, setDeleteInfo] = useState<{ id: string; name: string } | null>(null);
  const router = useRouter();

  const fetchChatbots = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/teacher/chatbots');
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${response.status})`);
      }
      const data: Chatbot[] = await response.json();
      setChatbots(data);
    } catch (err) {
      console.error("Error fetching chatbots:", err);
      setError(err instanceof Error ? err.message : 'Could not load chatbots.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchChatbots(); // Refresh the list
  };

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbot = async (chatbotId: string, chatbotName: string) => {
    // For now, just a confirm. We will integrate DeleteModal later.
    if (window.confirm(`Are you sure you want to delete chatbot "${chatbotName}"? This will also delete associated documents.`)) {
      try {
        // We'll need a DELETE API route: /api/teacher/chatbots/[chatbotId]
        // const response = await fetch(`/api/teacher/chatbots/${chatbotId}`, { method: 'DELETE' });
        // if (!response.ok) throw new Error('Failed to delete chatbot');
        alert(`DELETE /api/teacher/chatbots/${chatbotId} would be called. Feature to be fully implemented.`);
        // fetchChatbots(); // Refresh list
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to delete chatbot.');
      }
    }
  };

  return (
    <div>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={() => setShowChatbotForm(true)}>+ Create Chatbot</Button>
      </PageHeader>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading chatbots...</Card>
      ) : (
        <ChatbotList
          chatbots={chatbots}
          onEdit={handleEditChatbot}
          onDelete={handleDeleteChatbot}
        />
      )}

      {showChatbotForm && (
        <ChatbotForm
          onClose={() => setShowChatbotForm(false)}
          onSuccess={handleChatbotCreated}
        />
      )}

      {/* {deleteInfo && (
        <DeleteModal
          itemType="Chatbot"
          itemName={deleteInfo.name}
          onConfirm={() => {
            // actual delete logic
            setDeleteInfo(null);
          }}
          onCancel={() => setDeleteInfo(null)}
          isDeleting={false} // manage this state
        />
      )} */}
    </div>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Button, Alert, Card } from '@/styles/StyledComponents';
import ChatbotList from '@/components/teacher/ChatbotList';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  /* ... */
`;

const PageHeader = styled.div`
  /* ... */
`;

const Title = styled.h1`
  /* ... */
`;

export default function ManageChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const fetchChatbots = useCallback(async () => {
    // ... (fetchChatbots logic remains the same)
    console.log('[ChatbotsPage] Fetching chatbots...');
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/teacher/chatbots');
      if (!response.ok) {
        const errData = await response.json().catch(() => ({ error: 'Server error' }));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${response.status})`);
      }
      const data: Chatbot[] = await response.json();
      setChatbots(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Could not load your chatbots.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbot = async (chatbotId: string, chatbotName: string) => {
    if (window.confirm(`Are you sure you want to delete the chatbot "${chatbotName}"? This will also delete associated documents and knowledge base entries if RAG was used.`)) {
      setError(null);
      try {
        // ***** CORRECTED FETCH URL FOR DELETE *****
        const response = await fetch(`/api/teacher/chatbots?chatbotId=${chatbotId}`, { method: 'DELETE' }); 
        // *****---------------------------------*****
        
        if (!response.ok) {
          const errData = await response.json().catch(() => ({ error: `Failed to delete chatbot - Server responded with ${response.status}` }));
          throw new Error(errData.error || 'Failed to delete chatbot');
        }
        // If response.ok, we can assume deletion was successful or at least accepted by the server.
        // The API route should return JSON, so we can parse it for a success message if desired.
        const result = await response.json();
        alert(result.message || `Chatbot "${chatbotName}" deleted successfully.`);
        fetchChatbots(); // Refresh list after successful deletion
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Failed to delete chatbot.';
        setError(errorMessage);
        alert(`Error: ${errorMessage}`);
      }
    }
  };
  
  const handleCreateNewChatbot = () => {
    router.push(`/teacher-dashboard/chatbots/new/edit`);
  };

  return (
    <PageWrapper>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={handleCreateNewChatbot}>+ Create New Chatbot</Button>
      </PageHeader>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner /> Loading your chatbots...
        </Card>
      ) : (
        <ChatbotList
          chatbots={chatbots}
          onEdit={handleEditChatbot}
          onDelete={handleDeleteChatbot}
        />
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
// import { useRouter } from 'next/navigation'; // << REMOVED UNUSED IMPORT
import { Button, Alert, Card } from '@/styles/StyledComponents';
import RoomList from '@/components/teacher/RoomList';
import RoomForm from '@/components/teacher/RoomForm';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import type { Room as BaseRoom, Chatbot, TeacherRoom } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div``;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

export default function ManageRoomsPage() {
  const [rooms, setRooms] = useState<TeacherRoom[]>([]);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null);
  // const router = useRouter(); // << REMOVED UNUSED VARIABLE

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [roomsResponse, chatbotsResponse] = await Promise.all([
        fetch('/api/teacher/rooms'),
        fetch('/api/teacher/chatbots') 
      ]);

      if (!roomsResponse.ok) {
        const errData = await roomsResponse.json().catch(()=>({}));
        throw new Error(errData.error || `Failed to fetch rooms (status ${roomsResponse.status})`);
      }
      if (!chatbotsResponse.ok) {
        const errData = await chatbotsResponse.json().catch(()=>({}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`);
      }

      const roomsData: TeacherRoom[] = await roomsResponse.json();
      const chatbotsData: Chatbot[] = await chatbotsResponse.json();
      
      setRooms(roomsData);
      setChatbots(chatbotsData);
    } catch (err) {
      console.error("Error fetching page data:", err);
      setError(err instanceof Error ? err.message : 'Could not load data.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleRoomCreatedOrUpdated = () => {
    setShowRoomForm(false);
    setEditingRoom(null);
    fetchData(); 
  };

  const handleDeleteRoom = async (room: BaseRoom) => {
     if (window.confirm(`Are you sure you want to delete room "${room.room_name}"? This will also delete associated student memberships and chat history.`)) {
        try {
            const response = await fetch(`/api/teacher/rooms/${room.room_id}`, { method: 'DELETE' });
            if (!response.ok) {
                const errData = await response.json().catch(()=>({}));
                throw new Error(errData.error || 'Failed to delete room');
            }
            fetchData(); 
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to delete room.');
        }
    }
  };

  return (
    <PageWrapper>
      <PageHeader>
        <Title>Classroom Rooms</Title>
        <Button 
          onClick={() => setShowRoomForm(true)}
          disabled={chatbots.length === 0}
          title={chatbots.length === 0 ? "Create a chatbot before creating a room" : "Create New Room"}
        >
          + Create New Room
        </Button>
      </PageHeader>
      {chatbots.length === 0 && !isLoading && (
        <Alert variant='info' style={{marginBottom: '16px'}}>
            You need to create at least one chatbot before you can create a classroom room.
        </Alert>
      )}

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading rooms...</Card>
      ) : (
        <RoomList
          rooms={rooms}
          onUpdate={fetchData} 
          onEditRoom={setEditingRoom} 
          onDeleteRoom={handleDeleteRoom}
        />
      )}

      {showRoomForm && (
        <RoomForm
          chatbots={chatbots}
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreatedOrUpdated}
        />
      )}

      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={() => setEditingRoom(null)}
          onSuccess={handleRoomCreatedOrUpdated}
        />
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/page.tsx
'use client';

import styled from 'styled-components';
import DashboardOverview from '@/components/teacher/DashboardOverview'; // Import the new component

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 2rem;
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.125rem;
`;

export default function TeacherDashboardPage() {
  console.log('[TeacherDashboardPage] Rendering with DashboardOverview...');
  return (
    <div>
      <PageHeader>
        <Title>Teacher Dashboard</Title> {/* Kept general title */}
        <Subtitle>Welcome! Here&apos;s a summary of your ClassBots activities.</Subtitle>
      </PageHeader>
      <DashboardOverview /> {/* Use the new overview component */}
    </div>
  );
}// src/app/teacher-dashboard/concerns/page.tsx
'use client';

import styled from 'styled-components';
import ConcernsList from '@/components/teacher/ConcernsList';
import { Container } from '@/styles/StyledComponents';

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.8rem; 
`;

export default function ConcernsPage() {
  return (
    <Container>
      <PageHeader>
        <Title>Student Welfare Concerns</Title>
      </PageHeader>
      <ConcernsList />
    </Container>
  );
}// src/app/teacher-dashboard/concerns/[flagId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// Import necessary components and styles
import { Container, Card, Button, Alert, Badge, TextArea, Label, Select as StyledSelect } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types (ensure Profile includes full_name)
import type { FlaggedMessage, ConcernStatus, ChatMessage as DatabaseChatMessage, Profile, Room } from '@/types/database.types'; // Import necessary base types


// Interface for the data structure returned by the API GET request
// This includes the nested objects directly as returned by the join syntax used
// and the flattened fields for easier use, plus surroundingMessages
interface FlagDetailsResponse extends FlaggedMessage {
    student: Pick<Profile, 'full_name' | 'email'> | null; // Nested original
    room: Pick<Room, 'room_name'> | null; // Nested original
    message: DatabaseChatMessage | null; // Nested original
    student_name: string | null; // Flattened
    student_email: string | null; // Flattened
    room_name: string | null; // Flattened
    message_content: string | null; // Flattened
    surroundingMessages: DatabaseChatMessage[];
}


// --- Styled Components (Keep as previously defined) ---
const PageWrapper = styled.div` padding: ${({ theme }) => theme.spacing.xl} 0; min-height: 100vh; `;
const Header = styled.div` display: flex; justify-content: space-between; align-items: center; margin-bottom: ${({ theme }) => theme.spacing.xl}; flex-wrap: wrap; gap: ${({ theme }) => theme.spacing.md}; `;
const Title = styled.h1` color: ${({ theme }) => theme.colors.text}; margin: 0; font-size: 1.8rem; @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) { font-size: 1.5rem; } `;
const BackButton = styled(Button)``;
const Grid = styled.div` display: grid; grid-template-columns: 3fr 2fr; gap: ${({ theme }) => theme.spacing.xl}; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { grid-template-columns: 1fr; } `;
const ConversationContext = styled(Card)` max-height: 75vh; display: flex; flex-direction: column; overflow: hidden; `;
const ContextHeader = styled.h3` padding: 0 0 ${({ theme }) => theme.spacing.md} 0; margin: 0 0 ${({ theme }) => theme.spacing.md} 0; border-bottom: 1px solid ${({ theme }) => theme.colors.border}; font-size: 1.2rem; `;
const MessagesList = styled.div` flex: 1; overflow-y: auto; padding-right: ${({ theme }) => theme.spacing.sm}; margin-right: -${({ theme }) => theme.spacing.sm}; &::-webkit-scrollbar { width: 6px; } &::-webkit-scrollbar-thumb { background-color: ${({ theme }) => theme.colors.borderDark}; border-radius: 3px; } &::-webkit-scrollbar-track { background: transparent; } `;
const FlaggedMessageHighlight = styled.div` border: 3px solid ${({ theme }) => theme.colors.red}; border-radius: ${({ theme }) => theme.borderRadius.large}; margin: ${({ theme }) => theme.spacing.md} 0; background-color: rgba(248, 127, 127, 0.08); padding: 2px; & > div { margin-bottom: 0; } `;
const ConcernDetailsCard = styled(Card)` align-self: start; position: sticky; top: 80px; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { position: static; margin-top: ${({ theme }) => theme.spacing.xl}; } `;
const DetailsHeader = styled.h3` margin-bottom: ${({ theme }) => theme.spacing.lg}; font-size: 1.2rem; `;
const DetailItem = styled.div` margin-bottom: ${({ theme }) => theme.spacing.md}; font-size: 0.9rem; line-height: 1.5; strong { display: block; margin-bottom: ${({ theme }) => theme.spacing.xs}; color: ${({ theme }) => theme.colors.textLight}; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; } span, p { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; } p { margin-bottom: 0; } `;
const AnalysisText = styled.p` font-style: italic; color: ${({ theme }) => theme.colors.textLight}; background-color: ${({ theme }) => theme.colors.backgroundDark}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin-top: ${({ theme }) => theme.spacing.xs}; `;
const ActionForm = styled.form` margin-top: ${({ theme }) => theme.spacing.lg}; padding-top: ${({ theme }) => theme.spacing.lg}; border-top: 1px solid ${({ theme }) => theme.colors.border}; `;
const FormActions = styled.div` margin-top: ${({ theme }) => theme.spacing.lg}; `;
const CustomSelect = styled(StyledSelect)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; `; // Use imported Select
const StyledTextArea = styled(TextArea)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; min-height: 100px; `;
// --- End Styled Components ---

// --- Helper Functions ---
function getConcernTypeText(type: string | undefined): string { if (!type) return 'Unknown'; return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); }
function getConcernLevelText(level: number | undefined): string { if (level === undefined) return 'N/A'; if (level >= 5) return 'Critical'; if (level >= 4) return 'High'; if (level >= 3) return 'Significant'; if (level >= 2) return 'Moderate'; if (level >= 1) return 'Minor'; return 'Low'; }
// -----------------------

export default function ConcernDetailPage() {
    const [concern, setConcern] = useState<FlagDetailsResponse | null>(null); // Use the more specific type for fetched data
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [actionError, setActionError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [selectedStatus, setSelectedStatus] = useState<ConcernStatus>('pending');
    const [notes, setNotes] = useState('');

    const params = useParams();
    const router = useRouter();
    const flagId = params?.flagId as string;
    const flaggedMessageRef = useRef<HTMLDivElement>(null);

    const fetchConcernDetails = useCallback(async () => {
        if (!flagId) { setError("Flag ID missing from page parameters."); setLoading(false); return; }
        setLoading(true); setError(null); setActionError(null);
        try {
            console.log(`Fetching details for flag: ${flagId}`);
            // --- FIX: Fetch using query parameter to the collection route ---
            const response = await fetch(`/api/teacher/concerns?flagId=${flagId}`);
            // -------------------------------------------------------------
            if (!response.ok) {
                const data = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                throw new Error(data.error || `Failed to fetch concern details (status: ${response.status})`);
            }
            const data: FlagDetailsResponse = await response.json(); // Use the correct response type
            console.log("Fetched Concern Data:", data);
            setConcern(data);
            setSelectedStatus(data.status || 'pending');
            setNotes(data.notes || '');
        } catch (err) {
            console.error("Error fetching concern:", err);
            setError(err instanceof Error ? err.message : 'Failed to load concern details');
            setConcern(null);
        } finally { setLoading(false); }
    }, [flagId]); // Keep flagId as dependency

    useEffect(() => { fetchConcernDetails(); }, [fetchConcernDetails]);

    useEffect(() => {
        const timer = setTimeout(() => {
            if (concern && flaggedMessageRef.current) {
                console.log("Scrolling to flagged message ref");
                flaggedMessageRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
        return () => clearTimeout(timer);
    }, [concern]);

    const handleStatusUpdate = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!concern?.flag_id) return; // Ensure we have the concern and its ID

        setIsSubmitting(true); setActionError(null);
        try {
            console.log(`Updating flag ${concern.flag_id} with status ${selectedStatus}`);
            // --- FIX: Send PATCH to collection route, include flagId in body ---
            const response = await fetch(`/api/teacher/concerns`, { // Target the collection route
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    flagId: concern.flag_id, // Include flagId in the body
                    status: selectedStatus,
                    notes: notes
                 }),
            });
            // --- END FIX ---
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Update failed' }));
                throw new Error(errorData.error || 'Failed to update status');
            }

            const updatedData = await response.json();
            // Update state based on the response from the PATCH request
            setConcern(prev => prev ? ({ ...prev, ...updatedData }) : null);
            setSelectedStatus(updatedData.status);
            setNotes(updatedData.notes || '');
            alert("Status updated successfully!");

        } catch (err) {
            setActionError(err instanceof Error ? err.message : 'Failed to update status');
        } finally {
            setIsSubmitting(false);
        }
    };

    // --- Render Logic ---
    if (loading) { return <PageWrapper><Container><Card><LoadingSpinner /> Loading concern details...</Card></Container></PageWrapper>; }
    if (error) { return <PageWrapper><Container><Alert variant="error">{error}</Alert><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }
    if (!concern) { return <PageWrapper><Container><Card>Concern not found or permission denied.</Card><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }

    // Find the actual flagged message within the surrounding messages (if fetched) or use the direct message object
    const actualFlaggedMessage = concern.surroundingMessages?.find(m => m.message_id === concern.message_id) || concern.message;

    return (
        <PageWrapper>
            <Container>
                <Header>
                    <Title>Review Concern</Title>
                    <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard#concerns')}>← Back to Dashboard</BackButton>
                </Header>
                <Grid>
                    {/* Conversation Context */}
                    <ConversationContext>
                        <ContextHeader>Conversation Context</ContextHeader>
                        <MessagesList>
                            {concern.surroundingMessages?.length > 0 ? (
                                concern.surroundingMessages.map(msg => {
                                    const isFlagged = msg.message_id === concern.message_id;
                                    const chatbotName = concern.room_name || "Chatbot"; // Placeholder name

                                    const messageComponent = ( <ChatMessageComponent key={msg.message_id} message={msg} chatbotName={chatbotName} /> );
                                    return isFlagged ? ( <FlaggedMessageHighlight key={msg.message_id} ref={flaggedMessageRef}>{messageComponent}</FlaggedMessageHighlight> ) : messageComponent;
                                })
                            ) : ( actualFlaggedMessage ? ( <FlaggedMessageHighlight ref={flaggedMessageRef}><ChatMessageComponent key={actualFlaggedMessage.message_id} message={actualFlaggedMessage} chatbotName={concern.room_name || "Chatbot"} /></FlaggedMessageHighlight> )
                                : <p style={{ textAlign: 'center', padding: '20px', color: '#888' }}>Conversation context unavailable.</p>
                            )}
                        </MessagesList>
                    </ConversationContext>

                    {/* Details & Actions */}
                    <ConcernDetailsCard>
                        <DetailsHeader>Concern Details</DetailsHeader>
                        {/* Use flattened properties from FlagDetailsResponse */}
                        <DetailItem><strong>Student:</strong><span>{concern.student_name || 'N/A'} ({concern.student_email || 'No Email'})</span></DetailItem>
                        <DetailItem><strong>Classroom:</strong><span>{concern.room_name || 'N/A'}</span></DetailItem>
                        <DetailItem><strong>Concern Type:</strong><span>{getConcernTypeText(concern.concern_type)}</span></DetailItem>
                        <DetailItem><strong>Assessed Level:</strong><Badge variant="default" style={{ marginLeft: '8px' }}>{getConcernLevelText(concern.concern_level)} (Level {concern.concern_level})</Badge></DetailItem>
                        <DetailItem><strong>Detected At:</strong><span>{new Date(concern.created_at).toLocaleString()}</span></DetailItem>
                        {concern.analysis_explanation && (<DetailItem><strong>AI Analysis:</strong><AnalysisText>{concern.analysis_explanation}</AnalysisText></DetailItem>)}
                        {concern.reviewed_at && (<DetailItem><strong>Last Reviewed:</strong><span>{new Date(concern.reviewed_at).toLocaleString()}</span></DetailItem>)}

                        <ActionForm onSubmit={handleStatusUpdate}>
                             <Label htmlFor="status">Update Status:</Label>
                            <CustomSelect id="status" value={selectedStatus} onChange={(e) => setSelectedStatus(e.target.value as ConcernStatus)}>
                               <option value="pending">Pending Review</option>
                               <option value="reviewing">Reviewing</option>
                               <option value="resolved">Resolved</option>
                               <option value="false_positive">False Positive</option>
                            </CustomSelect>
                             <Label htmlFor="notes">Review Notes:</Label>
                             <StyledTextArea id="notes" rows={5} value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Add notes on actions taken, observations, or decision rationale..." />
                             {actionError && <Alert variant="error" style={{ marginBottom: '16px' }}>{actionError}</Alert>}
                             <FormActions><Button type="submit" disabled={isSubmitting} style={{ width: '100%' }}>{isSubmitting ? 'Updating...' : 'Update Status & Notes'}</Button></FormActions>
                        </ActionForm>
                    </ConcernDetailsCard>
                </Grid>
            </Container>
        </PageWrapper>
    );
}.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
// src/app/layout.tsx
import { Metadata } from 'next';
import Providers from './providers';
import Header from '@/components/layout/Header';
import { APP_NAME, APP_DESCRIPTION } from '@/lib/utils/constants';
import './globals.css';

export const metadata: Metadata = {
  title: APP_NAME,
  description: APP_DESCRIPTION,
  viewport: 'width=device-width, initial-scale=1.0, maximum-scale=1.0',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>
          <Header />
          {children}
        </Providers>
      </body>
    </html>
  );
}// src/app/api/chat/[roomId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateEmbedding } from '@/lib/openai/embeddings';
import { queryVectors } from '@/lib/pinecone/utils';

// ONLY import what is DIRECTLY CALLED by THIS file.
// checkMessageSafety is the function we call from monitoring.ts.
// initialConcernCheck and verifyConcern are used INTERNALLY by checkMessageSafety.
import { checkMessageSafety } from '@/lib/safety/monitoring';

// Import specific types needed in THIS file.
import type { ChatMessage, Room } from '@/types/database.types';
// Database and SupabaseClient types are generally not needed if the supabase client instance is not explicitly typed here.

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
// CONCERN_THRESHOLD is defined and used within 'src/lib/safety/monitoring.ts', so it's not needed here.

// These constants WILL BE USED when we re-integrate assessment logic.
// For now, to avoid "unused var" errors while we stabilize, we can comment them out
// or keep them if we are immediately moving to re-add assessment logic after this fix.
// Let's keep them for now, anticipating the next step.
const ASSESSMENT_TRIGGER_COMMAND = "/assess";
const ASSESSMENT_CONTEXT_MESSAGE_COUNT = 5;

const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// --- GET Function ---
export async function GET(request: NextRequest) {
    try {
        const pathname = request.nextUrl.pathname;
        const segments = pathname.split('/');
        const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
        const { searchParams } = new URL(request.url);
        const chatbotIdFilter = searchParams.get('chatbotId');

        if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });

        if (!isTeacherTestRoom(roomId)) {
            const { data: roomResult, error: roomError } = await supabase
                .from('rooms')
                .select('room_id')
                .eq('room_id', roomId)
                .maybeSingle();
            if (roomError || !roomResult) {
                console.warn(`[API Chat GET] Room ${roomId} not found or access denied for user ${user.id}.`);
                return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 });
            }
        }

        let query = supabase.from('chat_messages').select('*').eq('room_id', roomId).eq('user_id', user.id);
        if (chatbotIdFilter) query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
        
        const { data: messages, error: messagesError } = await query.order('created_at', { ascending: true });

        if (messagesError) { 
            console.error('[API Chat GET] Error fetching messages:', messagesError); 
            return NextResponse.json({ error: messagesError.message }, { status: 500 }); 
        }
        return NextResponse.json(messages || []);
    } catch (error) { 
        console.error('[API Chat GET] General error:', error); 
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Unknown server error' }, { status: 500 }); 
    }
}

// --- POST Handler ---
export async function POST(request: NextRequest) {
  let userMessageId: string | null = null;
  const supabase = await createServerSupabaseClient(); // User-context client

  try {
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
    if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }

    const { data: userProfile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
    if (profileError || !userProfile) { return NextResponse.json({ error: 'User profile not found' }, { status: 403 }); }
    
    const isStudent = userProfile.role === 'student';
    const isTeacher = userProfile.role === 'teacher';

    const { content, chatbot_id, model: requestedModel } = await request.json();
    const trimmedContent = content?.trim();
    if (!trimmedContent || typeof trimmedContent !== 'string') return NextResponse.json({ error: 'Invalid message content' }, { status: 400 });
    if (!chatbot_id) return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });

    // Fetch full chatbot config, including bot_type for assessment logic
    const { data: chatbotConfig, error: chatbotFetchError } = await supabase
        .from('chatbots')
        .select('system_prompt, model, temperature, max_tokens, enable_rag, bot_type, assessment_criteria_text')
        .eq('chatbot_id', chatbot_id)
        .single();

    if (chatbotFetchError || !chatbotConfig) {
        console.warn(`[API Chat POST] Error fetching chatbot ${chatbot_id} config:`, chatbotFetchError?.message);
        return NextResponse.json({ error: 'Chatbot configuration not found.' }, { status: 404 });
    }

    let roomForSafetyCheck: Room | null = null;
    if (!isTeacherTestRoom(roomId)) {
        const { data: roomData, error: roomFetchError } = await supabase
            .from('rooms')
            .select('room_id, teacher_id, room_name') // Ensure all fields needed by checkMessageSafety are here
            .eq('room_id', roomId)
            .single();
        if (roomFetchError || !roomData) { 
            console.error("[API Chat POST] Room fetch error for non-test room:", roomFetchError); 
            return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 }); 
        }
        roomForSafetyCheck = roomData as Room;
    } else if (isTeacherTestRoom(roomId) && !isTeacher) {
        return NextResponse.json({ error: 'Not authorized for this test room' }, { status: 403 });
    }

    const userMessageToStore: Omit<ChatMessage, 'message_id' | 'created_at' | 'updated_at'> & { metadata: { chatbotId: string } } = {
      room_id: roomId, user_id: user.id, role: 'user' as const, content: trimmedContent, metadata: { chatbotId: chatbot_id }
    };
    const { data: savedUserMessageData, error: userMessageError } = await supabase.from('chat_messages').insert(userMessageToStore).select('message_id, created_at').single();
    if (userMessageError || !savedUserMessageData) { console.error('Error storing user message:', userMessageError); return NextResponse.json({ error: 'Failed to store message' }, { status: 500 }); }
    userMessageId = savedUserMessageData.message_id;
    const userMessageCreatedAt = savedUserMessageData.created_at; // Will be used when re-adding assessment trigger
    
    // Safety Check Trigger
    if (isStudent && userMessageId && roomForSafetyCheck && !isTeacherTestRoom(roomId)) {
        console.log(`[API Chat POST] Triggering imported checkMessageSafety for student ${user.id}, message ${userMessageId}`);
        // Call the imported function. The 'supabase' here is the user-context client.
        checkMessageSafety(supabase, trimmedContent, userMessageId, user.id, roomForSafetyCheck)
            .catch(safetyError => console.error(`[Safety Check Background Error] for message ${userMessageId}:`, safetyError));
    } else {
        console.log(`[API Chat POST] Skipping safety check. isStudent: ${isStudent}, isTeacherTestRoom: ${isTeacherTestRoom(roomId)}`);
    }

    // --- ASSESSMENT TRIGGER LOGIC ---
    // This is where the assessment trigger logic, which uses ASSESSMENT_TRIGGER_COMMAND and ASSESSMENT_CONTEXT_MESSAGE_COUNT,
    // and userMessageCreatedAt will be re-inserted.
    if (isStudent && chatbotConfig.bot_type === 'assessment' && trimmedContent.toLowerCase() === ASSESSMENT_TRIGGER_COMMAND) {
        console.log(`[API Chat POST] Assessment trigger detected for student ${user.id}, bot ${chatbot_id}, room ${roomId}.`);
        
        const { data: contextMessagesForAssessment, error: contextMsgsError } = await supabase
            .from('chat_messages')
            .select('message_id')
            .eq('room_id', roomId)
            .eq('user_id', user.id) 
            .eq('metadata->>chatbotId', chatbot_id)
            .lt('created_at', userMessageCreatedAt) // Use the timestamp of the "/assess" command
            .order('created_at', { ascending: false })
            .limit(ASSESSMENT_CONTEXT_MESSAGE_COUNT * 2 + 5); // Fetch enough to get varied turns

        if (contextMsgsError) {
            console.error(`[API Chat POST] Error fetching message IDs for assessment context: ${contextMsgsError.message}`);
            // Not returning error, assessment might proceed with less context
        }
        
        const messageIdsToAssess = (contextMessagesForAssessment || []).map(m => m.message_id).reverse();
        
        const assessmentPayload = {
            student_id: user.id,
            chatbot_id: chatbot_id,
            room_id: roomId,
            message_ids_to_assess: messageIdsToAssess,
        };

        console.log(`[API Chat POST] Asynchronously calling /api/assessment/process.`);
        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || `http://localhost:${process.env.PORT || 3000}`;
        fetch(`${baseUrl}/api/assessment/process`, { // This is the call to the new dedicated assessment API
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(assessmentPayload),
        }).catch(fetchError => {
            console.error(`[API Chat POST] Error calling /api/assessment/process internally:`, fetchError);
        });

        return NextResponse.json({
            type: "assessment_pending",
            message: "Your responses are being submitted for assessment. Feedback will appear here shortly."
        });
    }
    // --- END OF ASSESSMENT TRIGGER LOGIC ---


    // Regular Chat Logic (RAG, LLM Call, Streaming)
    // This part will only execute if it's NOT an assessment trigger.
    const { data: contextMessagesData, error: contextError } = await supabase.from('chat_messages')
      .select('role, content').eq('room_id', roomId).eq('user_id', user.id)
      .filter('metadata->>chatbotId', 'eq', chatbot_id).neq('message_id', userMessageId)
      .order('created_at', { ascending: false }).limit(5);
    if (contextError) console.warn("Error fetching context messages:", contextError.message);
    const contextMessages = (contextMessagesData || []).map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }));

    const { 
        system_prompt: systemPromptToUse = "You are a helpful AI assistant.",
        model: modelToUseFromConfig = 'x-ai/grok-3-mini-beta', 
        temperature: temperatureToUse = 0.7, 
        max_tokens: maxTokensToUse = 1000, 
        enable_rag: enableRagFromConfig = false 
    } = chatbotConfig;
    
    const finalModelToUse = requestedModel || modelToUseFromConfig;

    let ragContextText = '';
    if (enableRagFromConfig && chatbotConfig.bot_type === 'learning') { 
        try {
            const queryEmbedding = await generateEmbedding(trimmedContent);
            const searchResults = await queryVectors(queryEmbedding, chatbot_id, 3);
            if (searchResults && searchResults.length > 0) {
                ragContextText = "\n\nRelevant information from knowledge base:\n";
                searchResults.forEach((result, index) => {
                    if (result.metadata?.text) {
                        const fileName = typeof result.metadata.fileName === 'string' ? result.metadata.fileName : 'document';
                        const chunkText = String(result.metadata.text).substring(0, 500);
                        ragContextText += `\n[${index + 1}] From "${fileName}":\n${chunkText}\n`;
                    }
                });
            }
        } catch (ragError) { console.warn(`[RAG] Error:`, ragError); }
    }

    const enhancedSystemPrompt = `${systemPromptToUse}${ragContextText ? `\n\n${ragContextText}\n\nRemember to cite sources by their number (e.g., [1], [2]) if you use their information.` : ''}`;
    const messagesForAPI = [ { role: 'system', content: enhancedSystemPrompt }, ...contextMessages.reverse(), { role: 'user', content: trimmedContent } ];

    const openRouterResponse = await fetch(OPENROUTER_API_URL, {
        method: 'POST', headers: { 'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`, 'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000', 'X-Title': 'ClassBots AI', 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: finalModelToUse, messages: messagesForAPI, temperature: temperatureToUse, max_tokens: maxTokensToUse, stream: true }),
    });

    if (!openRouterResponse.ok || !openRouterResponse.body) {
        const errorBody = await openRouterResponse.text(); console.error(`OpenRouter Error: Status ${openRouterResponse.status}`, errorBody);
        let errorMessage = `Failed to get AI response (status: ${openRouterResponse.status})`;
        try { const errorJson = JSON.parse(errorBody); errorMessage = errorJson.error?.message || errorMessage; } catch {}
        throw new Error(errorMessage);
    }

    // Streaming logic...
    let fullResponseContent = ''; const encoder = new TextEncoder(); let assistantMessageId: string | null = null;
    const stream = new ReadableStream({
        async start(controller) {
            const reader = openRouterResponse.body!.getReader(); const decoder = new TextDecoder();
            try {
                const { data: initData, error: initError } = await supabase.from('chat_messages')
                    .insert({ room_id: roomId, user_id: user.id, role: 'assistant', content: '', metadata: { chatbotId: chatbot_id } })
                    .select('message_id').single();
                if (initError || !initData) console.error('Error creating placeholder assistant message:', initError);
                else assistantMessageId = initData.message_id;

                while (true) {
                    const { done, value } = await reader.read(); if (done) break;
                    const chunk = decoder.decode(value, { stream: true }); const lines = chunk.split('\n').filter(l => l.trim().startsWith('data:'));
                    for (const line of lines) {
                        const dataContent = line.substring(6).trim(); if (dataContent === '[DONE]') continue;
                        try { const parsed = JSON.parse(dataContent); const piece = parsed.choices?.[0]?.delta?.content; if (typeof piece === 'string') { fullResponseContent += piece; controller.enqueue(encoder.encode(`data: ${JSON.stringify({ content: piece })}\n\n`)); } }
                        catch (e) { console.warn('Stream parse error:', e); }
                    }
                }
            } catch (streamError) { console.error('Stream error:', streamError); controller.error(streamError); }
            finally {
                const finalContent = fullResponseContent.trim();
                if (assistantMessageId && finalContent) {
                    const { error: updateError } = await supabase.from('chat_messages').update({ content: finalContent, updated_at: new Date().toISOString() }).eq('message_id', assistantMessageId);
                    if (updateError) console.error(`Error updating assistant message ${assistantMessageId}:`, updateError); else console.log(`Assistant message ${assistantMessageId} updated.`);
                } else if (!assistantMessageId && finalContent) { 
                    console.warn("Fallback: Assistant message placeholder not created, inserting full message."); 
                    await supabase.from('chat_messages').insert({ room_id: roomId, user_id: user.id, role: 'assistant', content: finalContent, metadata: { chatbotId: chatbot_id } }); 
                }
                controller.close(); console.log("Server stream closed.");
            }
        }
    });
    return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'X-Content-Type-Options': 'nosniff' } });

  } catch (error) { 
      console.error('Error in POST /api/chat/[roomId]:', error); 
      return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to process message' }, { status: 500 }); 
  }
}

// NO LOCAL DEFINITION OF checkMessageSafety, initialConcernCheck, or verifyConcern HERE.
// They are handled by the import from '@/lib/safety/monitoring.ts'.// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Test database connection
    const { error } = await supabase
      .from('schools')
      .select('count')
      .limit(1);

    if (error) {
      return NextResponse.json({ 
        status: 'error', 
        message: 'Database connection failed',
        error: error.message 
      }, { status: 500 });
    }

    return NextResponse.json({ 
      status: 'healthy',
      database: 'connected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return NextResponse.json({ 
      status: 'error', 
      message: 'Server error',
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}// src/app/api/student/join-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { isValidRoomCode } from '@/lib/utils/room-codes'; // Ensure this utility is present

export async function POST(request: Request) {
  console.log('[API POST /student/join-room] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError || !session?.user) {
      console.warn('[API POST /student/join-room] Not authenticated or session error:', sessionError);
      return NextResponse.json({ error: sessionError?.message || 'Not authenticated' }, { status: 401 });
    }
    const studentUser = session.user;
    console.log('[API POST /student/join-room] User authenticated:', studentUser.id);

    // Verify the user trying to join actually has a 'student' role in profiles table
    const { data: studentProfile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', studentUser.id)
        .single();

    if (profileError || !studentProfile) {
        console.error('[API POST /student/join-room] Profile not found or error for student:', studentUser.id, profileError);
        return NextResponse.json({ error: 'Student profile not found.' }, { status: 403 });
    }
    if (studentProfile.role !== 'student') {
        console.warn('[API POST /student/join-room] User is not a student. Role:', studentProfile.role);
        return NextResponse.json({ error: 'Only students can join rooms this way.' }, { status: 403 });
    }
    console.log('[API POST /student/join-room] User confirmed as student.');


    const { room_code } = await request.json();
    console.log('[API POST /student/join-room] Received room_code:', room_code);

    if (!room_code || !isValidRoomCode(room_code.toUpperCase())) { // Ensure case-insensitivity if codes are stored uppercase
      console.warn('[API POST /student/join-room] Invalid room code format:', room_code);
      return NextResponse.json({ error: 'Invalid room code format' }, { status: 400 });
    }

    const formattedRoomCode = room_code.toUpperCase();

    // Find room by code
    console.log('[API POST /student/join-room] Searching for room with code:', formattedRoomCode);
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id, is_active')
      .eq('room_code', formattedRoomCode) // Ensure room_code in DB is also consistently cased or use a case-insensitive query
      .single();

    if (roomError) {
        console.error('[API POST /student/join-room] Error fetching room by code:', formattedRoomCode, roomError);
        // This could be a "relation rooms does not exist" if table is missing, or other DB error
        // But more likely if table exists, it's "0 rows" which isn't an error for .single() if it becomes !room
        // For a true DB error, throw it.
        if (roomError.code && !['PGRST116'].includes(roomError.code)) { // PGRST116 is "Searched for a single row, but found 0 rows"
             throw roomError;
        }
    }
    
    if (!room) { // This handles both "0 rows found" and if roomError was PGRST116
      console.warn('[API POST /student/join-room] Room not found with code:', formattedRoomCode);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 }); // This is your current error
    }
    console.log('[API POST /student/join-room] Room found:', room.room_id, 'Is active:', room.is_active);


    if (!room.is_active) {
      console.warn('[API POST /student/join-room] Room is inactive:', room.room_id);
      return NextResponse.json({ error: 'This room is currently inactive.' }, { status: 400 });
    }

    // Check if student is already in room
    const { data: existingMembership, error: membershipCheckError } = await supabase
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', room.room_id)
      .eq('student_id', studentUser.id)
      .maybeSingle(); // Use maybeSingle to not error if no membership found

    if (membershipCheckError) {
        console.error('[API POST /student/join-room] Error checking existing membership:', membershipCheckError);
        throw membershipCheckError;
    }

    if (existingMembership) {
      console.warn('[API POST /student/join_room] Student already a member of this room:', room.room_id);
      return NextResponse.json({ message: 'Already joined this room', roomId: room.room_id }, { status: 200 }); // Or 400 if you want to treat as error
    }

    // Add student to room
    console.log('[API POST /student/join-room] Adding student to room_memberships. RoomID:', room.room_id, 'StudentID:', studentUser.id);
    const { error: joinError } = await supabase
      .from('room_memberships')
      .insert({
        room_id: room.room_id,
        student_id: studentUser.id
        // joined_at has a default value
      });

    if (joinError) {
      console.error('[API POST /student/join-room] Error inserting into room_memberships:', joinError);
      // Check for unique constraint violation (already a member, though prior check should catch this)
      if (joinError.code === '23505') { // unique_violation
         return NextResponse.json({ message: 'Already a member of this room (insert conflict).', roomId: room.room_id }, { status: 200 });
      }
      throw joinError;
    }
    console.log('[API POST /student/join-room] Student successfully joined room:', room.room_id);
    return NextResponse.json({ success: true, roomId: room.room_id, message: 'Successfully joined room!' });
  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API POST /student/join-room] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to join room' },
      { status: 500 }
    );
  }
}// src/app/api/student/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

// Define proper interfaces for the exact Supabase query structure
interface ChatbotData {
  chatbot_id: string;
  name: string;
  description: string | null;
}

interface RoomChatbotRelation {
  chatbots: ChatbotData;
}

interface RoomData {
  room_id: string;
  room_name: string;
  room_code: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: RoomChatbotRelation[] | null;
}

interface MembershipData {
  joined_at: string;
  rooms: RoomData | null;
}

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a student
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'student') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Fetch rooms the student has joined with chatbot info - MODIFIED QUERY
    const { data: membershipData, error } = await supabase
      .from('room_memberships')
      .select(`
        joined_at,
        rooms!inner(
          room_id,
          room_name,
          room_code,
          is_active,
          created_at,
          room_chatbots(
            chatbots(
              chatbot_id,
              name,
              description
            )
          )
        )
      `)
      .eq('student_id', user.id);

    if (error) {
      throw error;
    }

    // Use unknown first, then cast to our type
    const typedMembershipData = membershipData as unknown as MembershipData[];

    // Transform the data to match expected format
    const rooms = typedMembershipData?.map(membership => {
      const room = membership.rooms;
      if (!room) return null;
      
      // Extract chatbots from room_chatbots
      const chatbots: ChatbotData[] = [];
      if (room.room_chatbots && room.room_chatbots.length > 0) {
        room.room_chatbots.forEach((rc: RoomChatbotRelation) => {
          if (rc.chatbots) {
            chatbots.push(rc.chatbots);
          }
        });
      }
      
      return {
        ...room,
        joined_at: membership.joined_at,
        chatbots
      };
    }).filter((room): room is NonNullable<typeof room> => room !== null);

    return NextResponse.json(rooms || []);
  } catch (error) {
    console.error('Error fetching student rooms:', error);
    return NextResponse.json(
      { error: 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}// src/app/api/assessment/process/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { DocumentType } from '@/types/knowledge-base.types'; // For extractTextFromFile
import { extractTextFromFile } from '@/lib/document-processing/extractor';
// Import AssessmentStatusEnum for setting status
import type { AssessmentStatusEnum } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const ASSESSMENT_LLM_MODEL = 'google/gemini-2.5-flash-preview'; // Or your preferred model like 'microsoft/phi-3-medium-128k-instruct'

interface ProcessAssessmentPayload {
  student_id: string; // For teacher tests, this will be the teacher's user_id
  chatbot_id: string;
  room_id: string; // Will be "teacher_test_room_for_..." for teacher tests
  message_ids_to_assess: string[];
}

// Helper function to identify teacher test rooms
const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// Define expected structure for LLM's JSON response (the content part)
interface LLMAssessmentOutput {
    grade: string;
    student_feedback: string;
    teacher_analysis: {
        summary: string;
        strengths: string[];
        areas_for_improvement: string[];
        grading_rationale: string;
    };
}

export async function POST(request: NextRequest) {
  console.log('--------------------------------------------------');
  console.log('[API /assessment/process] Received assessment processing request.');
  const adminSupabase = createAdminClient();

  try {
    const payload: ProcessAssessmentPayload = await request.json();
    const { student_id: userId, chatbot_id, room_id, message_ids_to_assess } = payload;
    const isTestByTeacher = isTeacherTestRoom(room_id);

    console.log(`[API /assessment/process] Payload: userId=${userId}, chatbot_id=${chatbot_id}, room_id=${room_id}, isTestByTeacher=${isTestByTeacher}, messages_count=${message_ids_to_assess.length}`);

    // 1. Fetch the Assessment Bot's configuration
    const { data: assessmentBotConfig, error: botConfigError } = await adminSupabase
      .from('chatbots')
      .select('assessment_criteria_text, enable_rag, teacher_id')
      .eq('chatbot_id', chatbot_id)
      .eq('bot_type', 'assessment')
      .single();

    if (botConfigError || !assessmentBotConfig) {
      console.error(`[API /assessment/process] CRITICAL: Error fetching assessment bot ${chatbot_id} config:`, botConfigError?.message);
      return NextResponse.json({ error: 'Assessment bot configuration not found or not an assessment bot.' }, { status: 404 });
    }
    if (!assessmentBotConfig.assessment_criteria_text) {
      console.warn(`[API /assessment/process] CRITICAL: Assessment bot ${chatbot_id} has no assessment criteria defined.`);
        await adminSupabase.from('chat_messages').insert({
            room_id: room_id, user_id: userId, role: 'system',
            content: "This assessment bot doesn't have its criteria defined by the teacher yet. Please set the criteria in the chatbot configuration.",
            metadata: { chatbotId: chatbot_id, isAssessmentFeedback: true, error: "Missing assessment criteria" }
        });
        return NextResponse.json({ success: true, message: "Assessment criteria missing, user notified." });
    }
    console.log(`[API /assessment/process] Fetched bot config. RAG enabled: ${assessmentBotConfig.enable_rag}`);

    // 2. Fetch the conversation segment to be assessed
    const { data: conversationMessages, error: messagesError } = await adminSupabase
      .from('chat_messages')
      .select('role, content, user_id')
      .in('message_id', message_ids_to_assess)
      .order('created_at', { ascending: true });

    if (messagesError || !conversationMessages || conversationMessages.length === 0) {
      console.error(`[API /assessment/process] CRITICAL: Error fetching conversation messages for assessment:`, messagesError?.message);
      return NextResponse.json({ error: 'Could not retrieve conversation for assessment.' }, { status: 500 });
    }
    console.log(`[API /assessment/process] Fetched ${conversationMessages.length} conversation messages.`);

    const conversationSegmentForPrompt = conversationMessages
      .map(m => `${m.user_id === userId ? (isTestByTeacher ? 'Tester (Teacher)' : 'Student') : 'Quiz Bot'}: ${m.content}`)
      .join('\n');

    // 3. Fetch the original passage/document text if this bot is RAG-enabled
    let originalPassageText = "No specific passage was used by the Quiz Bot for these questions, or it could not be retrieved for this assessment.";
    if (assessmentBotConfig.enable_rag) {
      console.log(`[API /assessment/process] Bot has RAG. Fetching primary document for passage context.`);
      const { data: botDocument, error: docError } = await adminSupabase
        .from('documents')
        .select('file_path, file_type')
        .eq('chatbot_id', chatbot_id)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (docError || !botDocument) {
        console.warn(`[API /assessment/process] No document found for RAG-enabled assessment bot ${chatbot_id}, or error:`, docError?.message);
      } else {
        try {
          console.log(`[API /assessment/process] Downloading document: ${botDocument.file_path}`);
          const { data: fileData, error: downloadError } = await adminSupabase.storage.from('documents').download(botDocument.file_path);
          if (!downloadError && fileData) {
            originalPassageText = await extractTextFromFile(Buffer.from(await fileData.arrayBuffer()), botDocument.file_type as DocumentType);
            console.log(`[API /assessment/process] Extracted text from passage (length: ${originalPassageText.length}).`);
          } else { console.warn(`[API /assessment/process] Failed to download document ${botDocument.file_path}:`, downloadError?.message); }
        } catch (extractionError) { console.warn(`[API /assessment/process] Error extracting text from document ${botDocument.file_path}:`, extractionError); }
      }
    }

    // 4. Construct the detailed assessment prompt for the LLM
    const finalAssessmentPrompt = `
You are an AI teaching assistant. Your task is to evaluate a student's (or tester's) interaction based on the teacher's criteria, the original passage (if provided), and the conversation history.

Teacher's Assessment Criteria:
--- TEACHER'S CRITERIA START ---
${assessmentBotConfig.assessment_criteria_text}
--- TEACHER'S CRITERIA END ---

Original Passage Context (if applicable, MCQs should be based on this):
--- ORIGINAL PASSAGE START ---
${originalPassageText}
--- ORIGINAL PASSAGE END ---

Conversation History to Assess (User is '${isTestByTeacher ? 'Tester (Teacher)' : 'Student'}'):
--- CONVERSATION HISTORY START ---
${conversationSegmentForPrompt}
--- CONVERSATION HISTORY END ---

Provide your evaluation ONLY as a single, valid JSON object matching the following structure EXACTLY:
{
  "grade": "string (e.g., 'Meets Expectations', '8/10', 'B', 'Needs Improvement'. Be concise.)",
  "student_feedback": "string (2-4 sentences of constructive feedback for the student, directly addressing their performance against the criteria. Start with 'Here is some feedback on your interaction:')",
  "teacher_analysis": {
    "summary": "string (A 1-2 sentence overall summary of the student's performance for the teacher.)",
    "strengths": [
      "string (A specific strength observed, referencing criteria/conversation. Be specific.)",
      "string (Another specific strength, if any. Up to 2-3 strengths total.)"
    ],
    "areas_for_improvement": [
      "string (A specific area for improvement, referencing criteria/conversation. Be specific.)",
      "string (Another specific area, if any. Up to 2-3 areas total.)"
    ],
    "grading_rationale": "string (A brief explanation of how the grade was derived based on the criteria and the student's performance in the conversation.)"
  }
}

Ensure all string values are properly escaped within the JSON. Do not include any text outside of this JSON object.
`;

    // 5. Call the Assessment LLM
    console.log(`[API /assessment/process] STEP 5: Calling Assessment LLM: ${ASSESSMENT_LLM_MODEL}.`);
    let llmOutput: LLMAssessmentOutput = {
        grade: "Error: AI Grade Not Generated",
        student_feedback: "An error occurred during AI assessment. The AI could not generate feedback based on your interaction. Please inform your teacher.",
        teacher_analysis: {
            summary: "AI assessment could not be completed due to an error or unexpected LLM response.",
            strengths: [],
            areas_for_improvement: [],
            grading_rationale: "Error during LLM processing or response parsing."
        }
    };
    let aiAssessmentDetailsRaw = JSON.stringify({ error: "LLM call not successfully completed or parsing failed." }); // Full raw response from LLM provider
    let llmCallSuccessful = false;

    try {
        const assessmentLLMResponse = await fetch(OPENROUTER_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
                'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
                'X-Title': 'ClassBots AI - Assessment Processing'
            },
            body: JSON.stringify({
                model: ASSESSMENT_LLM_MODEL,
                messages: [{ role: 'user', content: finalAssessmentPrompt }],
                temperature: 0.3,
                max_tokens: 800,
                response_format: { type: "json_object" }
            })
        });

        aiAssessmentDetailsRaw = await assessmentLLMResponse.text(); // Store the full raw text response

        if (!assessmentLLMResponse.ok) {
            console.error(`[API /assessment/process] LLM CALL FAILED: Status ${assessmentLLMResponse.status}. Raw Response Preview:`, aiAssessmentDetailsRaw.substring(0, 1000));
            // llmOutput remains the default error structure
        } else {
            console.log(`[API /assessment/process] LLM Call Successful (Status ${assessmentLLMResponse.status}). Raw Response for Parsing (first 1000 chars):\n`, aiAssessmentDetailsRaw.substring(0,1000));
            try {
                const outerParsedJson = JSON.parse(aiAssessmentDetailsRaw); // This is the OpenRouter/Provider's response structure
                // console.log("[API /assessment/process] Parsed outer LLM provider response:", outerParsedJson); // For deep debugging

                const contentString = outerParsedJson.choices?.[0]?.message?.content;

                if (typeof contentString === 'string') {
                    console.log("[API /assessment/process] Extracted content string for inner JSON parse (first 500 chars):", contentString.substring(0, 500) + "...");
                    let jsonStringToParse = contentString.trim();
                    
                    const markdownJsonMatch = jsonStringToParse.match(/```json\s*([\s\S]*?)\s*```/);
                    if (markdownJsonMatch && markdownJsonMatch[1]) {
                        jsonStringToParse = markdownJsonMatch[1].trim();
                        console.log("[API /assessment/process] Extracted inner JSON from markdown block.");
                    } else {
                        if (!jsonStringToParse.startsWith('{') || !jsonStringToParse.endsWith('}')) {
                             console.warn("[API /assessment/process] Inner content string doesn't look like a direct JSON object or markdown JSON. Attempting parse anyway.");
                        }
                    }

                    const innerParsedJson = JSON.parse(jsonStringToParse);
                    console.log("[API /assessment/process] Successfully parsed inner assessment JSON:", innerParsedJson);

                    if (
                        innerParsedJson &&
                        typeof innerParsedJson.grade === 'string' &&
                        typeof innerParsedJson.student_feedback === 'string' &&
                        typeof innerParsedJson.teacher_analysis === 'object' &&
                        innerParsedJson.teacher_analysis !== null &&
                        typeof innerParsedJson.teacher_analysis.summary === 'string' &&
                        Array.isArray(innerParsedJson.teacher_analysis.strengths) &&
                        Array.isArray(innerParsedJson.teacher_analysis.areas_for_improvement) &&
                        typeof innerParsedJson.teacher_analysis.grading_rationale === 'string'
                    ) {
                        llmOutput = innerParsedJson as LLMAssessmentOutput;
                        llmCallSuccessful = true;
                        console.log(`[API /assessment/process] Successfully validated structured assessment from LLM. Grade: ${llmOutput.grade}`);
                    } else {
                        console.warn(`[API /assessment/process] LLM response valid inner JSON but missed one or more expected fields. Parsed inner JSON:`, innerParsedJson);
                        llmOutput.grade = typeof innerParsedJson.grade === 'string' ? innerParsedJson.grade : "Format Error (Grade Missing)";
                        llmOutput.student_feedback = typeof innerParsedJson.student_feedback === 'string' ? innerParsedJson.student_feedback : "AI feedback format was incomplete.";
                        if (typeof innerParsedJson.teacher_analysis === 'object' && innerParsedJson.teacher_analysis !== null) {
                            llmOutput.teacher_analysis.summary = typeof innerParsedJson.teacher_analysis.summary === 'string' ? innerParsedJson.teacher_analysis.summary : "Summary missing.";
                            llmOutput.teacher_analysis.strengths = Array.isArray(innerParsedJson.teacher_analysis.strengths) ? innerParsedJson.teacher_analysis.strengths : [];
                            llmOutput.teacher_analysis.areas_for_improvement = Array.isArray(innerParsedJson.teacher_analysis.areas_for_improvement) ? innerParsedJson.teacher_analysis.areas_for_improvement : [];
                            llmOutput.teacher_analysis.grading_rationale = typeof innerParsedJson.teacher_analysis.grading_rationale === 'string' ? innerParsedJson.teacher_analysis.grading_rationale : "Rationale missing.";
                        }
                    }
                } else {
                    console.error("[API /assessment/process] 'content' string not found or not a string in LLM choices. Full choices[0].message:", outerParsedJson.choices?.[0]?.message);
                }
            } catch (parseError) {
                console.error(`[API /assessment/process] FAILED TO PARSE JSON (either outer provider response or inner content string). Raw Preview:`, aiAssessmentDetailsRaw.substring(0, 1000), parseError);
            }
        }
    } catch (llmCallException) {
        console.error(`[API /assessment/process] EXCEPTION during Assessment LLM call:`, llmCallException);
        aiAssessmentDetailsRaw = JSON.stringify({ error: `LLM Call Exception: ${llmCallException instanceof Error ? llmCallException.message : String(llmCallException)}` });
    }
    
    let savedAssessmentId: string | null = null;
    const assessmentStatusToSave: AssessmentStatusEnum = llmCallSuccessful ? 'ai_completed' : 'ai_processing';

    if (!isTestByTeacher) {
      console.log(`[API /assessment/process] STEP 6: Attempting to save student assessment. Student ID: ${userId}, LLM Call Successful: ${llmCallSuccessful}, Status to Save: ${assessmentStatusToSave}`);
      const insertPayload = {
        student_id: userId,
        chatbot_id: chatbot_id,
        room_id: room_id,
        assessed_message_ids: message_ids_to_assess,
        teacher_id: assessmentBotConfig.teacher_id,
        teacher_assessment_criteria_snapshot: assessmentBotConfig.assessment_criteria_text,
        ai_feedback_student: llmOutput.student_feedback,
        ai_assessment_details_raw: aiAssessmentDetailsRaw,
        ai_grade_raw: llmOutput.grade,
        ai_assessment_details_teacher: llmOutput.teacher_analysis,
        status: assessmentStatusToSave,
      };
      // console.log("[API /assessment/process] Payload for student_assessments insert:", JSON.stringify(insertPayload, null, 2));

      const { data: savedAssessmentData, error: assessmentSaveError } = await adminSupabase
        .from('student_assessments')
        .insert(insertPayload)
        .select('assessment_id').single();

      if (assessmentSaveError) {
        console.error(`[API /assessment/process] CRITICAL: Error saving student assessment to DB:`, assessmentSaveError.message, assessmentSaveError.details, assessmentSaveError.hint);
      } else if (savedAssessmentData) {
        savedAssessmentId = savedAssessmentData.assessment_id;
        console.log(`[API /assessment/process] Student assessment ${savedAssessmentId} saved successfully with status: ${assessmentStatusToSave}.`);
      } else {
        console.warn(`[API /assessment/process] Student assessment insert attempt completed but no data/ID returned, and no explicit error.`);
      }
    } else {
        console.log(`[API /assessment/process] STEP 6: Teacher test assessment. LLM Call Successful: ${llmCallSuccessful}. Skipping save to student_assessments table.`);
    }

    console.log(`[API /assessment/process] STEP 7: Inserting feedback message into chat_messages for user ${userId}. Feedback snippet: "${String(llmOutput.student_feedback).substring(0, 100)}..."`);
    const { error: feedbackMessageError } = await adminSupabase
        .from('chat_messages')
        .insert({
            room_id: room_id, 
            user_id: userId,
            role: 'system', 
            content: llmOutput.student_feedback,
            metadata: {
                chatbotId: chatbot_id, 
                isAssessmentFeedback: true,
                assessmentId: savedAssessmentId 
            }
        });

    if (feedbackMessageError) {
        console.error(`[API /assessment/process] Error inserting feedback message into chat_messages for user ${userId}:`, 
            feedbackMessageError.message, feedbackMessageError.details, feedbackMessageError.hint);
    } else {
        console.log(`[API /assessment/process] Feedback message successfully inserted into chat for user ${userId}.`);
    }

    console.log('[API /assessment/process] Processing complete. Returning response.');
    console.log('--------------------------------------------------');
    return NextResponse.json({ success: true, message: 'Assessment processed.', assessmentId: savedAssessmentId });

  } catch (error) {
    console.error('[API /assessment/process] CRITICAL UNHANDLED error:', error);
    console.log('--------------------------------------------------');
    return NextResponse.json({ error: 'Failed to process assessment due to a critical internal server error.' }, { status: 500 });
  }
}// src/app/api/teacher/assessments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
// Ensure all necessary types from database.types.ts are imported
import type {
    StudentAssessment,
    Profile,
    ChatMessage as DbChatMessage,
    AssessmentStatusEnum,
    AssessmentListSummary,      // These should be in your database.types.ts now
    PaginatedAssessmentsResponse,
    DetailedAssessmentResponse,
    UpdateAssessmentPayload
} from '@/types/database.types';


// getSingleDetailedAssessment function (remains exactly as in your provided code)
async function getSingleDetailedAssessment(
    assessmentId: string,
    requestingUserId: string,
    adminSupabase: ReturnType<typeof createAdminClient>
): Promise<NextResponse> {
    console.log(`[API GET /assessments?assessmentId=${assessmentId}] Fetching single assessment details.`);
    const { data: assessment, error: assessmentError } = await adminSupabase.from('student_assessments').select('*').eq('assessment_id', assessmentId).single();
    if (assessmentError || !assessment) { return NextResponse.json({ error: 'Assessment not found or error fetching it.' }, { status: 404 }); }
    const { data: chatbotOwner, error: chatbotOwnerError } = await adminSupabase.from('chatbots').select('teacher_id, name').eq('chatbot_id', assessment.chatbot_id).single();
    if (chatbotOwnerError || !chatbotOwner || chatbotOwner.teacher_id !== requestingUserId) { return NextResponse.json({ error: 'Not authorized to view this assessment' }, { status: 403 });}
    let studentProfile: Pick<Profile, 'full_name' | 'email'> | null = null;
    if (assessment.student_id) {
        const { data: studentData } = await adminSupabase.from('profiles').select('full_name, email').eq('user_id', assessment.student_id).single();
        studentProfile = studentData;
    }
    let assessedConversation: DbChatMessage[] = [];
    if (assessment.assessed_message_ids && Array.isArray(assessment.assessed_message_ids) && assessment.assessed_message_ids.length > 0) {
        const { data: messagesData } = await adminSupabase.from('chat_messages').select('*').in('message_id', assessment.assessed_message_ids).order('created_at', { ascending: true });
        assessedConversation = (messagesData || []) as DbChatMessage[];
    }
    const responseData: DetailedAssessmentResponse = {
        ...(assessment as StudentAssessment), student_name: studentProfile?.full_name || null, student_email: studentProfile?.email || null,
        chatbot_name: chatbotOwner?.name || null, assessed_conversation: assessedConversation,
    };
    return NextResponse.json(responseData);
}


export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const assessmentId = searchParams.get('assessmentId');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const statusFilter = searchParams.get('status') as AssessmentStatusEnum | null;
    const roomIdFilter = searchParams.get('roomId');
    const studentIdFilter = searchParams.get('studentId');

    console.log(`[API GET /assessments] Request: assessmentId=${assessmentId||'list'}, page=${page}, limit=${limit}, status=${statusFilter||'all'}`);

    const supabaseUserClient = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();

    const { data: { user }, error: authError } = await supabaseUserClient.auth.getUser();
    if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }

    const { data: profile, error: profileError } = await supabaseUserClient.from('profiles').select('role').eq('user_id', user.id).single();
    if (profileError || !profile || profile.role !== 'teacher') { return NextResponse.json({ error: 'Not authorized' }, { status: 403 });}
    
    if (assessmentId) {
        return getSingleDetailedAssessment(assessmentId, user.id, adminSupabase);
    } else {
        console.log(`[API GET /assessments] Fetching list for teacher ${user.id}. Filters: status=${statusFilter}, room=${roomIdFilter}, student=${studentIdFilter}`);
        const offset = page * limit;
        try {
            const studentForeignKeyHint = "!student_assessments_student_id_fkey"; // Using the name from your FK list
            const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey"; // Using the name from your FK list

            let query = adminSupabase
                .from('student_assessments')
                .select(`
                    assessment_id,
                    student_id,
                    chatbot_id,
                    room_id,
                    teacher_id, 
                    assessed_at,
                    ai_grade_raw,
                    teacher_override_grade,
                    status,
                    student:profiles${studentForeignKeyHint}!inner(full_name), 
                    chatbot:chatbots${chatbotForeignKeyHint}!inner(name)
                `, { count: 'exact' })
                .eq('teacher_id', user.id) 
                .order('assessed_at', { ascending: false })
                .range(offset, offset + limit - 1);

            if (statusFilter) query = query.eq('status', statusFilter);
            if (roomIdFilter) query = query.eq('room_id', roomIdFilter);
            if (studentIdFilter) query = query.eq('student_id', studentIdFilter);

            const { data, error, count } = await query;

            if (error) {
                console.error(`[API GET /assessments] DB Error fetching list (initial query):`, JSON.stringify(error, null, 2));
                throw error;
            }

            if (!data) { // Should not happen if error is null, but good check
                console.warn("[API GET /assessments] No assessment data returned from initial query, though no explicit error.");
                 return NextResponse.json({ assessments: [], pagination: { currentPage: page, pageSize: limit, totalCount: 0, totalPages: 0 }});
            }
            
            // Step 2: Fetch room names separately for valid UUID room_ids
            const roomIdsToFetchNames = [...new Set(
                data.map(item => item.room_id).filter(id => id && !id.startsWith('teacher_test_room_'))
            )] as string[]; // Ensure it's an array of strings

            const roomNamesMap: Map<string, string> = new Map();
            if (roomIdsToFetchNames.length > 0) {
                const { data: roomData, error: roomNameError } = await adminSupabase
                    .from('rooms')
                    .select('room_id, room_name')
                    .in('room_id', roomIdsToFetchNames);
                
                if (roomNameError) {
                    console.warn("[API GET /assessments] Error fetching room names separately:", roomNameError.message);
                } else if (roomData) {
                    roomData.forEach(room => roomNamesMap.set(room.room_id, room.room_name));
                }
            }

            const assessments: AssessmentListSummary[] = data.map(item => {
                const studentData = item.student as { full_name?: string | null } | null;
                const chatbotData = item.chatbot as { name?: string | null } | null;
                
                let resolvedRoomName = 'N/A';
                if (item.room_id) {
                    if (item.room_id.startsWith('teacher_test_room_')) {
                        resolvedRoomName = 'Teacher Test Chat';
                    } else if (roomNamesMap.has(item.room_id)) {
                        resolvedRoomName = roomNamesMap.get(item.room_id)!;
                    } else {
                        // Fallback if room_id is a UUID but not found in rooms table (e.g., room deleted)
                        resolvedRoomName = `Room ID: ${item.room_id.substring(0,8)}...`;
                    }
                }

                return {
                    assessment_id: item.assessment_id, student_id: item.student_id, chatbot_id: item.chatbot_id,
                    room_id: item.room_id, teacher_id: item.teacher_id, assessed_at: item.assessed_at,
                    ai_grade_raw: item.ai_grade_raw, teacher_override_grade: item.teacher_override_grade, status: item.status,
                    student_name: studentData?.full_name || 'N/A',
                    chatbot_name: chatbotData?.name || 'N/A',
                    room_name: resolvedRoomName
                };
            });
            
            const totalCount = count || 0;
            const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;
            const responsePayload: PaginatedAssessmentsResponse = {
                assessments,
                pagination: { currentPage: page, pageSize: limit, totalCount, totalPages }
            };
            console.log(`[API GET /assessments] Returning ${assessments.length} assessments. Total: ${totalCount}`);
            return NextResponse.json(responsePayload);

        } catch (error) {
            console.error(`[API GET /assessments] CATCH BLOCK fetching list:`, error);
            return NextResponse.json({ error: 'Failed to fetch assessments list' }, { status: 500 });
        }
    }
}

// PATCH handler (remains exactly as you provided)
export async function PATCH(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const assessmentId = searchParams.get('assessmentId');
    if (!assessmentId) { return NextResponse.json({ error: 'Assessment ID is required for PATCH' }, { status: 400 });}
    console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] Request to update.`);
    const supabaseUserClient = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();
    try {
        const { data: { user }, error: authError } = await supabaseUserClient.auth.getUser();
        if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }
        const { data: assessment, error: fetchError } = await adminSupabase.from('student_assessments').select('chatbot_id').eq('assessment_id', assessmentId).single();
        if (fetchError || !assessment) { return NextResponse.json({ error: 'Assessment not found' }, { status: 404 });}
        const { data: chatbotOwner, error: chatbotOwnerError } = await adminSupabase.from('chatbots').select('teacher_id').eq('chatbot_id', assessment.chatbot_id).single();
        if (chatbotOwnerError || !chatbotOwner || chatbotOwner.teacher_id !== user.id) { return NextResponse.json({ error: 'Not authorized' }, { status: 403 });}
        const body: UpdateAssessmentPayload = await request.json();
        const updateData: Partial<Omit<StudentAssessment, 'created_at' | 'assessment_id'>> = {};
        if (body.hasOwnProperty('teacher_override_grade')) updateData.teacher_override_grade = body.teacher_override_grade;
        if (body.hasOwnProperty('teacher_override_notes')) updateData.teacher_override_notes = body.teacher_override_notes;
        if (body.status) {
            const validStatuses: AssessmentStatusEnum[] = ['ai_processing', 'ai_completed', 'teacher_reviewed'];
            if (validStatuses.includes(body.status)) updateData.status = body.status;
            else console.warn(`[API PATCH /assessments?assessmentId=${assessmentId}] Invalid status: ${body.status}`);
        }
        updateData.updated_at = new Date().toISOString();
        if (Object.keys(updateData).length <= 1 && updateData.updated_at) { console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] No data fields to update.`); }
        console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] Updating with:`, updateData);
        const { data: updatedAssessment, error: updateError } = await adminSupabase.from('student_assessments').update(updateData).eq('assessment_id', assessmentId).select().single();
        if (updateError) { return NextResponse.json({ error: 'Failed to update assessment', details: updateError.message }, { status: 500 });}
        return NextResponse.json(updatedAssessment);
    } catch (error) {
        console.error(`[API PATCH /assessments?assessmentId=${assessmentId}] General error:`, error);
        if (error instanceof SyntaxError) return NextResponse.json({ error: 'Invalid JSON payload.' }, { status: 400 });
        return NextResponse.json({ error: 'Internal server error during PATCH.' }, { status: 500 });
    }
}// src/app/api/teacher/student-chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface ChatbotInfoFromDB {
  chatbot_id: string;
  name: string;
}

interface RoomChatbotResponseFromDB {
  chatbot_id: string;
  chatbots: ChatbotInfoFromDB;
}

export async function GET(request: NextRequest) {
  try {
    // Extract query parameters instead of path parameters
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');
    const chatbotIdFilter = searchParams.get('chatbotId');

    console.log("Fetching chats for student:", studentId, "in room:", roomId);

    if (!roomId || !studentId) {
      return NextResponse.json({ error: 'Room ID and Student ID are required' }, { status: 400 });
    }

    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.error("Room fetch error or unauthorized:", roomError);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    const { data: membership, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      console.error("Membership fetch error or not a member:", membershipError);
      return NextResponse.json({ error: 'Student is not a member of this room' }, { status: 404 });
    }

    let query = supabase
      .from('chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .eq('user_id', studentId)
      .order('created_at', { ascending: true });

    if (chatbotIdFilter) {
      query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
    }

    const { data: messagesData, error: messagesError } = await query;

    if (messagesError) {
      console.error("Error fetching messages:", messagesError);
      return NextResponse.json({ error: 'Failed to fetch chat messages' }, { status: 500 });
    }

    const allMessages: DatabaseChatMessage[] = (messagesData as DatabaseChatMessage[] | null) || [];

    const { data: roomChatbotsDataRaw, error: chatbotsError } = await supabase
      .from('room_chatbots')
      .select(`
        chatbot_id,
        chatbots:chatbots!inner(
          chatbot_id,
          name
        )
      `)
      .eq('room_id', roomId);

    if (chatbotsError) {
      console.error("Error fetching room chatbots:", chatbotsError);
    }

    const availableChatbots: Array<{ chatbot_id: string; name: string }> = [];
    if (roomChatbotsDataRaw && roomChatbotsDataRaw.length > 0) {
      const typedRoomChatbots = roomChatbotsDataRaw as unknown as RoomChatbotResponseFromDB[];
      typedRoomChatbots.forEach(item => {
        if (item.chatbots && typeof item.chatbots === 'object') {
          availableChatbots.push({
            chatbot_id: item.chatbots.chatbot_id,
            name: item.chatbots.name
          });
        }
      });
    }

    const conversations: Conversation[] = [];
    let currentConversation: Conversation | null = null;
    let currentChatbotIdForConversation: string | null = null;

    for (const message of allMessages) {
      const msgChatbotId = message.metadata?.chatbotId || null;

      if (currentConversation === null || msgChatbotId !== currentChatbotIdForConversation) {
        if (currentConversation) {
          conversations.push(currentConversation);
        }
        const matchingChatbot = availableChatbots.find(c => c.chatbot_id === msgChatbotId);
        currentChatbotIdForConversation = msgChatbotId;
        currentConversation = {
          chatbot_id: msgChatbotId,
          chatbot_name: matchingChatbot ? matchingChatbot.name : (msgChatbotId ? 'Unknown Chatbot' : 'General Chat'),
          started_at: message.created_at,
          messages: [message],
        };
      } else {
        currentConversation.messages.push(message);
      }
    }

    if (currentConversation) {
      conversations.push(currentConversation);
    }

    return NextResponse.json({
      conversations,
      chatbots: availableChatbots,
      pagination: { hasMore: false }
    });

  } catch (error) {
    console.error('Error fetching student chats:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.message, error.stack);
    }
    return NextResponse.json(
      { error: 'Failed to fetch student chats' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server'; // For initial auth and room check
import { createAdminClient } from '@/lib/supabase/admin';         // << IMPORT ADMIN CLIENT

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient(); // Standard client for user context
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API /teacher/students] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API /teacher/students] Authenticated user:', user.id);

    // Verify teacher owns the room using the standard client (respects RLS)
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.warn(`[API /teacher/students] Room not found (ID: ${roomId}) or teacher (ID: ${user.id}) not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }
    console.log(`[API /teacher/students] Teacher ${user.id} authorized for room ${roomId}.`);

    // Fetch memberships using the standard client (respects RLS)
    const { data: memberships, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id, joined_at')
      .eq('room_id', roomId);

    if (membershipError) {
      console.error(`[API /teacher/students] Failed to fetch room memberships for room ${roomId}:`, membershipError.message);
      return NextResponse.json(
        { error: `Failed to fetch room memberships: ${membershipError.message}` },
        { status: 500 }
      );
    }

    if (!memberships || memberships.length === 0) {
      console.log(`[API /teacher/students] No student memberships found for room ${roomId}.`);
      return NextResponse.json([]); // No students in the room
    }

    const studentIds = memberships.map(m => m.student_id);
    console.log(`[API /teacher/students] Student IDs in room ${roomId}:`, studentIds);

    // >> MODIFICATION: Use Admin Client to fetch profiles <<
    const adminSupabase = createAdminClient(); 

    const { data: profilesData, error: profilesError } = await adminSupabase
      .from('profiles')
      .select('user_id, full_name, email') // Select only necessary fields
      .in('user_id', studentIds);

    if (profilesError) {
      console.error(`[API /teacher/students] Admin client failed to fetch profiles for student IDs (${studentIds.join(', ')}):`, profilesError.message);
      // Fall through, error will be handled by studentData mapping if profilesData is null/empty
    } else {
        console.log('[API /teacher/students] Profiles data fetched with admin client:', profilesData);
    }
    
    const studentData = await Promise.all(
      memberships.map(async (membership) => {
        const profile = profilesData?.find(p => p.user_id === membership.student_id);
        
        let name = "Student"; 
        let email = "No email available";

        if (profile) {
          if (profile.full_name) name = profile.full_name;
          else if (profile.email) name = profile.email.split('@')[0]; // Fallback to email username if full_name is missing
          
          if (profile.email) email = profile.email;
        }
        console.log(`[API /teacher/students] Student ${membership.student_id} initial data from profiles: Name='${name}', Email='${email}'`);

        // Fallback to auth.admin.getUserById if profile info is still default,
        // AND if the admin client was available (service_role key is set)
        if ((name === "Student" || email === "No email available") && process.env.SUPABASE_SERVICE_ROLE_KEY) {
          console.log(`[API /teacher/students] Profile for ${membership.student_id} still default, trying auth.admin.getUserById.`);
          try {
            // Use the adminSupabase instance for auth.admin calls too
            const { data: authUserData, error: authUserError } = await adminSupabase.auth.admin.getUserById(membership.student_id);

            if (authUserError) {
              console.warn(`[API /teacher/students] auth.admin.getUserById error for student ${membership.student_id}:`, authUserError.message);
            } else if (authUserData?.user) {
              const fetchedUser = authUserData.user;
              console.log(`[API /teacher/students] auth.admin.getUserById success for ${membership.student_id}. Email: ${fetchedUser.email}, Metadata:`, fetchedUser.user_metadata);
              if (name === "Student") { // Only overwrite if still default
                if (fetchedUser.user_metadata?.full_name) name = fetchedUser.user_metadata.full_name;
                else if (fetchedUser.user_metadata?.name) name = fetchedUser.user_metadata.name;
                else if (fetchedUser.email) name = fetchedUser.email.split('@')[0];
              }
              if (email === "No email available" && fetchedUser.email) { // Only overwrite if still default
                email = fetchedUser.email;
              }
            } else {
              console.log(`[API /teacher/students] auth.admin.getUserById for ${membership.student_id} returned no user data.`);
            }
          } catch (e) {
            console.error(`[API /teacher/students] Exception calling auth.admin.getUserById for ${membership.student_id}:`, e);
          }
        }
        
        console.log(`[API /teacher/students] Final data for student ${membership.student_id}: Name='${name}', Email='${email}'`);
        return {
          user_id: membership.student_id,
          name,
          email,
          joined_at: membership.joined_at,
        };
      })
    );

    return NextResponse.json(studentData);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API /teacher/students] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to fetch students' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/[chatbotId]/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function POST(request: NextRequest) {
  console.log("Document upload request received");
  
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Rest of the function remains the same
    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get file from formData
    const formData = await request.formData();
    console.log("FormData received:", formData);
    
    const file = formData.get('file') as File;
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("File received:", file.name, file.type, file.size);

    // Validate file type
    const fileType = getFileType(file.name);
    if (!fileType) {
      return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });
    }

    // Create storage path
    const filePath = `${user.id}/${chatbotId}/${file.name}`;
    
    // Get file buffer
    const buffer = await file.arrayBuffer();
    
    // Upload file to storage
    const { error: uploadError } = await supabase
      .storage
      .from('documents')
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: true
      });

    if (uploadError) {
      console.error("Storage upload error:", uploadError);
      return NextResponse.json({ error: `Failed to upload file: ${uploadError.message}` }, { status: 500 });
    }

    // Create document record
    const { data: document, error: documentError } = await supabase
      .from('documents')
      .insert({
        chatbot_id: chatbotId,
        file_name: file.name,
        file_path: filePath,
        file_type: fileType,
        file_size: file.size,
        status: 'uploaded'
      })
      .select()
      .single();

    if (documentError) {
      console.error("Document insert error:", documentError);
      
      // Clean up uploaded file if document record creation fails
      await supabase.storage.from('documents').remove([filePath]);
      
      return NextResponse.json({ error: `Failed to create document record: ${documentError.message}` }, { status: 500 });
    }

    return NextResponse.json({
      document: document,
      message: 'Document uploaded successfully. Processing will begin shortly.'
    });
  } catch (error) {
    console.error('Error in document upload:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to upload document' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching documents for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get all documents for this chatbot
    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 });
    }

    return NextResponse.json(documents || []);
  } catch (error) {
    console.error('Error fetching documents:', error);
    return NextResponse.json(
      { error: 'Failed to fetch documents' },
      { status: 500 }
    );
  }
}

// Helper function to determine file type
function getFileType(fileName: string): 'pdf' | 'docx' | 'txt' | null {
  const extension = fileName.split('.').pop()?.toLowerCase();
  
  switch (extension) {
    case 'pdf': return 'pdf';
    case 'docx': case 'doc': return 'docx';
    case 'txt': return 'txt';
    default: return null;
  }
}// src/app/api/teacher/chatbots/[chatbotId]/vectorize/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { processDocument as processDocumentFile } from '@/lib/document-processing/processor';
import type { Document } from '@/types/knowledge-base.types';

export async function POST(request: NextRequest) {
  console.log("Document processing request received via POST");

  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    let body;
    try {
      body = await request.json();
    } catch (parseError) {
      console.error("Error parsing request body:", parseError);
      return NextResponse.json({ error: 'Invalid request body format' }, { status: 400 });
    }

    const documentId = body.documentId;

    if (!documentId) {
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    const { data: document, error: documentError } = await supabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError || !document) {
      console.error("Document not found:", documentError);
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    if (document.status === 'processing') {
      return NextResponse.json({ error: 'Document is already being processed' }, { status: 400 });
    }

    const { error: updateError } = await supabase
      .from('documents')
      .update({
        status: 'processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', documentId);

    if (updateError) {
      console.error("Error updating document status:", updateError);
      return NextResponse.json({ error: 'Failed to update document status' }, { status: 500 });
    }

    // Process in the background using the imported function
    processDocumentFile(document as Document)
      .catch(error => console.error(`Background processing error for doc ${document.document_id}:`, error));

    return NextResponse.json({ message: 'Document processing started' });
  } catch (error) {
    console.error('Error in document processing endpoint (POST):', error);
    return NextResponse.json(
      { error: 'Internal server error during POST' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  console.log("Document processing status GET request received");
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching status for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const documentId = searchParams.get('documentId');

    if (!documentId) {
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    const { data: document, error: documentError } = await supabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError || !document) {
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    const { data: allChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .select('status')
      .eq('document_id', documentId);

    if (chunksError) {
      return NextResponse.json({ error: 'Failed to fetch document chunks' }, { status: 500 });
    }

    const totalChunks = allChunks?.length || 0;
    const processedChunks = allChunks?.filter(chunk => chunk.status === 'embedded').length || 0;
    const errorChunks = allChunks?.filter(chunk => chunk.status === 'error').length || 0;
    const percentComplete = totalChunks ? Math.round((processedChunks / totalChunks) * 100) : 0;

    console.log(`Status for doc ${documentId}: Total ${totalChunks}, Processed ${processedChunks}, Errors ${errorChunks}, Complete ${percentComplete}%`);

    return NextResponse.json({
      document,
      processingStats: {
        totalChunks,
        processedChunks,
        errorChunks,
        percentComplete
      }
    });
  } catch (error) {
    console.error('Error fetching processing status (GET):', error);
    return NextResponse.json(
      { error: 'Failed to fetch processing status' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { deleteChatbotVectors } from '@/lib/pinecone/utils';
import type { CreateChatbotPayload } from '@/types/database.types';

// GET Handler (from your working version - content-reply-027)
export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const { data: chatbots, error: fetchError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) {
      console.error('Error fetching chatbots:', fetchError);
      throw fetchError;
    }

    return NextResponse.json(chatbots || []);
  } catch (error) {
    console.error('Error in GET /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch chatbots' },
      { status: 500 }
    );
  }
}

// POST Handler (from your working version, adapted in content-reply-027, ensure it has bot_type and criteria)
export async function POST(request: NextRequest) { // Changed from Request to NextRequest
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body: CreateChatbotPayload = await request.json();
    console.log("[API POST /teacher/chatbots] Received payload for creation:", body);

    if (!body.name || !body.system_prompt) {
        return NextResponse.json({ error: 'Name and system prompt are required' }, { status: 400 });
    }
    if (body.bot_type === 'assessment' && (!body.assessment_criteria_text || body.assessment_criteria_text.trim() === '')) {
        return NextResponse.json({ error: 'Assessment criteria are required for assessment bots.' }, { status: 400 });
    }

    const chatbotDataToInsert = {
      name: body.name,
      description: body.description,
      system_prompt: body.system_prompt,
      teacher_id: user.id,
      model: body.model || 'x-ai/grok-3-mini-beta', // Default if not provided
      max_tokens: body.max_tokens === undefined || body.max_tokens === null ? 1000 : Number(body.max_tokens),
      temperature: body.temperature === undefined || body.temperature === null ? 0.7 : Number(body.temperature),
      enable_rag: body.bot_type === 'learning' ? (body.enable_rag || false) : false, // RAG only for learning, default false
      bot_type: body.bot_type || 'learning', // Default to 'learning'
      assessment_criteria_text: body.bot_type === 'assessment' ? body.assessment_criteria_text : null,
    };

    const { data: newChatbot, error: insertError } = await supabase
      .from('chatbots')
      .insert(chatbotDataToInsert)
      .select() // Select all fields of the newly created bot
      .single();

    if (insertError) {
      console.error('Error creating chatbot:', insertError);
      if (insertError.code === '23505') {
         return NextResponse.json({ error: 'A chatbot with this name might already exist or another unique constraint was violated.' }, { status: 409 });
      }
      throw insertError;
    }

    return NextResponse.json(newChatbot, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create chatbot' },
      { status: 500 }
    );
  }
}


// NEW DELETE Handler for this collection route
export async function DELETE(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const chatbotId = searchParams.get('chatbotId'); // Expect chatbotId as a query parameter

    if (!chatbotId) {
        return NextResponse.json({ error: 'Chatbot ID is required as a query parameter for deletion' }, { status: 400 });
    }
    console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Request received.`);

    const supabase = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();

    try {
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        // 1. Verify teacher owns the chatbot
        const { data: chatbot, error: fetchError } = await supabase
            .from('chatbots')
            .select('teacher_id, name')
            .eq('chatbot_id', chatbotId)
            .single();

        if (fetchError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error fetching chatbot: ${fetchError.message}`);
            if (fetchError.code === 'PGRST116') return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
            return NextResponse.json({ error: 'Failed to fetch chatbot details' }, { status: 500 });
        }
        if (!chatbot) { // Should be caught by fetchError.code PGRST116, but as a safeguard
            return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
        }
        if (chatbot.teacher_id !== user.id) {
            return NextResponse.json({ error: 'Not authorized to delete this chatbot' }, { status: 403 });
        }
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] User ${user.id} authorized to delete chatbot "${chatbot.name}".`);

        // 2. Delete associated documents from Supabase Storage
        const documentsFolderPath = `${user.id}/${chatbotId}/`;
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Listing files in storage path: ${documentsFolderPath}`);
        const { data: filesInStorage, error: listError } = await adminSupabase.storage
            .from('documents')
            .list(documentsFolderPath);

        if (listError) {
            console.warn(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error listing files in storage for cleanup: ${listError.message}`);
        } else if (filesInStorage && filesInStorage.length > 0) {
            const filePathsToRemove = filesInStorage.map(file => `${documentsFolderPath}${file.name}`);
            if (filePathsToRemove.length > 0) {
                console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Removing ${filePathsToRemove.length} files from storage.`);
                const { error: removeFilesError } = await adminSupabase.storage.from('documents').remove(filePathsToRemove);
                if (removeFilesError) console.warn(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error removing files from storage: ${removeFilesError.message}`);
                else console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Successfully removed files from storage.`);
            }
        }

        // 3. Delete chatbot record from database (cascades should apply)
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Deleting chatbot record from database.`);
        const { error: deleteChatbotError } = await adminSupabase
            .from('chatbots')
            .delete()
            .eq('chatbot_id', chatbotId); // Ensure this uses the admin client

        if (deleteChatbotError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error deleting chatbot from database: ${deleteChatbotError.message}`);
            throw deleteChatbotError;
        }
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Chatbot record deleted from database.`);

        // 4. Delete vectors from Pinecone
        try {
            console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Deleting vectors from Pinecone.`);
            await deleteChatbotVectors(chatbotId);
            console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Pinecone vectors deletion initiated/completed.`);
        } catch (pineconeError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error deleting vectors from Pinecone:`, pineconeError);
        }

        return NextResponse.json({ success: true, message: `Chatbot "${chatbot.name}" and associated data deleted.` });

    } catch (error) {
        console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] General error:`, error);
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to delete chatbot' }, { status: 500 });
    }
}// src/app/api/teacher/dashboard-stats/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  console.log('\n--- [API GET /dashboard-stats] ---');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API STATS] Not authenticated.', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API STATS] User authenticated:', user.id);

    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError || !profile) {
      console.error('[API STATS] Profile fetch failed or not found:', profileError?.message);
      return NextResponse.json({ error: `Profile fetch issue: ${profileError?.message || 'Not found'}` }, { status: 500 });
    }
    if (profile.role !== 'teacher') {
      console.warn('[API STATS] User is not a teacher. Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (not a teacher)' }, { status: 403 });
    }
    console.log('[API STATS] User is teacher. Proceeding with stats.');
    
    // Fetch all stats concurrently
    const [
        chatbotsResult,
        roomsResult,
        activeRoomsResult,
        pendingConcernsResult
    ] = await Promise.all([
        supabase
            .from('chatbots')
            .select('chatbot_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id),
        supabase
            .from('rooms')
            .select('room_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id),
        supabase
            .from('rooms')
            .select('room_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id)
            .eq('is_active', true),
        supabase
            .from('flagged_messages')
            .select('flag_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id)
            .eq('status', 'pending') // <<<< Count only PENDING concerns
    ]);

    // Error handling for each query (optional, but good for debugging)
    if (chatbotsResult.error) console.error('[API STATS] Error fetching chatbots count:', chatbotsResult.error.message);
    if (roomsResult.error) console.error('[API STATS] Error fetching total rooms count:', roomsResult.error.message);
    if (activeRoomsResult.error) console.error('[API STATS] Error fetching active rooms count:', activeRoomsResult.error.message);
    if (pendingConcernsResult.error) console.error('[API STATS] Error fetching pending concerns count:', pendingConcernsResult.error.message);

    const stats = {
      totalChatbots: chatbotsResult.count || 0,
      totalRooms: roomsResult.count || 0,
      activeRooms: activeRoomsResult.count || 0,
      pendingConcerns: pendingConcernsResult.count || 0, // <<<< Use the actual count
    };
    
    console.log('[API STATS] Returning stats:', stats);
    return NextResponse.json(stats);

  } catch (error: unknown) {
    const typedError = error as Error;
    console.error('[API STATS] CATCH BLOCK Error:', typedError.message);
    return NextResponse.json({ error: typedError.message || 'Failed to fetch dashboard stats' }, { status: 500 });
  }
}// src/app/api/teacher/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { DocumentType } from '@/types/knowledge-base.types'; // Use DocumentType only
import { createAdminClient } from '@/lib/supabase/admin'; // For potential cascade deletes or privileged ops if needed

// Helper function to determine file type
function getFileTypeFromFile(file: File): DocumentType | null {
    const fileName = file.name;
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'pdf': return 'pdf';
        case 'doc': case 'docx': return 'docx';
        case 'txt': return 'txt';
        default: return null;
    }
}

// --- GET Handler: Fetch documents for a specific chatbot ---
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const chatbotId = searchParams.get('chatbotId');

  if (!chatbotId) {
    return NextResponse.json({ error: 'Chatbot ID is required as a query parameter' }, { status: 400 });
  }
  console.log(`[API /documents GET] Request for chatbotId: ${chatbotId}`);

  try {
    const supabase = await createServerSupabaseClient(); // User-context client
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.log('[API /documents GET] Not authenticated');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a teacher and owns the chatbot
    const { data: chatbot, error: chatbotOwnerError } = await supabase
      .from('chatbots')
      .select('chatbot_id, teacher_id') // Select teacher_id for ownership check
      .eq('chatbot_id', chatbotId)
      .single(); // Use single to ensure it exists

    if (chatbotOwnerError || !chatbot) {
      console.log(`[API /documents GET] Chatbot not found for ID: ${chatbotId}`, chatbotOwnerError);
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }
    if (chatbot.teacher_id !== user.id) {
        console.log(`[API /documents GET] User ${user.id} does not own chatbot ${chatbotId}. Owner: ${chatbot.teacher_id}`);
        return NextResponse.json({ error: 'Not authorized to access documents for this chatbot' }, { status: 403 });
    }

    // Get all documents for this chatbot
    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      console.error('[API /documents GET] Error fetching documents from DB:', documentsError);
      return NextResponse.json({ error: 'Failed to fetch documents', details: documentsError.message }, { status: 500 });
    }

    return NextResponse.json(documents || []);

  } catch (error) {
    console.error('[API /documents GET] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch documents due to an unexpected error' },
      { status: 500 }
    );
  }
}

// --- POST Handler: Upload a new document for a chatbot ---
export async function POST(request: NextRequest) {
  console.log("[API /documents POST] Document upload request received");
  try {
    const supabase = await createServerSupabaseClient(); // User-context client
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    const chatbotId = formData.get('chatbotId') as string | null;

    if (!file) return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    if (!chatbotId) return NextResponse.json({ error: 'Chatbot ID not provided in form data' }, { status: 400 });
    
    console.log(`[API /documents POST] Processing for chatbot ID: ${chatbotId}, File: ${file.name}`);

    // Verify user owns the chatbot
    const { data: chatbot, error: chatbotOwnerError } = await supabase
      .from('chatbots')
      .select('chatbot_id, teacher_id')
      .eq('chatbot_id', chatbotId)
      .single();

    if (chatbotOwnerError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found for upload' }, { status: 404 });
    }
    if (chatbot.teacher_id !== user.id) {
        return NextResponse.json({ error: 'Not authorized to upload documents to this chatbot' }, { status: 403 });
    }

    const fileType = getFileTypeFromFile(file);
    if (!fileType) return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });
    
    // Max file size check (e.g., 10MB)
    const MAX_FILE_SIZE_MB = 10;
    if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
        return NextResponse.json({ error: `File too large. Maximum size is ${MAX_FILE_SIZE_MB}MB.` }, { status: 413 });
    }


    const filePath = `${user.id}/${chatbotId}/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9_.\-]/g, '_')}`; // Sanitize file name slightly
    const buffer = await file.arrayBuffer();

    console.log(`[API /documents POST] Uploading to storage path: ${filePath}`);
    const { error: uploadError } = await supabase.storage
      .from('documents')
      .upload(filePath, buffer, { contentType: file.type, upsert: false });

    if (uploadError) {
      console.error("[API /documents POST] Storage upload error:", uploadError);
      return NextResponse.json({ error: `Failed to upload file to storage: ${uploadError.message}` }, { status: 500 });
    }
    console.log(`[API /documents POST] File uploaded to storage successfully.`);

    const { data: documentRecord, error: documentInsertError } = await supabase
      .from('documents')
      .insert({
        chatbot_id: chatbotId,
        file_name: file.name,
        file_path: filePath,
        file_type: fileType,
        file_size: file.size,
        status: 'uploaded'
      })
      .select()
      .single();

    if (documentInsertError) {
      console.error("[API /documents POST] Document DB insert error:", documentInsertError);
      // Attempt to clean up storage if DB insert fails
      console.log(`[API /documents POST] Attempting to remove orphaned file from storage: ${filePath}`);
      await supabase.storage.from('documents').remove([filePath]);
      return NextResponse.json({ error: `Failed to create document record in database: ${documentInsertError.message}` }, { status: 500 });
    }
    console.log(`[API /documents POST] Document record created in DB: ${documentRecord.document_id}`);

    return NextResponse.json({
      document: documentRecord,
      message: 'Document uploaded successfully. Processing can now be initiated.'
    }, { status: 201 });

  } catch (error) {
    console.error('[API /documents POST] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to upload document due to an unexpected error' },
      { status: 500 }
    );
  }
}


// --- DELETE Handler: Delete a specific document ---
export async function DELETE(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const documentId = searchParams.get('documentId');

  if (!documentId) {
    return NextResponse.json({ error: 'Document ID is required as a query parameter' }, { status: 400 });
  }
  console.log(`[API /documents DELETE] Request for documentId: ${documentId}`);

  try {
    const supabase = await createServerSupabaseClient(); // User-context for initial checks
    const adminSupabase = createAdminClient(); // Admin client for actual deletion to ensure cascades work if RLS is restrictive
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Fetch the document to get its chatbot_id and file_path, and to verify ownership indirectly
    const { data: document, error: docFetchError } = await supabase
        .from('documents')
        .select('document_id, chatbot_id, file_path')
        .eq('document_id', documentId)
        .single();

    if (docFetchError || !document) {
        console.log(`[API /documents DELETE] Document not found: ${documentId}`, docFetchError);
        return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    // Verify the user (teacher) owns the chatbot associated with this document
    const { data: chatbot, error: chatbotFetchError } = await supabase
        .from('chatbots')
        .select('teacher_id')
        .eq('chatbot_id', document.chatbot_id)
        .single();
    
    if (chatbotFetchError || !chatbot || chatbot.teacher_id !== user.id) {
        console.log(`[API /documents DELETE] User ${user.id} unauthorized to delete document ${documentId} or chatbot not found.`);
        return NextResponse.json({ error: 'Unauthorized to delete this document or its parent chatbot not found' }, { status: 403 });
    }

    // Proceed with deletion using admin client for broader permissions if needed for cascade
    // 1. Delete from 'documents' table (and 'document_chunks' via cascade if RLS on chunks allows or if admin client bypasses)
    // For cascading deletes to work reliably, ensure your foreign key constraint from document_chunks to documents has ON DELETE CASCADE.
    console.log(`[API /documents DELETE] Deleting document record ${documentId} from database.`);
    const { error: dbDeleteError } = await adminSupabase // Using admin for delete operation
      .from('documents')
      .delete()
      .eq('document_id', documentId);

    if (dbDeleteError) {
      console.error(`[API /documents DELETE] Error deleting document record ${documentId} from DB:`, dbDeleteError);
      return NextResponse.json({ error: 'Failed to delete document record from database', details: dbDeleteError.message }, { status: 500 });
    }
    console.log(`[API /documents DELETE] Document record ${documentId} deleted from database.`);

    // 2. Delete from storage
    if (document.file_path) {
        console.log(`[API /documents DELETE] Deleting file from storage: ${document.file_path}`);
        const { error: storageError } = await adminSupabase.storage.from('documents').remove([document.file_path]); // Use admin for storage ops too
        if (storageError) {
            console.error(`[API /documents DELETE] Error deleting file ${document.file_path} from storage:`, storageError);
            // Log this but don't necessarily fail the whole operation if DB record was deleted.
            // The document is effectively gone from the app's perspective. Orphaned storage files can be cleaned up later.
        } else {
            console.log(`[API /documents DELETE] File ${document.file_path} deleted from storage.`);
        }
    }
    
    // 3. TODO: Delete associated vectors from Pinecone (this requires a separate utility call)
    // import { deleteDocumentVectors } from '@/lib/pinecone/utils';
    // await deleteDocumentVectors(documentId).catch(pineconeError => {
    //    console.error(`[API /documents DELETE] Error deleting vectors from Pinecone for document ${documentId}:`, pineconeError);
    // });
    console.log(`[API /documents DELETE] TODO: Implement Pinecone vector deletion for document ${documentId}.`);


    return NextResponse.json({ success: true, message: 'Document deleted successfully' });

  } catch (error) {
    console.error('[API /documents DELETE] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to delete document due to an unexpected error' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/magic-link/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function POST(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // Verify user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Generate a signup link with embedded room code
    const magicLink = `${process.env.NEXT_PUBLIC_APP_URL}/join?code=${room.room_code}`;

    return NextResponse.json({ 
      magicLink: magicLink,
      roomCode: room.room_code 
    });
  } catch (error) {
    console.error('Error generating magic link:', error);
    return NextResponse.json(
      { error: 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function PATCH(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { is_active } = await request.json();
    const params = await context.params;
    const roomId = params.roomId;

    // Update room status
    const { data: room, error } = await supabase
      .from('rooms')
      .update({ is_active })
      .eq('room_id', roomId)
      .eq('teacher_id', user.id) // Ensure only the room owner can update
      .select()
      .single();

    if (error) {
      throw error;
    }

    if (!room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    return NextResponse.json(room);
  } catch (error) {
    console.error('Error updating room:', error);
    return NextResponse.json(
      { error: 'Failed to update room' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // First, check if the user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Delete the room (this will cascade to related tables via foreign key constraints)
    const { error: deleteError } = await supabase
      .from('rooms')
      .delete()
      .eq('room_id', roomId)
      .eq('teacher_id', user.id);

    if (deleteError) {
      throw deleteError;
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting room:', error);
    return NextResponse.json(
      { error: 'Failed to delete room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateRoomCode } from '@/lib/utils/room-codes'; // Ensure this utility exists
import type { CreateRoomPayload } from '@/types/database.types'; // Ensure this type is correct

// GET all rooms for the teacher
export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Fetch teacher's rooms WITH associated chatbot names for display
    const { data: rooms, error: fetchError } = await supabase
      .from('rooms')
      .select(`
        *,
        room_chatbots (
          chatbots ( chatbot_id, name )
        )
      `)
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) throw fetchError;
    return NextResponse.json(rooms || []);
  } catch (error) {
    console.error('Error in GET /api/teacher/rooms:', error);
    return NextResponse.json({ error: 'Failed to fetch rooms' }, { status: 500 });
  }
}

// POST a new room
export async function POST(request: Request) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    
    const { data: profile } = await supabase.from('profiles').select('role, school_id').eq('user_id', user.id).single();
    if (!profile || profile.role !== 'teacher') return NextResponse.json({ error: 'Not authorized' }, { status: 403 });

    const body: CreateRoomPayload = await request.json();
    if (!body.room_name || !body.chatbot_ids || body.chatbot_ids.length === 0) {
      return NextResponse.json({ error: 'Room name and at least one chatbot ID are required' }, { status: 400 });
    }

    let roomCode = '';
    let isUnique = false;
    while (!isUnique) {
      roomCode = generateRoomCode();
      const { data: existing } = await supabase.from('rooms').select('room_code').eq('room_code', roomCode).single();
      if (!existing) isUnique = true;
    }

    // Create room in a transaction
    const { data: newRoom, error: roomInsertError } = await supabase.from('rooms').insert({
      room_name: body.room_name,
      room_code: roomCode,
      teacher_id: user.id,
      school_id: profile.school_id, // from teacher's profile
      is_active: true,
    }).select().single();

    if (roomInsertError) throw roomInsertError;
    if (!newRoom) throw new Error('Room creation failed silently.');

    const roomChatbotEntries = body.chatbot_ids.map(chatbotId => ({
      room_id: newRoom.room_id,
      chatbot_id: chatbotId,
    }));

    const { error: rcInsertError } = await supabase.from('room_chatbots').insert(roomChatbotEntries);
    if (rcInsertError) {
      // Rollback room creation if linking chatbots fails
      await supabase.from('rooms').delete().eq('room_id', newRoom.room_id);
      throw rcInsertError;
    }
    
    // Fetch the complete room data to return
    const { data: completeRoomData, error: fetchCompleteError } = await supabase
        .from('rooms')
        .select(`*, room_chatbots(chatbots(chatbot_id, name))`)
        .eq('room_id', newRoom.room_id)
        .single();

    if (fetchCompleteError) throw fetchCompleteError;

    return NextResponse.json(completeRoomData, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/teacher/rooms:', error);
    return NextResponse.json({ error: 'Failed to create room' }, { status: 500 });
  }
}// src/app/api/teacher/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateRoomCode } from '@/lib/utils/room-codes';
import type { CreateRoomPayload, TeacherRoom } from '@/types/database.types';

// GET all rooms for the teacher
export async function GET() {
  console.log('[API GET /rooms] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API GET /rooms] User authenticated by getUser:', {
        id: user.id, 
        email: user.email, 
        aud: user.aud, // Should be 'authenticated'
        role: user.role // JWT role, typically 'authenticated'
    });

    console.log('[API GET /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileError) {
      console.error('[API GET /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileError, null, 2));
      console.warn('[API GET /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileError.message);
      return NextResponse.json({ error: `User profile not found or error fetching it. Details: ${profileError.message}` }, { status: 403 });
    }
    
    if (!profile) {
      console.warn('[API GET /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
      return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }

    console.log('[API GET /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API GET /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    
    console.log('[API GET /rooms] User is confirmed teacher. Fetching rooms.');
    
    const { data: rooms, error: fetchError } = await supabase
      .from('rooms')
      .select(`
        *,
        room_chatbots (
          chatbots ( chatbot_id, name )
        )
      `)
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) {
      console.error('[API GET /rooms] Error fetching rooms from DB:', fetchError);
      throw fetchError; // Let the outer catch handle it by re-throwing
    }
    console.log(`[API GET /rooms] Successfully fetched ${rooms?.length || 0} rooms.`);
    return NextResponse.json(rooms || []);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string }; // Cast with error properties
    console.error('[API GET /rooms] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}

// POST a new room
export async function POST(request: Request) {
  console.log('[API POST /rooms] Received request to create a new room.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API POST /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API POST /rooms] User authenticated by getUser:', {
        id: user.id, 
        email: user.email, 
        aud: user.aud, // Should be 'authenticated'
        role: user.role // JWT role, typically 'authenticated'
    });
    
    console.log('[API POST /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileFetchError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileFetchError) {
        console.error('[API POST /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileFetchError, null, 2));
        console.warn('[API POST /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileFetchError.message);
        return NextResponse.json({ error: `Error fetching user profile. Details: ${profileFetchError.message}` }, { status: 500 });
    }
    if (!profile) {
        console.error('[API POST /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
        return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }
     console.log('[API POST /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API POST /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    console.log('[API POST /rooms] User is confirmed teacher. Proceeding with room creation.');

    const body: CreateRoomPayload = await request.json();
    console.log('[API POST /rooms] Request body:', body);

    if (!body.room_name || !body.chatbot_ids || !Array.isArray(body.chatbot_ids) || body.chatbot_ids.length === 0) {
      console.warn('[API POST /rooms] Invalid request body: Missing room_name or chatbot_ids.');
      return NextResponse.json({ error: 'Room name and at least one chatbot ID are required' }, { status: 400 });
    }

    let roomCode = '';
    let isUnique = false;
    let attempts = 0;
    const MAX_ATTEMPTS = 10; 
    
    console.log('[API POST /rooms] Generating unique room code...');
    while (!isUnique && attempts < MAX_ATTEMPTS) {
      roomCode = generateRoomCode();
      const { data: existingRoom, error: codeCheckError } = await supabase
        .from('rooms')
        .select('room_code')
        .eq('room_code', roomCode)
        .maybeSingle(); 
      
      if (codeCheckError) {
        console.error('[API POST /rooms] Error checking room code uniqueness:', codeCheckError);
        throw codeCheckError;
      }
      if (!existingRoom) {
        isUnique = true;
      }
      attempts++;
    }

    if (!isUnique) {
        console.error('[API POST /rooms] Failed to generate a unique room code after multiple attempts.');
        throw new Error('Failed to generate a unique room code.');
    }
    console.log('[API POST /rooms] Unique room code generated:', roomCode);

    console.log('[API POST /rooms] Inserting new room into "rooms" table.');
    const { data: newRoom, error: roomInsertError } = await supabase
      .from('rooms')
      .insert({
        room_name: body.room_name,
        room_code: roomCode,
        teacher_id: user.id,
        school_id: profile.school_id, 
        is_active: true,
      })
      .select()
      .single();

    if (roomInsertError) {
      console.error('[API POST /rooms] Error inserting into "rooms" table:', roomInsertError);
      throw roomInsertError;
    }
    if (!newRoom) {
        console.error('[API POST /rooms] Room creation failed: newRoom data is null after insert.');
        throw new Error('Room creation returned no data.');
    }
    console.log('[API POST /rooms] Room inserted successfully. Room ID:', newRoom.room_id);

    console.log('[API POST /rooms] Preparing to insert into "room_chatbots" table.');
    const roomChatbotEntries = body.chatbot_ids.map(chatbotId => ({
      room_id: newRoom.room_id,
      chatbot_id: chatbotId,
    }));

    const { error: rcInsertError } = await supabase
      .from('room_chatbots')
      .insert(roomChatbotEntries);

    if (rcInsertError) {
      console.error('[API POST /rooms] Error inserting into "room_chatbots":', rcInsertError);
      console.log(`[API POST /rooms] Attempting to rollback room creation for room ID: ${newRoom.room_id} due to room_chatbots insert failure.`);
      const { error: deleteError } = await supabase.from('rooms').delete().eq('room_id', newRoom.room_id);
      if (deleteError) {
          console.error(`[API POST /rooms] CRITICAL: Failed to rollback room ${newRoom.room_id} after room_chatbots insert error:`, deleteError);
      } else {
          console.log(`[API POST /rooms] Successfully rolled back room ${newRoom.room_id}.`);
      }
      throw rcInsertError; 
    }
    console.log(`[API POST /rooms] Successfully inserted ${roomChatbotEntries.length} entries into "room_chatbots".`);
    
    console.log('[API POST /rooms] Fetching complete room data for response.');
    const { data: completeRoomData, error: fetchCompleteError } = await supabase
        .from('rooms')
        .select(`
            *,
            room_chatbots (
              chatbots ( chatbot_id, name )
            )
        `)
        .eq('room_id', newRoom.room_id)
        .single();

    if (fetchCompleteError) {
        console.error('[API POST /rooms] Error fetching complete room data after creation:', fetchCompleteError);
        throw fetchCompleteError;
    }
    if (!completeRoomData) {
        console.error('[API POST /rooms] Failed to fetch complete room data after creation, though room should exist.');
        throw new Error('Failed to retrieve newly created room details.');
    }

    console.log('[API POST /rooms] Room creation successful. Returning complete room data.');
    return NextResponse.json(completeRoomData as TeacherRoom, { status: 201 });

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string; constraint?: string };
    console.error('[API POST /rooms] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    if (typedError?.code === '23505' && typedError?.constraint === 'rooms_room_code_key') {
        return NextResponse.json({ error: 'A room with this code already exists. This is highly unlikely and might indicate an issue with room code generation.' }, { status: 409 });
    }
    return NextResponse.json(
      { error: typedError?.message || 'Failed to create room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/concerns/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin'; // << IMPORT ADMIN CLIENT
import type { FlaggedMessage, ConcernStatus, Profile, Room, ChatMessage as DatabaseChatMessage } from '@/types/database.types';
import { PostgrestError, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

// Intermediate type - Simpler, as we'll fetch student profiles separately
type RawFlaggedMessage = FlaggedMessage & {
    // No 'student' field here initially
    room: Pick<Room, 'room_name'> | null;
    message: Pick<DatabaseChatMessage, 'content' | 'created_at' | 'metadata'> | null;
};

interface FlaggedConcernListDetails extends FlaggedMessage {
    student_name: string | null;
    student_email: string | null;
    room_name: string | null;
    message_content: string | null;
}
// ... (FlagDetailsResponse and getSingleConcernDetails can remain mostly as is, but getSingleConcernDetails will also use admin client for student profile)
interface FlagDetailsResponse extends FlaggedMessage {
    student: null;
    student_name: string | null;
    student_email: string | null;
    room_name: string;
    message_content: string;
    message: DatabaseChatMessage | null;
    surroundingMessages: DatabaseChatMessage[];
}


export async function GET(request: NextRequest) {
    console.log('[API GET /concerns] Received request.');
    try {
        const supabase = await createServerSupabaseClient(); // Standard client for user context
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) { /* ... auth checks ... */ 
            console.warn('[API GET /concerns] Not authenticated.');
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }
        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
        if (profileError || !profile || profile.role !== 'teacher') {
            console.warn('[API GET /concerns] User profile/role issue.');
            return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
        }
        console.log(`[API GET /concerns] Authenticated teacher: ${user.id}`);

        const { searchParams } = new URL(request.url);
        const flagId = searchParams.get('flagId');
        
        if (flagId) {
            console.log(`[API GET /concerns] Fetching single concern details for flagId: ${flagId}`);
            // Modify getSingleConcernDetails to use admin client for student profile
            return await getSingleConcernDetails_V2(supabase, flagId, user.id); 
        }
        
        const statusFilter = searchParams.get('status');
        const limit = parseInt(searchParams.get('limit') || '10', 10);
        const page = parseInt(searchParams.get('page') || '0', 10);
        const offset = page * limit;

        console.log(`[API GET /concerns] Fetching concerns list. Status: ${statusFilter || 'all'}, Page: ${page}, Limit: ${limit}`);

        let countQuery = supabase
            .from('flagged_messages')
            .select('*', { count: 'exact', head: true })
            .eq('teacher_id', user.id);

        // Fetch flagged_messages with joins to rooms and chat_messages, but NOT profiles yet
        let dataQuery = supabase
            .from('flagged_messages')
            .select(`
                *, 
                room:rooms!fk_room(room_name),
                message:chat_messages!fk_message(content, created_at, metadata)
            `)
            .eq('teacher_id', user.id) // RLS on flagged_messages will handle this
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);

        if (statusFilter && ['pending', 'reviewing', 'resolved', 'false_positive'].includes(statusFilter)) {
            countQuery = countQuery.eq('status', statusFilter);
            dataQuery = dataQuery.eq('status', statusFilter);
        }

        const [countResult, dataResult] = await Promise.all([countQuery, dataQuery]);

        const { count, error: countError } = countResult;
        const { data: rawFlagsData, error: fetchError } = dataResult as { data: RawFlaggedMessage[] | null, error: PostgrestError | null };

        if (countError) console.warn('[API GET /concerns] Error fetching concerns count:', countError.message);
        if (fetchError) {
            console.error('[API GET /concerns] Error fetching base flagged messages data:', fetchError);
            throw new Error(`Failed to fetch flagged messages: ${fetchError.message}`);
        }

        if (!rawFlagsData || rawFlagsData.length === 0) {
            console.log('[API GET /concerns] No raw flags found.');
            return NextResponse.json({ concerns: [], pagination: { currentPage: page, pageSize: limit, totalCount: 0, totalPages: 0, hasMore: false } });
        }

        // Get unique student IDs from the fetched flags
        const studentIds = [...new Set(rawFlagsData.map(flag => flag.student_id).filter(id => id != null))] as string[];
        const studentProfilesMap: Map<string, Pick<Profile, 'full_name' | 'email'>> = new Map();

        if (studentIds.length > 0) {
            console.log('[API GET /concerns] Fetching profiles for student IDs:', studentIds);
            const adminSupabase = createAdminClient();
            const { data: profilesData, error: profilesError } = await adminSupabase
                .from('profiles')
                .select('user_id, full_name, email')
                .in('user_id', studentIds);

            if (profilesError) {
                console.error('[API GET /concerns] Admin client error fetching student profiles:', profilesError.message);
                // Proceed without student names if this fails, or handle error more gracefully
            } else if (profilesData) {
                profilesData.forEach(p => studentProfilesMap.set(p.user_id, { full_name: p.full_name, email: p.email }));
            }
        }

        // Map raw flags to the detailed response, adding student info
        const concerns: FlaggedConcernListDetails[] = rawFlagsData.map((flag: RawFlaggedMessage) => {
            const studentProfile = flag.student_id ? studentProfilesMap.get(flag.student_id) : null;
            return {
                ...flag,
                student_name: studentProfile?.full_name || 'Unknown Student',
                student_email: studentProfile?.email || null,
                room_name: flag.room?.room_name || 'Unknown Room',
                message_content: flag.message?.content || '[Message Content Unavailable]',
            };
        });

        const totalCount = count || 0;
        const hasMore = (offset + concerns.length) < totalCount;
        const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;

        console.log(`[API GET /concerns] Processed ${concerns.length} concerns for page ${page}, total: ${totalCount}`);
        return NextResponse.json({
            concerns,
            pagination: { currentPage: page, pageSize: limit, totalCount, totalPages, hasMore }
        });

    } catch (error) { /* ... error handling ... */ 
        console.error('[API GET /concerns] CATCH BLOCK Error:', error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'An internal error occurred while fetching concerns.' },
            { status: 500 }
        );
    }
}


// Modified getSingleConcernDetails to use Admin Client for student profile
async function getSingleConcernDetails_V2(
    supabaseUserClient: SupabaseClient<Database>, // User-context client for initial flag fetch
    flagId: string,
    teacherId: string
): Promise<NextResponse> {
    try {
        console.log(`[API getSingleConcernDetails_V2] Fetching details for concern flag ID: ${flagId}`);
        
        // Fetch the main flag data (without student profile yet)
        const { data: flag, error: flagError } = await supabaseUserClient
            .from('flagged_messages')
            .select(`
                *, 
                room:rooms!fk_room(room_name),
                message:chat_messages!fk_message(*)
            `)
            .eq('flag_id', flagId)
            .eq('teacher_id', teacherId) // Ensures teacher owns the flag
            .single();
            
        if (flagError) { /* ... error handling for flag fetch ... */ 
            console.error(`[API getSingleConcernDetails_V2] Error fetching flag ${flagId}:`, flagError);
            if (flagError.code === 'PGRST116') {
                 return NextResponse.json({ error: 'Concern not found or not authorized' }, { status: 404 });
            }
            throw flagError;
        }
        if (!flag) { return NextResponse.json({ error: 'Concern not found' }, { status: 404 }); }
        
        // Cast to a working type, student profile will be added
        const typedFlag = flag as unknown as (FlaggedMessage & { 
            room: Pick<Room, 'room_name'> | null; 
            message: DatabaseChatMessage | null;
        });

        let studentName: string | null = 'Unknown Student';
        let studentEmail: string | null = null;

        if (typedFlag.student_id) {
            const adminSupabase = createAdminClient();
            const { data: studentProfileData, error: studentProfileError } = await adminSupabase
                .from('profiles')
                .select('full_name, email')
                .eq('user_id', typedFlag.student_id)
                .single();
            if (studentProfileError) {
                console.warn(`[API getSingleConcernDetails_V2] Admin client error fetching student profile ${typedFlag.student_id}:`, studentProfileError.message);
            } else if (studentProfileData) {
                studentName = studentProfileData.full_name || studentName;
                studentEmail = studentProfileData.email || studentEmail;
            }
        }

        const response: FlagDetailsResponse = {
            ...typedFlag,
            student: null, // Not fetching the full student object in this structure anymore, using flattened names
            student_name: studentName,
            student_email: studentEmail,
            room_name: typedFlag.room?.room_name || 'Unknown Room',
            message_content: typedFlag.message?.content || '[Message Content Unavailable]',
            message: typedFlag.message, 
            surroundingMessages: [] // Populate this as before
        };
        
        // Fetch surrounding messages (logic remains similar, ensure chatMessageRoomId is correct)
        if (typedFlag.message && typedFlag.message.room_id && typedFlag.student_id) {
            const messageCreatedAt = typedFlag.message.created_at;
            const studentId = typedFlag.student_id;
            const chatMessageRoomId = typedFlag.message.room_id; // TEXT room_id from chat_messages
            const messageChatbotId = typedFlag.message.metadata?.chatbotId || null;

            const { data: messagesData, error: messagesError } = await supabaseUserClient // Use user client for chat history
                .from('chat_messages')
                .select<string, DatabaseChatMessage>("*") 
                .eq('room_id', chatMessageRoomId) 
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', messageChatbotId ? 'eq' : 'is', messageChatbotId || null)
                .lt('created_at', messageCreatedAt) 
                .order('created_at', { ascending: false })
                .limit(5); 
            
            const { data: messagesDataAfter, error: messagesErrorAfter } = await supabaseUserClient
                .from('chat_messages')
                .select<string, DatabaseChatMessage>("*")
                .eq('room_id', chatMessageRoomId) 
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', messageChatbotId ? 'eq' : 'is', messageChatbotId || null)
                .gt('created_at', messageCreatedAt) 
                .order('created_at', { ascending: true })
                .limit(5); 

            if (messagesError || messagesErrorAfter) {
                console.warn(`[API getSingleConcernDetails_V2] Error fetching conversation context for flag ${flagId}:`, messagesError || messagesErrorAfter);
            } else {
                const beforeMessages = (messagesData || []).reverse(); 
                const afterMessages = messagesDataAfter || [];
                const mainFlaggedMessageTyped = typedFlag.message as DatabaseChatMessage;
                response.surroundingMessages = [...beforeMessages, mainFlaggedMessageTyped, ...afterMessages].filter(Boolean);
            }
        }
        
        console.log(`[API getSingleConcernDetails_V2] Successfully fetched details for flag ${flagId}`);
        return NextResponse.json(response);
        
    } catch (error) { /* ... error handling ... */ 
        console.error(`[API getSingleConcernDetails_V2] CATCH for flag ${flagId}:`, error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Failed to fetch concern details' },
            { status: 500 }
        );
    }
}

// PATCH handler remains the same, as it operates on flagged_messages directly
// and RLS for UPDATE on flagged_messages already checks teacher_id.
export async function PATCH(request: NextRequest) {
    console.log('[API PATCH /concerns] Received request.');
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            console.warn('[API PATCH /concerns] Not authenticated.');
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
        if (!profile || profile.role !== 'teacher') {
            console.warn('[API PATCH /concerns] User not a teacher or profile error.');
            return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
        }

        const body = await request.json();
        const { flagId, status, notes } = body;

        if (!flagId) {
            return NextResponse.json({ error: 'Flag ID is required' }, { status: 400 });
        }

        const validStatuses: ConcernStatus[] = ['pending', 'reviewing', 'resolved', 'false_positive'];
        if (!status || !validStatuses.includes(status as ConcernStatus)) {
            return NextResponse.json({ error: `Invalid status provided: ${status}` }, { status: 400 });
        }
        
        if (notes !== undefined && notes !== null && typeof notes !== 'string') {
            return NextResponse.json({ error: 'Invalid notes format, must be a string or null.' }, { status: 400 });
        }

        console.log(`[API PATCH /concerns] Updating flag ${flagId} by teacher ${user.id} to status: ${status}`);

        const updateData: Partial<FlaggedMessage> = {
            status: status as ConcernStatus,
            updated_at: new Date().toISOString(),
            reviewer_id: user.id,
            reviewed_at: new Date().toISOString(),
        };
        if (notes !== undefined) {
            updateData.notes = notes === '' ? null : notes;
        }

        const { data: updatedFlag, error: updateError } = await supabase
            .from('flagged_messages')
            .update(updateData)
            .eq('flag_id', flagId)
            .eq('teacher_id', user.id)
            .select()
            .single();

        if (updateError) {
            console.error(`[API PATCH /concerns] Error updating flag ${flagId}:`, updateError);
            if (updateError.code === 'PGRST116') {
                return NextResponse.json({ error: 'Update failed: Flag not found or permission denied' }, { status: 404 });
            }
            throw updateError;
        }

        if (!updatedFlag) {
            return NextResponse.json({ error: 'Flag not found or update failed post-operation' }, { status: 404 });
        }

        console.log(`[API PATCH /concerns] Flag ${flagId} updated successfully.`);
        return NextResponse.json(updatedFlag);

    } catch (error) { 
        console.error(`[API PATCH /concerns] CATCH BLOCK Error:`, error); 
        return NextResponse.json({ 
            error: error instanceof Error ? error.message : 'Failed to update concern status' 
        }, { status: 500 }); 
    }
}// src/app/api/debug-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    
    if (!roomId) {
      return NextResponse.json({ error: 'roomId parameter required' }, { status: 400 });
    }
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Use admin client to fetch room details
    const adminClient = createAdminClient();
    const { data: room, error: roomError } = await adminClient
      .from('rooms')
      .select('*')
      .eq('room_id', roomId)
      .single();
      
    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found', details: roomError }, { status: 404 });
    }
    
    // Get teacher profile using the room's teacher_id
    const { data: teacherProfile, error: profileError } = await adminClient
      .from('profiles')
      .select('*')
      .eq('user_id', room.teacher_id)
      .single();
      
    return NextResponse.json({
      room,
      teacherProfile,
      profileError,
      teacherIdInRoom: room.teacher_id,
      yourUserId: user.id,
      isMatch: room.teacher_id === user.id,
    });
  } catch {
    return NextResponse.json({ error: 'Failed to get room debug info' }, { status: 500 });
  }
}// src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Container, Card, Button } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';

const HomePage = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const Hero = styled.section`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl} 0;
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.primary};
  font-size: 3rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const CTAButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const Features = styled.section`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  margin-top: ${({ theme }) => theme.spacing.xxl};
`;

const FeatureCard = styled(Card)`
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  
  h3 {
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

export default function Home() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkUserAndRedirect = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        setUser(user);
        
        if (user) {
          setIsRedirecting(true);
          
          // Get user profile to check role
          const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
          
          if (profile?.role === 'teacher') {
            router.push('/teacher-dashboard');
          } else if (profile?.role === 'student') {
            router.push('/student');
          }
        }
      } catch (error) {
        console.error('Error checking user:', error);
      } finally {
        setLoading(false);
      }
    };

    checkUserAndRedirect();
  }, [router, supabase]);

  if (loading || isRedirecting) {
    return (
      <HomePage>
        <Container>
          <Hero>
            <Title>Loading...</Title>
          </Hero>
        </Container>
      </HomePage>
    );
  }

  return (
    <HomePage>
      <Container>
        <Hero>
          <Title>ClassBots AI</Title>
          <Subtitle>AI-powered chatbots for modern classrooms</Subtitle>
          
          {!user && (
            <CTAButtons>
              <Button size="large" onClick={() => router.push('/auth')}>
                Teacher Sign In
              </Button>
              <Button size="large" variant="secondary" onClick={() => router.push('/join')}>
                Student: Join Class
              </Button>
            </CTAButtons>
          )}
        </Hero>

        <Features>
          <FeatureCard>
            <h3>For Teachers</h3>
            <p>Create custom AI chatbots tailored to your classroom needs</p>
          </FeatureCard>
          <FeatureCard>
            <h3>For Students</h3>
            <p>Learn interactively with AI-powered classroom assistants</p>
          </FeatureCard>
          <FeatureCard>
            <h3>Easy to Use</h3>
            <p>Simple setup and magic link access for students</p>
          </FeatureCard>
        </Features>
      </Container>
    </HomePage>
  );
}/* src/app/globals.css */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}// src/app/providers.tsx
'use client';

import StyledComponentsRegistry from '@/lib/StyledComponentsRegistry';
import ThemeProvider from '@/components/ThemeProvider';

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <StyledComponentsRegistry>
      <ThemeProvider>
        {children}
      </ThemeProvider>
    </StyledComponentsRegistry>
  );
}// src/styles/GlobalStyles.ts
'use client';

import { createGlobalStyle } from 'styled-components';

export const GlobalStyles = createGlobalStyle`
  /* Use web-safe fonts for now - add Google Fonts to your layout.tsx instead */
  
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  
  html, body {
    max-width: 100vw;
    overflow-x: hidden;
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: ${({ theme }) => theme.fonts.heading};
    line-height: 1.2;
    color: ${({ theme }) => theme.colors.text};
    font-weight: 600;
  }
  
  h1 { font-size: 2.5rem; }
  h2 { font-size: 2rem; }
  h3 { font-size: 1.75rem; }
  h4 { font-size: 1.5rem; }
  h5 { font-size: 1.25rem; }
  h6 { font-size: 1rem; }
  
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }
  
  a {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: none;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primaryLight};
    }
  }
  
  button {
    font-family: ${({ theme }) => theme.fonts.body};
    cursor: pointer;
    border: none;
    background: none;
    transition: all ${({ theme }) => theme.transitions.fast};
    
    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  }
  
  input, textarea, select {
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.5;
  }
  
  /* Custom scrollbar styles */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  
  ::-webkit-scrollbar-track {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  ::-webkit-scrollbar-thumb {
    background: ${({ theme }) => theme.colors.border};
    border-radius: ${({ theme }) => theme.borderRadius.small};
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: ${({ theme }) => theme.colors.borderDark};
  }
  
  /* Focus styles */
  button:focus-visible,
  input:focus-visible,
  textarea:focus-visible,
  select:focus-visible {
    outline: 2px solid ${({ theme }) => theme.colors.focus};
    outline-offset: 2px;
  }
`;// src/styles/StyledComponents.ts
import styled from 'styled-components'; // Removed 'css' import as it's not used here

export const Container = styled.div`
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0 ${({ theme }) => theme.spacing.md};
  }
`;

export const Card = styled.div`
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.xl};
  padding: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.lg};
  }
`;

export const Button = styled.button<{
    variant?: 'primary' | 'secondary' | 'outline' | 'danger'; // Added 'danger'
    size?: 'small' | 'medium' | 'large';
  }>`
    background: ${({ theme, variant = 'primary' }) => {
      // Determine background color based on variant
      if (variant === 'primary') return theme.colors.primary;
      if (variant === 'secondary') return theme.colors.secondary;
      if (variant === 'danger') return theme.colors.red; // Danger background
      // For 'outline' or any other unspecified variant, background is transparent
      return 'transparent'; 
    }};
    color: ${({ theme, variant = 'primary' }) => {
      // Determine text color based on variant
      if (variant === 'outline') return theme.colors.primary;
      // For primary, secondary, danger, text is white (or could be adjusted)
      return 'white'; 
    }};
    border: ${({ theme, variant }) => {
      // Determine border based on variant
      if (variant === 'outline') return `2px solid ${theme.colors.primary}`;
      // Danger variant could also have a border matching its background or a darker shade
      if (variant === 'danger') return `2px solid ${theme.colors.red}`; 
      // Primary and secondary have no border by default in this setup
      return 'none'; 
    }};
    padding: ${({ theme, size = 'medium' }) =>
      size === 'small' ? `${theme.spacing.xs} ${theme.spacing.md}` :
      size === 'large' ? `${theme.spacing.md} ${theme.spacing.xl}` :
      `${theme.spacing.sm} ${theme.spacing.lg}`
    };
    border-radius: ${({ theme }) => theme.borderRadius.large};
    font-weight: 500;
    transition: all ${({ theme }) => theme.transitions.fast};
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1.2;
    text-decoration: none; // For 'as={Link}' usage

    &:hover:not(:disabled) {
      background: ${({ theme, variant = 'primary' }) => {
        if (variant === 'primary') return theme.colors.primaryDark;
        if (variant === 'secondary') return theme.colors.secondaryDark;
        if (variant === 'danger') return theme.colors.red; // Could define theme.colors.redDark
        if (variant === 'outline') return theme.colors.primary; 
        return undefined; // Fallback or inherit
      }};
      border-color: ${({ theme, variant = 'primary' }) => {
        // Ensure border color might change on hover too if desired
        if (variant === 'danger') return theme.colors.red; // Or theme.colors.redDark
        if (variant === 'outline') return theme.colors.primary; // Border remains primary for outline on hover
        return undefined; // Fallback
      }};
      color: ${({ variant }) => {
        if (variant === 'outline') return 'white'; // Outline text becomes white on hover
        // For other variants like danger, text color typically remains white
        return 'white'; 
      }};
      transform: translateY(-1px);
      box-shadow: ${({ theme }) => theme.shadows.md};
    }

    &:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    &:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  `;

// Inherit from Button for consistency
export const SecondaryButton = styled(Button).attrs({ variant: 'secondary' })``;
export const OutlineButton = styled(Button).attrs({ variant: 'outline' })``;
export const DangerButton = styled(Button).attrs({ variant: 'danger' })``; // Optional: specific export for danger

export const FormGroup = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

export const Label = styled.label`
  display: block;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.9rem;
`;

export const Input = styled.input`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast};
  min-height: 44px;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary + '40'};
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const TextArea = styled.textarea`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.6;
  transition: border-color ${({ theme }) => theme.transitions.fast};
  min-height: 100px;
  resize: vertical;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary + '40'};
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

   &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const Select = styled.select`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast};
  min-height: 44px;
  cursor: pointer;
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${({ theme }) => theme.colors.textMuted.replace('#', '')}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right ${({ theme }) => theme.spacing.md} center;
  background-size: 0.65em auto;
  padding-right: ${({ theme }) => `calc(${theme.spacing.md} * 2.5 + 1em)`};

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary + '40'};
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
    background-image: none;
  }

  option {
    color: ${({ theme }) => theme.colors.text};
    background: ${({ theme }) => theme.colors.background};
  }
`;

export const Alert = styled.div<{ variant?: 'info' | 'success' | 'warning' | 'error' }>`
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  border-left: 4px solid;
  font-size: 0.9rem;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `
          background: ${theme.colors.green + '15'};
          border-color: ${theme.colors.green};
          color: ${theme.colors.text};
        `;
      case 'warning':
        return `
          background: ${theme.colors.secondary + '15'};
          border-color: ${theme.colors.secondary};
          color: ${theme.colors.text};
        `;
      case 'error':
        return `
          background: ${theme.colors.red + '15'};
          border-color: ${theme.colors.red};
          color: ${theme.colors.text};
        `;
      default: // info
        return `
          background: ${theme.colors.blue + '15'};
          border-color: ${theme.colors.blue};
          color: ${theme.colors.text};
        `;
    }
  }}
`;

export const Badge = styled.span<{ variant?: 'default' | 'success' | 'warning' | 'error' }>`
  display: inline-flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.round};
  font-size: 0.75rem;
  font-weight: 600;
  line-height: 1;
  text-transform: uppercase;
  letter-spacing: 0.05em;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `
          background: ${theme.colors.green + '20'};
          color: ${theme.colors.green};
        `;
      case 'warning':
        return `
          background: ${theme.colors.secondary + '20'};
          color: ${theme.colors.secondaryDark};
        `;
      case 'error':
        return `
          background: ${theme.colors.red + '20'};
          color: ${theme.colors.red};
        `;
      default: 
        return `
          background: ${theme.colors.primary + '20'};
          color: ${theme.colors.primary};
        `;
    }
  }}
`;// src/styles/theme.ts
import { DefaultTheme } from 'styled-components';

const theme: DefaultTheme = {
  colors: {
    // Primary colors - inspired by Canva's purple
    primary: '#6B50B7', // Canva-like purple
    primaryLight: '#9B8DD4', // Lighter purple
    primaryDark: '#4A3889', // Darker purple
    
    // Secondary colors - accent colors
    secondary: '#FFB849', // Warm accent orange
    secondaryLight: '#FFC978',
    secondaryDark: '#E5A03D',
    
    // Neutral colors
    background: '#FFFFFF', // Clean white
    backgroundDark: '#F5F5F5', // Light gray
    backgroundCard: '#F9FAFB', // Card background
    text: '#1A1E2E', // Deep dark blue
    textLight: '#5E6C7A', // Muted blue-gray
    textMuted: '#9CA3AF', // Light gray text
    
    // Accent colors
    green: '#4BCE97', // Success green
    red: '#F87F7F', // Error red/pink
    blue: '#4A9FFF', // Info blue
    
    // UI colors
    border: '#E5E7EB', // Light border
    borderDark: '#D1D5DB', // Darker border
    focus: '#6B50B7', // Focus ring color
    shadow: '0, 0, 0', // Shadow RGB
  },
  
  fonts: {
    heading: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    body: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    mono: "'SF Mono', 'Fira Code', Consolas, monospace",
  },
  
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px',
  },
  
  borderRadius: {
    small: '6px', // Slightly bigger for modern look
    medium: '8px',
    large: '12px',
    xl: '16px', // Extra large for cards
    round: '50%',
  },
  
  shadows: {
    sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
    md: '0 4px 6px rgba(0, 0, 0, 0.1)',
    lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
    xl: '0 20px 25px rgba(0, 0, 0, 0.1)',
  },
  
  gradients: {
    primary: 'linear-gradient(135deg, #6B50B7, #8A74C5)',
    secondary: 'linear-gradient(135deg, #FFB849, #FFC978)',
  },
  
  breakpoints: {
    mobile: '480px',
    tablet: '768px',
    desktop: '1024px',
    wide: '1280px',
  },
  
  transitions: {
    fast: '0.15s ease',
    normal: '0.25s ease',
    slow: '0.35s ease',
  },
};

export default theme;// src/components/auth/MagicLink.tsx
'use client';

import { useState, useEffect, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Alert } from '@/styles/StyledComponents';

const MagicCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const SubText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
`;

const RoomCode = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

function MagicLinkContent() {
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [error, setError] = useState<string>('');
  const [roomCode, setRoomCode] = useState<string>('');
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const handleMagicLink = async () => {
      // Check if we're in the browser
      if (typeof window === 'undefined') return;

      const params = new URLSearchParams(window.location.search);
      // Get all possible parameters
      const code = params.get('token') || params.get('code');
      const roomCodeParam = params.get('room');
      
      if (!code || !roomCodeParam) {
        console.log('Missing parameters:', { code, roomCodeParam });
        setError('Invalid magic link: missing required parameters');
        setStatus('error');
        return;
      }

      setRoomCode(roomCodeParam);

      try {
        // Exchange code for session using client-side supabase only
        const { error: authError } = await supabase.auth.exchangeCodeForSession(code);
        if (authError) throw authError;

        // Get user data
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) throw userError || new Error('No user found');

        // Get room details
        const { data: room, error: roomError } = await supabase
          .from('rooms')
          .select('room_id, school_id')
          .eq('room_code', roomCodeParam)
          .single();

        if (roomError || !room) throw roomError || new Error('Room not found');

        // Create or update user profile
        const { error: profileError } = await supabase
          .from('profiles')
          .upsert(
            { 
              user_id: user.id,
              email: user.email || '',
              role: 'student',
              school_id: room.school_id 
            },
            { onConflict: 'user_id' }
          );

        if (profileError) throw profileError;

        // Join the room
        const { error: joinError } = await supabase
          .from('room_memberships')
          .insert({
            room_id: room.room_id,
            student_id: user.id
          });

        // Ignore duplicate errors
        if (joinError && !joinError.message.includes('duplicate')) {
          throw joinError;
        }

        setStatus('success');
        
        // Redirect to student dashboard after 2 seconds
        setTimeout(() => {
          router.push('/student');
        }, 2000);

      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to process magic link');
        setStatus('error');
      }
    };

    handleMagicLink();
  }, [router, supabase]);

  return (
    <MagicCard>
      <Title>Join Classroom</Title>
      
      {roomCode && (
        <RoomCode>{roomCode}</RoomCode>
      )}

      {status === 'loading' && (
        <SubText>Processing your invitation...</SubText>
      )}

      {status === 'success' && (
        <>
          <Alert variant="success">Successfully joined classroom!</Alert>
          <SubText>Redirecting to your dashboard...</SubText>
        </>
      )}

      {status === 'error' && (
        <>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.push('/auth')}>
            Go to Login
          </Button>
        </>
      )}
    </MagicCard>
  );
}

export default function MagicLink() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MagicLinkContent />
    </Suspense>
  );
}// src/components/auth/AuthForm.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, FormGroup, Label, Input, Button as StyledButton, Alert } from '@/styles/StyledComponents';

const AuthCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
`;

const Title = styled.h1`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const InfoBox = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  
  p {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
  
  strong {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

interface AuthFormProps {
  type: 'login' | 'signup';
}

export default function AuthForm({ type }: AuthFormProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [fullName, setFullName] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const isStudentSignup = searchParams?.get('type') === 'student';
  const redirectTo = searchParams?.get('redirect') || '/';

  const checkUser = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      router.push(redirectTo);
    }
  }, [supabase, router, redirectTo]);

  useEffect(() => {
    checkUser();
  }, [checkUser]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate full name for all signup types
    if (type === 'signup' && !fullName.trim()) {
      setError('Full name is required');
      return;
    }
    
    setLoading(true);
    setError('');

    try {
      if (type === 'signup') {
        // Determine role based on student signup flag
        const role = isStudentSignup ? 'student' : 'teacher';
        
        // Simplified signup with just the essential data
        // Let the database trigger handle profile creation
        const { error: signUpError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/auth/callback?redirect=${encodeURIComponent(redirectTo)}`,
            data: {
              role: role,
              full_name: fullName,
            }
          },
        });
        
        if (signUpError) {
          console.error('Signup error details:', signUpError);
          throw signUpError;
        }
        
        // For student signup, wait a moment then try to sign in
        if (isStudentSignup) {
          // Wait a moment for account creation to complete
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Try to sign in
          const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
            email,
            password,
          });
          
          if (!signInError && signInData.user) {
            // Successfully signed in, redirect to join page
            router.push(redirectTo);
          } else {
            // If login fails, show error but allow student to proceed to login page
            setError('Account created! Please log in to continue.');
            setTimeout(() => {
              router.push(`/auth?type=login&redirect=${encodeURIComponent(redirectTo)}`);
            }, 3000);
          }
        } else {
          // For teachers, show success message
          alert('Check your email for the confirmation link!');
        }
      } else {
        // Handle login
        const { error: signInError } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        
        if (signInError) {
          throw signInError;
        }
        
        router.push(redirectTo);
        router.refresh();
      }
    } catch (error) {
      console.error('Auth error:', error);
      setError(error instanceof Error ? error.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  // Special UI for student signup (very similar to teacher signup now)
  if (isStudentSignup && type === 'signup') {
    return (
      <AuthCard>
        <Title>Student Sign Up</Title>
        
        <InfoBox>
          <p><strong>For Students:</strong> Sign up here to join your classroom.</p>
        </InfoBox>
        
        {error && <Alert variant="error">{error}</Alert>}
        
        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="fullName">Full Name</Label>
            <Input
              id="fullName"
              type="text"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
              placeholder="Enter your full name"
              required
            />
          </FormGroup>
          <FormGroup>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Enter your email"
              required
            />
          </FormGroup>
          <FormGroup>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Create a password"
              required
            />
          </FormGroup>
          <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
            {loading ? 'Creating Account...' : 'Sign Up as Student'}
          </StyledButton>
        </form>
      </AuthCard>
    );
  }

  // Regular auth form for teachers or login
  return (
    <AuthCard>
      <Title>{type === 'login' ? 'Login' : 'Teacher Sign Up'}</Title>
      
      {type === 'signup' && (
        <InfoBox>
          <p><strong>For Teachers:</strong> Sign up here to create your teacher account.</p>
          <p><strong>For Students:</strong> Ask your teacher for a join link to create your account.</p>
        </InfoBox>
      )}
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        {type === 'signup' && (
          <FormGroup>
            <Label htmlFor="fullName">Full Name</Label>
            <Input
              id="fullName"
              type="text"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
              placeholder="Enter your full name"
              required
            />
          </FormGroup>
        )}
        <FormGroup>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Enter your email"
            required
          />
        </FormGroup>
        <FormGroup>
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter your password"
            required
          />
        </FormGroup>
        <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
          {loading ? 'Loading...' : type === 'login' ? 'Login' : 'Sign Up as Teacher'}
        </StyledButton>
      </form>
    </AuthCard>
  );
}// src/components/layout/Footer.tsx
'use client';

import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';

const FooterWrapper = styled.footer`
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.xl} 0;
  margin-top: auto;
`;

const FooterContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    text-align: center;
  }
`;

const Copyright = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

const Links = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  
  a {
    color: ${({ theme }) => theme.colors.textMuted};
    text-decoration: none;
    font-size: 0.875rem;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primary};
    }
  }
`;

export default function Footer() {
  const currentYear = new Date().getFullYear();
  
  return (
    <FooterWrapper>
      <Container>
        <FooterContent>
          <Copyright>
            © {currentYear} {APP_NAME}. All rights reserved.
          </Copyright>
          <Links>
            <a href="/privacy">Privacy Policy</a>
            <a href="/terms">Terms of Service</a>
            <a href="/help">Help Center</a>
          </Links>
        </FooterContent>
      </Container>
    </FooterWrapper>
  );
}// src/components/layout/Header.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';
import { Container, Button } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';
import type { User } from '@supabase/supabase-js';

const HeaderWrapper = styled.header`
  background: ${({ theme }) => theme.colors.background};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md} 0;
  position: sticky;
  top: 0;
  z-index: 100;
`;

const HeaderContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-wrap: wrap;
    gap: ${({ theme }) => theme.spacing.sm};
  }
`;

const Logo = styled(Link)`
  font-size: 1.5rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.primary};
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  
  &:hover {
    color: ${({ theme }) => theme.colors.primaryDark};
  }
`;

const Nav = styled.nav`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    order: 3;
    width: 100%;
    justify-content: center;
    margin-top: ${({ theme }) => theme.spacing.sm};
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const NavLink = styled(Link)`
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
    color: ${({ theme }) => theme.colors.primary};
  }
  
  &.active {
    background: ${({ theme }) => theme.colors.primaryLight}20;
    color: ${({ theme }) => theme.colors.primary};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.sm};
    flex: 1;
    text-align: center;
  }
`;

const UserSection = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    min-width: 100px; /* Ensure consistent space */
    justify-content: flex-end;
  }
`;

const HeaderButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    font-size: 0.9rem;
  }
`;

export default function Header() {
  const [user, setUser] = useState<User | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  const supabase = createClient();

  useEffect(() => {
    const getUserInfo = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      setUser(user);
      
      if (user) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', user.id)
          .single();
        
        if (profile) {
          setUserRole(profile.role);
        }
      }
    };
    
    getUserInfo();

    // Add auth state change listener
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user || null);
      
      // Update role if user exists
      if (session?.user) {
        supabase
          .from('profiles')
          .select('role')
          .eq('user_id', session.user.id)
          .single()
          .then(({ data }) => {
            if (data) {
              setUserRole(data.role);
            }
          });
      } else {
        setUserRole(null);
      }
    });

    // Cleanup subscription on unmount
    return () => {
      subscription.unsubscribe();
    };
  }, [supabase]);

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    window.location.href = '/';
  };

  return (
    <HeaderWrapper>
      <Container>
        <HeaderContent>
          <Logo href="/">
            {APP_NAME}
          </Logo>
          
          {user && (
            <Nav>
              {userRole === 'teacher' && (
                <NavLink href="/teacher-dashboard">Dashboard</NavLink>
              )}
              {userRole === 'student' && (
                <NavLink href="/student">My Rooms</NavLink>
              )}
            </Nav>
          )}
          
          <UserSection>
            {user ? (
              <HeaderButton variant="outline" onClick={handleSignOut}>
                Sign Out
              </HeaderButton>
            ) : (
              <HeaderButton as={Link} href="/auth">
                Sign In
              </HeaderButton>
            )}
          </UserSection>
        </HeaderContent>
      </Container>
    </HeaderWrapper>
  );
}// src/components/student/RoomList.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button } from '@/styles/StyledComponents';
import type { StudentRoom } from '@/types/student.types';

const RoomGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCard = styled(Card)`
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    transform: translateY(-2px);
  }
`;

const RoomHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const RoomName = styled.h3`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 1.25rem;
`;

const RoomDetails = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const ChatbotsList = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ChatbotInfo = styled.div`
  font-weight: 600;
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.div`
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 0.875rem;
  
  &:last-child {
    margin-bottom: 0;
  }
  
  strong {
    color: ${({ theme }) => theme.colors.text};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-top: ${({ theme }) => theme.spacing.xs};
  }
`;

const EmptyState = styled.div`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
`;

const RoomFooter = styled.div`
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const JoinedDate = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface RoomListProps {
  rooms: StudentRoom[];
}

export default function RoomList({ rooms }: RoomListProps) {
  return (
    <RoomGrid>
      {rooms.map((room) => (
        <RoomCard key={room.room_id}>
          <RoomHeader>
            <RoomName>{room.room_name}</RoomName>
            <RoomDetails>
              Room Code: <strong>{room.room_code}</strong>
            </RoomDetails>
          </RoomHeader>
          
          <ChatbotsList>
            {room.chatbots.length > 0 ? (
              <>
                <ChatbotInfo>
                  {room.chatbots.length} chatbot{room.chatbots.length > 1 ? 's' : ''}:
                </ChatbotInfo>
                {room.chatbots.map((chatbot) => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <strong>{chatbot.name}</strong>
                    {chatbot.description && (
                      <p>{chatbot.description}</p>
                    )}
                  </ChatbotItem>
                ))}
              </>
            ) : (
              <EmptyState>No chatbots assigned</EmptyState>
            )}
          </ChatbotsList>
          
          <RoomFooter>
            <JoinedDate>
              Joined: {new Date(room.joined_at || room.created_at).toLocaleDateString()}
            </JoinedDate>
            <Button 
              as={Link} 
              href={`/room/${room.room_id}`}
              size="medium"
              style={{ 
                minWidth: '120px',
                textAlign: 'center'
              }}
            >
              Enter Room
            </Button>
          </RoomFooter>
        </RoomCard>
      ))}
    </RoomGrid>
  );
}// src/components/student/JoinRoom.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';
import { isValidRoomCode } from '@/lib/utils/room-codes';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0 0 ${({ theme }) => theme.spacing.sm} 0;
  color: ${({ theme }) => theme.colors.text};
`;

const Description = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface JoinRoomProps {
  onClose: () => void;
  onSuccess: () => void;
}

export default function JoinRoom({ onClose, onSuccess }: JoinRoomProps) {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isCheckingAuth, setIsCheckingAuth] = useState(true);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setIsAuthenticated(true);
        }
      } catch (error) {
        console.error('Auth check error:', error);
      } finally {
        setIsCheckingAuth(false);
      }
    };
    
    checkAuth();
  }, [supabase]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formattedCode = roomCode.toUpperCase();

    if (!isValidRoomCode(formattedCode)) {
      setError('Invalid room code format');
      setIsLoading(false);
      return;
    }

    try {
      if (!isAuthenticated) {
        // If not authenticated, redirect to signup with room code
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
        return;
      }

      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ room_code: formattedCode }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to join room');
      }

      onSuccess();
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to join room');
    } finally {
      setIsLoading(false);
    }
  };

  if (isCheckingAuth) {
    return (
      <Overlay>
        <JoinCard>
          <Header>
            <Title>Loading...</Title>
          </Header>
        </JoinCard>
      </Overlay>
    );
  }

  return (
    <Overlay>
      <JoinCard>
        <Header>
          <Title>Join Classroom</Title>
          <Description>
            {isAuthenticated 
              ? 'Enter the room code provided by your teacher'
              : 'You need to log in to join a classroom'
            }
          </Description>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <Form onSubmit={handleSubmit}>
          <RoomCodeInput
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
            placeholder="ROOM CODE"
            maxLength={6}
            required
          />
          
          <ButtonGroup>
            <Button 
              type="button" 
              variant="outline" 
              onClick={onClose}
              style={{ flex: 1 }}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isLoading}
              style={{ flex: 1 }}
            >
              {isLoading ? 'Joining...' : isAuthenticated ? 'Join Room' : 'Sign In'}
            </Button>
          </ButtonGroup>
        </Form>
      </JoinCard>
    </Overlay>
  );
}// src/components/student/ProfileCompletion.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';

const ProfileCard = styled(Card)`
  max-width: 500px;
  margin: 0 auto;
  padding: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
  text-align: center;
`;

const Description = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function ProfileCompletion({ onComplete }: { onComplete: () => void }) {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClient();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!firstName.trim() || !lastName.trim()) {
      setError('Please enter both first and last name');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      // Update profile with name information
      const { error: updateError } = await supabase
        .from('profiles')
        .update({
          name: `${firstName} ${lastName}`.trim(),
          // We could also add these fields if the database schema supports them
          // first_name: firstName,
          // last_name: lastName,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', user.id);
      
      if (updateError) {
        throw updateError;
      }
      
      // Call the completion callback
      onComplete();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <ProfileCard>
      <Title>Complete Your Profile</Title>
      <Description>
        Please provide your name to complete your profile setup
      </Description>
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        <FormGroup>
          <Label htmlFor="firstName">First Name</Label>
          <Input
            id="firstName"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Enter your first name"
            required
          />
        </FormGroup>
        
        <FormGroup>
          <Label htmlFor="lastName">Last Name</Label>
          <Input
            id="lastName"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            placeholder="Enter your last name"
            required
          />
        </FormGroup>
        
        <Button 
          type="submit" 
          disabled={isSubmitting}
          style={{ width: '100%' }}
        >
          {isSubmitting ? 'Saving...' : 'Complete Profile'}
        </Button>
      </form>
    </ProfileCard>
  );
}// src/components/shared/LoadingSpinner.tsx
'use client';

import styled, { keyframes } from 'styled-components';

const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const SpinnerWrapper = styled.div`
  display: inline-flex;
  align-items: center;
  justify-content: center;
`;

const Spinner = styled.div<{ size?: 'small' | 'medium' | 'large' }>`
  width: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  height: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  border: 3px solid ${({ theme }) => theme.colors.border};
  border-top-color: ${({ theme }) => theme.colors.primary};
  border-radius: 50%;
  animation: ${spin} 1s linear infinite;
`;

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
}

export default function LoadingSpinner({ size = 'medium' }: LoadingSpinnerProps) {
  return (
    <SpinnerWrapper>
      <Spinner size={size} />
    </SpinnerWrapper>
  );
}// src/components/shared/Chat.tsx
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import ChatInput from '@/components/shared/ChatInput';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// --- CORRECTED IMPORT ---
import type { ChatMessage, Chatbot } from '@/types/database.types';
// ------------------------

const ChatContainer = styled(Card)`
  display: flex;
  flex-direction: column;
  height: calc(100vh - 200px); /* Adjust as needed */
  max-height: 800px;
  position: relative;
  padding: 0; /* Remove Card padding if MessagesList/InputContainer handle it */

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    height: calc(100vh - 150px);
    max-height: none;
    margin: 0;
    border-radius: 0;
    border: none; /* Remove border on mobile */
    box-shadow: none; /* Remove shadow on mobile */
  }
`;

const MessagesList = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: ${({ theme }) => theme.spacing.lg};
  background: ${({ theme }) => theme.colors.background};
  /* No border-radius needed if ChatContainer handles it */

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const StyledChatInputContainer = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  background: ${({ theme }) => theme.colors.backgroundCard};
  /* No border-radius needed if ChatContainer handles it */


  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.xl};

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const ErrorContainer = styled(Alert)`
  margin: ${({ theme }) => theme.spacing.md};
`;

const LoadingIndicator = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  height: 100%;
`;

interface ChatProps {
  roomId: string;
  chatbot: Chatbot;
}

export default function Chat({ roomId, chatbot }: ChatProps) {
  // --- CORRECTED TYPE for messages state ---
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  // -----------------------------------------
  const [isLoading, setIsLoading] = useState(false);
  const [isFetchingMessages, setIsFetchingMessages] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [fetchError, setFetchError] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const fetchedRef = useRef(false); // To prevent multiple initial fetches
  const supabase = createClient();

  useEffect(() => {
    const getUserId = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setUserId(user.id);
        } else {
          console.warn("Chat component: User not authenticated.");
          setFetchError("Authentication error. Please log in.");
        }
      } catch (err) {
        console.error('Error getting user ID:', err);
        setFetchError("Could not verify user. Please try refreshing.");
      }
    };
    getUserId();
  }, [supabase]); // Depend only on supabase client

  const scrollToBottom = useCallback(() => { // Wrap in useCallback
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  },[]); // No dependencies needed if it only uses ref

  const fetchMessages = useCallback(async () => {
    if (!chatbot?.chatbot_id || !userId || !roomId) {
        if (!chatbot?.chatbot_id) console.log("Fetch messages waiting: no chatbotId");
        if (!userId) console.log("Fetch messages waiting: no userId");
        if (!roomId) console.log("Fetch messages waiting: no roomId");
        setIsFetchingMessages(false); // Stop loading if prerequisites aren't met
        return;
    }

    console.log(`Fetching messages for room: ${roomId}, chatbot: ${chatbot.chatbot_id}, user: ${userId}`);
    setIsFetchingMessages(true);
    setFetchError(null);
    fetchedRef.current = true;

    try {
      const url = `/api/chat/${roomId}?chatbotId=${chatbot.chatbot_id}`;
      const response = await fetch(url);

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Failed to parse error response');
        console.error(`API error fetching messages: ${response.status}`, errorText);
        throw new Error(`Failed to fetch messages (status: ${response.status})`);
      }

      const data = await response.json();
      console.log("Fetched messages data:", data);
      // --- CORRECTED TYPE for fetched data ---
      setMessages(Array.isArray(data) ? data as ChatMessage[] : []);
      // --------------------------------------
      // Use timeout to allow DOM update before scrolling
      setTimeout(scrollToBottom, 100);
    } catch (err) {
      console.error('Message fetch error:', err);
      setFetchError(err instanceof Error ? err.message : 'Failed to load messages');
      fetchedRef.current = false; // Allow retry if fetch failed
    } finally {
      setIsFetchingMessages(false);
    }
  }, [roomId, chatbot?.chatbot_id, userId, scrollToBottom]); // Add scrollToBottom to deps

  useEffect(() => {
    // Fetch only when userId and chatbotId are available, and haven't successfully fetched yet
    if (userId && chatbot?.chatbot_id && !fetchedRef.current) {
      fetchMessages();
    }
    // If chatbotId changes, reset fetchedRef and fetch again
    const chatbotId = chatbot?.chatbot_id; // Capture for effect cleanup
    return () => {
        if (chatbotId !== chatbot?.chatbot_id) {
            fetchedRef.current = false;
        }
    }

  }, [userId, chatbot?.chatbot_id, fetchMessages]);


  const handleRetryFetch = () => {
    fetchedRef.current = false; // Allow refetch attempt
    fetchMessages();
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim() || isLoading || !userId || !chatbot?.chatbot_id || !roomId) return;

    setIsLoading(true);
    setError(null);

    // --- CORRECTED TYPE for optimistic messages ---
    const optimisticUserMessage: ChatMessage = {
      message_id: `local-user-${Date.now()}`,
      room_id: roomId,
      user_id: userId,
      role: 'user',
      content: content.trim(),
      created_at: new Date().toISOString(),
      metadata: { chatbotId: chatbot.chatbot_id }
    };

    const optimisticAssistantPlaceholder: ChatMessage = {
      message_id: `local-assistant-${Date.now()}`,
      room_id: roomId,
      user_id: "assistant-placeholder", // Placeholder
      role: 'assistant',
      content: 'Thinking...',
      created_at: new Date().toISOString(),
      metadata: { chatbotId: chatbot.chatbot_id }
    };
    // --------------------------------------------

    setMessages(prev => [...prev, optimisticUserMessage, optimisticAssistantPlaceholder]);
    setTimeout(scrollToBottom, 50); // Scroll immediately

    try {
      const response = await fetch(`/api/chat/${roomId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: content.trim(),
          chatbot_id: chatbot.chatbot_id,
          model: chatbot.model // Send model preference if available
        }),
      });

      if (!response.ok || !response.body) {
        const errorData = await response.json().catch(() => ({ error: { message: 'Failed to parse API error response' } }));
        console.error("Send message API error:", errorData);
        throw new Error(errorData.error?.message || `API error sending message (status: ${response.status})`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let streamedContent = '';
      let firstChunkReceived = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

         // Update placeholder on first chunk received
         if (!firstChunkReceived) {
            setMessages(prev => prev.map(msg =>
                msg.message_id === optimisticAssistantPlaceholder.message_id
                ? { ...msg, content: '' } // Clear "Thinking..."
                : msg
            ));
            firstChunkReceived = true;
         }

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);
            if (data.trim() === '[DONE]') continue;
            try {
              const parsedData = JSON.parse(data);
              if (parsedData.content) {
                streamedContent += parsedData.content;
                setMessages(prev => prev.map(msg =>
                  msg.message_id === optimisticAssistantPlaceholder.message_id
                    ? { ...msg, content: streamedContent } // Append streamed content
                    : msg
                ));
                // Consider scrolling less frequently for performance
                 scrollToBottom();
              }
            } catch (e) {
              console.error('Error parsing stream data chunk:', e, "Data:", data);
            }
          }
        }
      }
      console.log("Stream finished. Full response:", streamedContent);
      // Backend saves the full message upon stream completion in its finally block.
      // We can optionally update the local message ID once the backend confirms saving,
      // but for now, the optimistic ID works for rendering.
      // Consider a final update here or rely on a potential WebSocket update later.
       setMessages(prev => prev.map(msg =>
        msg.message_id === optimisticAssistantPlaceholder.message_id
          ? { ...msg, content: streamedContent.trim() } // Ensure final content is trimmed
          : msg
       ));


    } catch (err) {
      console.error('Chat send/receive error:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to send or receive message';
      setError(errorMsg);
      // Remove optimistic messages on error
      setMessages(prev => prev.filter(msg =>
          msg.message_id !== optimisticUserMessage.message_id &&
          msg.message_id !== optimisticAssistantPlaceholder.message_id
      ));
       // Optionally, re-add the user message that failed to send, perhaps with an error indicator
       setMessages(prev => [...prev, {...optimisticUserMessage, metadata: {...optimisticUserMessage.metadata, error: errorMsg}}]);

    } finally {
      setIsLoading(false);
    }
  };

  return (
    <ChatContainer>
      {fetchError && (
        <ErrorContainer variant="error">
          Error loading messages: {fetchError}
          <Button onClick={handleRetryFetch} size="small" style={{ marginLeft: '10px' }}>Retry</Button>
        </ErrorContainer>
      )}

      <MessagesList>
        {isFetchingMessages && messages.length === 0 ? (
           <LoadingIndicator><LoadingSpinner /> Loading messages...</LoadingIndicator>
        ) : !isFetchingMessages && messages.length === 0 && !fetchError ? (
          <EmptyState>
            <h3>Start your conversation with {chatbot.name}</h3>
            <p>Your chat history will appear here.</p>
          </EmptyState>
        ) : (
          messages.map((message) => (
            <ChatMessageComponent
              // Use message_id if available, otherwise generate a fallback key
              key={message.message_id || `local-${message.role}-${message.created_at}-${Math.random()}`}
              message={message}
              chatbotName={chatbot.name}
            />
          ))
        )}
        <div ref={messagesEndRef} /> {/* Element to scroll to */}
      </MessagesList>

      <StyledChatInputContainer>
        <ChatInput
          onSend={handleSendMessage}
          isLoading={isLoading}
          error={error}
          onClearError={() => setError(null)}
        />
      </StyledChatInputContainer>
    </ChatContainer>
  );
}// src/components/shared/ChatMessage.tsx
'use client';

import styled, { css } from 'styled-components'; // Added css import
import ReactMarkdown, { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { ChatMessage as DbChatMessage } from '@/types/database.types'; // Renamed to avoid conflict

// --- Type Definitions ---\
interface ChatMessageProps {
  message: DbChatMessage; // Use the aliased type
  chatbotName: string;
}

type MessageMetadataWithFlags = {
    error?: unknown;
    isAssessmentFeedback?: boolean; // New flag
    isAssessmentPlaceholder?: boolean; // New flag
    [key: string]: unknown;
} | null | undefined;

// --- Styled Components ---
interface MessageWrapperProps {
  $isUser: boolean;
  $hasError: boolean;
}
const MessageWrapper = styled.div<MessageWrapperProps>`
  display: flex;
  justify-content: ${({ $isUser }) => $isUser ? 'flex-end' : 'flex-start'};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  opacity: ${({ $hasError }) => $hasError ? 0.7 : 1};
`;

interface MessageBubbleProps {
  $isUser: boolean;
  $hasError: boolean;
  $isAssessmentFeedback?: boolean; // New prop for styling
  $isAssessmentPlaceholder?: boolean; // New prop for styling
}
const MessageBubble = styled.div<MessageBubbleProps>`
  max-width: 80%;
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme, $isUser }) =>
    $isUser
      ? `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small} ${theme.borderRadius.xl}`
      : `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small}`
  };
  background: ${({ theme, $isUser, $isAssessmentFeedback, $isAssessmentPlaceholder }) => {
    if ($isAssessmentFeedback) return theme.colors.blue + '20'; // Light blue for feedback
    if ($isAssessmentPlaceholder) return theme.colors.backgroundDark;
    return $isUser ? theme.colors.primary : theme.colors.backgroundCard;
  }};
  color: ${({ theme, $isUser, $isAssessmentFeedback, $isAssessmentPlaceholder }) => {
    if ($isAssessmentFeedback) return theme.colors.blue; // Darker blue text
    if ($isAssessmentPlaceholder) return theme.colors.textMuted;
    return $isUser ? 'white' : theme.colors.text;
  }};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  position: relative;
  border: 1px solid transparent; // Default border

  ${({ $hasError, theme }) => $hasError && `
      border-color: ${theme.colors.red};
   `}

  ${({ $isAssessmentFeedback, theme }) => $isAssessmentFeedback && css`
    border-color: ${theme.colors.blue};
    /* You could add an icon or other distinct styling here */
  `}
   ${({ $isAssessmentPlaceholder }) => $isAssessmentPlaceholder && css`
    font-style: italic;
  `}
`;

const MessageHeader = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const SenderName = styled.span`
  font-weight: 600;
  font-size: 0.875rem;
  opacity: 0.8;
`;

const Timestamp = styled.span`
  font-size: 0.75rem;
  opacity: 0.7;
`;

const MessageContent = styled.div<{ $isUser: boolean }>`
  line-height: 1.5;
  word-wrap: break-word;
  // ... (Markdown styling remains the same as previous version)
  h1, h2, h3, h4, h5, h6 { margin-top: ${({ theme }) => theme.spacing.md}; margin-bottom: ${({ theme }) => theme.spacing.sm}; font-weight: 600; line-height: 1.3; color: inherit; }
  h1 { font-size: 1.5em; } h2 { font-size: 1.3em; } h3 { font-size: 1.2em; }
  h4 { font-size: 1.1em; } h5 { font-size: 1em; } h6 { font-size: 0.9em; }
  p { margin-bottom: ${({ theme }) => theme.spacing.sm}; &:last-child { margin-bottom: 0; } }
  ul, ol { margin-bottom: ${({ theme }) => theme.spacing.sm}; padding-left: ${({ theme }) => theme.spacing.lg}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }
  blockquote { border-left: 4px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.5)' : theme.colors.border}; padding-left: ${({ theme }) => theme.spacing.md}; margin: ${({ theme }) => theme.spacing.sm} 0; font-style: italic; color: ${({ $isUser }) => $isUser ? 'rgba(255,255,255,0.9)' : 'inherit'}; opacity: 0.9; }
  pre.code-block-wrapper { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)'}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin: ${({ theme }) => theme.spacing.sm} 0; overflow-x: auto; code { background: none !important; padding: 0 !important; font-family: ${({ theme }) => theme.fonts.mono}; white-space: pre; font-size: 0.9em; color: inherit; } }
  code.inline-code { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.1)'}; padding: 2px 5px; border-radius: ${({ theme }) => theme.borderRadius.small}; font-family: ${({ theme }) => theme.fonts.mono}; font-size: 0.9em; }
  hr { border: none; height: 1px; background: ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; margin: ${({ theme }) => theme.spacing.md} 0; }
  table { border-collapse: collapse; margin: ${({ theme }) => theme.spacing.sm} 0; width: auto; border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; th, td { border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm}; } th { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)'}; font-weight: 600; } }
  a { color: ${({ $isUser, theme }) => $isUser ? '#c1d9ff' : theme.colors.primaryDark}; text-decoration: underline; &:hover { text-decoration: none; } }
  ul.contains-task-list { list-style-type: none; padding-left: ${({ theme }) => theme.spacing.sm}; }
  li.task-list-item { display: flex; align-items: center; input[type="checkbox"] { margin-right: ${({ theme }) => theme.spacing.sm}; cursor: default; } }
`;

const ErrorIndicator = styled.div`
    font-size: 0.75rem;
    color: ${({ theme }) => theme.colors.red};
    margin-top: ${({ theme }) => theme.spacing.xs};
    font-style: italic;
`;
// --- End Styled Components ---

// --- Helper Function ---
function formatTimestamp(timestamp: string | undefined): string {
  // ... (formatTimestamp remains the same)
  if (!timestamp) return '';
  const date = new Date(timestamp);
  if (isNaN(date.getTime())) return '';
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  if (diffInSeconds < 5) return 'just now';
  if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
  if (now.getFullYear() === date.getFullYear()) {
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  } else {
    return date.toLocaleDateString();
  }
}
// -----------------------

// --- React Markdown Custom Components (remain the same) ---
const markdownComponents: Components = {
    a: (props) => (<a {...props} target="_blank" rel="noopener noreferrer"/>),
    input: (props) => { const { checked, ...rest } = props; return (<input type="checkbox" checked={!!checked} disabled={true} readOnly {...rest}/> ); },
    code({ className, children, inline, ...props }: React.HTMLAttributes<HTMLElement> & { className?: string; children?: React.ReactNode; inline?: boolean; }) {
        const match = /language-(\w+)/.exec(className || '');
        const codeString = String(children).replace(/\n$/, '');
        const { style: _unused, ...restProps } = props;
        void _unused;
        return !inline ? (
            <pre className="code-block-wrapper" {...restProps}>
                <code className={match ? `language-${match[1]}` : undefined}>{codeString}</code>
            </pre>
        ) : (
            <code className={`inline-code ${className || ''}`} {...restProps}>{codeString}</code>
        );
    }
};
// --- End React Markdown Components ---

// --- Main Component ---
function ChatMessageDisplay({ message, chatbotName }: ChatMessageProps) {
    const isUser = message.role === 'user';
    
    const metadata = message.metadata as MessageMetadataWithFlags; // Use new type
    const hasError = !!metadata?.error;
    const errorMessage = hasError ? String(metadata.error) : null;
    const isAssessmentFeedback = !!metadata?.isAssessmentFeedback;
    const isAssessmentPlaceholder = !!metadata?.isAssessmentPlaceholder;

    let senderNameToDisplay = chatbotName;
    if (isUser) {
        senderNameToDisplay = 'You';
    } else if (isAssessmentFeedback || isAssessmentPlaceholder || message.role === 'system') {
        // For system messages or assessment feedback, use a generic name or the bot's name
        // If it's a placeholder or feedback, you might want a specific title like "Assessment System"
        senderNameToDisplay = isAssessmentFeedback ? `${chatbotName} (Assessment)` : (isAssessmentPlaceholder ? 'System' : chatbotName);
        if (message.user_id === 'system-assessment' || message.user_id === 'system-feedback') {
             // Let's refine this. If the message.role is 'system', it should be styled as such.
        }
    }


    return (
        <MessageWrapper $isUser={isUser} $hasError={hasError}>
            <MessageBubble
              $isUser={isUser}
              $hasError={hasError}
              $isAssessmentFeedback={isAssessmentFeedback}
              $isAssessmentPlaceholder={isAssessmentPlaceholder}
            >
                <MessageHeader>
                    <SenderName>{senderNameToDisplay}</SenderName>
                    <Timestamp>
                        {formatTimestamp(message.created_at)}
                    </Timestamp>
                </MessageHeader>
                <MessageContent $isUser={isUser}>
                    <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={markdownComponents}
                    >
                        {message.content || ''}
                    </ReactMarkdown>
                </MessageContent>
                {hasError && (
                    <ErrorIndicator title={errorMessage || 'Failed to send message'}>
                       ⚠️ Failed to send
                    </ErrorIndicator>
                 )}
            </MessageBubble>
        </MessageWrapper>
    );
}
// --- End Main Component ---

export { ChatMessageDisplay as ChatMessage };// src/components/shared/ChatInput.tsx
'use client';

import { useState, KeyboardEvent } from 'react';
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';

// ... (InputContainer, InputForm, TextInput, SendButton, ErrorAlert styled components remain the same)

const InputForm = styled.form`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
  }
`;

const TextInput = styled.input`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
  }
  
  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  
  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const SendButton = styled(Button)`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.xl};
  min-width: 100px;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const ErrorAlert = styled(Alert)`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;


const InputHint = styled.p`
  font-size: 0.8rem; /* Slightly larger for better readability */
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.sm};
  text-align: left; /* Align to left, often better for hints near input */
  padding-left: ${({ theme }) => theme.spacing.xs};

  /* Default hint shown on mobile for Ctrl/Cmd+Enter */
  @media (min-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none; 
  }
`;

// Specific hint for assessment bots
const AssessmentHint = styled(InputHint)`
    display: block; /* Ensure it's always visible if provided */
    text-align: center; /* Center this specific hint */
    margin-bottom: -${({ theme }) => theme.spacing.xs}; /* Adjust spacing slightly */
`;


interface ChatInputProps {
  onSend: (content: string) => Promise<void>;
  isLoading: boolean;
  error: string | null;
  onClearError: () => void;
  hint?: string; // New optional hint prop
}

export default function ChatInput({ onSend, isLoading, error, onClearError, hint }: ChatInputProps) {
  const [message, setMessage] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() || isLoading) return;

    const content = message.trim();
    setMessage(''); // Clear input immediately
    await onSend(content);
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      // Prevent default Enter behavior (like newline in some setups) if Ctrl/Meta is pressed
      e.preventDefault(); 
      handleSubmit(e as unknown as React.FormEvent); // Cast because original event is KeyboardEvent
    } else if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
      // If just Enter is pressed (and not Shift+Enter for newline)
      e.preventDefault(); 
      handleSubmit(e as unknown as React.FormEvent);
    }
  };

  return (
    // InputContainer styling has been removed from Chat.tsx and should be part of ChatInput itself if needed.
    // For now, assuming StyledChatInputContainer in Chat.tsx provides the main padding.
    <> 
      {error && (
        <ErrorAlert variant="error" onClick={onClearError} style={{marginBottom: '8px'}}>
          {error}
        </ErrorAlert>
      )}
      
      <InputForm onSubmit={handleSubmit}>
        <TextInput
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder="Type your message..."
          disabled={isLoading}
        />
        <SendButton
          type="submit"
          disabled={isLoading || !message.trim()}
        >
          {isLoading ? 'Sending...' : 'Send'}
        </SendButton>
      </InputForm>

      {hint && <AssessmentHint>{hint}</AssessmentHint>}
      
      {/* General hint for mobile, could be combined or made more context-aware */}
      {!hint && (
         <InputHint>
            Press Enter to send. Use Shift+Enter for a new line.
         </InputHint>
      )}
    </>
  );
}// src/components/ThemeProvider.tsx
'use client';

import { ThemeProvider as StyledThemeProvider } from 'styled-components';
import theme from '@/styles/theme';
import { GlobalStyles } from '@/styles/GlobalStyles';

export default function ThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <StyledThemeProvider theme={theme}>
      <GlobalStyles />
      {children}
    </StyledThemeProvider>
  );
}// src/components/teacher/StudentChatHistory.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

const HistoryContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.xl};
`;

const FilterCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const FilterTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterForm = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    align-items: stretch;
  }
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

const StudentNameDisplay = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.primary};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }
`;

const Select = styled.select`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  min-width: 200px;
`;

const ConversationCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ConversationHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const ConversationInfo = styled.div`
  h4 {
    margin: 0;
    color: ${({ theme }) => theme.colors.text};
  }

  .timestamp {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
`;

const MessagesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.md};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadMoreButton = styled(Button)`
  margin: ${({ theme }) => theme.spacing.md} auto;
  display: block;
`;

interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface StudentChatHistoryProps {
  roomId: string;
  studentId: string;
  studentName: string;
  chatbots: ChatbotOption[];
}

export default function StudentChatHistory({
  roomId,
  studentId,
  studentName,
  chatbots
}: StudentChatHistoryProps) {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedChatbotFilter, setSelectedChatbotFilter] = useState<string>('');
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(false);

  const fetchConversations = useCallback(async (resetPage = true) => {
    const currentPageToFetch = resetPage ? 0 : page;

    if (resetPage) {
      setPage(0);
      setConversations([]);
    }

    setLoading(true);
    setError(null);

    try {
      // Use the new flattened API endpoint
      const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';
      const url = new URL(`/api/teacher/student-chats`, baseUrl);
      
      // Add parameters as query parameters
      url.searchParams.append('roomId', roomId);
      url.searchParams.append('studentId', studentId);
      
      if (selectedChatbotFilter) {
        url.searchParams.append('chatbotId', selectedChatbotFilter);
      }

      // Add pagination params if your API supports them
      if (!resetPage && currentPageToFetch > 0) {
        url.searchParams.append('page', currentPageToFetch.toString());
        url.searchParams.append('limit', '10'); // Example limit
      }

      const response = await fetch(url.toString());

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({error: 'Failed to parse error response'}));
        throw new Error(errorData.error || 'Failed to fetch chat history');
      }

      const data = await response.json();

      if (resetPage) {
        setConversations(data.conversations || []);
      } else {
        setConversations(prev => [...prev, ...(data.conversations || [])]);
      }

      // Set has more if API returns pagination info
      setHasMore(data.pagination?.hasMore || false);

      if (!resetPage && data.conversations && data.conversations.length > 0) {
        setPage(currentPageToFetch + 1);
      } else if (resetPage) {
        setPage(0);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load chat history');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, selectedChatbotFilter, page]);

  useEffect(() => {
    // Initial fetch or fetch when filter changes
    fetchConversations(true);
  }, [roomId, studentId, selectedChatbotFilter, fetchConversations]);

  const handleLoadMore = () => {
    fetchConversations(false);
  };

  const handleChatbotChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedChatbotFilter(e.target.value);
  };

  const formatDate = (dateString: string) => {
    if (!dateString) return 'Unknown date';
    return new Date(dateString).toLocaleString();
  };

  return (
    <HistoryContainer>
      <FilterCard>
        <FilterTitle>Chat History</FilterTitle>
        <FilterForm>
          <StudentNameDisplay>
            Showing conversations for: {studentName}
          </StudentNameDisplay>
          <FilterControls>
            <Select
              value={selectedChatbotFilter}
              onChange={handleChatbotChange}
            >
              <option value="">All Chatbots</option>
              {chatbots.map(chatbot => (
                <option key={chatbot.chatbot_id} value={chatbot.chatbot_id}>
                  {chatbot.name}
                </option>
              ))}
            </Select>
          </FilterControls>
        </FilterForm>
      </FilterCard>

      {error && (
        <Alert variant="error">Error: {error}</Alert>
      )}

      {loading && conversations.length === 0 ? (
        <Card>
          <p>Loading conversations...</p>
        </Card>
      ) : conversations.length === 0 ? (
        <EmptyState>
          <h3>No conversations found</h3>
          <p>
            {selectedChatbotFilter
              ? `This student hasn't chatted with the selected chatbot yet.`
              : `This student hasn't chatted with any chatbots yet.`}
          </p>
        </EmptyState>
      ) : (
        <>
          {conversations.map((conversation, index) => {
            const chatbotNameForDisplay = conversation.chatbot_name || 'Unknown Chatbot';

            return (
              <ConversationCard key={`conv-${index}-${conversation.started_at}`}>
                <ConversationHeader>
                  <ConversationInfo>
                    <h4>{chatbotNameForDisplay}</h4>
                    <span className="timestamp">Started {formatDate(conversation.started_at)}</span>
                  </ConversationInfo>
                </ConversationHeader>

                <MessagesList>
                  {conversation.messages.map(message => (
                    <ChatMessageComponent
                      key={message.message_id}
                      message={message}
                      chatbotName={chatbotNameForDisplay}
                    />
                  ))}
                </MessagesList>
              </ConversationCard>
            );
          })}

          {hasMore && (
            <LoadMoreButton
              variant="outline"
              onClick={handleLoadMore}
              disabled={loading}
            >
              {loading ? 'Loading...' : 'Load More'}
            </LoadMoreButton>
          )}
        </>
      )}
    </HistoryContainer>
  );
}'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { Card, Button, Alert, Badge } from '@/styles/StyledComponents'; // Added Alert and Badge
import ChatbotForm from '@/components/teacher/ChatbotForm';
import RoomForm from '@/components/teacher/RoomForm';
import RoomList from '@/components/teacher/RoomList';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import ConcernsList from '@/components/teacher/ConcernsList'; // Import ConcernsList
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import Loader
import { createClient } from '@/lib/supabase/client';
import type { Chatbot, Room as BaseRoom } from '@/types/database.types'; // Use BaseRoom alias

// --- Styled Components (Keep as previously defined) ---
const DashboardContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  flex-wrap: wrap; /* Allow wrapping */
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    button {
      width: 100%;
    }
  }
`;

const SectionTitle = styled.h2`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.5rem;
  margin: 0; /* Remove default margin */
`;

const StatsCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: pointer; // Make stats cards clickable if they link somewhere
  transition: transform 0.2s ease, box-shadow 0.2s ease;

   &:hover {
      transform: translateY(-2px);
      box-shadow: ${({ theme }) => theme.shadows.md};
   }

  h3 {
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }

  .value {
    font-size: 2rem;
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const ChatbotList = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};

  &:hover {
    transform: translateY(-2px);
    box-shadow: ${({ theme }) => theme.shadows.md};
  }

  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
  }

  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1;
    min-height: 2.5rem;

    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }

  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.sm};
    margin-top: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap;
    justify-content: flex-start;

    button, a {
        flex-grow: 1;
        min-width: 100px;
        text-align: center;
    }

     @media (max-width: 550px) {
         button, a {
            width: 100%;
            flex-grow: 0;
         }
     }
  }

  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
`;


const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 450px;
  margin: 20px;
  position: relative;
  text-align: center;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

// --- Define the Room type WITH joined data (Matching API Response) ---
interface RoomWithChatbots extends BaseRoom {
  room_chatbots: {
    chatbots: {
      chatbot_id: string;
      name: string;
    } | null;
  }[] | null;
}
// ---------------------------------------------------------------


interface DeleteModalProps {
  isOpen: boolean;
  itemType: 'Chatbot' | 'Room';
  itemName: string;
  onConfirm: () => Promise<void>; // Make confirm async
  onCancel: () => void;
  isDeleting: boolean;
}

function DeleteModal({ isOpen, itemType, itemName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete {itemType}</ModalTitle>
        <ModalText>
          Are you sure you want to delete the {itemType.toLowerCase()} &quot;
          <strong>{itemName}</strong>
          &quot;? This action cannot be undone and may affect associated data (e.g., student memberships, chat history).
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
             variant="secondary" // Use secondary as base, style for danger
             style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }}
             onClick={onConfirm} // Directly call the passed async handler
             disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : `Yes, Delete ${itemType}`}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

export default function Dashboard() {
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  // --- FIX: Use the correct type for rooms state ---
  const [rooms, setRooms] = useState<RoomWithChatbots[]>([]);
  // --------------------------------------------------
  const [stats, setStats] = useState({
    totalChatbots: 0,
    totalRooms: 0,
    activeRooms: 0,
    pendingConcerns: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    type: 'Chatbot' | 'Room';
    id: string | null;
    name: string;
  }>({ isOpen: false, type: 'Chatbot', id: null, name: '' });
   const [isDeleting, setIsDeleting] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null); // Edit modal likely needs BaseRoom
  const supabase = createClient();
  const router = useRouter();

  const fetchDashboardData = useCallback(async () => {
    setError(null);

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }

      // Fetch all data concurrently
      const [chatbotsRes, roomsRes, concernsRes] = await Promise.all([
        supabase.from('chatbots').select('*').eq('teacher_id', user.id),
        // --- FIX: Fetch rooms using the API route which handles the join ---
        fetch('/api/teacher/rooms').then(res => {
            if (!res.ok) throw new Error('Failed to fetch rooms');
            return res.json();
        }),
        // --------------------------------------------------------------------
        supabase.from('flagged_messages')
          .select('flag_id', { count: 'exact', head: true })
          .eq('teacher_id', user.id)
          .eq('status', 'pending')
      ]);

      // Process Chatbots
      if (chatbotsRes.error) throw new Error(`Failed to fetch chatbots: ${chatbotsRes.error.message}`);
      const chatbotsData = chatbotsRes.data || [];
      setChatbots(chatbotsData);

      // Process Rooms (data is already fetched via API)
      const roomsData: RoomWithChatbots[] = roomsRes || []; // Type assertion based on API response
      setRooms(roomsData);

       // Process Concerns Count
       if (concernsRes.error) throw new Error(`Failed to fetch concerns count: ${concernsRes.error.message}`);
       const pendingConcernsCount = concernsRes.count || 0;

      // Update Stats
      setStats({
        totalChatbots: chatbotsData.length,
        totalRooms: roomsData.length,
        activeRooms: roomsData.filter(room => room.is_active).length,
        pendingConcerns: pendingConcernsCount,
      });

    } catch (error) {
      console.error('Error fetching dashboard data:', error);
      setError(error instanceof Error ? error.message : 'Failed to load dashboard data.');
      // Reset state on error
      setChatbots([]);
      setRooms([]);
      setStats({ totalChatbots: 0, totalRooms: 0, activeRooms: 0, pendingConcerns: 0 });
    } finally {
      setLoading(false);
    }
  }, [supabase, router]); // Dependencies

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchDashboardData();
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    fetchDashboardData();
  };

  // Test Chatbot (unused function removed)

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const openDeleteModal = (type: 'Chatbot' | 'Room', id: string, name: string) => {
    setDeleteModal({ isOpen: true, type, id, name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, type: 'Chatbot', id: null, name: '' });
  };

  // --- Combined Delete Handler ---
  const handleDeleteConfirm = async () => {
    if (!deleteModal.id || !deleteModal.type) return;

    setIsDeleting(true);
    setError(null);

    const { type, id } = deleteModal;
    const endpoint = type === 'Chatbot' ? `/api/teacher/chatbots/${id}` : `/api/teacher/rooms/${id}`;

    try {
        const response = await fetch(endpoint, { method: 'DELETE' });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete ${type.toLowerCase()}`);
        }

        console.log(`${type} ${id} deleted successfully.`);
        closeDeleteModal();
        fetchDashboardData(); // Refresh dashboard
    } catch (error) {
        console.error(`Error deleting ${type}:`, error);
        setError(error instanceof Error ? error.message : `Failed to delete ${type}.`);
        // Keep modal open on error to show feedback if desired, or close:
        // closeDeleteModal();
    } finally {
        setIsDeleting(false);
    }
};


  const handleEditRoom = (room: BaseRoom) => { // Use BaseRoom for editing modal
    setEditingRoom(room);
  };

  const handleCloseEditRoom = () => {
    setEditingRoom(null);
  };

  const handleRoomEditSuccess = () => {
    setEditingRoom(null);
    fetchDashboardData();
  };

  // Get model display name (no changes)
    const getModelDisplayName = (model: string | undefined) => {
      if (!model) return 'Default Model';
      const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B A22B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash'
      };
      return modelNames[model] || model;
    };


  if (loading) {
    return <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading dashboard...</Card>;
  }

  return (
    <div>
        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        {/* Quick Stats Section */}
        <Section>
            <DashboardContainer>
            <StatsCard onClick={() => document.getElementById('chatbots-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Chatbots</h3>
                <div className="value">{stats.totalChatbots}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Rooms</h3>
                <div className="value">{stats.totalRooms}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Active Rooms</h3>
                <div className="value">{stats.activeRooms}</div>
            </StatsCard>
            <StatsCard style={{ cursor: 'pointer' }} onClick={() => document.getElementById('concerns-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Pending Concerns</h3>
                <div className="value" style={{ color: stats.pendingConcerns > 0 ? '#F87F7F' : undefined }}>
                    {stats.pendingConcerns}
                </div>
                 {stats.pendingConcerns > 0 && <Badge variant='error' style={{ marginTop: '8px' }}>Review Needed</Badge>}
            </StatsCard>
            </DashboardContainer>
        </Section>

      {/* Concerns Section */}
      <Section id="concerns-section">
            <SectionHeader>
                 <SectionTitle>Welfare Concerns</SectionTitle>
                 {/* Can add a direct link/button to a dedicated concerns page if needed */}
            </SectionHeader>
            <ConcernsList />
       </Section>


      {/* Chatbots Section */}
      <Section id="chatbots-section">
        <SectionHeader>
          <SectionTitle>Your Chatbots</SectionTitle>
          <Button onClick={() => setShowChatbotForm(true)}>
            + Create Chatbot
          </Button>
        </SectionHeader>

        {showChatbotForm && (
          <ChatbotForm
            onClose={() => setShowChatbotForm(false)}
            onSuccess={handleChatbotCreated}
          />
        )}

        {chatbots.length > 0 ? (
          <ChatbotList>
            {chatbots.map(chatbot => (
              <ChatbotCard key={chatbot.chatbot_id}>
                <h3>{chatbot.name}</h3>
                <p className="description">{chatbot.description || 'No description provided.'}</p>
                <div className="model-info">
                  Model: {getModelDisplayName(chatbot.model)}
                </div>
                <div className="actions">
                  <Button
                    size="small"
                    variant="outline"
                    onClick={() => handleEditChatbot(chatbot.chatbot_id)}
                    title="Edit chatbot configuration"
                  >
                    Configure
                  </Button>
                   <Button
                        as={Link}
                        size="small"
                        variant="outline"
                        href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/knowledge-base`}
                        title="Manage knowledge base documents"
                    >
                        Knowledge Base
                    </Button>
                   <Button
                        size="small"
                        variant="secondary"
                         style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }} // Danger style
                        onClick={() => openDeleteModal('Chatbot', chatbot.chatbot_id, chatbot.name)}
                        title="Delete this chatbot"
                    >
                        Delete
                    </Button>
                </div>
              </ChatbotCard>
            ))}
          </ChatbotList>
        ) : (
          <Card>
            <p>No chatbots created yet. Click &quot;+ Create Chatbot&quot; to get started!</p>
          </Card>
        )}
      </Section>

      {/* Rooms Section */}
      <Section id="rooms-section">
        <SectionHeader>
          <SectionTitle>Classroom Rooms</SectionTitle>
          <Button onClick={() => setShowRoomForm(true)} disabled={chatbots.length === 0}>
            + Create Room
          </Button>
           {chatbots.length === 0 && <Alert variant='info'>Create a chatbot before creating a room.</Alert>}
        </SectionHeader>

        {showRoomForm && (
          <RoomForm
            chatbots={chatbots}
            onClose={() => setShowRoomForm(false)}
            onSuccess={handleRoomCreated}
          />
        )}

        <RoomList
          rooms={rooms} // Pass the correctly typed rooms state
          onUpdate={fetchDashboardData}
          onEditRoom={handleEditRoom}
          onDeleteRoom={(room) => openDeleteModal('Room', room.room_id, room.room_name)} // Pass handler for delete button in list
        />
      </Section>

      {/* Delete Confirmation Modal */}
      <DeleteModal
        isOpen={deleteModal.isOpen}
        itemType={deleteModal.type}
        itemName={deleteModal.name}
        onConfirm={handleDeleteConfirm} // Use the combined handler
        onCancel={closeDeleteModal}
        isDeleting={isDeleting}
      />

      {/* Edit Room Modal */}
      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={handleCloseEditRoom}
          onSuccess={handleRoomEditSuccess}
        />
      )}
    </div>
  );
}// src/components/teacher/EmbeddingStatus.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert } from '@/styles/StyledComponents';
import { Document, ProcessingStats } from '@/types/knowledge-base.types';

const StatusContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h3`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const ProgressContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ProgressBar = styled.div`
  height: 8px;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  overflow: hidden;
`;

const ProgressFill = styled.div<{ $progress: number; $hasErrors: boolean }>`
  height: 100%;
  width: ${({ $progress }) => `${$progress}%`};
  background-color: ${({ theme, $hasErrors }) => 
    $hasErrors ? theme.colors.secondary : theme.colors.green};
  transition: width 0.5s ease;
`;

const StatsContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const StatCard = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  text-align: center;
`;

const StatValue = styled.div`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: ${({ theme }) => theme.spacing.xs};
  color: ${({ theme }) => theme.colors.text};
`;

const StatLabel = styled.div`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const StatusText = styled.div<{ $isComplete: boolean; $hasErrors: boolean }>`
  color: ${({ theme, $isComplete, $hasErrors }) => 
    $isComplete 
      ? $hasErrors ? theme.colors.secondary : theme.colors.green 
      : theme.colors.text};
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

interface EmbeddingStatusProps {
  document: Document;
  chatbotId: string;
  onRefresh?: () => void;
}

export default function EmbeddingStatus({ 
  document, 
  chatbotId,
  onRefresh
}: EmbeddingStatusProps) {
  const [stats, setStats] = useState<ProcessingStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(null);

  const fetchStatus = useCallback(async () => {
    try {
      const response = await fetch(
        `/api/teacher/chatbots/${chatbotId}/vectorize?documentId=${document.document_id}`
      );
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch processing status');
      }
      
      const data = await response.json();
      setStats(data.processingStats);
      
      // Update document with latest status
      if (data.document.status !== document.status && onRefresh) {
        onRefresh();
      }
      
      // If processing is complete, stop polling
      if (data.document.status === 'completed' || data.document.status === 'error') {
        if (pollingInterval) {
          clearInterval(pollingInterval);
          setPollingInterval(null);
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch processing status');
    } finally {
      setLoading(false);
    }
  }, [document.document_id, document.status, chatbotId, onRefresh, pollingInterval]);

  useEffect(() => {
    fetchStatus();
    
    // Set up polling for processing status
    if (document.status === 'processing' && !pollingInterval) {
      const interval = setInterval(fetchStatus, 5000); // Poll every 5 seconds
      setPollingInterval(interval);
    }
    
    return () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [document.status, fetchStatus, pollingInterval]);

  if (loading) {
    return (
      <StatusContainer>
        <p>Loading processing status...</p>
      </StatusContainer>
    );
  }

  if (error) {
    return (
      <StatusContainer>
        <Alert variant="error">{error}</Alert>
      </StatusContainer>
    );
  }

  if (!stats) {
    return (
      <StatusContainer>
        <p>No processing statistics available</p>
      </StatusContainer>
    );
  }

  const progressPercent = stats.totalChunks > 0
    ? Math.round((stats.processedChunks / stats.totalChunks) * 100)
    : 0;
  
  const hasErrors = stats.errorChunks > 0;
  const isComplete = document.status === 'completed' || 
                     (document.status === 'processing' && progressPercent === 100);

  return (
    <StatusContainer>
      <Header>
        <Title>Document Processing Status</Title>
      </Header>
      
      <ProgressContainer>
        <ProgressBar>
          <ProgressFill $progress={progressPercent} $hasErrors={hasErrors} />
        </ProgressBar>
        <StatusText 
          $isComplete={isComplete} 
          $hasErrors={hasErrors}
        >
          {document.status === 'error' ? 'Processing failed' :
           isComplete ? 'Processing complete' : 'Processing in progress'}
           {hasErrors && ' (with some errors)'}
           {document.status === 'processing' && ` - ${progressPercent}%`}
        </StatusText>
      </ProgressContainer>
      
      <StatsContainer>
        <StatCard>
          <StatValue>{stats.totalChunks}</StatValue>
          <StatLabel>Total Chunks</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.processedChunks}</StatValue>
          <StatLabel>Processed</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.errorChunks}</StatValue>
          <StatLabel>Errors</StatLabel>
        </StatCard>
      </StatsContainer>
      
      {document.error_message && (
        <Alert variant="error">Error: {document.error_message}</Alert>
      )}
    </StatusContainer>
  );
}// src/components/teacher/EditRoomModal.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Card, Button, Alert } from '@/styles/StyledComponents';
import type { Room, Chatbot } from '@/types/database.types';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const SectionTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;

interface EditRoomModalProps {
  room: Room;
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function EditRoomModal({ room, chatbots, onClose, onSuccess }: EditRoomModalProps) {
  const [selectedChatbots, setSelectedChatbots] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Fetch current chatbots for this room
    const fetchRoomChatbots = async () => {
      try {
        const response = await fetch(`/api/teacher/rooms/${room.room_id}/chatbots`);
        if (!response.ok) throw new Error('Failed to fetch room chatbots');
        
        const data = await response.json();
        setSelectedChatbots(data.map((rc: { chatbot_id: string }) => rc.chatbot_id));
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load chatbots');
      } finally {
        setIsLoading(false);
      }
    };

    fetchRoomChatbots();
  }, [room.room_id]);

  const handleToggleChatbot = (chatbotId: string) => {
    setSelectedChatbots(prev => 
      prev.includes(chatbotId)
        ? prev.filter(id => id !== chatbotId)
        : [...prev, chatbotId]
    );
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch(`/api/teacher/rooms/${room.room_id}/chatbots`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ chatbot_ids: selectedChatbots }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update room chatbots');
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update room chatbots');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Edit Room: {room.room_name}</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <Section>
          <SectionTitle>Select Chatbots for this Room</SectionTitle>
          {isLoading ? (
            <div>Loading chatbots...</div>
          ) : (
            <ChatbotList>
              {chatbots.map(chatbot => (
                <ChatbotItem key={chatbot.chatbot_id}>
                  <Checkbox
                    type="checkbox"
                    checked={selectedChatbots.includes(chatbot.chatbot_id)}
                    onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                  />
                  {chatbot.name}
                  {chatbot.description && (
                    <span style={{ marginLeft: '8px', color: '#888' }}>
                      - {chatbot.description}
                    </span>
                  )}
                </ChatbotItem>
              ))}
            </ChatbotList>
          )}
        </Section>

        <Footer>
          <Button type="button" variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleSubmit} 
            disabled={isSubmitting || selectedChatbots.length === 0}
          >
            {isSubmitting ? 'Saving...' : 'Save Changes'}
          </Button>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/RoomList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import type { Room as BaseRoom } from '@/types/database.types'; // Import base Room type

// --- Styled Components (Keep as they are) ---
const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* Hide table view on smaller screens if mobile view is preferred */
    /* display: none; */
  }
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  min-width: 700px; /* Ensure minimum width for desktop view */
`;

const Th = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.875rem;
  letter-spacing: 0.05em;
  white-space: nowrap;
`;

const Td = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  vertical-align: top; /* Align content nicely */
`;

const ActionButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  flex-wrap: wrap; /* Allow buttons to wrap */
`;

const RoomCode = styled.span`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  background-color: ${({ theme }) => theme.colors.backgroundDark}; /* Add background */
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  display: inline-block; /* Ensure padding works */

  &:hover {
    text-decoration: underline;
    background-color: ${({ theme }) => theme.colors.border}; /* Darker on hover */
  }
`;

const RoomNameLink = styled(Link)`
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-weight: 500;
  transition: color ${({ theme }) => theme.transitions.fast};

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: underline;
  }
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textLight};

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.md};
    color: ${({ theme }) => theme.colors.text};
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6); /* Darker overlay */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
  text-align: center;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

// --- Mobile view styled components commented out since they're not used ---
/* 
const MobileCardList = styled.div`
  display: none;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    // Enable this block if you want to show cards instead of table on mobile
    // display: flex;
    // flex-direction: column;
    // gap: ${({ theme }) => theme.spacing.md};
  }
`;
// ... (MobileCard, RoomCardHeader, RoomCardTitle, RoomCardDetails, DetailItem, MobileActions) ...
// Add the full definitions for these if you plan to use the mobile card view.
*/

// --- Define the expected Room type WITH joined data ---
// This structure should match what the API returns from the .select() with joins
interface RoomWithChatbots extends BaseRoom {
  room_chatbots: { // The name of the joined relation
    chatbots: { // The nested object within the relation
      chatbot_id: string;
      name: string;
    } | null; // chatbots might be null if !inner fails or no match
  }[] | null; // The room_chatbots array itself might be null or empty
}

// --- Define Props for RoomList ---
interface RoomListProps {
  rooms: RoomWithChatbots[]; // Use the more specific type
  onUpdate: () => void;
  onEditRoom: (room: BaseRoom) => void; // Edit probably only needs base room info
  onDeleteRoom: (room: BaseRoom) => void; // Delete needs base room info
}

// --- Define Props for DeleteModal ---
interface DeleteModalProps {
  isOpen: boolean;
  roomName: string;
  onConfirm: () => void;
  onCancel: () => void;
  isDeleting: boolean; // Added loading state
}

// --- Delete Modal Component ---
function DeleteModal({ isOpen, roomName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete Room</ModalTitle>
        <ModalText>
          Are you sure you want to delete the room &quot;<strong>{roomName}</strong>&quot;? This action cannot be undone and will remove all student memberships and associated data.
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
            variant="secondary"
            style={{ backgroundColor: '#F87F7F', color: 'white' }} // Danger style
            onClick={onConfirm}
            disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : 'Yes, Delete Room'}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

// --- Main RoomList Component ---
export default function RoomList({ rooms, onUpdate, onEditRoom, onDeleteRoom }: RoomListProps) {
  const [loadingState, setLoadingState] = useState<{ [key: string]: boolean }>({}); // Track loading per room for actions
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    roomId: string | null;
    roomName: string;
  }>({
    isOpen: false,
    roomId: null,
    roomName: '',
  });
  const [isDeleting, setIsDeleting] = useState(false); // Loading state for delete confirmation

  // --- Action Handlers ---
  const toggleRoomStatus = async (roomId: string, currentStatus: boolean) => {
    setLoadingState(prev => ({ ...prev, [roomId]: true })); // Set loading for this specific room
    try {
      const response = await fetch(`/api/teacher/rooms/${roomId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_active: !currentStatus }),
      });
      if (!response.ok) throw new Error('Failed to update room status');
      onUpdate(); // Refresh the list via the parent component
    } catch (error) {
      console.error('Error updating room status:', error);
      alert(`Error: ${error instanceof Error ? error.message : 'Could not update room status.'}`);
    } finally {
      setLoadingState(prev => ({ ...prev, [roomId]: false })); // Clear loading for this room
    }
  };

  const copyRoomCode = async (code: string) => {
    try {
      await navigator.clipboard.writeText(code);
      alert(`Room code "${code}" copied to clipboard!`); // Simple feedback
    } catch (error) {
      console.error('Failed to copy room code:', error);
      alert('Failed to copy room code.');
    }
  };

  const generateMagicLink = async (roomId: string, roomCode: string) => {
    try {
      // No need to fetch room again, code is already available
      const joinLink = `${window.location.origin}/join?code=${roomCode}`;
      await navigator.clipboard.writeText(joinLink);
      alert(`Student join link copied to clipboard:\n${joinLink}`);
    } catch (error) {
      console.error('Error generating join link:', error);
      alert('Failed to generate join link.');
    }
  };

  const openDeleteModal = (room: BaseRoom) => { // Expect BaseRoom here
    setDeleteModal({
      isOpen: true,
      roomId: room.room_id,
      roomName: room.room_name,
    });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, roomId: null, roomName: '' });
  };

  const handleDeleteRoomConfirm = async () => {
    if (!deleteModal.roomId) return;

    setIsDeleting(true); // Set modal loading state
    try {
      // Call the prop passed from Dashboard which handles API call + refresh
      await onDeleteRoom({ room_id: deleteModal.roomId, room_name: deleteModal.roomName } as BaseRoom);
      closeDeleteModal(); // Close modal on success
    } catch (error) {
      // Error handling might be done in the parent, or show here
      console.error('Error during delete confirmation:', error);
      alert(`Failed to delete room: ${error instanceof Error ? error.message : 'Unknown error'}`);
      // Optionally keep modal open on error
    } finally {
      setIsDeleting(false); // Clear modal loading state
    }
  };

  // --- Helper to count chatbots (FIXED TYPE) ---
  const getChatbotCount = (room: RoomWithChatbots): number => {
    // Access the structure defined by the API query and RoomWithChatbots interface
    if (room.room_chatbots && Array.isArray(room.room_chatbots)) {
      // Filter out any null entries potentially caused by left join issues or empty relations
      return room.room_chatbots.filter(rc => rc && rc.chatbots).length;
    }
    return 0; // Default to 0 if the structure isn't as expected
  };
  // ----------------------------------------------


  if (rooms.length === 0) {
    return (
      <EmptyState>
        <h3>No Rooms Created</h3>
        <p>Create your first classroom room to get started!</p>
      </EmptyState>
    );
  }

  return (
    <>
      <Card>
        {/* Desktop Table View */}
        <TableContainer>
          <Table>
            <thead>
              <tr>
                <Th>Room Name</Th>
                <Th>Room Code</Th>
                <Th>Chatbots</Th>
                <Th>Status</Th>
                <Th>Created</Th>
                <Th>Actions</Th>
              </tr>
            </thead>
            <tbody>
              {rooms.map((room) => {
                const chatbotCount = getChatbotCount(room);
                const isLoading = loadingState[room.room_id] || false; // Check loading state for this room

                return (
                  <tr key={room.room_id}>
                    <Td>
                      <RoomNameLink href={`/room/${room.room_id}`} title={`Go to room: ${room.room_name}`}>
                        {room.room_name}
                      </RoomNameLink>
                    </Td>
                    <Td>
                      <RoomCode onClick={() => copyRoomCode(room.room_code)} title="Click to copy room code">
                        {room.room_code}
                      </RoomCode>
                    </Td>
                    <Td>
                      {chatbotCount > 0 ? `${chatbotCount} Attached` : 'None'}
                    </Td>
                    <Td>
                      <Badge variant={room.is_active ? 'success' : 'default'}>
                        {room.is_active ? 'Active' : 'Inactive'}
                      </Badge>
                    </Td>
                    <Td>
                      {new Date(room.created_at).toLocaleDateString()}
                    </Td>
                    <Td>
                      <ActionButtons>
                        <Button
                          size="small"
                          onClick={() => onEditRoom(room)} // Pass the base room object
                          disabled={isLoading}
                          title="Edit Chatbots for this Room"
                        >
                          Edit
                        </Button>
                        <Button
                          size="small"
                          variant="outline" // Changed variant
                          onClick={() => generateMagicLink(room.room_id, room.room_code)}
                          disabled={isLoading}
                          title="Copy Student Join Link"
                        >
                          Join Link
                        </Button>
                        <Button
                          size="small"
                          variant={room.is_active ? 'secondary' : 'primary'} // Use secondary for deactivation
                          onClick={() => toggleRoomStatus(room.room_id, room.is_active)}
                          disabled={isLoading}
                          title={room.is_active ? 'Deactivate Room' : 'Activate Room'}
                        >
                          {isLoading ? '...' : room.is_active ? 'Deactivate' : 'Activate'}
                        </Button>
                        <Button
                          size="small"
                          variant="secondary" // Keep secondary, maybe add danger style later
                           style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }} // Danger style
                          onClick={() => openDeleteModal(room)} // Pass base room object
                          disabled={isLoading}
                          title="Delete Room"
                        >
                          Delete
                        </Button>
                      </ActionButtons>
                    </Td>
                  </tr>
                );
              })}
            </tbody>
          </Table>
        </TableContainer>

        {/* Mobile Card View (Commented out for now) */}
        {/*
        <MobileCardList>
          {rooms.map((room) => {
             const chatbotCount = getChatbotCount(room);
             const isLoading = loadingState[room.room_id] || false;
             return ( <MobileCard key={room.room_id}> ... </MobileCard> );
          })}
        </MobileCardList>
         */}
      </Card>

      {/* Delete Confirmation Modal */}
      <DeleteModal
        isOpen={deleteModal.isOpen}
        roomName={deleteModal.roomName}
        onConfirm={handleDeleteRoomConfirm}
        onCancel={closeDeleteModal}
        isDeleting={isDeleting} // Pass loading state
      />
    </>
  );
}// src/components/teacher/TeacherNav.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { usePathname } from 'next/navigation';

const NavWrapper = styled.nav`
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};

  ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    gap: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap; // Allow wrapping on smaller screens
  }

  li a {
    text-decoration: none;
    color: ${({ theme }) => theme.colors.textLight};
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    font-weight: 500;
    transition: all ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.backgroundDark};
    }

    &.active {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.primary + '20'}; // Light primary background
    }
  }
`;

const navItems = [
  { href: '/teacher-dashboard', label: 'Overview' },
  { href: '/teacher-dashboard/chatbots', label: 'Chatbots' },
  { href: '/teacher-dashboard/rooms', label: 'Rooms' },
  { href: '/teacher-dashboard/concerns', label: 'Concerns' },
  // { href: '/teacher-dashboard/students', label: 'Students' }, // Future
  // { href: '/teacher-dashboard/settings', label: 'Settings' }, // Future
];

export default function TeacherNav() {
  const pathname = usePathname();

  return (
    <NavWrapper>
      <ul>
        {navItems.map((item) => (
          <li key={item.href}>
            <Link href={item.href} className={pathname === item.href ? 'active' : ''}>
              {item.label}
            </Link>
          </li>
        ))}
      </ul>
    </NavWrapper>
  );
}// src/components/teacher/DocumentUploader.tsx
'use client';

import { useState, useRef, ChangeEvent, DragEvent } from 'react'; // Added specific event types
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';
import type { DocumentType } from '@/types/knowledge-base.types'; // Ensure this path is correct

const UploaderContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const UploadArea = styled.div<{ $isDragging: boolean }>`
  border: 2px dashed ${({ theme, $isDragging }) => 
    $isDragging ? theme.colors.primary : theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  transition: all ${({ theme }) => theme.transitions.fast};
  background-color: ${({ theme, $isDragging }) => 
    $isDragging ? `${theme.colors.primary}10` : theme.colors.backgroundCard};
  
  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => `${theme.colors.primary}05`};
  }
  cursor: pointer;
`;

const FileInput = styled.input`
  display: none;
`;

const UploadIcon = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 2rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const UploadText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SelectedFileContainer = styled.div` // Renamed from SelectedFile to avoid conflict
  margin-top: ${({ theme }) => theme.spacing.md};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const FileName = styled.span`
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const FileSize = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface DocumentUploaderProps {
  chatbotId: string;
  onUploadSuccess: () => void; // Callback after successful upload
}

export default function DocumentUploader({ chatbotId, onUploadSuccess }: DocumentUploaderProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(false);
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const validateAndSetFile = (file: File) => {
    setError(null);
    setSuccessMessage(null);
    const validTypes: DocumentType[] = ['pdf', 'docx', 'txt'];
    const extension = file.name.split('.').pop()?.toLowerCase();

    if (!extension || (!validTypes.includes(extension as DocumentType) && extension !== 'doc')) {
      setError('Invalid file type. Please upload PDF, Word (.doc, .docx), or TXT.');
      setSelectedFile(null);
      return;
    }
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      setError('File too large. Maximum size is 10MB.');
      setSelectedFile(null);
      return;
    }
    setSelectedFile(file);
  };

  const handleUpload = async () => {
    if (!selectedFile) return;

    setIsUploading(true);
    setError(null);
    setSuccessMessage(null);

    const formData = new FormData();
    formData.append('file', selectedFile);
    formData.append('chatbotId', chatbotId); // << MODIFICATION: Add chatbotId to FormData

    try {
      // << MODIFICATION: Change API endpoint >>
      const response = await fetch('/api/teacher/documents', {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Failed to upload document');
      }
      
      setSuccessMessage(data.message || 'Document uploaded successfully!');
      setSelectedFile(null); 
      if (fileInputRef.current) {
        fileInputRef.current.value = ""; // Reset file input
      }
      onUploadSuccess(); // Call parent callback
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred during upload.');
    } finally {
      setIsUploading(false);
    }
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  return (
    <UploaderContainer>
      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      {successMessage && <Alert variant="success" style={{ marginBottom: '16px' }}>{successMessage}</Alert>}
      
      <UploadArea
        $isDragging={isDragging}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={() => fileInputRef.current?.click()}
      >
        <FileInput
          type="file"
          ref={fileInputRef}
          onChange={handleFileChange}
          accept=".pdf,.doc,.docx,.txt"
        />
        <UploadIcon>📄</UploadIcon> {/* Replace with actual icon if you have one */}
        <UploadText>{isDragging ? 'Drop your file here' : 'Click or drag file to upload'}</UploadText>
        <FileTypeInfo>Supported: PDF, DOC, DOCX, TXT (Max 10MB)</FileTypeInfo>
        {!selectedFile && (
            <Button size="small" variant="outline" type="button" onClick={(e) => { e.stopPropagation(); fileInputRef.current?.click();}}>
                Browse Files
            </Button>
        )}
      </UploadArea>

      {selectedFile && (
        <>
          <SelectedFileContainer>
            <FileName title={selectedFile.name}>{selectedFile.name}</FileName>
            <FileSize>{formatFileSize(selectedFile.size)}</FileSize>
            <Button
              size="small"
              variant="outline"
              onClick={(e) => { e.stopPropagation(); setSelectedFile(null); if(fileInputRef.current) fileInputRef.current.value = ""; setError(null);}}
              type="button"
            >
              Remove
            </Button>
          </SelectedFileContainer>
          
          <Button
            onClick={handleUpload}
            disabled={isUploading}
            style={{ marginTop: '16px', width: '100%' }}
            type="button"
          >
            {isUploading ? 'Uploading...' : `Upload ${selectedFile.name}`}
          </Button>
        </>
      )}
    </UploaderContainer>
  );
}// src/components/teacher/StatsCard.tsx
'use client';

import styled from 'styled-components';
import { Card } from '@/styles/StyledComponents'; // Assuming Card is your base styled card

interface StatsCardProps {
  title: string;
  value: string | number;
  onClick?: () => void;
  icon?: React.ReactNode; // Optional icon
  variant?: 'default' | 'warning' | 'danger'; // For highlighting
}

const StyledStatsCard = styled(Card)<{ $clickable: boolean; $variant: StatsCardProps['variant'] }>`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: ${({ $clickable }) => ($clickable ? 'pointer' : 'default')};
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    transform: ${({ $clickable }) => ($clickable ? 'translateY(-3px)' : 'none')};
    box-shadow: ${({ $clickable, theme }) => ($clickable ? theme.shadows.md : theme.shadows.sm)};
  }

  .icon {
    font-size: 1.8rem;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme, $variant }) =>
      $variant === 'danger' ? theme.colors.red :
      $variant === 'warning' ? theme.colors.secondaryDark :
      theme.colors.primary};
  }
  
  h3 { // Title
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-weight: 500;
  }

  .value {
    font-size: 2.2rem;
    font-weight: 600;
    color: ${({ theme, $variant }) =>
      $variant === 'danger' ? theme.colors.red :
      $variant === 'warning' ? theme.colors.secondaryDark :
      theme.colors.primary};
    line-height: 1.2;
  }
`;

export default function StatsCard({ title, value, onClick, icon, variant = 'default' }: StatsCardProps) {
  return (
    <StyledStatsCard onClick={onClick} $clickable={!!onClick} $variant={variant}>
      {icon && <div className="icon">{icon}</div>}
      <h3>{title}</h3>
      <div className="value">{value}</div>
    </StyledStatsCard>
  );
}// src/components/teacher/ChatbotForm.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import {
    Card,
    Button,
    FormGroup,
    Label,
    Input,
    TextArea,
    Alert,
    Select as StyledSelect
} from '@/styles/StyledComponents';

// Define BotTypeEnum locally for form state
type BotType = 'learning' | 'assessment';

// ... (Overlay, FormCard, Header, Title, CloseButton, FormContent, Footer, ActionButton styled components remain the same)
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 650px;
  margin: 20px;
  position: relative;
  display: flex;
  flex-direction: column;
  max-height: 90vh;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    width: 100%;
    min-height: 100vh;
    max-height: 100vh;
    border-radius: 0;
    box-shadow: none;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.lg};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  flex-shrink: 0;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const Title = styled.h2`
  margin: 0;
  font-size: 1.4rem;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.75rem;
  padding: 0;
  line-height: 1;

  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const FormContent = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  overflow-y: auto;
  flex-grow: 1;

  &::-webkit-scrollbar {
    width: 6px;
  }
  &::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => theme.colors.borderDark};
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }


  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;


const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  flex-shrink: 0;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

// NEW: Styling for the rubric/assessment criteria section
const AssessmentCriteriaSection = styled(FormGroup)`
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background}; // Slightly different background
`;

const RubricInfoText = styled(HelpText)`
  font-style: italic;
  margin-top: ${({ theme }) => theme.spacing.md};
`;


interface ChatbotFormData {
  name: string;
  description: string;
  system_prompt: string;
  model: string;
  max_tokens?: number;
  temperature?: number;
  enable_rag: boolean;
  bot_type: BotType;
  assessment_criteria_text: string;
}

interface ChatbotFormProps {
  onClose: () => void;
  onSuccess: (chatbotId: string) => void;
}

export default function ChatbotForm({ onClose, onSuccess }: ChatbotFormProps) {
  const [formData, setFormData] = useState<ChatbotFormData>({
    name: '',
    description: '',
    system_prompt: '',
    model: 'qwen/qwen3-235b-a22b',
    max_tokens: 1000,
    temperature: 0.7,
    enable_rag: false,
    bot_type: 'learning',
    assessment_criteria_text: '',
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    const payload = {
      ...formData,
      assessment_criteria_text: formData.bot_type === 'assessment' ? formData.assessment_criteria_text : undefined,
      enable_rag: formData.bot_type === 'learning' ? formData.enable_rag : false,
    };
    if (payload.max_tokens === undefined || payload.max_tokens === null || isNaN(payload.max_tokens) || String(payload.max_tokens).trim() === '') delete payload.max_tokens;
    if (payload.temperature === undefined || payload.temperature === null || isNaN(payload.temperature) || String(payload.temperature).trim() === '') delete payload.temperature;


    try {
      const response = await fetch('/api/teacher/chatbots', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error || 'Failed to create chatbot');
      }

      onSuccess(responseData.chatbot_id);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create chatbot');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;

    if (type === 'checkbox') {
        const { checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: checked,
        }));
    } else {
        setFormData(prev => ({
            ...prev,
            [name]: (name === 'max_tokens' || name === 'temperature') && value !== '' ? Number(value) : value,
        }));
    }
  };


  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create New Chatbot</Title>
          <CloseButton onClick={onClose} aria-label="Close modal">×</CloseButton>
        </Header>

        <FormContent>
          {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

          <form onSubmit={handleSubmit} id="chatbotCreateForm">
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input
                id="name"
                name="name"
                value={formData.name}
                onChange={handleChange}
                placeholder="e.g., History Helper, Vocab Quizzer"
                required
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="bot_type">Bot Type</Label>
              <StyledSelect
                id="bot_type"
                name="bot_type"
                value={formData.bot_type}
                onChange={handleChange}
              >
                <option value="learning">Learning Bot</option>
                <option value="assessment">Assessment Bot</option>
              </StyledSelect>
              <HelpText>
                Choose &apos;Learning&apos; for general interaction or &apos;Assessment&apos; to evaluate student responses against criteria.
              </HelpText>
            </FormGroup>

            {/* ASSESSMENT CRITERIA SECTION (Conditional) */}
            {formData.bot_type === 'assessment' && (
              <AssessmentCriteriaSection> {/* Using new styled component */}
                <Label htmlFor="assessment_criteria_text">Define Assessment Rubric / Criteria</Label>
                <TextArea
                  id="assessment_criteria_text"
                  name="assessment_criteria_text"
                  value={formData.assessment_criteria_text}
                  onChange={handleChange}
                  rows={5} // Slightly more rows
                  placeholder="Clearly describe what the AI should assess. For example:
1. Accuracy of answers to key concepts.
2. Clarity of student's explanations.
3. Use of specific examples or evidence.
4. Critical thinking demonstrated."
                  required={formData.bot_type === 'assessment'}
                />
                <HelpText>
                  This text will guide the AI in evaluating student responses. Be specific.
                </HelpText>
                <RubricInfoText>
                  For more complex rubrics, you will be able to upload a document (e.g., PDF, DOCX) with detailed criteria after creating the bot (on the chatbot&apos;s configuration page). For now, please provide a text-based summary here.
                </RubricInfoText>
              </AssessmentCriteriaSection>
            )}

            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input
                id="description"
                name="description"
                value={formData.description}
                onChange={handleChange}
                placeholder="A brief summary of what this chatbot does"
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="system_prompt">System Prompt (AI&apos;s Persona & Core Instructions)</Label>
              <TextArea
                id="system_prompt"
                name="system_prompt"
                value={formData.system_prompt}
                onChange={handleChange}
                placeholder={
                  formData.bot_type === 'assessment'
                  ? "e.g., You are an assessment assistant. Engage the student based on the provided topic. Do not provide answers directly but guide them if they struggle. After the interaction, your analysis will be based on teacher criteria."
                  : "e.g., You are a friendly and helpful history tutor for Grade 10 students."
                }
                required
                rows={formData.bot_type === 'assessment' ? 3 : 5}
              />
              <HelpText>
                  This defines the AI&apos;s general behavior.
                  {formData.bot_type === 'assessment' && " For Assessment Bots, assessment-specific instructions are primarily driven by the Assessment Criteria you define above."}
              </HelpText>
            </FormGroup>

            <FormGroup>
              <Label htmlFor="model">AI Model (for Chatting)</Label>
              <StyledSelect
                  id="model"
                  name="model"
                  value={formData.model}
                  onChange={handleChange}
              >
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta (Paid)</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B (Free)</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
              </StyledSelect>
              <HelpText>
                  This model is used for the chatbot&apos;s direct replies to students. The assessment evaluation will use a dedicated model (Qwen3 235B by default for now).
              </HelpText>
            </FormGroup>

            {/* RAG Enable - Conditionally shown for Learning Bots */}
            {formData.bot_type === 'learning' && (
              <FormGroup>
                  <Label htmlFor="enable_rag">Knowledge Base (RAG)</Label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px'}}>
                      <input
                          id="enable_rag"
                          name="enable_rag"
                          type="checkbox"
                          checked={formData.enable_rag}
                          onChange={handleChange}
                          style={{ width: '1.15em', height: '1.15em', cursor: 'pointer' }}
                      />
                      <span>Enable RAG: Allow chatbot to use uploaded documents to answer questions.</span>
                  </div>
                  <HelpText>
                      If enabled, you can upload documents to this chatbot&apos;s knowledge base after creation (on the chatbot&apos;s configuration page).
                  </HelpText>
              </FormGroup>
            )}

            {/* Max Tokens and Temperature - these apply to the CHATTING model, not necessarily the assessment evaluation model */}
            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens (Chat Response Length)</Label>
              <Input id="max_tokens" name="max_tokens" type="number" value={formData.max_tokens || ''} onChange={handleChange} placeholder="Default: 1000" />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="temperature">Temperature (Chat Creativity)</Label>
              <Input id="temperature" name="temperature" type="number" value={formData.temperature || ''} onChange={handleChange} min="0" max="2" step="0.1" placeholder="Default: 0.7"/>
              <HelpText>0.0 = most deterministic, 2.0 = most creative. Default is 0.7 for the chatbot&apos;s replies.</HelpText>
            </FormGroup>
          </form>
        </FormContent>

        <Footer>
          <ActionButton type="button" variant="outline" onClick={onClose}>
            Cancel
          </ActionButton>
          <ActionButton type="submit" form="chatbotCreateForm" disabled={isSubmitting}>
            {isSubmitting ? 'Creating...' : 'Create Chatbot'}
          </ActionButton>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/ConcernsList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button, Badge, Select as StyledSelect } from '@/styles/StyledComponents'; // Import Select
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import LoadingSpinner
import type { ConcernStatus, FlaggedMessage } from '@/types/database.types'; // Import base types

// --- Styled Components ---
const ListContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2` // Changed from h3 for better hierarchy potentially
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterControls = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  flex-wrap: wrap;
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; /* Ensure enough space for columns */
  border-collapse: collapse;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* Hide table on mobile/tablet if using mobile list */
    /* display: none; */
    /* OR, make it the primary view if MobileList isn't implemented fully */
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md}; /* Slightly less padding */
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  white-space: nowrap;
  vertical-align: bottom;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.875rem;
  vertical-align: top;
`;

const MessagePreview = styled.div`
  max-width: 200px; /* Limit width */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: ${({ theme }) => theme.colors.textLight};
  font-style: italic;
`;

// Interface for props passed to ConcernBadge
interface ConcernBadgeProps {
  $level: number; // Use transient prop syntax ($)
}

const ConcernBadge = styled(Badge)<ConcernBadgeProps>`
  background: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red + '20'; // Use alpha hex
    if ($level >= 3) return theme.colors.secondary + '20';
    return theme.colors.blue + '20'; // Use blue for moderate/minor
  }};

  color: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red;
    if ($level >= 3) return theme.colors.secondaryDark; // Use darker secondary for contrast
    return theme.colors.blue;
  }};
  font-weight: 500;
`;

// Interface for props passed to StatusBadge
interface StatusBadgeProps {
  $status: ConcernStatus; // Use transient prop syntax ($)
}

const StatusBadge = styled(Badge)<StatusBadgeProps>`
   background: ${({ theme, $status }) => {
       switch ($status) {
           case 'resolved': return theme.colors.green + '20';
           case 'false_positive': return theme.colors.textMuted + '20';
           case 'reviewing': return theme.colors.secondary + '20';
           case 'pending': return theme.colors.red + '20';
           default: return theme.colors.backgroundDark;
       }
   }};
   color: ${({ theme, $status }) => {
        switch ($status) {
           case 'resolved': return theme.colors.green;
           case 'false_positive': return theme.colors.textMuted;
           case 'reviewing': return theme.colors.secondaryDark;
           case 'pending': return theme.colors.red;
           default: return theme.colors.textLight;
       }
   }};
   font-weight: 500;
`;


const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  min-height: 100px; /* Give it some height */
`;

const PaginationControls = styled.div`
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: ${({ theme }) => theme.spacing.lg};
    gap: ${({ theme }) => theme.spacing.md};
`;

// --- Data Interface (Matching API Response) ---
interface ConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

// --- Helper Functions ---
function getConcernTypeText(type: string): string {
    if (!type) return 'Unknown';
    return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

function getConcernLevelText(level: number): string {
    if (level >= 5) return 'Critical';
    if (level >= 4) return 'High';
    if (level >= 3) return 'Significant';
    if (level >= 2) return 'Moderate';
    if (level >= 1) return 'Minor';
    return 'Low';
}

function getStatusText(status: ConcernStatus): string {
    switch (status) {
        case 'pending': return 'Pending';
        case 'reviewing': return 'Reviewing';
        case 'resolved': return 'Resolved';
        case 'false_positive': return 'False Positive';
        default: return status || 'Unknown';
    }
}
// -----------------------

interface ConcernsListProps {
  limit?: number; // Optional limit for dashboard preview
}

export default function ConcernsList({ limit }: ConcernsListProps) {
    const [concerns, setConcerns] = useState<ConcernDetails[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [statusFilter, setStatusFilter] = useState<string>('pending'); // Default to pending
    const [pagination, setPagination] = useState({ currentPage: 0, hasMore: false, totalCount: 0 });
    const router = useRouter();

    const fetchConcerns = useCallback(async (page = 0, filter = statusFilter, isNewFilter = false) => {
        setLoading(true); // Show loading indicator on fetch
        if (isNewFilter) {
             setConcerns([]); // Clear existing concerns when filter changes
             setPagination(prev => ({ ...prev, currentPage: 0, hasMore: false })); // Reset pagination
        }
        setError(null);

        try {
            const itemsPerPage = limit || 10; // Use prop limit or default to 10 for full view
            const url = new URL('/api/teacher/concerns', window.location.origin);
            url.searchParams.append('page', page.toString());
            url.searchParams.append('limit', itemsPerPage.toString());
            if (filter) {
                url.searchParams.append('status', filter);
            }

            const response = await fetch(url.toString());

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to fetch concerns (status: ${response.status})`);
            }

            const data = await response.json();
            // Append if loading more, replace if it's a new filter or first page
            setConcerns(prev => (page > 0 && !isNewFilter) ? [...prev, ...(data.concerns || [])] : (data.concerns || []));
            setPagination({
                 currentPage: data.pagination?.currentPage ?? 0,
                 hasMore: data.pagination?.hasMore ?? false,
                 totalCount: data.pagination?.totalCount ?? 0,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error loading concerns');
            setConcerns([]); // Clear concerns on error
            setPagination({ currentPage: 0, hasMore: false, totalCount: 0 }); // Reset pagination on error
        } finally {
            setLoading(false);
        }
    }, [limit, statusFilter]); // statusFilter is now a dependency

    useEffect(() => {
        // Initial fetch when component mounts
        fetchConcerns(0, statusFilter, true); // isNewFilter = true on initial load
    }, [fetchConcerns, statusFilter]); // Fetch when filter changes


    const handleViewConversation = (concern: ConcernDetails) => {
        router.push(`/teacher-dashboard/concerns/${concern.flag_id}`);
    };

    const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newFilter = e.target.value;
        setStatusFilter(newFilter);
        // Fetch will be triggered by useEffect dependency change
    };

    const handleLoadMore = () => {
        if (!loading && pagination.hasMore) {
            fetchConcerns(pagination.currentPage + 1, statusFilter, false); // isNewFilter = false
        }
    };

    // Render Logic
    const renderContent = () => {
        if (loading && concerns.length === 0) { // Show loading only on initial load
            return <LoadingState><LoadingSpinner /> Loading concerns...</LoadingState>;
        }

        if (error) {
            return <Alert variant="error">{error}</Alert>;
        }

        if (concerns.length === 0) {
            return (
            <EmptyState>
                <p>No concerns {statusFilter ? `with status "${getStatusText(statusFilter as ConcernStatus)}"` : ''} found.</p>
            </EmptyState>
            );
        }

        return (
            <>
                <TableContainer>
                    <Table>
                        <thead>
                            <tr>
                                <TableHeader>Student</TableHeader>
                                <TableHeader>Room</TableHeader>
                                <TableHeader>Concern Type</TableHeader>
                                <TableHeader>Level</TableHeader>
                                <TableHeader>Message Preview</TableHeader>
                                <TableHeader>Date Flagged</TableHeader>
                                <TableHeader>Status</TableHeader>
                                <TableHeader>Actions</TableHeader>
                            </tr>
                        </thead>
                        <tbody>
                            {concerns.map((concern) => (
                                <tr key={concern.flag_id}>
                                    <TableCell>{concern.student_name || 'N/A'}</TableCell>
                                    <TableCell>{concern.room_name || 'N/A'}</TableCell>
                                    <TableCell>{getConcernTypeText(concern.concern_type)}</TableCell>
                                    <TableCell>
                                        <ConcernBadge $level={concern.concern_level}>
                                            {getConcernLevelText(concern.concern_level)} ({concern.concern_level})
                                        </ConcernBadge>
                                    </TableCell>
                                    <TableCell>
                                        <MessagePreview title={concern.message_content || ''}>
                                            {concern.message_content || '[N/A]'}
                                        </MessagePreview>
                                    </TableCell>
                                    <TableCell>
                                        {new Date(concern.created_at).toLocaleString()}
                                    </TableCell>
                                    <TableCell>
                                        <StatusBadge $status={concern.status}>
                                            {getStatusText(concern.status)}
                                        </StatusBadge>
                                    </TableCell>
                                    <TableCell>
                                        <Button
                                            size="small"
                                            onClick={() => handleViewConversation(concern)}
                                        >
                                            Review
                                        </Button>
                                    </TableCell>
                                </tr>
                            ))}
                        </tbody>
                    </Table>
                </TableContainer>

                {/* Add Mobile List View Here if needed */}
                {/*
                <MobileList>
                   ... Mobile card rendering ...
                </MobileList>
                */}

                {!limit && pagination.hasMore && ( // Only show load more if not limited by prop
                 <PaginationControls>
                     <Button onClick={handleLoadMore} variant="outline" disabled={loading}>
                         {loading ? 'Loading...' : 'Load More Concerns'}
                     </Button>
                 </PaginationControls>
                )}
            </>
        );
    };

    return (
        <ListContainer>
            {/* Render Title and Filters only if not limited (i.e., it's the full list view) */}
            {!limit && (
                <>
                    <Title>Student Welfare Concerns</Title>
                    <FilterControls>
                        <label htmlFor="status-filter">Filter by status:</label>
                        <StyledSelect // Use the imported styled Select
                            id="status-filter"
                            value={statusFilter}
                            onChange={handleFilterChange}
                            disabled={loading}
                        >
                            <option value="pending">Pending</option>
                            <option value="reviewing">Reviewing</option>
                            <option value="resolved">Resolved</option>
                            <option value="false_positive">False Positive</option>
                            <option value="">All</option>
                        </StyledSelect>
                        {!loading && <span>Total Found: {pagination.totalCount}</span>}
                    </FilterControls>
                 </>
            )}
            {/* Render the main content (table/loading/empty/error) */}
            {renderContent()}
        </ListContainer>
    );
}// src/components/teacher/DashboardOverview.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import StatsCard from './StatsCard'; // Assuming this is correctly imported
import { Button, Alert, Card } from '@/styles/StyledComponents'; // Added Card for structure
import { useRouter } from 'next/navigation';
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // For loading state
import RoomForm from '@/components/teacher/RoomForm'; // For the "Create New Room" modal
import type { Chatbot } from '@/types/database.types'; // For fetching chatbots to pass to RoomForm

const OverviewWrapper = styled.div`
  /* Add any specific wrapper styles if needed */
`;

const StatsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Section = styled(Card)` // Use Card as base for sections for consistent styling
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  padding: ${({ theme }) => theme.spacing.lg};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

const QuickActionsContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    button {
      width: 100%;
    }
  }
`;

interface DashboardStats {
  totalChatbots: number;
  totalRooms: number;
  activeRooms: number;
  pendingConcerns: number;
}

export default function DashboardOverview() {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loadingStats, setLoadingStats] = useState(true);
  const [statsError, setStatsError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false); // For "Create New Room" modal
  const [availableChatbots, setAvailableChatbots] = useState<Chatbot[]>([]); // For RoomForm
  const [loadingChatbots, setLoadingChatbots] = useState(false); // For fetching chatbots

  const router = useRouter();

  useEffect(() => {
    const fetchDashboardData = async () => {
      setLoadingStats(true);
      setStatsError(null);
      setLoadingChatbots(true); // Also set loading for chatbots

      try {
        // Fetch stats and chatbots concurrently
        const [statsResponse, chatbotsResponse] = await Promise.all([
          fetch('/api/teacher/dashboard-stats'),
          fetch('/api/teacher/chatbots') // Fetch all chatbots for the RoomForm
        ]);

        if (!statsResponse.ok) {
          const errorData = await statsResponse.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to fetch stats (status ${statsResponse.status})`);
        }
        const statsData: DashboardStats = await statsResponse.json();
        setStats(statsData);

        if (!chatbotsResponse.ok) {
          const errorData = await chatbotsResponse.json().catch(() => ({}));
          // Don't throw an error that stops stats from loading, just log and set empty array
          console.error(errorData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`);
          setStatsError(prev => prev ? `${prev}\nFailed to load chatbots for Room Creation.` : 'Failed to load chatbots for Room Creation.');
          setAvailableChatbots([]);
        } else {
          const chatbotsData: Chatbot[] = await chatbotsResponse.json();
          setAvailableChatbots(chatbotsData);
        }

      } catch (err) {
        console.error("Error fetching dashboard data:", err);
        const errorMessage = err instanceof Error ? err.message : 'Could not load dashboard overview.';
        setStatsError(prev => prev ? `${prev}\n${errorMessage}` : errorMessage);
      } finally {
        setLoadingStats(false);
        setLoadingChatbots(false);
      }
    };
    fetchDashboardData();
  }, []);

  const handleCreateNewChatbot = () => {
    router.push('/teacher-dashboard/chatbots/new/edit'); // Navigate to unified page
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    // Optionally, re-fetch stats or navigate, but for now, just close modal
    // Consider a toast message for success
    alert("Room created successfully!");
    // Re-fetch stats to update room counts
     const fetchStatsOnly = async () => {
        setLoadingStats(true);
        try {
            const response = await fetch('/api/teacher/dashboard-stats');
            if (!response.ok) throw new Error('Failed to refresh stats');
            const data: DashboardStats = await response.json();
            setStats(data);
        } catch (e) { console.error("Failed to refresh stats after room creation", e); }
        finally { setLoadingStats(false); }
    };
    fetchStatsOnly();
  };


  if (loadingStats) { // Main loading indicator for stats
    return (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
            <LoadingSpinner size="large" />
            <p style={{marginTop: '16px'}}>Loading dashboard overview...</p>
        </Card>
    );
  }


  return (
    <OverviewWrapper>
      {statsError && <Alert variant="error" style={{ marginBottom: '16px' }}>{statsError}</Alert>}

      {stats && (
        <StatsGrid>
          <StatsCard
            title="Pending Concerns"
            value={stats.pendingConcerns}
            onClick={() => router.push('/teacher-dashboard/concerns')}
            variant={stats.pendingConcerns > 0 ? 'danger' : 'default'}
          />
          <StatsCard
            title="Active Rooms"
            value={stats.activeRooms}
            onClick={() => router.push('/teacher-dashboard/rooms')}
          />
          <StatsCard
            title="My Chatbots"
            value={stats.totalChatbots}
            onClick={() => router.push('/teacher-dashboard/chatbots')}
          />
          <StatsCard
            title="Total Rooms"
            value={stats.totalRooms}
            onClick={() => router.push('/teacher-dashboard/rooms')} // Also link to rooms page
          />
        </StatsGrid>
      )}

      <Section>
        <SectionHeader>
          <SectionTitle>Quick Actions</SectionTitle>
        </SectionHeader>
        <QuickActionsContainer>
          <Button onClick={handleCreateNewChatbot}>
            + Create New Chatbot
          </Button>
          <Button
            onClick={() => setShowRoomForm(true)}
            disabled={loadingChatbots || availableChatbots.length === 0}
            title={availableChatbots.length === 0 && !loadingChatbots ? "Create a chatbot before creating a room" : "Create New Room"}
          >
            {loadingChatbots ? "Loading Chatbots..." : "+ Create New Room"}
          </Button>
        </QuickActionsContainer>
        {availableChatbots.length === 0 && !loadingChatbots && !statsError?.includes("Failed to load chatbots") && (
            <Alert variant='info' style={{marginTop: '16px'}}>
                You need to create at least one chatbot before you can create a classroom room using the quick action.
            </Alert>
        )}
      </Section>

      {/* You can add other sections here like a preview of recent concerns, etc. */}
      {/* For example, to show the ConcernsList directly on the dashboard (as a preview):
      <Section id="concerns-section">
            <SectionHeader>
                 <SectionTitle>Recent Pending Concerns</SectionTitle>
                 <Button variant="outline" size="small" onClick={() => router.push('/teacher-dashboard/concerns')}>View All Concerns</Button>
            </SectionHeader>
            <ConcernsList limit={3} /> // Pass a limit to show only a few
       </Section>
       */}


      {/* RoomForm Modal for "Create New Room" quick action */}
      {showRoomForm && (
        <RoomForm
          chatbots={availableChatbots} // Pass the fetched chatbots
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreated}
        />
      )}
    </OverviewWrapper>
  );
}// src/components/teacher/StudentList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react'; // Added useCallback
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import a spinner

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; 
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled(EmptyState)` // Reuse EmptyState style for consistency
    display: flex;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
`;


const MobileList = styled.div`
  display: none;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block;
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const StudentName = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.875rem;
  
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-right: ${({ theme }) => theme.spacing.md};
  }
  
  .value {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

interface Student {
  user_id: string;
  name: string;
  email: string;
  joined_at: string | null;
  // message_count: number; // Removed as API doesn't provide it yet
  // last_activity: string | null; // Removed
}

interface StudentListProps {
  roomId: string;
}

export default function StudentList({ roomId }: StudentListProps) {
  const [students, setStudents] = useState<Student[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const fetchStudents = useCallback(async () => {
    console.log(`[StudentList] Fetching students for roomId: ${roomId}`);
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/teacher/students?roomId=${roomId}`);
      
      if (!response.ok) {
        let errorMessage = `Failed to fetch students (status ${response.status})`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.error || errorMessage;
        } catch {
          // Failed to parse error JSON
        }
        console.error(`[StudentList] API error: ${errorMessage}`);
        throw new Error(errorMessage);
      }
      
      const data = await response.json();
      console.log('[StudentList] Students data received:', data);
      setStudents(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error('[StudentList] Catch block error fetching students:', err);
      setError(err instanceof Error ? err.message : 'Could not load student data.');
      setStudents([]); // Clear students on error
    } finally {
      console.log('[StudentList] Setting loading to false.');
      setLoading(false);
    }
  }, [roomId]); // roomId is the dependency

  useEffect(() => {
    if (roomId) { // Only fetch if roomId is available
        fetchStudents();
    } else {
        console.warn("[StudentList] RoomId is missing, not fetching students.");
        setLoading(false); // Don't hang in loading state if no roomId
    }
  }, [roomId, fetchStudents]); // fetchStudents is stable due to useCallback

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString();
    } catch {
        return 'Invalid Date';
    }
  };

  const handleViewChats = (studentId: string) => {
    router.push(`/room/${roomId}/student/${studentId}`);
  };

  if (loading) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <LoadingState><LoadingSpinner size="small" /> Loading student data...</LoadingState>
      </ListContainer>
    );
  }

  // Error display takes precedence over empty state if an error occurred
  if (error) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <Alert variant="error">
          Error: {error}
          <Button size="small" onClick={fetchStudents} style={{ marginLeft: '10px' }}>
            Retry
          </Button>
        </Alert>
      </ListContainer>
    );
  }

  if (students.length === 0) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <EmptyState>
          <p>No students have joined this room yet, or data could not be loaded.</p>
          <Button size="small" onClick={fetchStudents} style={{ marginTop: '10px' }}>
            Refresh List
          </Button>
        </EmptyState>
      </ListContainer>
    );
  }

  return (
    <ListContainer>
      <Title>Students ({students.length})</Title>
      
      <Table>
        {/* ... (thead remains the same) ... */}
        <thead>
          <tr>
            <TableHeader>Name</TableHeader>
            <TableHeader>Email</TableHeader>
            <TableHeader>Joined</TableHeader>
            <TableHeader>Actions</TableHeader>
          </tr>
        </thead>
        <tbody>
          {students.map((student) => (
            <tr key={student.user_id}>
              <TableCell>{student.name}</TableCell>
              <TableCell>{student.email}</TableCell>
              <TableCell>{formatDate(student.joined_at)}</TableCell>
              <TableCell>
                <Button
                  size="small"
                  onClick={() => handleViewChats(student.user_id)}
                >
                  View Chats
                </Button>
              </TableCell>
            </tr>
          ))}
        </tbody>
      </Table>
      
      <MobileList>
        {students.map((student) => (
          <MobileCard key={student.user_id}>
            <MobileHeader>
              <StudentName>{student.name}</StudentName>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Email:</span>
              <span className="value">{student.email}</span>
              <span className="label">Joined:</span>
              <span className="value">{formatDate(student.joined_at)}</span>
            </MobileDetails>
            <MobileActions>
              <Button
                size="small"
                onClick={() => handleViewChats(student.user_id)}
                style={{ width: '100%' }}
              >
                View Chats
              </Button>
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/teacher/ChatbotList.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { Card, Button } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

// ... (ListGrid, StyledChatbotCard, getModelDisplayName styled components remain the same) ...
const ListGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const StyledChatbotCard = styled(Card)`
  position: relative;
  display: flex;
  flex-direction: column;

  a > h3 { 
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
    text-decoration: none;
    display: block; 
    transition: color ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      text-decoration: underline;
    }
  }
  
  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1;
    min-height: 2.5rem;
  }
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.sm};
    margin-top: auto; 
    padding-top: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap;
    button, a { 
        flex-grow: 1;
        min-width: calc(33% - ${({ theme }) => theme.spacing.sm} * 2 / 3);
        text-align: center;
         @media (max-width: 420px) { 
            min-width: 100%;
         }
    }
  }
`;

const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash'
    };
    return modelNames[model] || model;
};

interface ChatbotListProps {
  chatbots: Chatbot[];
  onEdit: (chatbotId: string) => void;
  onDelete: (chatbotId: string, chatbotName: string) => void;
}

export default function ChatbotList({ chatbots, onEdit, onDelete }: ChatbotListProps) {
  if (chatbots.length === 0) {
    return <Card><p>No chatbots created yet. Click &quot;+ Create Chatbot&quot; to get started!</p></Card>;
  }

  return (
    <ListGrid>
      {chatbots.map(chatbot => (
        <StyledChatbotCard key={chatbot.chatbot_id}>
          {/* MODIFIED LINK for chatbot name */}
          <Link href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/test-chat`} title={`Test chat with ${chatbot.name}`}>
            <h3>{chatbot.name}</h3>
          </Link>
          <p className="description">{chatbot.description || 'No description provided.'}</p>
          <div className="model-info">
            Model: {getModelDisplayName(chatbot.model)}
          </div>
          <div className="actions">
            <Button
              size="small"
              variant="outline"
              onClick={() => onEdit(chatbot.chatbot_id)}
              title="Edit chatbot configuration"
            >
              Configure
            </Button>
            <Button
                as={Link} 
                href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/knowledge-base`}
                size="small"
                variant="outline"
                title="Manage knowledge base documents"
            >
                Knowledge
            </Button>
            <Button
                size="small"
                variant="danger"
                onClick={() => onDelete(chatbot.chatbot_id, chatbot.name)}
                title="Delete this chatbot"
            >
                Delete
            </Button>
          </div>
        </StyledChatbotCard>
      ))}
    </ListGrid>
  );
}'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
    overflow-y: auto;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    max-height: 100%;
    min-height: 100vh;
    border-radius: 0;
    overflow-y: auto;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    position: sticky;
    top: 0;
    background: ${({ theme }) => theme.colors.backgroundCard};
    padding: ${({ theme }) => theme.spacing.sm} 0;
    z-index: 5;
  }
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
  }
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    max-height: 200px;
  }
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
    min-height: 44px; // Better for touch inputs
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 20px;
    height: 20px;
  }
`;

const ChatbotName = styled.span`
  flex: 1;
`;

const ChatbotDescription = styled.span`
  margin-left: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none;
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px; // Better for touch inputs
  }
`;

interface RoomFormProps {
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function RoomForm({ chatbots, onClose, onSuccess }: RoomFormProps) {
  const [formData, setFormData] = useState({
    room_name: '',
    chatbot_ids: [] as string[],
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/teacher/rooms', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create room');
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create room');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({
      ...prev,
      room_name: e.target.value,
    }));
  };

  const handleToggleChatbot = (chatbotId: string) => {
    setFormData(prev => ({
      ...prev,
      chatbot_ids: prev.chatbot_ids.includes(chatbotId)
        ? prev.chatbot_ids.filter(id => id !== chatbotId)
        : [...prev.chatbot_ids, chatbotId]
    }));
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create Classroom Room</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="room_name">Room Name</Label>
            <Input
              id="room_name"
              name="room_name"
              value={formData.room_name}
              onChange={handleNameChange}
              placeholder="Enter room name"
              required
            />
          </FormGroup>

          <FormGroup>
            <Label>Select Chatbots</Label>
            {chatbots.length === 0 ? (
              <Alert variant="warning">
                You need to create a chatbot before you can create a room.
              </Alert>
            ) : (
              <ChatbotList>
                {chatbots.map(chatbot => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <Checkbox
                      type="checkbox"
                      checked={formData.chatbot_ids.includes(chatbot.chatbot_id)}
                      onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                    />
                    <ChatbotName>{chatbot.name}</ChatbotName>
                    {chatbot.description && (
                      <ChatbotDescription>
                        - {chatbot.description}
                      </ChatbotDescription>
                    )}
                  </ChatbotItem>
                ))}
              </ChatbotList>
            )}
          </FormGroup>

          <Footer>
            <ActionButton type="button" variant="outline" onClick={onClose}>
              Cancel
            </ActionButton>
            <ActionButton 
              type="submit" 
              disabled={isSubmitting || chatbots.length === 0 || formData.chatbot_ids.length === 0}
            >
              {isSubmitting ? 'Creating...' : 'Create Room'}
            </ActionButton>
          </Footer>
        </form>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/DocumentList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, Badge, Alert } from '@/styles/StyledComponents';
import type { Document as KnowledgeDocument, DocumentStatus } from '@/types/knowledge-base.types';

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  overflow-x: auto; // Ensure table is scrollable horizontally if it overflows
`;

const Table = styled.table`
  width: 100%;
  min-width: 700px; // Ensure table has a minimum width for all columns
  border-collapse: collapse; // Corrected from seperate to collapse
  
  th, td {
    text-align: left;
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    vertical-align: middle; // Changed from top for better alignment with buttons
  }

  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    white-space: nowrap; // Prevent headers from wrapping
  }

  td {
    color: ${({ theme }) => theme.colors.text};
    font-size: 0.875rem;
  }

  .actions-cell {
    width: 1%; // Allow this column to shrink but also expand for multiple buttons
    white-space: nowrap;
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* Forcing table display for now, mobile list can be a future enhancement */
    /* display: none; */ 
  }
`;

// MobileList and related components are kept but not used if Table is always displayed
const MobileList = styled.div`
  display: none; /* Hidden for now, enable if switching views */
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* display: block; */
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const FileNameMobile = styled.div` // Renamed to avoid conflict with Table's FileName
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  word-break: break-all;
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.8rem;
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  .value {
    color: ${({ theme }) => theme.colors.text};
    word-break: break-all;
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  flex-wrap: wrap;
  button {
    flex-grow: 1;
    min-width: 100px;
  }
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

// StatusBadge is imported from StyledComponents, so it should use its defined props
// The $status prop was correct if Badge in StyledComponents expects it for styling.
// If Badge in StyledComponents uses 'variant', then we adjust.
// Assuming Badge uses 'variant' prop and we map status to variant:
// Removed unused StyledStatusBadge

const getStatusBadgeVariant = (status: DocumentStatus): 'success' | 'warning' | 'error' | 'default' => {
    switch (status) {
      case 'completed': return 'success';
      case 'processing': return 'default'; // Or a 'info' / 'blue' if you have one
      case 'error': return 'error';
      case 'uploaded': return 'warning'; // 'uploaded' might be better as 'warning' or 'default'
      default: return 'default';
    }
};


interface DocumentListProps {
  documents: KnowledgeDocument[];
  onProcessDocument: (documentId: string) => Promise<void>;
  onDeleteDocument: (documentId: string) => Promise<void>;
  onViewStatus: (documentId: string) => void;
}

export default function DocumentList({
  documents,
  onProcessDocument,
  onDeleteDocument,
  onViewStatus
}: DocumentListProps) {
  const [processingId, setProcessingId] = useState<string | null>(null);
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [actionError, setActionError] = useState<string | null>(null);

  const formatDate = (dateString: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleString();
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + ['Bytes', 'KB', 'MB', 'GB', 'TB'][i];
  };

  const getStatusLabel = (status: DocumentStatus): string => {
    const labels: Record<DocumentStatus, string> = {
      uploaded: 'Uploaded',
      processing: 'Processing',
      completed: 'Completed',
      error: 'Error',
    };
    return labels[status] || status;
  };

  const handleProcess = async (documentId: string) => {
    setProcessingId(documentId);
    setActionError(null);
    try {
      await onProcessDocument(documentId);
    } catch (err) {
      setActionError(err instanceof Error ? err.message : "Failed to start processing.");
    } finally {
      setProcessingId(null);
    }
  };

  const handleDelete = async (documentId: string, documentName: string) => {
    if (!window.confirm(`Are you sure you want to delete the document "${documentName}"? This action cannot be undone.`)) {
        return;
    }
    setDeletingId(documentId);
    setActionError(null);
    try {
      await onDeleteDocument(documentId);
    } catch (err) {
      setActionError(err instanceof Error ? err.message : "Failed to delete document.");
    } finally {
      setDeletingId(null);
    }
  };

  if (documents.length === 0) {
    return (
      <ListContainer>
        <EmptyState>
          <p>No documents have been uploaded for this chatbot yet.</p>
        </EmptyState>
      </ListContainer>
    );
  }

  const renderActions = (doc: KnowledgeDocument) => (
    <>
      {doc.status === 'uploaded' && (
        <Button
          size="small"
          onClick={() => handleProcess(doc.document_id)}
          disabled={processingId === doc.document_id}
          title="Process this document for RAG"
        >
          {processingId === doc.document_id ? 'Starting...' : 'Process'}
        </Button>
      )}
      {(doc.status === 'processing' || doc.status === 'completed' || doc.status === 'error') && (
        <Button
          size="small"
          variant="outline"
          onClick={() => onViewStatus(doc.document_id)}
          title="View detailed processing status"
        >
          View Status
        </Button>
      )}
      <Button
        size="small"
        variant="danger" 
        onClick={() => handleDelete(doc.document_id, doc.file_name)}
        disabled={deletingId === doc.document_id}
        title="Delete this document"
      >
        {deletingId === doc.document_id ? 'Deleting...' : 'Delete'}
      </Button>
    </>
  );

  // The main issue was likely `className` on `TableHeader` and `TableCell` which are styled components.
  // Styled components pass props directly, or use transient props ($prop) for styling only.
  // For `actions-cell`, it's better to create a specific styled TD or handle width via CSS.

  return (
    <ListContainer>
      {actionError && <Alert variant="error" style={{ marginBottom: '16px'}}>{actionError}</Alert>}
      <Table>
        <thead>
          <tr>
            <th>Name</th> {/* Changed from TableHeader component to direct th */}
            <th>Type</th>
            <th>Size</th>
            <th>Status</th>
            <th>Uploaded</th>
            <th className="actions-cell">Actions</th> {/* Using a className for specific styling */}
          </tr>
        </thead>
        <tbody>
          {documents.map((doc) => (
            <tr key={doc.document_id}>
              <td title={doc.file_name}>{doc.file_name}</td> {/* Changed from TableCell to direct td */}
              <td>{doc.file_type.toUpperCase()}</td>
              <td>{formatFileSize(doc.file_size)}</td>
              <td>
                {/* Using the imported Badge and determining its variant */}
                <Badge variant={getStatusBadgeVariant(doc.status)}>
                  {getStatusLabel(doc.status)}
                </Badge>
              </td>
              <td>{formatDate(doc.created_at)}</td>
              <td className="actions-cell">
                <div style={{ display: 'flex', gap: '8px' }}>
                  {renderActions(doc)}
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </Table>

      {/* MobileList remains unchanged for now, as the focus is fixing the table errors */}
      <MobileList>
        {documents.map((doc) => (
          <MobileCard key={doc.document_id}>
            <MobileHeader>
              <FileNameMobile title={doc.file_name}>{doc.file_name}</FileNameMobile>
              <Badge variant={getStatusBadgeVariant(doc.status)}>
                {getStatusLabel(doc.status)}
              </Badge>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Type:</span>
              <span className="value">{doc.file_type.toUpperCase()}</span>
              <span className="label">Size:</span>
              <span className="value">{formatFileSize(doc.file_size)}</span>
              <span className="label">Uploaded:</span>
              <span className="value">{formatDate(doc.created_at)}</span>
              {doc.error_message && (
                <>
                    <span className="label" style={{color: 'red'}}>Error:</span>
                    <span className="value" style={{color: 'red', whiteSpace: 'normal'}}>{doc.error_message}</span>
                </>
              )}
            </MobileDetails>
            <MobileActions>
                {renderActions(doc)}
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo } from 'react';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    void error;
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || <h1>Sorry.. there was an error</h1>;
    }

    return this.props.children;
  }
}// src/lib/openrouter/client.ts
import type { ChatMessage } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

export interface OpenRouterConfig {
  model: string;
  temperature?: number;
  maxTokens?: number;
}

export interface OpenRouterResponse {
  choices: {
    message: {
      content: string;
    };
  }[];
  usage?: {
    total_tokens: number;
  };
}

export async function sendChatCompletion(
  messages: ChatMessage[],
  config: OpenRouterConfig
): Promise<OpenRouterResponse> {
  const response = await fetch(OPENROUTER_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
      'X-Title': 'ClassBots AI',
    },
    body: JSON.stringify({
      model: config.model,
      messages: messages.map(msg => ({
        role: msg.role,
        content: msg.content,
      })),
      temperature: config.temperature || 0.7,
      max_tokens: config.maxTokens || 1000,
    }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    console.error('OpenRouter error details:', errorData);
    throw new Error(`OpenRouter API error: ${errorData.error?.message || response.statusText}`);
  }

  return response.json();
}// src/lib/utils/room-codes.ts
const CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
const CODE_LENGTH = 6;

export function generateRoomCode(): string {
  let code = '';
  for (let i = 0; i < CODE_LENGTH; i++) {
    const randomIndex = Math.floor(Math.random() * CHARACTERS.length);
    code += CHARACTERS[randomIndex];
  }
  return code;
}

export function isValidRoomCode(code: string): boolean {
  if (code.length !== CODE_LENGTH) {
    return false;
  }
  
  const regex = new RegExp(`^[${CHARACTERS}]{${CODE_LENGTH}}$`);
  return regex.test(code);
}// src/lib/utils/constants.ts

// App Constants
export const APP_NAME = 'ClassBots AI';
export const APP_DESCRIPTION = 'AI-powered classroom chatbots for teachers and students';

// Route Constants
export const ROUTES = {
  HOME: '/',
  AUTH: '/auth',
  TEACHER_DASHBOARD: '/teacher-dashboard',
  STUDENT: '/student',
  CHAT: (roomId: string) => `/chat/${roomId}`,
  API: {
    TEACHER: {
      CHATBOTS: '/api/teacher/chatbots',
      ROOMS: '/api/teacher/rooms',
    },
    STUDENT: {
      ROOMS: '/api/student/rooms',
      JOIN_ROOM: '/api/student/join-room',
    },
    CHAT: (roomId: string) => `/api/chat/${roomId}`,
  },
} as const;

// Default Chatbot Config
export const DEFAULT_CHATBOT_CONFIG = {
  model: 'x-ai/grok-3-mini-beta', // Keeping Grok as default
  maxTokens: 1500,
  temperature: 0.7,
} as const;

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant',
  SYSTEM: 'system',
} as const;

// User Roles
export const USER_ROLES = {
  TEACHER: 'teacher',
  STUDENT: 'student',
} as const;

// Local Storage Keys
export const STORAGE_KEYS = {
  THEME: 'classbots-theme',
  LAST_ROOM: 'classbots-last-room',
} as const;// src/lib/document-processing/extractor.ts
import * as pdfParse from 'pdf-parse/lib/pdf-parse.js';
import mammoth from 'mammoth';
import { DocumentType } from '@/types/knowledge-base.types';

/**
 * Extract text from different document types
 */
export async function extractTextFromFile(
  fileBuffer: Buffer,
  fileType: DocumentType
): Promise<string> {
  try {
    switch (fileType) {
      case 'pdf':
        return extractFromPdf(fileBuffer);
      case 'docx':
        return extractFromDocx(fileBuffer);
      case 'txt':
        return extractFromTxt(fileBuffer);
      default:
        throw new Error(`Unsupported file type: ${fileType}`);
    }
  } catch (error) {
    console.error(`Error extracting text from ${fileType} file:`, error);
    throw new Error(`Failed to extract text from ${fileType} file: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF files
 */
async function extractFromPdf(fileBuffer: Buffer): Promise<string> {
  try {
    // Use a minimal options object to avoid looking for test files
    const options = {
      // No version testing, no page rendering
      max: 0,
      pagerender: null
    };
    
    const data = await pdfParse(fileBuffer, options);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw error;
  }
}

/**
 * Extract text from DOCX files
 */
async function extractFromDocx(fileBuffer: Buffer): Promise<string> {
  try {
    const result = await mammoth.extractRawText({ buffer: fileBuffer });
    return result.value;
  } catch (error) {
    console.error('Error extracting text from DOCX:', error);
    throw error;
  }
}

/**
 * Extract text from TXT files
 */
function extractFromTxt(fileBuffer: Buffer): Promise<string> {
  return Promise.resolve(fileBuffer.toString('utf-8'));
}// src/lib/document-processing/processor.ts
import { extractTextFromFile } from './extractor';
import { splitTextIntoChunks, estimateTokenCount } from './chunker';
import { generateEmbeddings } from '@/lib/openai/embeddings';
import { upsertVectors } from '@/lib/pinecone/utils';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { Document, DocumentChunk, DocumentStatus } from '@/types/knowledge-base.types';

// Mock embedding function for fallback - using 1536 dimensions for OpenAI
function createMockEmbedding(): number[] {
  // Create a random vector - 1536 dimensions for OpenAI compatibility
  return Array(1536).fill(0).map(() => (Math.random() * 2) - 1);
}

/**
 * Process a document by extracting text, chunking, and generating embeddings
 */
export async function processDocument(document: Document): Promise<void> {
  console.log(`[PROCESSOR] Starting document processing for doc ID: ${document.document_id}, file: ${document.file_name}`);
  const supabase = await createServerSupabaseClient();

  try {
    // Update document status to processing (already done by caller, but good for robustness)
    await supabase
      .from('documents')
      .update({ status: 'processing' as DocumentStatus, updated_at: new Date().toISOString() })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Status set to processing.`);

    // Download file from storage
    console.log(`[PROCESSOR ${document.document_id}] Downloading file from storage: ${document.file_path}`);
    const { data: fileData, error: fileError } = await supabase
      .storage
      .from('documents')
      .download(document.file_path);

    if (fileError || !fileData) {
      throw new Error(`Failed to download file: ${fileError?.message}`);
    }
    console.log(`[PROCESSOR ${document.document_id}] File downloaded successfully.`);

    // Extract text from file
    console.log(`[PROCESSOR ${document.document_id}] Extracting text from file type: ${document.file_type}`);
    const extractedText = await extractTextFromFile(
      Buffer.from(await fileData.arrayBuffer()),
      document.file_type
    );
    console.log(`[PROCESSOR ${document.document_id}] Extracted ${extractedText.length} characters.`);

    // Split text into chunks
    console.log(`[PROCESSOR ${document.document_id}] Splitting text into chunks.`);
    const chunks = splitTextIntoChunks(extractedText);
    console.log(`[PROCESSOR ${document.document_id}] Created ${chunks.length} chunks.`);

    if (chunks.length === 0) {
        console.warn(`[PROCESSOR ${document.document_id}] No chunks generated. Document might be empty or too small.`);
        await supabase
          .from('documents')
          .update({ status: 'completed' as DocumentStatus, error_message: 'No content to process.', updated_at: new Date().toISOString() })
          .eq('document_id', document.document_id);
        return;
    }

    // Create chunk records in database
    console.log(`[PROCESSOR ${document.document_id}] Creating database records for chunks.`);
    const chunkRecords: Partial<DocumentChunk>[] = chunks.map((chunkText, index) => ({
      document_id: document.document_id,
      chunk_index: index,
      chunk_text: chunkText,
      token_count: estimateTokenCount(chunkText),
      status: 'pending'
    }));

    const { data: insertedChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .insert(chunkRecords)
      .select();

    if (chunksError) {
      throw new Error(`Failed to insert chunks: ${chunksError.message}`);
    }
    if (!insertedChunks || insertedChunks.length === 0) {
        throw new Error("No chunks were inserted into the database, though chunks were generated.");
    }
    console.log(`[PROCESSOR ${document.document_id}] Inserted ${insertedChunks.length} chunk records.`);

    // SAFER APPROACH: Process chunks in smaller batches for OpenAI embeddings
    const openAIbatchSize = 20;
    let usingMockEmbeddings = false;
    let embeddings: number[][] = [];

    console.log(`[PROCESSOR ${document.document_id}] Generating embeddings in batches of ${openAIbatchSize}.`);
    for (let i = 0; i < chunks.length; i += openAIbatchSize) {
      const batchChunksText = chunks.slice(i, i + openAIbatchSize);
      console.log(`[PROCESSOR ${document.document_id}] Processing OpenAI batch ${Math.floor(i/openAIbatchSize) + 1}/${Math.ceil(chunks.length/openAIbatchSize)} (${batchChunksText.length} chunks)`);

      try {
        const batchEmbeddings = await generateEmbeddings(batchChunksText);
        embeddings = [...embeddings, ...batchEmbeddings];
      } catch (embedError) {
        console.error(`[PROCESSOR ${document.document_id}] Error generating embeddings for batch, falling back to mock:`, embedError);
        usingMockEmbeddings = true;
        const mockBatchEmbeddings = batchChunksText.map(() => createMockEmbedding());
        embeddings = [...embeddings, ...mockBatchEmbeddings];

        await supabase
          .from('documents')
          .update({
            error_message: `Warning: Using mock embeddings for some chunks. OpenAI API error: ${embedError instanceof Error ? embedError.message : String(embedError)}`
          })
          .eq('document_id', document.document_id);
      }
      if (chunks.length > openAIbatchSize) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    console.log(`[PROCESSOR ${document.document_id}] Generated ${embeddings.length} embeddings. ${usingMockEmbeddings ? '(Used MOCK embeddings for some)' : '(Used REAL embeddings)'}`);

    // Build vectors array with an initial filter to remove nulls
    const preparedVectors = [];
    
    for (let i = 0; i < embeddings.length; i++) {
      const chunkId = insertedChunks[i]?.chunk_id;
      if (!chunkId) {
        console.error(`[PROCESSOR ${document.document_id}] Mismatch: No chunk_id for embedding at index ${i}. Skipping this vector.`);
        continue;
      }
      
      preparedVectors.push({
        id: chunkId,
        values: embeddings[i],
        metadata: {
          chatbotId: document.chatbot_id,
          documentId: document.document_id,
          chunkId: chunkId,
          text: chunks[i],
          fileName: document.file_name,
          fileType: document.file_type,
          isMockEmbedding: usingMockEmbeddings ? "true" : "false" // Use string to avoid type conflicts
        }
      });
    }

    if (preparedVectors.length === 0 && chunks.length > 0) {
        console.error(`[PROCESSOR ${document.document_id}] No vectors prepared for Pinecone, though chunks exist. This indicates an issue with chunk_id mapping.`);
        throw new Error("Failed to prepare vectors for Pinecone due to chunk ID mismatch.");
    }

    console.log(`[PROCESSOR ${document.document_id}] Prepared ${preparedVectors.length} vectors for Pinecone.`);

    let vectorsUpsertedSuccessfully = false;
    try {
      console.log(`[PROCESSOR ${document.document_id}] Upserting ${preparedVectors.length} vectors to Pinecone via SDK.`);
      await upsertVectors(preparedVectors);
      vectorsUpsertedSuccessfully = true;
      console.log(`[PROCESSOR ${document.document_id}] Successfully upserted vectors to Pinecone.`);
    } catch (pineconeError) {
        console.error(`[PROCESSOR ${document.document_id}] Error upserting vectors to Pinecone:`, pineconeError);
    }

    console.log(`[PROCESSOR ${document.document_id}] Updating chunk statuses in DB.`);
    for (const insertedChunk of insertedChunks) {
        const vectorAttempted = preparedVectors.find(v => v.id === insertedChunk.chunk_id);
        if (vectorAttempted) {
            await supabase
                .from('document_chunks')
                .update({
                    status: vectorsUpsertedSuccessfully ? 'embedded' : 'error',
                    embedding_id: vectorsUpsertedSuccessfully ? insertedChunk.chunk_id : null
                })
                .eq('chunk_id', insertedChunk.chunk_id);
        } else {
            await supabase
                .from('document_chunks')
                .update({ status: 'error' })
                .eq('chunk_id', insertedChunk.chunk_id);
        }
    }
    console.log(`[PROCESSOR ${document.document_id}] Chunk statuses updated.`);

    const finalDocStatus = vectorsUpsertedSuccessfully ? 'completed' : 'error';
    let finalErrorMessage = vectorsUpsertedSuccessfully ? null : 'Failed to upsert vectors to Pinecone.';
    if (usingMockEmbeddings && vectorsUpsertedSuccessfully) {
        finalErrorMessage = (finalErrorMessage ? finalErrorMessage + " " : "") + "Warning: Some or all embeddings are MOCK data.";
    }

    await supabase
      .from('documents')
      .update({
        status: finalDocStatus as DocumentStatus,
        error_message: finalErrorMessage,
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document final status set to ${finalDocStatus}. Processing finished.`);

  } catch (error) {
    console.error(`[PROCESSOR ${document.document_id}] Critical error during processing:`, error);
    await supabase
      .from('documents')
      .update({
        status: 'error' as DocumentStatus,
        error_message: error instanceof Error ? error.message : 'Unknown critical error during processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document status updated to ERROR due to critical failure.`);
  }
}// src/lib/document-processing/chunker.ts

/**
 * Split text into chunks of approximately the specified size with overlap
 * @param text The full text to split
 * @param maxChunkSize Maximum size of each chunk in characters
 * @param overlap Number of characters to overlap between chunks
 * @returns Array of text chunks
 */
export function splitTextIntoChunks(
  text: string,
  maxChunkSize: number = 1000,
  overlap: number = 200
): string[] {
  // Validate parameters
  if (maxChunkSize <= 0) {
    console.error("[CHUNKER] maxChunkSize must be positive. Using default 1000.");
    maxChunkSize = 1000;
  }
  if (overlap < 0) {
    console.error("[CHUNKER] overlap cannot be negative. Using default 0.");
    overlap = 0;
  }
  // Ensure overlap is less than maxChunkSize to guarantee progress
  if (overlap >= maxChunkSize) {
    console.warn(`[CHUNKER] Overlap (${overlap}) is greater than or equal to maxChunkSize (${maxChunkSize}). Adjusting overlap to ensure progress.`);
    overlap = Math.max(0, Math.floor(maxChunkSize / 2) -1); // Ensure it's strictly less
  }

  const cleanedText = text
    .replace(/\s+/g, " ") // Normalize whitespace
    .replace(/\n{2,}/g, "\n") // Reduce multiple newlines to single (or adjust if double is preferred)
    .trim();

  if (cleanedText.length === 0) {
    return [];
  }

  if (cleanedText.length <= maxChunkSize) {
    return [cleanedText];
  }

  const chunks: string[] = [];
  let startIndex = 0;
  let safetyBreak = 0; // To prevent accidental infinite loops during development
  const maxIterations = Math.ceil(cleanedText.length / (maxChunkSize - overlap)) + 10; // Generous estimate

  while (startIndex < cleanedText.length && safetyBreak < maxIterations) {
    safetyBreak++;
    let endIndex = Math.min(startIndex + maxChunkSize, cleanedText.length);

    // If not at the end, try to find a better breakpoint
    if (endIndex < cleanedText.length) {
      let idealEnd = endIndex;
      // Try to break at a paragraph end (double newline, now single due to cleaning)
      // Search backwards from idealEnd, but not too far back (e.g., within last 30% of chunk)
      const searchStartPara = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.3));
      const paragraphBreak = cleanedText.lastIndexOf("\n", idealEnd);
      if (paragraphBreak > searchStartPara && paragraphBreak > startIndex) {
        idealEnd = paragraphBreak + 1; // Include the newline
      } else {
        // Try to break at a sentence end (period followed by space)
        // Search backwards from idealEnd
        const searchStartSentence = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.2));
        const sentenceBreak = cleanedText.lastIndexOf(". ", idealEnd);
        if (sentenceBreak > searchStartSentence && sentenceBreak > startIndex) {
          idealEnd = sentenceBreak + 1; // Include the period
        } else {
          // Try to break at a space
          const searchStartSpace = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.1));
          const spaceBreak = cleanedText.lastIndexOf(" ", idealEnd);
          if (spaceBreak > searchStartSpace && spaceBreak > startIndex) {
            idealEnd = spaceBreak + 1; // Include the space
          }
          // If no good break found, stick with Math.min(startIndex + maxChunkSize, cleanedText.length)
        }
      }
      endIndex = idealEnd;
    }

    const chunk = cleanedText.substring(startIndex, endIndex).trim();
    if (chunk.length > 0) { // Only push non-empty chunks
      chunks.push(chunk);
    }

    // Calculate the next starting point
    // Ensure startIndex always moves forward by at least (maxChunkSize - overlap)
    // unless it's the last chunk
    const nextStart = endIndex - overlap;

    // If nextStart isn't advancing past the current startIndex, it means chunks are too small or overlap is too big
    // This check ensures progress. If endIndex is already at the end, this loop will terminate.
    if (nextStart <= startIndex && endIndex < cleanedText.length) {
        // Force advancement if stuck, this could happen if maxChunkSize is very small or overlap is almost maxChunkSize
        // Or if the breakpoint logic consistently brings endIndex back too far.
        // A simple forced advancement might be to just move past the current chunk with minimal overlap.
        console.warn(`[CHUNKER] Potential stall detected. Forcing startIndex advancement. startIndex: ${startIndex}, endIndex: ${endIndex}, overlap: ${overlap}, nextStart: ${nextStart}`);
        startIndex = endIndex; // Effectively makes next chunk start where this one ended (no overlap if stalled)
                              // Or, for a more robust solution with overlap:
                              // startIndex = Math.max(startIndex + 1, endIndex - overlap);
    } else {
        startIndex = nextStart;
    }

    if (startIndex < 0) startIndex = 0; // Should not happen with validated overlap
  }

  if (safetyBreak >= maxIterations) {
    console.error("[CHUNKER] Safety break triggered, possible infinite loop. Returning collected chunks.", chunks.length);
  }

  // Filter out any potential empty strings again, just in case
  return chunks.filter(c => c.length > 0);
}

/**
 * Simple estimate of token count based on character count
 * @param text The text to estimate tokens for
 * @returns Estimated token count
 */
export function estimateTokenCount(text: string): number {
  // Rough estimate: ~4 characters per token for English text
  return Math.ceil(text.length / 4);
}// src/lib/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export async function updateSession(request: NextRequest) {
  const response = NextResponse.next(); // Changed from let to const

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value,
            ...options, // Use the full options object
          });
        },
        remove(name: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value: '',
            ...options, // Use the full options object
            maxAge: 0,
          });
        },
      },
    }
  );

  await supabase.auth.getUser();

  return response;
}// src/lib/supabase/admin.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

export const createAdminClient = () => {
  // Log the environment variables to verify they exist (redact part of the key for security)
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';
  console.log('Admin client initialization:');
  console.log(`- URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL}`);
  console.log(`- Service key exists: ${serviceRoleKey.length > 0 ? 'YES' : 'NO'}`);
  
  return createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      },
      // These headers ensure the service role bypasses RLS
      global: {
        headers: {
          'X-Client-Info': 'admin-supabase-js',
          'Authorization': `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`
        }
      }
    }
  );
};// src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database.types';

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );// src/lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export const createServerSupabaseClient = async () => {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value,
            ...options
          });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value: '',
            ...options,
            maxAge: 0
          });
        },
      },
    }
  );
};// src/lib/safety/monitoring.ts
import type { Room, Database } from '@/types/database.types';
import { createAdminClient } from '@/lib/supabase/admin';
import { SupabaseClient } from '@supabase/supabase-js';
import { sendTeacherAlert } from '@/lib/safety/alerts';

// OpenRouter Configuration
const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const SAFETY_CHECK_MODEL = 'meta-llama/llama-4-scout';
const CONCERN_THRESHOLD = 3;

// Keywords organized by category - FULL LIST AS PROVIDED
const CONCERN_KEYWORDS: Record<string, string[]> = {
  self_harm: [
    'hate myself',
    'don\'t want to live',
    'don\'t want to be alive',
    'don\'t want to be here',
    'don\'t want to exist',
    'not worth going on',
    'no point in living',
    'no point going on',
    'rather be dead',
    'should end it',
    'should end it all',
    'end it all',
    'give up',
    'giving up',
    'take my own life',
    'take my life',
    'harming myself',
    'harm myself',
    'hurting myself',
    'cut myself',
    'cutting myself',
    'disappear forever',
    'everyone better off without me',
    'they\'d be better off without me',
    'they would be better off without me',
    'leave this world',
    'escape this world',
    'stop existing',
    'tired of being alive',
    'tired of existing',
    'too much pain',
    'can\'t take it anymore',
    'life is too hard',
    'life isn\'t worth it',
    'never wake up',
    'wish I wouldn\'t wake up',
    'make the pain stop',
    'no hope left',
    'nowhere to turn',
    'plan to kill',
    'how to end',
    'easier if I wasn\'t here',
    'easier if I was gone',
    'want to die',
    'wanna die',
    'kill myself',
    'suicidal'
  ],
  bullying: [
    'bullied', 'bully', 'bullying', 'they hate me', 'everyone hates me', 'laughed at me', 'laugh at me', 'excluded', 'leave me out', 'leaving me out', 'no friends', 'don\'t have friends', 'nobody likes me', 'no one likes me', 'call me names', 'called me names', 'push me around', 'pushed me', 'shove me', 'shoved me', 'making threats', 'threatened me', 'online bullying', 'cyberbullying', 'posting about me', 'spreading rumors', 'spreading rumours', 'spreading lies', 'everyone talks about me', 'made fun of', 'mock me', 'mocking me', 'rejected by everyone', 'being isolated', 'no one talks to me', 'nobody talks to me', 'they ignore me', 'everyone ignores me', 'being targeted', 'pick on me', 'won\'t leave me alone', 'always after me', 'ganging up on me', 'scared to go to school', 'don\'t want to go to school', 'afraid at school', 'scared at school'
  ],
  abuse: [
    'hurt me', 'hurting me', 'hitting me', 'hit by', 'kicks me', 'kicking me', 'pushed me', 'pushes me', 'throws things at me', 'threw things at me', 'threw something at me', 'yells at me', 'yelling at me', 'screams at me', 'screaming at me', 'threatens me', 'threatening me', 'controls me', 'controlling me', 'not allowed to', 'won\'t let me', 'keeps me from', 'locked me in', 'locks me in', 'touches me', 'touched me', 'uncomfortable touching', 'hurt by someone', 'afraid of them', 'afraid to go home', 'scared to go home', 'not safe at home', 'don\'t feel safe around', 'being punished', 'punishes me unfairly', 'treated badly', 'treats me badly', 'calls me stupid', 'calls me worthless', 'makes me feel worthless', 'makes me feel bad', 'punched me', 'punches me', 'slapped me', 'slaps me', 'bruises from', 'left bruises', 'threatened to hurt me if I told', 'can\'t tell anyone'
  ],
  depression: [
    'hate my life', 'no one cares', 'nobody cares', 'nobody loves me', 'no one loves me', 'feel empty', 'feeling empty', 'feel nothing', 'feels like nothing matters', 'nothing matters', 'what\'s the point', 'feel worthless', 'feeling worthless', 'don\'t feel anything', 'don\'t know what to do', 'can\'t see a future', 'lost all hope', 'lost hope', 'given up', 'feel like a failure', 'am a failure', 'everything is dark', 'darkness closing in', 'can\'t get out of bed', 'can\'t face the day', 'crying all the time', 'crying myself to sleep', 'never happy', 'always feeling down', 'feel so alone', 'completely alone', 'no one understands', 'nobody understands', 'don\'t enjoy anything', 'nothing makes me happy', 'too sad to function', 'too sad to do anything', 'life is meaningless', 'unable to feel joy', 'can\'t sleep', 'can\'t eat', 'can\'t concentrate', 'mind feels foggy', 'exhausted all the time', 'overwhelmed by sadness', 'drowning in sadness'
  ],
  family_issues: [
    'parents always fighting', 'parents always argue', 'parents hate each other', 'home is not safe', 'scared at home', 'afraid at home', 'can\'t stand being home', 'hate being home', 'nowhere to go', 'might get kicked out', 'might be kicked out', 'threatened to kick me out', 'parent drinking', 'parent drunk', 'parents drunk', 'drinking problem', 'drug problem', 'parents using drugs', 'parent using drugs', 'not enough food', 'going hungry', 'no food at home', 'can\'t sleep at home', 'parents separated', 'parents separating', 'parents broke up', 'parents splitting up', 'losing our house', 'lost our house', 'might be homeless', 'could be homeless', 'moving in with relatives', 'have to move', 'parent lost job', 'no money for', 'can\'t afford', 'parent in jail', 'parent arrested', 'no one takes care of me', 'have to take care of myself', 'have to take care of my siblings', 'parent is sick', 'parent is ill', 'parent in hospital', 'no electricity', 'utilities shut off', 'water shut off'
  ],
};

/**
 * First-pass check: Look for concerning keywords in a message.
 */
export function initialConcernCheck(message: string): {
  hasConcern: boolean;
  concernType?: string;
} {
  if (!message || typeof message !== 'string' || message.trim() === '') {
    return { hasConcern: false };
  }
  const lowerMessage = message.toLowerCase();

  for (const [category, keywords] of Object.entries(CONCERN_KEYWORDS)) {
    for (const keyword of keywords) {
        const escapedKeyword = keyword.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`\\b${escapedKeyword}\\b`); // Word boundary
        if (regex.test(lowerMessage)) {
            console.log(`[InitialCheck] Keyword MATCH! Category: ${category}, Keyword: "${keyword}"`);
            return { hasConcern: true, concernType: category };
        }
    }
  }

  // Your existing heuristics (can be expanded)
  if (lowerMessage.includes('hate myself') && (lowerMessage.includes('not worth') || lowerMessage.includes('don\'t know what to do'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  if ((lowerMessage.includes('not worth') || lowerMessage.includes('no point')) && (lowerMessage.includes('going on') || lowerMessage.includes('living') || lowerMessage.includes('anymore'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  // ... (add more heuristics as needed)

  return { hasConcern: false };
}

/**
 * Second-pass check: Use specified OpenRouter model to verify concern and rate severity.
 */
export async function verifyConcern(
  message: string,
  concernType: string,
  recentMessages: Array<{ role: 'user' | 'assistant' | 'system'; content: string }> = []
): Promise<{
  isRealConcern: boolean;
  concernLevel: number;
  analysisExplanation: string;
}> {
  let contextString = '';
  if (recentMessages.length > 0) {
    contextString = "\n\nRecent Conversation History (most recent last):\n";
    recentMessages.slice(-3).forEach(msg => {
      const roleLabel = msg.role === 'user' ? 'Student' : (msg.role === 'assistant' ? 'Assistant' : 'System');
      contextString += `${roleLabel}: ${msg.content}\n`;
    });
  }

  const promptForModel = `
You are an AI safety analyst reviewing a student's chat message for a specific concern.
Concern Category Identified by Keywords: ${concernType.replace(/_/g, ' ')}
${contextString}
Student's Message: "${message}"

Task:
1.  Determine if the student's message genuinely expresses the identified concern category. Distinguish real expressions of distress or risk from creative writing, hypothetical scenarios, or misinterpretations of keywords.
2.  If it is a genuine concern, assess its severity level on a scale of 0 to 5 (0=No Concern, 1=Very Low, 2=Low, 3=Moderate, 4=High, 5=Critical).
3.  Provide a brief (1-2 sentences) explanation for your assessment.

Respond ONLY with a valid JSON object with these exact keys:
"isRealConcern": boolean
"concernLevel": number (integer 0-5)
"analysisExplanation": string
`;

  try {
    const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
          'X-Title': 'ClassBots AI - Safety Verification',
        },
        body: JSON.stringify({
          model: SAFETY_CHECK_MODEL,
          messages: [ { role: "user", content: promptForModel } ],
          temperature: 0.2,
          max_tokens: 250,
          response_format: { type: "json_object" }
        }),
      });

    if (!response.ok) {
        const errorBody = await response.text();
        console.error(`[VerifyConcern] OpenRouter Error: Status ${response.status}`, errorBody);
        throw new Error(`OpenRouter API error (status ${response.status}) during safety verification.`);
    }

    const responseData = await response.json();
    const rawResponseContent = responseData.choices?.[0]?.message?.content;

    if (!rawResponseContent) {
      throw new Error("OpenRouter response for safety verification was empty or missing content.");
    }

    let analysisResult;
    try {
        const jsonMatch = rawResponseContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
            analysisResult = JSON.parse(jsonMatch[1]);
        } else {
            const directJsonMatch = rawResponseContent.match(/\{[\s\S]*\}/);
            if (directJsonMatch && directJsonMatch[0]) {
                 analysisResult = JSON.parse(directJsonMatch[0]);
            } else {
                throw new Error("No valid JSON found in LLM response for safety verification.");
            }
        }
    } catch (parseError) {
         console.error("[VerifyConcern] Failed to parse JSON from safety model:", rawResponseContent, parseError);
         return {
             isRealConcern: true, concernLevel: 3,
             analysisExplanation: `Safety model response was not valid JSON. Raw snippet: ${String(rawResponseContent).substring(0, 150)}... Review manually.`
         };
    }

    const isRealConcern = typeof analysisResult.isRealConcern === 'boolean' ? analysisResult.isRealConcern : false;
    const concernLevel = typeof analysisResult.concernLevel === 'number'
      ? Math.max(0, Math.min(5, Math.round(analysisResult.concernLevel)))
      : (isRealConcern ? 3 : 0);
    const analysisExplanation = typeof analysisResult.analysisExplanation === 'string'
      ? analysisResult.analysisExplanation.trim()
      : "AI analysis explanation was not provided or in an invalid format.";

    console.log(`[VerifyConcern] LLM Analysis: isReal=${isRealConcern}, level=${concernLevel}, explanation="${analysisExplanation}"`);
    return { isRealConcern, concernLevel, analysisExplanation };

  } catch (error) {
    console.error('[VerifyConcern] Error during OpenRouter call or processing:', error);
    return {
      isRealConcern: true, concernLevel: 3,
      analysisExplanation: `Concern verification process failed: ${error instanceof Error ? error.message : 'Unknown LLM call error'}. Flagged for manual review.`,
    };
  }
}


export async function checkMessageSafety(
    supabaseUserContextClient: SupabaseClient<Database>,
    messageContent: string,
    messageId: string,
    studentId: string,
    room: Room
): Promise<void> {
    console.log(`[Safety Check] START - MsgID: ${messageId}, Student: ${studentId}, Room: ${room.room_id}, Teacher: ${room.teacher_id}`);
    try {
        const adminClient = createAdminClient();
        const { data: currentMessageData, error: fetchMsgError } = await supabaseUserContextClient
            .from('chat_messages')
            .select('created_at, metadata')
            .eq('message_id', messageId)
            .single();

        if (fetchMsgError || !currentMessageData) {
             console.error(`[Safety Check] Failed to fetch current message ${messageId}:`, fetchMsgError);
             return;
        }

        const { hasConcern, concernType } = initialConcernCheck(messageContent);
        console.log(`[Safety Check] Initial Keyword Check: hasConcern=${hasConcern}, concernType=${concernType || 'N/A'}`);

        if (hasConcern && concernType) {
            const chatbotIdForContext = currentMessageData.metadata?.chatbotId || null;
            const { data: contextMessagesData } = await adminClient
                .from('chat_messages')
                .select('role, content')
                .eq('room_id', room.room_id)
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', chatbotIdForContext ? 'eq' : 'is', chatbotIdForContext)
                .lt('created_at', currentMessageData.created_at)
                .order('created_at', { ascending: false })
                .limit(4);
            const recentMessagesForSafetyLLM = (contextMessagesData || [])
                .map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }))
                .reverse();
            const { isRealConcern, concernLevel, analysisExplanation } = await verifyConcern(messageContent, concernType, recentMessagesForSafetyLLM);

            if (isRealConcern && concernLevel >= CONCERN_THRESHOLD) {
                const { data: teacherProfile } = await adminClient.from('profiles').select('email').eq('user_id', room.teacher_id).single();
                const { data: studentProfile } = await adminClient.from('profiles').select('full_name').eq('user_id', studentId).single();
                const studentName = studentProfile?.full_name || `Student (ID: ${studentId.substring(0, 6)}...)`;
                const { data: insertedFlag, error: flagInsertError } = await adminClient.from('flagged_messages').insert({
                    message_id: messageId, student_id: studentId, teacher_id: room.teacher_id,
                    room_id: room.room_id, concern_type: concernType, concern_level: concernLevel,
                    analysis_explanation: analysisExplanation, status: 'pending',
                }).select('flag_id').single();

                if (flagInsertError) { console.error(`[Safety Check] FAILED to insert flag:`, flagInsertError.message); return; }
                
                const newFlagId = insertedFlag!.flag_id; // Assert not null after error check
                console.log(`[Safety Check] Flag ${newFlagId} inserted for message ${messageId}.`);
                if (teacherProfile?.email) {
                    const viewUrl = `${process.env.NEXT_PUBLIC_APP_URL}/teacher-dashboard/concerns/${newFlagId}`;
                    await sendTeacherAlert(teacherProfile.email,studentName,room.room_name || `Room (ID: ${room.room_id.substring(0,6)})`,concernType,concernLevel,messageContent,viewUrl);
                } else { console.warn(`[Safety Check] Teacher email for ${room.teacher_id} not found. Cannot send alert for flag ${newFlagId}.`);}
            } else { console.log(`[Safety Check] Concern level ${concernLevel} < threshold ${CONCERN_THRESHOLD} or not real.`); }
        } else { console.log(`[Safety Check] No initial concern for message ${messageId}.`); }
    } catch (error) { console.error(`[Safety Check] CRITICAL ERROR for msg ${messageId}:`, error); }
    console.log(`[Safety Check] END - Checked message ID: ${messageId}`);
}// src/lib/safety/alerts.ts - Replace the existing function
import { sendEmail } from '@/lib/email/resend';  // Import the new function
import { APP_NAME } from '@/lib/utils/constants';

// Keep helper functions the same
export function getConcernTypeDisplayName(type: string): string {
  if (!type) return 'Unknown Concern';
  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

export function getConcernLevelDisplayName(level: number): string {
  if (level >= 5) return 'Critical';
  if (level >= 4) return 'High';
  if (level >= 3) return 'Significant';
  if (level >= 2) return 'Moderate';
  if (level >= 1) return 'Minor';
  return 'Low';
}

export async function sendTeacherAlert(
  teacherEmail: string,
  studentName: string,
  roomName: string,
  concernType: string,
  concernLevel: number,
  messageContent: string,
  viewUrl: string
): Promise<boolean> {
  // Basic validation
  if (!teacherEmail || !studentName || !roomName || !concernType || concernLevel < 0 || !messageContent || !viewUrl) {
    console.error('Missing required information for sending teacher alert');
    return false;
  }

  // Generate email content
  const concernTypeName = getConcernTypeDisplayName(concernType);
  const concernLevelName = getConcernLevelDisplayName(concernLevel);
  const subject = `[${APP_NAME}] ${concernLevelName} ${concernTypeName} Alert for Student: ${studentName}`;
  const displayedMessage = messageContent.replace(/</g, "&lt;").replace(/>/g, "&gt;");

  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        h2 { color: #6B50B7; }
        h3 { color: #4A3889; }
        ul { list-style: none; padding: 0; }
        li { margin-bottom: 5px; }
        strong { font-weight: bold; }
        blockquote {
          border-left: 4px solid #E5E7EB;
          padding-left: 15px;
          margin-left: 0;
          color: #555;
          background-color: #F9FAFB;
          padding: 10px;
        }
        a.button {
          display: inline-block;
          padding: 12px 24px;
          background-color: #6B50B7;
          color: white !important;
          text-decoration: none;
          border-radius: 6px;
          font-weight: bold;
          text-align: center;
        }
         a.button:hover {
             background-color: #4A3889;
         }
      </style>
    </head>
    <body>
      <h2>${APP_NAME} - Student Welfare Alert</h2>
      <p>A message from a student in one of your classrooms has been automatically flagged for a potential welfare concern based on its content.</p>
      <p>Please review the details below and the conversation context as soon as possible.</p>

      <h3>Alert Details:</h3>
      <ul>
        <li><strong>Student:</strong> ${studentName}</li>
        <li><strong>Classroom:</strong> ${roomName}</li>
        <li><strong>Concern Type:</strong> ${concernTypeName}</li>
        <li><strong>Assessed Level:</strong> ${concernLevelName} (Level ${concernLevel})</li>
        <li><strong>Time Detected:</strong> ${new Date().toLocaleString()}</li>
      </ul>

      <h3>Flagged Message:</h3>
      <blockquote>
        <p>${displayedMessage}</p>
      </blockquote>

      <p>Click the button below to view the full conversation context and manage this alert:</p>
      <p style="text-align: center;">
        <a href="${viewUrl}" class="button">Review Concern Now</a>
      </p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
      <p style="font-size: 0.9em; color: #777;">This is an automated message from ${APP_NAME}. Please do not reply directly to this email.</p>
    </body>
    </html>
  `;

  // Use the Resend API to send the email
  return await sendEmail(
    teacherEmail,
    subject,
    html,
    `${APP_NAME} Safety`
  );
}// src/lib/pinecone/utils.ts
import { index, pinecone } from './client';
import { RecordMetadata } from '@pinecone-database/pinecone';

interface ChunkMetadata extends RecordMetadata {
  chatbotId: string;
  documentId: string;
  chunkId: string;
  text: string;
  fileName: string;
  fileType: string;
}

/**
 * Upsert vectors into Pinecone with enhanced error handling
 * @param vectors Array of vectors with their IDs and metadata
 */
export async function upsertVectors(
  vectors: { 
    id: string, 
    values: number[], 
    metadata: ChunkMetadata 
  }[]
) {
  // Validate that Pinecone is initialized
  if (!index || !pinecone) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    throw new Error('Pinecone client not initialized. Check API key and environment variables.');
  }

  try {
    // Use a smaller batch size to avoid timeouts
    const batchSize = 25; // Reduced from 50 to 25
    
    console.log(`Upserting ${vectors.length} vectors in batches of ${batchSize}`);
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      try {
        // Add retries for resilience
        let retries = 0;
        const maxRetries = 3;
        let success = false;
        
        while (!success && retries < maxRetries) {
          try {
            await index.upsert(batch);
            success = true;
            console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
          } catch (retryError) {
            retries++;
            console.warn(`Retry ${retries}/${maxRetries} failed:`, retryError);
            
            // Print detailed error information
            if (retryError instanceof Error) {
              console.warn('Error message:', retryError.message);
              
              // Log the first part of HTML responses for debugging
              if (retryError.message.includes('<!DOCTYPE')) {
                const htmlStart = retryError.message.substring(0, 200);
                console.warn('HTML error detected in response:', htmlStart);
                
                // Check for specific error signatures
                if (retryError.message.includes('401') || 
                    retryError.message.includes('unauthorized') || 
                    retryError.message.includes('authentication')) {
                  console.error('AUTHENTICATION ERROR: Check your Pinecone API key');
                }
              }
            }
            
            if (retries < maxRetries) {
              // Exponential backoff: 1s, 2s, 4s, etc.
              const delay = Math.pow(2, retries) * 1000;
              console.log(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        if (!success) {
          throw new Error(`Failed to upsert batch after ${maxRetries} retries`);
        }
      } catch (batchError) {
        console.error(`Error upserting batch ${Math.floor(i/batchSize) + 1}:`, batchError);
        
        // Try upserting one by one as a fallback with additional retry logic
        console.log("Trying to upsert vectors one by one...");
        for (const vector of batch) {
          try {
            let individualRetries = 0;
            const maxIndividualRetries = 2;
            
            while (individualRetries < maxIndividualRetries) {
              try {
                await index.upsert([vector]);
                break; // Success, exit retry loop
              } catch (singleRetryError) {
                individualRetries++;
                console.warn(`Individual vector retry ${individualRetries}/${maxIndividualRetries} failed:`, singleRetryError);
                
                if (individualRetries >= maxIndividualRetries) {
                  console.error(`Failed to upsert vector ${vector.id} after ${maxIndividualRetries} retries`);
                } else {
                  // Wait before retry
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }
            }
          } catch (singleError) {
            console.error(`Failed to upsert vector ${vector.id}:`, singleError);
          }
        }
      }
      
      // Add a slightly longer delay between batches to avoid rate limits
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log(`Completed upserting vectors to Pinecone`);
    return true;
  } catch (error) {
    console.error('Error in upsertVectors:', error);
    
    // Provide more detailed error information
    if (error instanceof Error) {
      if (error.message.includes('<!DOCTYPE')) {
        console.error('Received HTML response instead of JSON. This typically indicates:');
        console.error('1. Authentication failure (check your API key)');
        console.error('2. Network proxy interference');
        console.error('3. Service endpoint issues');
        
        // Extract status code if present in HTML
        const statusMatch = error.message.match(/<title>(\d+)[^<]*<\/title>/);
        if (statusMatch && statusMatch[1]) {
          console.error(`Status code found in HTML: ${statusMatch[1]}`);
        }
      }
    }
    
    throw new Error(`Failed to upsert vectors: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Rest of the functions remain the same...

export async function queryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return [];
  }

  try {
    const results = await index.query({
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    
    return results.matches;
  } catch (error) {
    console.error('Error querying vectors:', error);
    return []; // Return empty array instead of throwing
  }
}

export async function deleteDocumentVectors(documentId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        documentId: { $eq: documentId }
      }
    });
    console.log(`Successfully deleted vectors for document ${documentId}`);
  } catch (error) {
    console.error('Error deleting vectors:', error);
    throw new Error('Failed to delete vectors');
  }
}

export async function deleteChatbotVectors(chatbotId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    console.log(`Successfully deleted all vectors for chatbot ${chatbotId}`);
  } catch (error) {
    console.error('Error deleting chatbot vectors:', error);
    throw new Error('Failed to delete chatbot vectors');
  }
}// src/lib/pinecone/direct-api.ts
/**
 * This file implements direct fetch-based API calls to Pinecone
 * to bypass any issues with the Pinecone SDK
 */

// Use node-fetch for compatibility
import fetch from 'node-fetch';

interface PineconeVector {
  id: string;
  values: number[];
  metadata?: Record<string, unknown>;
}

interface PineconeResponse {
  status: number;
  statusText: string;
  data?: unknown;
  error?: string;
}

// Add specific interface for query response
interface PineconeQueryResponse extends PineconeResponse {
  data?: {
    matches?: Array<{
      id: string;
      score: number;
      metadata: Record<string, unknown>;
    }>;
  };
}

/**
 * Make a direct API call to Pinecone with detailed logging
 */
async function callPineconeAPI(
  endpoint: string,
  method: 'GET' | 'POST' | 'DELETE' = 'GET',
  body?: unknown
): Promise<PineconeResponse> {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is missing');
    return {
      status: 401,
      statusText: 'Unauthorized',
      error: 'API key is missing'
    };
  }
  
  const url = `https://api.pinecone.io/v1/indexes/${indexName}${endpoint}`;
  
  console.log(`Making ${method} request to Pinecone: ${url}`);
  
  try {
    // Make the API call with fetch
    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': apiKey
      },
      body: body ? JSON.stringify(body) : undefined
    });
    
    console.log(`Pinecone API response status: ${response.status} ${response.statusText}`);
    
    // Handle non-JSON responses
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      return {
        status: response.status,
        statusText: response.statusText,
        data
      };
    } else {
      // Handle HTML or other non-JSON responses
      const text = await response.text();
      console.error('Received non-JSON response from Pinecone:');
      console.error(`Status: ${response.status} ${response.statusText}`);
      console.error(`Content-Type: ${contentType}`);
      console.error(`Response (first 200 chars): ${text.substring(0, 200)}`);
      
      if (text.includes('<!DOCTYPE')) {
        // Parse out any error message from HTML
        const titleMatch = text.match(/<title>([^<]+)<\/title>/);
        const messageMatch = text.match(/<p>([^<]+)<\/p>/);
        
        const errorTitle = titleMatch ? titleMatch[1] : 'Unknown error';
        const errorMessage = messageMatch ? messageMatch[1] : text.substring(0, 100);
        
        return {
          status: response.status,
          statusText: response.statusText,
          error: `HTML response: ${errorTitle} - ${errorMessage}`
        };
      }
      
      return {
        status: response.status,
        statusText: response.statusText,
        error: `Non-JSON response: ${text.substring(0, 100)}`
      };
    }
  } catch (error) {
    console.error('Error making Pinecone API call:', error);
    return {
      status: 500,
      statusText: 'Internal Error',
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * Upsert vectors directly to Pinecone
 */
export async function directUpsertVectors(vectors: PineconeVector[]): Promise<boolean> {
  try {
    // Split vectors into smaller batches
    const batchSize = 20;
    let allSuccessful = true;
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      const result = await callPineconeAPI('/vectors/upsert', 'POST', {
        vectors: batch
      });
      
      if (result.status >= 400 || result.error) {
        console.error(`Error upserting batch: ${result.error || result.statusText}`);
        allSuccessful = false;
        
        // Try single vector upserts as fallback
        console.log('Attempting individual vector upserts as fallback...');
        
        for (const vector of batch) {
          const singleResult = await callPineconeAPI('/vectors/upsert', 'POST', {
            vectors: [vector]
          });
          
          if (singleResult.status >= 400 || singleResult.error) {
            console.error(`Failed to upsert vector ${vector.id}: ${singleResult.error || singleResult.statusText}`);
          } else {
            console.log(`Successfully upserted vector ${vector.id}`);
          }
        }
      } else {
        console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
      }
      
      // Add a delay between batches
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    return allSuccessful;
  } catch (error) {
    console.error('Error in directUpsertVectors:', error);
    return false;
  }
}

/**
 * Query vectors directly from Pinecone
 */
export async function directQueryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  try {
    // Query vectors directly from Pinecone
    const result = await callPineconeAPI('/query', 'POST', {
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    }) as PineconeQueryResponse;
    
    if (result.status >= 400 || result.error) {
      console.error(`Error querying vectors: ${result.error || result.statusText}`);
      return [];
    }
    
    // Now TypeScript knows that result.data?.matches exists
    return result.data?.matches || [];
  } catch (error) {
    console.error('Error in directQueryVectors:', error);
    return [];
  }
}

/**
 * Delete vectors for a specific document directly from Pinecone
 */
export async function directDeleteDocumentVectors(documentId: string): Promise<boolean> {
  try {
    const result = await callPineconeAPI('/vectors/delete', 'POST', {
      filter: {
        documentId: { $eq: documentId }
      }
    });
    
    if (result.status >= 400 || result.error) {
      console.error(`Error deleting document vectors: ${result.error || result.statusText}`);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in directDeleteDocumentVectors:', error);
    return false;
  }
}

/**
 * Check Pinecone API connectivity and report detailed status
 */
export async function checkPineconeStatus(): Promise<{
  isConnected: boolean;
  details: string;
  stats?: unknown;
}> {
  try {
    const result = await callPineconeAPI('/describe_index_stats');
    
    if (result.status >= 400 || result.error) {
      return {
        isConnected: false,
        details: result.error || `API error: ${result.status} ${result.statusText}`
      };
    }
    
    return {
      isConnected: true,
      details: 'Successfully connected to Pinecone',
      stats: result.data
    };
  } catch (error) {
    return {
      isConnected: false,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}// src/lib/pinecone/client.ts
import { Pinecone } from '@pinecone-database/pinecone';

// More robust way to check environment variables
const getPineconeConfig = () => {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is not defined in environment variables');
  }
  
  console.log("Pinecone Configuration:");
  console.log(`- API Key exists: ${!!apiKey}`);
  console.log(`- Index Name: ${indexName}`);
  
  return { apiKey, indexName };
};

// Create client with proper error handling
let pineconeClient: Pinecone | null = null;
let indexClient: ReturnType<Pinecone['index']> | null = null;

try {
  const { apiKey, indexName } = getPineconeConfig();
  
  if (apiKey) {
    pineconeClient = new Pinecone({
      apiKey,
    });
    
    // Get the index for our embeddings
    indexClient = pineconeClient.index(indexName);
    console.log("Pinecone client initialized successfully");
  } else {
    console.error("Failed to initialize Pinecone client: Missing API key");
  }
} catch (error) {
  console.error("Error initializing Pinecone client:", error);
}

export const pinecone = pineconeClient;
export const index = indexClient;// src/lib/StyledComponentsRegistry.tsx
'use client';

import { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { ServerStyleSheet, StyleSheetManager } from 'styled-components';

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  // Only create stylesheet once with lazy initial state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== 'undefined') return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}// src/lib/email/resend.ts
import { Resend } from 'resend';

const resendApiKey = process.env.SMTP_PASSWORD || '';  // Reuse your existing API key
const resend = new Resend(resendApiKey);

export async function sendEmail(
  to: string,
  subject: string,
  html: string,
  fromName: string = 'ClassBots Safety',
  fromEmail: string = 'onboarding@resend.dev'
): Promise<boolean> {
  try {
    console.log(`Sending email via Resend API to ${to}`);
    
    const { data, error } = await resend.emails.send({
      from: `${fromName} <${fromEmail}>`,
      to: to,
      subject: subject,
      html: html,
    });
    
    if (error) {
      console.error('Resend API Error:', error);
      return false;
    }
    
    console.log('Email sent successfully with Resend API', data);
    return true;
  } catch (error) {
    console.error('Error sending email with Resend API:', error);
    return false;
  }
}// src/lib/openai/embeddings.ts
import openai from './client';

/**
 * Generate embeddings for a text using OpenAI's embedding model
 * @param text The text to generate embeddings for
 * @returns An array of floating point numbers representing the embedding
 */
export async function generateEmbedding(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
      encoding_format: "float",
    });

    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embedding:', error);
    throw new Error('Failed to generate embedding');
  }
}

/**
 * Generate embeddings for multiple texts in a batch
 * @param texts Array of texts to generate embeddings for
 * @returns Array of embedding arrays
 */
export async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: texts,
      encoding_format: "float",
    });

    return response.data.map(item => item.embedding);
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw new Error('Failed to generate embeddings');
  }
}// src/lib/openai/client.ts
import { OpenAI } from 'openai';

// Initialize the OpenAI client with API key from environment variables
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default openai;