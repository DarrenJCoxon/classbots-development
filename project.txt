// src/types/student.types.ts - Add this new file
import { Room, Chatbot } from './database.types';

export interface StudentRoom extends Room {
  joined_at: string;
  chatbots: Chatbot[];
}// src/types/knowledge-base.types.ts
export type DocumentType = 'pdf' | 'docx' | 'txt' | 'webpage'; // MODIFIED: Added 'webpage'

export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error' | 'fetched'; // MODIFIED: Added 'fetched' for URLs

export type ChunkStatus = 'pending' | 'embedded' | 'error';

export interface Document {
  document_id: string;
  chatbot_id: string;
  file_name: string; // For webpages, this might be the <title> or a truncated URL
  file_path: string; // For webpages, this will be the original URL
  file_type: DocumentType;
  file_size: number; // For webpages, this could be the size of the extracted text
  status: DocumentStatus;
  error_message?: string;
  created_at: string;
  updated_at: string;
}

export interface DocumentChunk {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
  created_at: string;
}

export interface DocumentUploadResponse {
  document: Document;
  uploadUrl?: string; // This might not be relevant for URLs
}

export interface ProcessingStats {
  totalChunks: number;
  processedChunks: number;
  errorChunks: number;
}// src/types/pdf-parse.d.ts
declare module 'pdf-parse';
declare module 'pdf-parse/lib/pdf-parse.js';
declare module 'mammoth';// src/types/database.types.ts

// Base common fields for all tables
export interface BaseTable {
  created_at: string;
  updated_at?: string;
}

// User roles enum
export type UserRole = 'teacher' | 'student' | 'school_admin';

// Concern status enum/type
export type ConcernStatus = 'pending' | 'reviewing' | 'resolved' | 'false_positive';

// Knowledge Base Types
export type DocumentType = 'pdf' | 'docx' | 'txt' | 'webpage'; // MODIFIED: Added 'webpage'
export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error' | 'fetched'; // MODIFIED: Added 'fetched'
export type ChunkStatus = 'pending' | 'embedded' | 'error';

// Bot Type Enum
export type BotTypeEnum = 'learning' | 'assessment';

// Assessment Status Enum
export type AssessmentStatusEnum = 'ai_processing' | 'ai_completed' | 'teacher_reviewed';


// --- Table Interfaces ---

export interface School extends BaseTable {
  school_id: string;
  name: string;
  magic_link_token?: string;
  token_expires_at?: string;
}

export interface Chatbot extends BaseTable {
  chatbot_id: string;
  name: string;
  description?: string;
  system_prompt: string;
  teacher_id: string;
  model?: string;
  max_tokens?: number | null;
  temperature?: number | null;
  enable_rag?: boolean;
  bot_type?: BotTypeEnum;
  assessment_criteria_text?: string | null;
  welcome_message?: string | null; // <-- ADDED (This was already correct in your original file)
}

export interface Room extends BaseTable {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id?: string | null;
  is_active: boolean;
  is_archived?: boolean;
}

export interface RoomChatbot extends BaseTable {
  room_id: string;
  chatbot_id: string;
}

export interface RoomMembership extends BaseTable {
  room_id: string;
  student_id: string;
  joined_at: string;
  is_archived?: boolean;
}

export interface ChatMessage extends BaseTable {
    message_id: string;
    room_id: string;
    user_id: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    tokens_used?: number;
    metadata?: {
        chatbotId?: string | null;
        error?: unknown;
        isAssessmentFeedback?: boolean;
        isAssessmentPlaceholder?: boolean;
        assessmentId?: string | null;
        isWelcomeMessage?: boolean; // <-- ADDED (Optional, for client-side identification) (This was already correct in your original file)
        [key: string]: unknown;
    } | null;
}

export interface Profile extends BaseTable {
  user_id: string;
  full_name?: string;
  email: string;
  role: UserRole;
  school_id?: string | null;
  country_code?: string | null;
  pin_code?: string | null; // PIN code for student login
  username?: string | null; // Username for student login
  last_pin_change?: string | null; // When PIN was last changed
  pin_change_by?: string | null; // Who changed the PIN
}

// THIS IS THE Document INTERFACE WITHIN database.types.ts
export interface Document extends BaseTable {
  document_id: string;
  chatbot_id: string;
  file_name: string;
  file_path: string;
  file_type: DocumentType; // This now correctly uses the MODIFIED DocumentType above
  file_size: number;
  status: DocumentStatus;  // This now correctly uses the MODIFIED DocumentStatus above
  error_message?: string;
}

export interface DocumentChunk extends BaseTable {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
}

export interface FlaggedMessage extends BaseTable {
  flag_id: string;
  message_id: string;
  student_id: string;
  teacher_id: string;
  room_id: string;
  concern_type: string;
  concern_level: number;
  analysis_explanation?: string;
  context_messages?: Record<string, unknown>;
  status: ConcernStatus;
  reviewed_at?: string;
  reviewer_id?: string | null;
  notes?: string;
}

export interface StudentAssessment extends BaseTable {
    assessment_id: string;
    student_id: string;
    chatbot_id: string;
    room_id: string;
    assessed_message_ids?: string[];
    teacher_id?: string | null;
    teacher_assessment_criteria_snapshot?: string | null;
    ai_feedback_student?: string | null;
    ai_assessment_details_raw?: string | null;
    ai_grade_raw?: string | null;
    ai_assessment_details_teacher?: {
        summary?: string;
        strengths?: string[];
        areas_for_improvement?: string[];
        grading_rationale?: string;
        [key: string]: unknown;
    } | null;
    teacher_override_grade?: string | null;
    teacher_override_notes?: string | null;
    status?: AssessmentStatusEnum;
    assessed_at: string;
}


// --- Database Schema Type ---
export interface Database {
  schools: School;
  profiles: Profile;
  chatbots: Chatbot;
  rooms: Room;
  room_chatbots: RoomChatbot;
  room_memberships: RoomMembership;
  chat_messages: ChatMessage;
  documents: Document; // This now refers to the locally defined Document interface
  document_chunks: DocumentChunk;
  flagged_messages: FlaggedMessage;
  student_assessments: StudentAssessment;
}

// --- API Payload Types ---
export interface CreateSchoolPayload {
  name: string;
}

export interface CreateChatbotPayload {
  name: string;
  description?: string;
  system_prompt: string;
  model?: string;
  max_tokens?: number | null;
  temperature?: number | null;
  enable_rag?: boolean;
  bot_type?: BotTypeEnum;
  assessment_criteria_text?: string | null;
  welcome_message?: string | null; // <-- ADDED (This was already correct in your original file)
}

export interface CreateRoomPayload {
  room_name: string;
  chatbot_ids: string[];
}

export interface UpdateRoomChatbotsPayload {
  chatbot_ids: string[];
}

export interface JoinRoomPayload {
  room_code: string;
}

export interface SendMessagePayload {
  content: string;
  room_id: string;
  chatbot_id: string;
}

// Payload for updating an assessment (teacher review)
export interface UpdateAssessmentPayload {
    teacher_override_grade?: string | null;
    teacher_override_notes?: string | null;
    status?: AssessmentStatusEnum;
}


// --- API Response Detail Types ---

export interface FlaggedConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

export interface StudentRoom extends Room {
  joined_at: string;
  // Chatbot here now includes welcome_message if you want student dashboard to access it
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'description' | 'bot_type' | 'welcome_message'>[];
}

export interface TeacherRoom extends Room {
   room_chatbots: {
       // Chatbot here could also include welcome_message if teacher room overview needs it
       chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type' | 'welcome_message'> | null;
   }[] | null;
}

// For single student assessment detail API
export interface DetailedAssessmentResponse extends StudentAssessment {
    student_name?: string | null;
    student_email?: string | null;
    chatbot_name?: string | null;
    assessed_conversation?: ChatMessage[];
}

// For the list of assessments for a teacher
export interface AssessmentListSummary extends Pick<
    StudentAssessment,
    'assessment_id' | 'student_id' | 'chatbot_id' | 'room_id' | 'teacher_id' |
    'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'
> {
    student_name?: string | null;
    chatbot_name?: string | null;
    room_name?: string | null;
}

// For the paginated response of assessment lists
export interface PaginatedAssessmentsResponse {
    assessments: AssessmentListSummary[];
    pagination: {
        currentPage: number;
        pageSize: number;
        totalCount: number;
        totalPages: number;
    };
}// src/types/auth.types.ts
import { User, Session } from '@supabase/supabase-js';
import { UserRole } from './database.types';

export interface AuthUser extends User {
  role?: UserRole;
  school_id?: string;
}

export interface AuthSession extends Session {
  user: AuthUser;
}

export interface SignUpData {
  email: string;
  password: string;
  fullName?: string;
  role: UserRole;
  schoolId?: string;
}

export interface SignInData {
  email: string;
  password: string;
}

export interface MagicLinkData {
  email: string;
  schoolId: string;
}// src/types/chatbot.types.ts
import type { ChatMessage as DatabaseChatMessage } from './database.types'; // Import the corrected type

// ChatMessage is now imported and used as DatabaseChatMessage or aliased if needed.
// REMOVE the old definition:
// export interface ChatMessage { ... }

export interface ChatbotConfig {
  name: string;
  description?: string;
  systemPrompt: string;
  model?: 'x-ai/grok-3-mini-beta' | 'qwen/qwen3-235b-a22b' | 'google/gemini-2.5-flash-preview' | 'openai/gpt-4.1-nano'; // MODIFIED
  maxTokens?: number;
  temperature?: number;
}

export interface ChatContext {
  chatbotId: string;
  roomId: string;
  systemPrompt: string;
  conversationHistory: DatabaseChatMessage[]; // Use the imported type
}

export interface ChatResponse {
  message: string;
  tokensUsed?: number;
  error?: string;
}'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import Chat from '@/components/shared/Chat';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { Chatbot, BotTypeEnum } from '@/types/database.types';

const PageWrapper = styled.div`
  min-height: 100vh;
  padding: 1rem 0;
`;

const Title = styled.h1`
  font-size: 2rem;
  color: ${({ theme }) => theme.colors.primary};
  margin-bottom: 1.5rem;
`;

const ChatContainer = styled(Card)`
  height: 80vh;
  margin-bottom: 1.5rem;
  padding: 0;
  overflow: hidden;
  display: flex;
  flex-direction: column;
`;

const HeaderBar = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  
  @media (max-width: 768px) {
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }
`;

const UserInfo = styled.div`
  background: ${({ theme }) => theme.colors.backgroundDark};
  padding: 0.5rem 1rem;
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  display: inline-block;
  
  span {
    font-weight: bold;
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 70vh;
  gap: 2rem;
`;

export default function DirectRoomAccess() {
  const params = useParams();
  const searchParams = useSearchParams();
  const router = useRouter();
  const supabase = createClient();
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  interface Room {
    room_id: string;
    room_name: string;
    room_code: string;
  }
  
  interface Student {
    user_id: string;
    full_name: string;
    email: string;
    role: string;
  }
  
  // Use the imported types
  
  const [room, setRoom] = useState<Room | null>(null);
  const [student, setStudent] = useState<Student | null>(null);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [selectedChatbot, setSelectedChatbot] = useState<string | null>(null);
  
  const roomId = params.roomId as string;
  // Ensure studentId is a string or undefined, not null
  const studentId = searchParams.get('student_id') || localStorage.getItem('student_direct_access_id') || undefined;
  
  // Check access on load
  useEffect(() => {
    const verifyAccess = async () => {
      if (!studentId) {
        setError('Student ID not provided. Please login again.');
        setLoading(false);
        return;
      }
      
      try {
        // First, check if the student exists
        const { data: studentData, error: studentError } = await supabase
          .from('profiles')
          .select('user_id, full_name, email, role')
          .eq('user_id', studentId)
          .single();
          
        if (studentError || !studentData) {
          throw new Error('Student not found');
        }
        
        if (studentData.role !== 'student') {
          throw new Error('User is not a student');
        }
        
        setStudent(studentData);
        
        // Verify room membership
        const { data: membershipData, error: membershipError } = await supabase
          .from('room_memberships')
          .select('room_id')
          .eq('student_id', studentId)
          .eq('room_id', roomId)
          .single();
          
        if (membershipError || !membershipData) {
          throw new Error('You are not a member of this room');
        }
        
        // Get room details
        const { data: roomData, error: roomError } = await supabase
          .from('rooms')
          .select('room_id, room_name, room_code')
          .eq('room_id', roomId)
          .single();
          
        if (roomError || !roomData) {
          throw new Error('Room not found');
        }
        
        setRoom(roomData);
        
        // Get available chatbots in room
        const { data: chatbotData } = await supabase
          .from('room_chatbots')
          .select(`
            chatbots (
              chatbot_id,
              name,
              description,
              bot_type
            )
          `)
          .eq('room_id', roomId);
        // chatbotError removed as it was unused
          
        if (chatbotData) {
          // Process chatbots with proper typing
          const availableChatbots: Chatbot[] = [];
          
          // Process each item safely
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          chatbotData.forEach((item: any) => {
            if (item && item.chatbots) {
              availableChatbots.push({
                chatbot_id: item.chatbots.chatbot_id || '',
                name: item.chatbots.name || 'Unnamed Bot',
                description: item.chatbots.description || '',
                system_prompt: item.chatbots.system_prompt || 'You are a helpful assistant.',
                teacher_id: item.chatbots.teacher_id || 'system',
                created_at: item.chatbots.created_at || new Date().toISOString(),
                bot_type: (item.chatbots.bot_type || 'learning') as BotTypeEnum
              });
            }
          });
            
          // Set chatbots with properly typed array
          setChatbots(availableChatbots as Chatbot[]);
          
          // Select the first chatbot by default
          if (availableChatbots.length > 0) {
            setSelectedChatbot(availableChatbots[0].chatbot_id);
          }
        }
        
      } catch (err) {
        console.error('Error verifying access:', err);
        setError(err instanceof Error ? err.message : 'Failed to verify access');
      } finally {
        setLoading(false);
      }
    };
    
    verifyAccess();
  }, [roomId, studentId, supabase]);
  
  const handleBackToRooms = () => {
    router.push('/student-access');
  };
  
  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" />
            <p>Loading room...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }
  
  if (error || !room || !student) {
    return (
      <PageWrapper>
        <Container>
          <Card>
            <Title>Error</Title>
            <Alert variant="error">{error || 'Could not access this room'}</Alert>
            <Button onClick={handleBackToRooms} style={{ marginTop: '1rem' }}>
              Back to Room List
            </Button>
          </Card>
        </Container>
      </PageWrapper>
    );
  }
  
  return (
    <PageWrapper>
      <Container>
        <HeaderBar>
          <div>
            <Title>{room.room_name}</Title>
            <UserInfo>
              Logged in as: <span>{student.full_name}</span>
            </UserInfo>
          </div>
          
          <div>
            <Button variant="outline" onClick={handleBackToRooms}>
              Back to Room List
            </Button>
          </div>
        </HeaderBar>
        
        {chatbots.length === 0 ? (
          <Alert variant="info">No chatbots available in this room</Alert>
        ) : (
          <>
            <div style={{ marginBottom: '1rem' }}>
              <select 
                value={selectedChatbot || ''} 
                onChange={(e) => setSelectedChatbot(e.target.value)}
                style={{ padding: '0.5rem', borderRadius: '4px', width: '100%', maxWidth: '300px' }}
              >
                {chatbots.map(chatbot => (
                  <option key={chatbot.chatbot_id} value={chatbot.chatbot_id}>
                    {chatbot.name}
                  </option>
                ))}
              </select>
            </div>
            
            <ChatContainer>
              {selectedChatbot && (
                <Chat 
                  roomId={roomId}
                  chatbot={chatbots.find(chatbot => chatbot.chatbot_id === selectedChatbot) || {
                    chatbot_id: selectedChatbot || '',
                    name: 'Selected Chatbot',
                    description: '',
                    system_prompt: 'You are a helpful assistant.',
                    teacher_id: 'system',
                    created_at: new Date().toISOString(),
                    bot_type: 'learning' as BotTypeEnum
                  }}
                  directMode={true}
                />
              )}
            </ChatContainer>
          </>
        )}
      </Container>
    </PageWrapper>
  );
}// src/app/room/[roomId]/student/[studentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import StudentChatHistory from '@/components/teacher/StudentChatHistory';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    align-items: flex-start;
  }
`;

const StudentInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
  }
`;

const BackButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

// Define explicit types
interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

// Define a more specific type for the chatbots nested object
interface RoomChatbotResponse {
  chatbot_id: string;
  chatbots: {
    chatbot_id: string;
    name: string;
  } | Array<{
    chatbot_id: string;
    name: string;
  }>;
}

export default function StudentChatPage() {
  const params = useParams();
  const roomId = params?.roomId as string;
  const studentId = params?.studentId as string;
  const [studentName, setStudentName] = useState<string>('Student');
  const [chatbots, setChatbots] = useState<ChatbotOption[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const supabase = createClient();

  const fetchPageData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Get user info
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }
      
      // Get student info - handle missing columns gracefully
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', studentId)
        .single();
        
      if (profile) {
        // Try different fields that might contain the name
        // The error suggests profiles.name doesn't exist, so check other fields
        if (profile.full_name) {
          setStudentName(profile.full_name);
        } else if (profile.email) {
          setStudentName(profile.email.split('@')[0]);
        } else if (profile.user_id) {
          // Last resort - use a generic label
          setStudentName('Student');
        }
      }
      
      // Get chatbots in this room
      const { data: roomChatbots } = await supabase
        .from('room_chatbots')
        .select(`
          chatbot_id,
          chatbots:chatbots!inner(
            chatbot_id,
            name
          )
        `)
        .eq('room_id', roomId);
        
      if (roomChatbots && roomChatbots.length > 0) {
        // Extract chatbot data with proper typing
        const chatbotList: ChatbotOption[] = [];
        
        // Type assertion to help TypeScript understand the structure
        const typedRoomChatbots = roomChatbots as unknown as RoomChatbotResponse[];
        
        typedRoomChatbots.forEach(item => {
          // Safely check and extract chatbot data
          if (item.chatbots) {
            if (Array.isArray(item.chatbots)) {
              item.chatbots.forEach(cb => {
                chatbotList.push({
                  chatbot_id: cb.chatbot_id,
                  name: cb.name
                });
              });
            } else {
              // It's a single object, not an array
              const cb = item.chatbots;
              chatbotList.push({
                chatbot_id: cb.chatbot_id,
                name: cb.name
              });
            }
          }
        });
        
        setChatbots(chatbotList);
      }
    } catch (err) {
      console.error('Error loading page data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load page data');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, router, supabase]);

  useEffect(() => {
    fetchPageData();
  }, [fetchPageData]);

  const handleBack = () => {
    router.push(`/room/${roomId}`);
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <Card>
            <p>Loading...</p>
          </Card>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Room
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <StudentInfo>
            <h1>{studentName}</h1>
            <p>Chat History</p>
          </StudentInfo>
          <BackButton 
            variant="outline" 
            onClick={handleBack}
          >
            ← Back to Room
          </BackButton>
        </Header>
        
        <StudentChatHistory
          roomId={roomId}
          studentId={studentId}
          studentName={studentName}
          chatbots={chatbots}
        />
      </Container>
    </PageWrapper>
  );
}// src/app/room/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import Link from 'next/link';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Alert, Button } from '@/styles/StyledComponents';
import StudentList from '@/components/teacher/StudentList';
import type { Chatbot } from '@/types/database.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md} 0;
  }
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    gap: ${({ theme }) => theme.spacing.md};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1.5rem;
      text-align: center;
    }
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1rem;
      text-align: center;
    }
  }
  
  .room-code {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-top: ${({ theme }) => theme.spacing.xs};
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      text-align: center;
    }
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    justify-content: center;
  }
`;

const ChatbotGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  margin-top: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  cursor: pointer;
  
  &:hover {
    transform: translateY(-4px);
    box-shadow: ${({ theme }) => theme.shadows.lg};
  }
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.5rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    min-height: 3rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }
  
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    display: inline-block;
  }
  
  .chat-button {
    width: 100%;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: 44px;
    }
  }
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
`;

// Extended chatbot interface to include instance_id
interface ChatbotWithInstance extends Chatbot {
  instance_id?: string;
}

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: {
    chatbots: Chatbot;
  }[] | null;
}

export default function RoomPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbots, setChatbots] = useState<ChatbotWithInstance[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  
  const params = useParams();
  const roomId = params?.roomId as string;
  const router = useRouter();
  const supabase = createClient();

  // Check for direct access via URL param with user ID
  const searchParams = useSearchParams();
  const uidFromUrl = searchParams?.get('uid');
  
  const fetchRoomData = useCallback(async () => {
    try {
      // Check for direct user ID access via URL
      const directUid = searchParams?.get('uid');
      let userId, userRole;
      
      // First, try to get the authenticated user normally
      const { data: { user } } = await supabase.auth.getUser();
      
      // Helper function to get cookie values
      const getCookieValue = (name: string): string | null => {
        if (typeof document === 'undefined') return null;
        const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? decodeURIComponent(match[2]) : null;
      };
      
      // Check for different auth mechanisms via cookies
      // First with standard auth-* cookies, then check older emergency_* cookies for backward compatibility
      const authUserId = getCookieValue('auth-user-id') || getCookieValue('emergency_user_id');
      const directAccess = getCookieValue('auth-direct-access') === 'true' || getCookieValue('emergency_access') === 'true';
      const cookieRoomId = getCookieValue('auth-room-id') || getCookieValue('emergency_room_id');
      const directAccessMode = searchParams?.get('direct') === 'true' || searchParams?.get('emergency') === 'true';
      
      if (!user) {
        if (directAccess && authUserId && cookieRoomId === roomId) {
          console.log('[RoomPage] Using direct access cookies:', authUserId);
          userId = authUserId;
          userRole = 'student';
        } else if (directUid) {
          console.log('[RoomPage] No authenticated user but direct UID provided:', directUid);
          // Try to use the direct UID
          userId = directUid;
          userRole = 'student'; // Assume student role for direct access
        } else {
          throw new Error('Not authenticated');
        }
      } else {
        userId = user.id;
        
        // Get user role from profile
        const { data: profile } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', userId)
          .single();
  
        if (!profile) throw new Error('User profile not found');
        userRole = profile.role;
        setUserRole(userRole);
      }

      // First, ensure we have access to this room
      let hasAccess = false;
      if (userRole === 'teacher') {
        // For teachers, check if they own the room
        const { data: teacherRoom } = await supabase
          .from('rooms')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('teacher_id', userId)
          .single();
        
        hasAccess = !!teacherRoom;
      } else if (userRole === 'student') {
        // For students, check if they're a member of the room
        const { data: membership } = await supabase
          .from('room_memberships')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('student_id', userId)
          .single();
        
        hasAccess = !!membership;
        
        // If direct uid was provided but no access, try using admin client
        if (!hasAccess && directUid) {
          console.warn('[RoomPage] No access found using standard query with direct UID, trying API...');
          // Use a special API endpoint with admin client to check membership
          try {
            const response = await fetch(`/api/student/verify-membership?roomId=${roomId}&userId=${directUid}`, {
              credentials: 'include'
            });
            
            if (response.ok) {
              const data = await response.json();
              hasAccess = data.isMember;
              console.log('[RoomPage] Access check via API:', hasAccess ? 'Granted' : 'Denied');
            }
          } catch (apiError) {
            console.error('[RoomPage] Error checking membership via API:', apiError);
          }
        }
      }

      if (!hasAccess) {
        throw new Error('You do not have access to this room');
      }

      // Get basic room info
      if (directUid || directAccess || directAccessMode) {
        console.log('[RoomPage] Using direct API endpoint for room data');
        // Use admin API to get data
        try {
          // Use the most reliable user ID available
          const effectiveUserId = authUserId || directUid;
          const response = await fetch(`/api/student/room-data?roomId=${roomId}&userId=${effectiveUserId}`, {
            credentials: 'include'
          });
          
          if (!response.ok) {
            throw new Error('Failed to fetch room data via API');
          }
          
          const data = await response.json();
          setRoom(data.room);
          setChatbots(data.chatbots || []);
          return;
        } catch (apiError) {
          console.error('[RoomPage] Error fetching room data via API:', apiError);
          // Continue with standard flow as fallback
        }
      }

      // Standard flow
      const { data: roomData, error: roomError } = await supabase
        .from('rooms')
        .select('*')
        .eq('room_id', roomId)
        .single();

      if (roomError || !roomData) {
        throw new Error('Room not found');
      }

      // Retrieve chatbots using a two-step process to bypass potential RLS issues
      // Step 1: Get chatbot IDs for this room
      const { data: roomChatbots, error: rcError } = await supabase
        .from('room_chatbots')
        .select('chatbot_id')
        .eq('room_id', roomId);

      if (rcError) {
        console.error('[RoomPage] Error fetching room-chatbot relations:', rcError);
        throw new Error('Failed to retrieve chatbot information');
      }

      // Step 2: Get the chatbot details
      const extractedChatbots: Chatbot[] = [];
      
      if (roomChatbots && roomChatbots.length > 0) {
        const chatbotIds = roomChatbots.map(rc => rc.chatbot_id);
        
        const { data: chatbots, error: chatbotsError } = await supabase
          .from('chatbots')
          .select('*')
          .in('chatbot_id', chatbotIds);

        if (chatbotsError) {
          console.error('[RoomPage] Error fetching chatbots:', chatbotsError);
          throw new Error('Failed to retrieve chatbot information');
        }
        
        extractedChatbots.push(...(chatbots || []));
      }
      
      // Set the state variables
      setRoom({
        ...roomData,
        room_chatbots: []
      } as RoomQueryResult);
      setChatbots(extractedChatbots);
    } catch (err) {
      console.error('[RoomPage] Error in fetchRoomData:', err);
      setError(err instanceof Error ? err.message : 'Failed to load room');
    } finally {
      setLoading(false);
    }
  }, [roomId, supabase, searchParams]);

  useEffect(() => {
    if (uidFromUrl) {
      console.log('[RoomPage] Direct user ID access detected:', uidFromUrl);
    }
    
    if (roomId) {
      fetchRoomData();
    }
  }, [roomId, fetchRoomData, uidFromUrl]);

  const handleBack = () => {
    if (userRole === 'teacher') {
      router.push('/teacher-dashboard');
    } else {
      // For students, we need to preserve the user ID
      const directUid = searchParams?.get('uid') || searchParams?.get('student_id');
      
      if (directUid) {
        // Store ID in localStorage for additional reliability
        localStorage.setItem('student_direct_access_id', directUid);
        localStorage.setItem('current_student_id', directUid);
        
        // Go back to dashboard with user ID - make sure both param formats are included
        router.push(`/student/dashboard?direct=1&user_id=${directUid}&_t=${Date.now()}`);
      } else {
        // Fallback to regular student dashboard
        router.push('/student/dashboard');
      }
    }
  };

  const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
      'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
      'google/gemma-3-27b-it:free': 'Gemma 3 27B',
      'microsoft/phi-4-reasoning-plus:free': 'Phi 4 Reasoning',
      'qwen/qwen3-32b:free': 'Qwen3 32B',
      'qwen/qwen3-235b-a22b:free': 'Qwen3 235B'
    };
    return modelNames[model] || model;
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <Card>Loading room...</Card>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Dashboard
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!room) {
    return null;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>
              {chatbots.length === 0 ? 'No chatbots available' : 
               chatbots.length === 1 ? '1 chatbot available' :
               `${chatbots.length} chatbots available`}
            </p>
            <div className="room-code">Room Code: {room.room_code}</div>
          </RoomInfo>
          <BackButton onClick={handleBack}>
            ← Back
          </BackButton>
        </Header>

        {chatbots.length === 0 ? (
          <EmptyState>
            <h3>No Chatbots Available</h3>
            <p>This room doesn&apos;t have any chatbots assigned yet.</p>
            {userRole === 'teacher' && (
              <p>Go back to the dashboard to assign chatbots to this room.</p>
            )}
          </EmptyState>
        ) : (
          <ChatbotGrid>
            {chatbots.map((chatbot) => (
              <Link 
                key={chatbot.instance_id || chatbot.chatbot_id} 
                href={uidFromUrl ? 
                  `/chat/${roomId}?chatbot=${chatbot.chatbot_id}&instance=${chatbot.instance_id || ''}&uid=${uidFromUrl}` : 
                  `/chat/${roomId}?chatbot=${chatbot.chatbot_id}&instance=${chatbot.instance_id || ''}`
                }
                style={{ textDecoration: 'none' }}
              >
                <ChatbotCard>
                  <h3>{chatbot.name}</h3>
                  <p>{chatbot.description || 'No description'}</p>
                  
                  <div className="model-info">
                    {getModelDisplayName(chatbot.model)}
                  </div>
                  
                  {process.env.NODE_ENV === 'development' && (
                    <div style={{ fontSize: '0.8rem', color: '#999', marginBottom: '0.5rem', padding: '0.25rem', background: '#f5f5f5', borderRadius: '4px' }}>
                      Instance ID: {chatbot.instance_id || 'None'}
                    </div>
                  )}
                  
                  <Button 
                    className="chat-button"
                    as="div"  // Prevent double link
                  >
                    Start Chat
                  </Button>
                </ChatbotCard>
              </Link>
            ))}
          </ChatbotGrid>
        )}
        
        {/* Student list section - only visible to teachers */}
        {userRole === 'teacher' && (
          <StudentList roomId={roomId} />
        )}
      </Container>
    </PageWrapper>
  );
}// src/app/magic-link/page.tsx
'use client';

import MagicLink from '@/components/auth/MagicLink';
import { Container } from '@/styles/StyledComponents';

export default function MagicLinkPage() {
  return (
    <Container>
      <MagicLink />
    </Container>
  );
}'use client';

import { useState, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const ConfirmCard = styled(Card)`
  width: 100%;
  max-width: 500px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

const EmailHighlight = styled.div`
  font-weight: bold;
  font-size: 1.2rem;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.md} 0;
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.primary}10;
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const ButtonGroup = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const LoadingFallback = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
`;

function ConfirmContent() {
  const [isResending, setIsResending] = useState(false);
  const [message, setMessage] = useState<{ type: 'success' | 'error', text: string } | null>(null);
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();
  
  const email = searchParams?.get('email') || '';
  const roomCode = searchParams?.get('room') || '';

  const handleResendLink = async () => {
    if (!email) return;
    
    setIsResending(true);
    setMessage(null);
    
    try {
      const { error } = await supabase.auth.signInWithOtp({
        email,
        options: {
          emailRedirectTo: `${window.location.origin}/magic-link?room=${roomCode}`
        }
      });
      
      if (error) throw error;
      
      setMessage({
        type: 'success',
        text: 'Magic link sent! Please check your email inbox.'
      });
    } catch (err) {
      console.error('Error sending magic link:', err);
      setMessage({
        type: 'error',
        text: err instanceof Error ? err.message : 'Failed to send magic link'
      });
    } finally {
      setIsResending(false);
    }
  };

  return (
    <PageWrapper>
      <ConfirmCard>
        <Title>Check Your Email</Title>
        
        <Text>
          We&apos;ve sent a magic link to your email. Click the link in your email to sign in and join the classroom.
        </Text>
        
        {email && <EmailHighlight>{email}</EmailHighlight>}
        
        {message && (
          <Alert variant={message.type}>
            {message.text}
          </Alert>
        )}
        
        <ButtonGroup>
          <Button 
            onClick={handleResendLink}
            disabled={isResending}
          >
            {isResending ? 'Sending...' : 'Resend Magic Link'}
          </Button>
          
          <Button 
            variant="outline"
            onClick={() => router.push('/join-room')}
          >
            Back to Room Join
          </Button>
        </ButtonGroup>
      </ConfirmCard>
    </PageWrapper>
  );
}

export default function ConfirmPage() {
  return (
    <Suspense fallback={<LoadingFallback><LoadingSpinner /></LoadingFallback>}>
      <ConfirmContent />
    </Suspense>
  );
}'use client';

import { useState, useEffect, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import { isValidRoomCode } from '@/lib/utils/room-codes';

const PageWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const ProfileCard = styled(Card)`
  width: 100%;
  max-width: 400px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const NameInput = styled(Input)`
  font-size: 1.2rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.primary};
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary}30;
  }
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

const CodeBox = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 1.5rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.md} 0;
  padding: ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  letter-spacing: 0.1em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

const LoadingFallback = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
`;

function ProfileContent() {
  const [fullName, setFullName] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();
  const roomCode = searchParams?.get('code') || '';

  useEffect(() => {
    // If no room code is provided, redirect to join page
    if (!roomCode) {
      router.push('/join-room');
      return;
    }
    
    // Also validate the room code format
    if (!isValidRoomCode(roomCode)) {
      setError('Invalid room code format');
      router.push('/join-room');
    }
  }, [roomCode, router]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    if (!fullName.trim()) {
      setError('Please enter your name');
      setIsLoading(false);
      return;
    }

    try {
      // 1. Find the room by code with consistent approach
      const { data: room, error: roomError } = await supabase
        .from('rooms')
        .select('room_id, is_active')
        .eq('room_code', roomCode)
        .single();

      if (roomError) {
        console.error('Error when looking up room by code:', roomCode, roomError);
        // Check if this is a "no rows" error (PGRST116) vs. a real database error
        if (roomError.code === 'PGRST116') {
          throw new Error('Room not found. Please check the code and try again.');
        } else {
          throw new Error('Database error when looking up room: ' + roomError.message);
        }
      }
      
      if (!room) {
        console.error('No room found but also no error for code:', roomCode);
        throw new Error('Room not found. Please check the code and try again.');
      }

      if (!room.is_active) {
        throw new Error('This room is currently inactive. Please contact your teacher.');
      }

      // 2. Generate a temporary anonymous account
      const timestamp = new Date().getTime();
      const randomId = Math.random().toString(36).substring(2, 12);
      const tempEmail = `anonymous-${timestamp}-${randomId}@temp.classbots.ai`;
      const tempPassword = Math.random().toString(36).substring(2, 14);

      // 3. Sign up with anonymous credentials
      const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
        email: tempEmail,
        password: tempPassword,
        options: {
          data: {
            role: 'student',
            full_name: fullName,
            is_anonymous: true
          }
        }
      });

      if (signUpError) {
        throw signUpError;
      }

      if (!signUpData.user) {
        throw new Error('Failed to create temporary account');
      }

      // 4. Sign in with the anonymous account
      const { error: signInError } = await supabase.auth.signInWithPassword({
        email: tempEmail,
        password: tempPassword,
      });
      // signInData is unused in this process

      if (signInError) {
        throw signInError;
      }

      // 5. Create a profile entry
      const { error: profileError } = await supabase
        .from('profiles')
        .insert({
          user_id: signUpData.user.id,
          email: tempEmail,
          full_name: fullName,
          role: 'student',
          is_anonymous: true
        });

      if (profileError) {
        throw profileError;
      }

      // 6. Join the room
      const { error: joinError } = await supabase
        .from('room_memberships')
        .insert({
          room_id: room.room_id,
          student_id: signUpData.user.id
        });

      if (joinError) {
        throw joinError;
      }

      // 7. Redirect to student dashboard
      router.push('/student/dashboard');

    } catch (err) {
      console.error('Error in profile creation:', err);
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
    } finally {
      setIsLoading(false);
    }
  };

  if (!roomCode) {
    return (
      <PageWrapper>
        <LoadingSpinner />
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <ProfileCard>
        <Title>Join Classroom</Title>
        
        <Text>
          Please enter your name to join the classroom.
        </Text>
        
        <CodeBox>Room: {roomCode}</CodeBox>
        
        {error && <Alert variant="error">{error}</Alert>}
        
        <Form onSubmit={handleSubmit}>
          <NameInput
            type="text"
            value={fullName}
            onChange={(e) => setFullName(e.target.value)}
            placeholder="Your Name"
            autoFocus
            required
          />
          <Button 
            type="submit" 
            disabled={isLoading} 
            style={{ width: '100%' }} 
            size="large"
          >
            {isLoading ? 'Joining...' : 'Join Classroom'}
          </Button>
        </Form>
      </ProfileCard>
    </PageWrapper>
  );
}

export default function ProfilePage() {
  return (
    <Suspense fallback={<LoadingFallback><LoadingSpinner /></LoadingFallback>}>
      <ProfileContent />
    </Suspense>
  );
}// src/app/join/page.tsx
'use client';

import { useState, useEffect, useCallback, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Input, Alert } from '@/styles/StyledComponents';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const JoinCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

function JoinPageContent() {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userRole, setUserRole] = useState<string | null>(null);
  const [isCheckingAuth, setIsCheckingAuth] = useState(true); // Added for better loading UI
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const checkAuthentication = useCallback(async () => {
    setIsCheckingAuth(true); // Start auth check
    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setIsAuthenticated(true);
          
          const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
          
          if (profile) {
            setUserRole(profile.role);
          }
        } else {
            setIsAuthenticated(false);
            setUserRole(null);
        }
    } catch (e) {
        console.error("Error during auth check on join page:", e);
        setIsAuthenticated(false); // Assume not authenticated on error
        setUserRole(null);
    } finally {
        setIsCheckingAuth(false); // End auth check
    }
  }, [supabase]);

  useEffect(() => {
    const codeFromUrl = searchParams?.get('code');
    if (codeFromUrl) {
      setRoomCode(codeFromUrl.toUpperCase());
    }
    checkAuthentication();
  }, [searchParams, checkAuthentication]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    const formattedCode = roomCode.toUpperCase();

    try {
      const { data: room, error: roomError } = await supabase
        .from('rooms')
        .select('room_id, is_active')
        .eq('room_code', formattedCode)
        .single();

      if (roomError || !room) {
        throw new Error('Room not found. Please check the code and try again.');
      }

      if (!room.is_active) {
        throw new Error('This room is currently inactive. Please contact your teacher.');
      }

      if (isAuthenticated && userRole === 'student') {
        const response = await fetch('/api/student/join-room', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ room_code: formattedCode }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || 'Failed to join room. You might already be a member or the room is full.');
        }
        // Redirect to student dashboard
        console.log('[Join Page] Student joined successfully, redirecting to /student/dashboard');
        router.push('/student/dashboard'); // <<< MODIFIED LINE
        router.refresh(); // Ensure page reloads to reflect new state if needed
      } else if (!isAuthenticated) {
        console.log('[Join Page] User not authenticated, redirecting to student signup.');
        // The redirect param ensures they come back here with the code after signup/login
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
      } else if (isAuthenticated && userRole !== 'student') {
         throw new Error('Only student accounts can join rooms this way. Please log in with a student account.');
      } else {
        // This case should ideally not be hit if logic is correct (e.g. authenticated but no role yet)
        // Prompt to re-authenticate or re-check role
        setError('Authentication issue. Please try logging out and back in, or contact support if this persists.');
        console.warn('[Join Page] Unexpected auth state:', {isAuthenticated, userRole});
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred while trying to join the room.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Loading UI while checking authentication
  if (isCheckingAuth) {
    return (
        <PageWrapper><Container><JoinCard><Title>Loading...</Title></JoinCard></Container></PageWrapper>
    );
  }


  // If not authenticated, show simplified "Create Account" view
  if (!isAuthenticated) {
    return (
      <PageWrapper>
        <Container>
          <JoinCard>
            <Title>Join Your Class</Title>
            <Text>
              To join the room with code <strong>{roomCode || '...'}</strong>, you&apos;ll need a student account.
            </Text>
            <Button 
              onClick={() => router.push(`/auth?type=student&redirect=/join?code=${roomCode}`)}
              style={{ width: '100%' }}
              size="large"
            >
              Create or Log In to Student Account
            </Button>
            {roomCode && (
              <Text style={{ marginTop: '1rem', fontSize: '0.875rem' }}>
                You are trying to join room: <strong>{roomCode}</strong>
              </Text>
            )}
          </JoinCard>
        </Container>
      </PageWrapper>
    );
  }

  // If authenticated (and presumably as a student, though `handleSubmit` re-checks role)
  return (
    <PageWrapper>
      <Container>
        <JoinCard>
          <Title>Join Your Class</Title>
          <Text>Enter the room code your teacher provided, or confirm the code from the link.</Text>
          
          {error && <Alert variant="error">{error}</Alert>}
          
          <Form onSubmit={handleSubmit}>
            <RoomCodeInput
              type="text"
              value={roomCode}
              onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
              placeholder="ROOM CODE"
              maxLength={6}
              required
            />
            <Button type="submit" disabled={isLoading} style={{ width: '100%' }} size="large">
              {isLoading ? 'Joining...' : 'Join Class'}
            </Button>
          </Form>
        </JoinCard>
      </Container>
    </PageWrapper>
  );
}

export default function JoinPage() {
  return (
    <Suspense fallback={<LoadingFallback>Loading join page...</LoadingFallback>}>
      <JoinPageContent />
    </Suspense>
  );
}// src/app/chat/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Alert } from '@/styles/StyledComponents';
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.75rem;
  }

  p {
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};

  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string | null;
  is_active: boolean;
  created_at: string;
  updated_at?: string;
  room_chatbots: {
    chatbots: Chatbot; // This Chatbot type already includes welcome_message
  }[] | null;
}

export default function ChatPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const params = useParams();
  const searchParams = useSearchParams();
  const router = useRouter();
  const supabase = createClient();

  const roomId = params?.roomId ? String(params.roomId) : null;
  const chatbotIdFromUrl = searchParams.get('chatbot');
  const instanceIdFromUrl = searchParams.get('instance');
  const initialFetchDoneRef = useRef(false);

  useEffect(() => {
    console.log('[ChatPage] Initializing/Params Update. Room ID:', roomId, 'Chatbot ID:', chatbotIdFromUrl);
    if (initialFetchDoneRef.current && (params?.roomId !== roomId || searchParams.get('chatbot') !== chatbotIdFromUrl)) {
        initialFetchDoneRef.current = false;
    }
  }, [roomId, chatbotIdFromUrl, params?.roomId, searchParams]);

  const fetchRoomData = useCallback(async () => {
    if (!roomId || !chatbotIdFromUrl) {
      console.warn("[ChatPage] fetchRoomData: Aborting fetch - RoomID or ChatbotID is missing.", { roomId, chatbotIdFromUrl });
      if (roomId && chatbotIdFromUrl === null) {
          setError("Chatbot ID is required in the URL (e.g., ?chatbot=...).");
      } else if (!roomId && chatbotIdFromUrl){
          setError("Room ID is missing from the URL path.");
      } else if (!roomId && !chatbotIdFromUrl) {
          setError("Both Room ID and Chatbot ID are missing from the URL.");
      }
      setLoading(false);
      return;
    }
    console.log(`[ChatPage] fetchRoomData: Attempting fetch. RoomID: ${roomId}, ChatbotID: ${chatbotIdFromUrl}`);
    setLoading(true);
    setError(null);
    
    // Check for direct user ID access via URL
    const directUid = searchParams.get('uid');
    if (directUid) {
      console.log('[ChatPage] Direct user ID provided in URL:', directUid);
    }

    try {
      // First try normal authentication
      const { data: { user } } = await supabase.auth.getUser();
      
      // If no authenticated user but direct UID provided, try to verify access via API
      if (!user && directUid) {
        console.log('[ChatPage] No authenticated user but direct UID provided, checking membership via API');
        
        try {
          // Use the verify-membership API to check and potentially add the user to the room
          const response = await fetch(`/api/student/verify-membership?roomId=${roomId}&userId=${directUid}`, {
            credentials: 'include'
          });
          
          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            console.error('[ChatPage] Membership verification failed:', errorData);
            throw new Error(errorData.error || 'Failed to verify room access');
          }
          
          const membershipData = await response.json();
          
          if (!membershipData.isMember) {
            throw new Error('You do not have access to this room');
          }
          
          console.log('[ChatPage] Direct access granted via API');
          
          // Continue with fetch using admin API
          const chatResponse = await fetch(`/api/student/room-chatbot-data?roomId=${roomId}&chatbotId=${chatbotIdFromUrl}&userId=${directUid}`, {
            credentials: 'include'
          });
          
          if (!chatResponse.ok) {
            throw new Error('Failed to fetch chat data');
          }
          
          const data = await chatResponse.json();
          
          setRoom(data.room);
          setChatbot(data.chatbot);
          initialFetchDoneRef.current = true;
          setLoading(false);
          return;
        } catch (apiError) {
          console.error('[ChatPage] API access verification failed:', apiError);
          initialFetchDoneRef.current = false;
          throw apiError;
        }
      }
      
      // Normal authenticated flow
      if (!user) {
        initialFetchDoneRef.current = false;
        throw new Error('Not authenticated');
      }

      const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
      if (!profile) {
        initialFetchDoneRef.current = false;
        throw new Error('User profile not found');
      }

      const { data: roomData, error: roomError } = await supabase.from('rooms')
        .select(`
          *, 
          room_chatbots!inner(
            chatbots!inner(
              chatbot_id, 
              name, 
              description, 
              system_prompt, 
              model, 
              max_tokens, 
              temperature, 
              enable_rag, 
              bot_type, 
              assessment_criteria_text,
              welcome_message
            )
          )
        `)
        .eq('room_id', roomId)
        .eq('room_chatbots.chatbot_id', chatbotIdFromUrl)
        .single();

      if (roomError) {
        initialFetchDoneRef.current = false;
        throw new Error(roomError.message || 'Data not found. Check room/chatbot association or permissions.');
      }
      if (!roomData) {
        initialFetchDoneRef.current = false;
        throw new Error('No data returned for room/chatbot. Check IDs and permissions.');
      }

      if (profile.role === 'student') {
        const { data: membership } = await supabase.from('room_memberships').select('room_id').eq('room_id', roomId).eq('student_id', user.id).single();
        if (!membership) {
            initialFetchDoneRef.current = false;
            throw new Error('You do not have access to this room');
        }
      } else if (profile.role === 'teacher') {
        const typedRoomData = roomData as RoomQueryResult;
        if (typedRoomData.teacher_id !== user.id) {
            initialFetchDoneRef.current = false;
            throw new Error('You do not own this room');
        }
      }

      const typedRoomData = roomData as RoomQueryResult;
      setRoom(typedRoomData);
      if (typedRoomData.room_chatbots && typedRoomData.room_chatbots.length > 0 && typedRoomData.room_chatbots[0].chatbots) {
        setChatbot(typedRoomData.room_chatbots[0].chatbots);
      } else {
        initialFetchDoneRef.current = false;
        throw new Error('Chatbot details missing in fetched room data.');
      }
      initialFetchDoneRef.current = true; // Mark as done only on full success
    } catch (err) {
      initialFetchDoneRef.current = false; // Allow retry on error
      setError(err instanceof Error ? err.message : 'Failed to load chat page data');
      setChatbot(null); setRoom(null);
    } finally {
      setLoading(false);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [roomId, chatbotIdFromUrl, supabase]); // searchParams intentionally omitted for performance

  useEffect(() => {
    if (roomId && chatbotIdFromUrl && !initialFetchDoneRef.current) {
      fetchRoomData();
    }
  }, [roomId, chatbotIdFromUrl, fetchRoomData, searchParams]);

  const handleBack = () => { 
    // Preserve the user ID parameter when going back to the room
    const uid = searchParams.get('uid');
    
    // Also store user ID in localStorage for reliability
    if (uid) {
      localStorage.setItem('student_direct_access_id', uid);
      localStorage.setItem('current_student_id', uid);
    }
    
    if (roomId) {
      if (uid) {
        // Add timestamp to avoid caching issues
        router.push(`/room/${roomId}?direct=1&uid=${uid}&_t=${Date.now()}`);
      } else {
        router.push(`/room/${roomId}`);
      }
    } else {
      // If no room ID, go to dashboard (with user ID if available)
      if (uid) {
        router.push(`/student/dashboard?direct=1&user_id=${uid}&_t=${Date.now()}`);
      } else {
        router.push('/student/dashboard');
      }
    }
  };

  if (loading && !initialFetchDoneRef.current) {
    return <PageWrapper><Container><LoadingContainer><LoadingSpinner size="large" /><p>Loading chat environment...</p></LoadingContainer></Container></PageWrapper>;
  }
  if (error) {
    return <PageWrapper><Container><Alert variant="error">{error}</Alert><BackButton onClick={handleBack} style={{ marginTop: '16px' }}>{'< Back to Room'}</BackButton></Container></PageWrapper>;
  }
  if (!room || !chatbot) {
    return <PageWrapper><Container><Alert variant="info">Chatbot or room information is unavailable. Ensure Chatbot ID is in URL.</Alert><BackButton onClick={handleBack} style={{ marginTop: '16px' }}>{'< Back to Room'}</BackButton></Container></PageWrapper>;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>Chatting with: <strong>{chatbot.name}</strong></p>
            {chatbot.bot_type === 'assessment' && <p style={{fontSize: '0.9em', fontStyle: 'italic', color: '#555'}}>This is an Assessment Bot.</p>}
          </RoomInfo>
          <BackButton onClick={handleBack}>
            {'< Back to Room'}
          </BackButton>
        </Header>
        {roomId && <Chat roomId={roomId} chatbot={chatbot} instanceId={instanceIdFromUrl || undefined} />}
      </Container>
    </PageWrapper>
  );
}// src/app/auth/callback/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url);
  const code = searchParams.get('code');
  const codeVerifier = searchParams.get('code_verifier');

  if (code) {
    const supabase = await createServerSupabaseClient();
    let authResult;
    
    // Check if code_verifier is provided (PKCE flow)
    // Handle API compatibility issues between Supabase versions
    try {
      if (codeVerifier) {
        // Newer Supabase versions accept the code verifier as an option
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        authResult = await (supabase.auth as any).exchangeCodeForSession(code, { 
          codeVerifier: codeVerifier 
        });
      } else {
        authResult = await supabase.auth.exchangeCodeForSession(code);
      }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (e) {
      // If above fails, try the older method
      authResult = await supabase.auth.exchangeCodeForSession(code);
    }
    
    const { error } = authResult;
    
    if (error) {
      console.error('Error exchanging code for session:', error);
      return NextResponse.redirect(new URL('/auth', origin));
    }
    
    // Get user data to determine redirect
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      console.log(`[Auth Callback] User authenticated: ${user.id}`);
      console.log(`[Auth Callback] User metadata:`, user.user_metadata);
      
      // Wait for profile to be created by trigger
      // This delay might still be needed if your trigger isn't instant
      await new Promise(resolve => setTimeout(resolve, 500)); 
      
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      // Get redirect URL from query params or use role-based default
      const redirectToParam = searchParams.get('redirect');
      let redirectTarget = '';
      
      // First, check safe redirect parameter
      if (redirectToParam && (redirectToParam.startsWith('/') || redirectToParam.startsWith(origin))) {
        try {
            const finalRedirectUrl = redirectToParam.startsWith('/') 
                                    ? new URL(redirectToParam, origin) 
                                    : new URL(redirectToParam);

            if (finalRedirectUrl.origin === origin) {
                console.log(`[Auth Callback] Will redirect to specified param: ${finalRedirectUrl.toString()}`);
                redirectTarget = finalRedirectUrl.toString();
            }
        } catch (e) {
            console.warn(`[Auth Callback] Error parsing redirect param: ${redirectToParam}`, e);
        }
      }
      
      // If no redirect param or it wasn't valid, determine by role
      if (!redirectTarget) {
        // Check profile role first
        const profileRole = profile?.role;
        
        // If profile has no role or profile error, check user metadata
        const metadataRole = user.user_metadata?.role;
        
        console.log(`[Auth Callback] Profile role: "${profileRole}", Metadata role: "${metadataRole}"`);
        
        // Always ensure profile existence with admin client
        const supabaseAdmin = createAdminClient();
        
        // If profile error or missing role, attempt to repair using metadata
        if (profileError || !profileRole) {
          if (metadataRole) {
            try {
              // Create/update profile based on metadata - add essential fields
              const email = user.email || `${user.id}@example.com`;
              console.log(`[Auth Callback] Repairing profile for user ${user.id}, email ${email}, role ${metadataRole}`);
              
              // For teachers especially, ensure they have a valid profile
              await supabaseAdmin.from('profiles').upsert({
                user_id: user.id,
                email: email,  // Email is marked NOT NULL in the schema, must provide it
                role: metadataRole,
                full_name: user.user_metadata?.full_name || 'User',
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              }, {
                onConflict: 'user_id'
              });
              console.log(`[Auth Callback] Fixed profile for user ${user.id} with role ${metadataRole}`);
            } catch (fixError) {
              console.error('[Auth Callback] Failed to fix profile:', fixError);
            }
          }
        }
        
        // Determine final redirect based on role (with fallbacks)
        const effectiveRole = profileRole || metadataRole;
        
        if (effectiveRole === 'teacher') {
          redirectTarget = `/teacher-dashboard?_t=${Date.now()}`;
          console.log('[Auth Callback] Redirecting teacher to dashboard');
        } else if (effectiveRole === 'student') {
          redirectTarget = `/student/dashboard?_t=${Date.now()}`;
          console.log('[Auth Callback] Redirecting student to dashboard');
        } else {
          // No role found anywhere, default to home
          redirectTarget = '/';
          console.warn(`[Auth Callback] No role found for user ${user.id}. Redirecting to home.`);
        }
      }
      
      // Final redirect
      return NextResponse.redirect(new URL(redirectTarget, origin));
    } else {
      console.log('[Auth Callback] No user found after exchanging code. Redirecting to /auth.');
      return NextResponse.redirect(new URL('/auth', origin));
    }
  }

  console.log('[Auth Callback] No code found in request. Redirecting to /.');
  // Default redirect if no code or other issues
  return NextResponse.redirect(new URL('/', origin));
}'use client';

import { useState, Suspense, useEffect } from 'react';
import styled from 'styled-components';
import { useSearchParams, useRouter } from 'next/navigation';
import AuthForm from '@/components/auth/AuthForm';
import { Container, Alert, Button } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const AuthPage = styled.div`
  padding: ${({ theme }) => theme.spacing.xl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const StyledAlert = styled(Alert)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const TabContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const TabButtons = styled.div`
  display: flex;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const TabButton = styled.button<{ $active: boolean }>`
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  background: none;
  border: none;
  border-bottom: 3px solid ${({ theme, $active }) => $active ? theme.colors.primary : 'transparent'};
  color: ${({ theme, $active }) => $active ? theme.colors.primary : theme.colors.textLight};
  font-weight: ${({ $active }) => $active ? 'bold' : 'normal'};
  cursor: pointer;
  transition: all 0.2s ease;
  
  &:hover {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const ToggleButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  margin-top: ${({ theme }) => theme.spacing.md};
  text-align: center;
  display: block;
  width: 100%;

  &:hover {
    text-decoration: underline;
  }
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const StudentRedirectCard = styled.div`
  background: ${({ theme }) => theme.colors.backgroundDark};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  text-align: center;
`;

function AuthContent() {
  const searchParams = useSearchParams();
  const router = useRouter();
  const urlLoginType = searchParams?.get('login');
  const urlType = searchParams?.get('type');
  const [redirecting, setRedirecting] = useState(false);
  
  // Redirect student logins to the new student access page
  useEffect(() => {
    if (urlLoginType === 'student') {
      setRedirecting(true);
      setTimeout(() => {
        router.push('/student-access');
      }, 2000);
    }
  }, [urlLoginType, router]);
  
  // Determine if we should show signup instead of login
  // Check if the URL has type=teacher_signup parameter
  const isSignup = urlType === 'teacher_signup';
  
  if (redirecting) {
    return (
      <AuthPage>
        <Container>
          <StudentRedirectCard>
            <h2>Student Login</h2>
            <p>We&apos;ve improved the student login experience!</p>
            <p>Redirecting you to the new student login page...</p>
            <div style={{ margin: '1rem auto', textAlign: 'center' }}>
              <LoadingSpinner size="medium" />
            </div>
            <Button onClick={() => router.push('/student-access')}>
              Go to Student Login Now
            </Button>
          </StudentRedirectCard>
        </Container>
      </AuthPage>
    );
  }
  
  return (
    <AuthPage>
      <Container>
        {urlLoginType === 'student' ? (
          <StyledAlert variant="info">
            The student login page has moved. Please use the new student access page.
            <Button onClick={() => router.push('/student-access')} style={{ marginTop: '1rem' }}>
              Go to Student Access
            </Button>
          </StyledAlert>
        ) : (
          <Suspense fallback={<LoadingFallback>Loading...</LoadingFallback>}>
            <TabContainer>
              <TabButtons>
                <TabButton 
                  $active={!isSignup}
                  onClick={() => router.push('/auth')}
                >
                  Teacher Login
                </TabButton>
                <TabButton 
                  $active={isSignup}
                  onClick={() => router.push('/auth?type=teacher_signup')}
                >
                  Teacher Sign Up
                </TabButton>
              </TabButtons>
              
              <AuthForm type={isSignup ? 'signup' : 'login'} />
            </TabContainer>
            
            {!isSignup ? (
              <ToggleButton onClick={() => router.push('/auth?type=teacher_signup')}>
                Need a teacher account? Sign up
              </ToggleButton>
            ) : (
              <ToggleButton onClick={() => router.push('/auth')}>
                Already have an account? Log in
              </ToggleButton>
            )}
          </Suspense>
        )}
      </Container>
    </AuthPage>
  );
}

// Export the page with a Suspense boundary
export default function Auth() {
  return (
    <Suspense fallback={<div>Loading auth page...</div>}>
      <AuthContent />
    </Suspense>
  );
}'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';

const PageContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 90vh;
  background: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.lg};
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 500px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const RoomCode = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.md} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const StyledInput = styled(Input)`
  font-size: 1.2rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

// For Next.js 15.3.1, we need to use any for the page props
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export default function SimpleRoomJoinPage(props: any) {
  const { params } = props;
  const [roomCode, setRoomCode] = useState('');
  const [studentName, setStudentName] = useState('');
  const [status, setStatus] = useState<'ready' | 'checking' | 'joining' | 'success' | 'error'>('ready');
  const [error, setError] = useState('');
  const router = useRouter();

  useEffect(() => {
    // Set room code from URL parameter
    if (params.code) {
      setRoomCode(params.code.toUpperCase());
    }
  }, [params.code]);

  const handleJoin = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!studentName.trim()) {
      setError('Please enter your name');
      return;
    }
    
    try {
      setStatus('joining');
      setError('');
      
      // Simple direct join with minimal complexity
      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          room_code: roomCode,
          student_name: studentName,
          skip_auth: true // Signal to the API to use a simplified flow
        }),
      });
      
      if (!response.ok) {
        // Try to get JSON error if available
        try {
          const errorData = await response.json();
          throw new Error(errorData.error || `Error: Failed to join room`);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (_error) {
          // If JSON parsing fails, use the response status
          // Variable is not used directly but needed for catch block
          throw new Error(`Error: Failed to join room (${response.status})`);
        }
      }
      
      const data = await response.json();
      
      // Show success message briefly
      setStatus('success');
      
      // Redirect to chat or student dashboard
      setTimeout(() => {
        if (data.roomId) {
          router.push(`/chat/${data.roomId}`);
        } else {
          router.push('/student/dashboard');
        }
      }, 1500);
    } catch (err) {
      console.error('Error joining room:', err);
      setError(err instanceof Error ? err.message : 'Failed to join room');
      setStatus('error');
    }
  };
  
  return (
    <PageContainer>
      <JoinCard>
        <Title>Join Classroom</Title>
        
        {roomCode && (
          <>
            <Text>You&apos;re joining a classroom with code:</Text>
            <RoomCode>{roomCode}</RoomCode>
          </>
        )}
        
        {status === 'ready' || status === 'error' ? (
          <>
            <Text>Please enter your name to continue:</Text>
            
            {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
            
            <Form onSubmit={handleJoin}>
              <StyledInput
                type="text"
                value={studentName}
                onChange={(e) => setStudentName(e.target.value)}
                placeholder="Your Name"
                autoFocus
                required
              />
              
              <Button 
                type="submit" 
                size="large" 
                style={{ width: '100%' }}
                disabled={['joining', 'checking'].includes(status)}
              >
                Join Classroom
              </Button>
            </Form>
          </>
        ) : status === 'joining' ? (
          <>
            <Text>Setting up your access...</Text>
            <LoadingSpinner />
          </>
        ) : status === 'success' ? (
          <>
            <Alert variant="success">Successfully joined!</Alert>
            <Text>Taking you to the classroom chat...</Text>
            <LoadingSpinner />
          </>
        ) : null}
      </JoinCard>
    </PageContainer>
  );
}'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const LoadingPage = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2rem;
`;

const Message = styled.p`
  text-align: center;
  font-size: 1.2rem;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function StudentLoginRedirect() {
  const router = useRouter();
  
  useEffect(() => {
    // Just redirect to the student-access page
    setTimeout(() => {
      router.push('/student-access');
    }, 500); // Reduced delay for faster transition
  }, [router]);
  
  return (
    <Container>
      <LoadingPage>
        <LoadingSpinner size="large" />
        <Message>
          Taking you to the student login page...
        </Message>
      </LoadingPage>
    </Container>
  );
}'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const LoadingPage = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 2rem;
`;

const Message = styled.p`
  text-align: center;
  font-size: 1.2rem;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function PinLoginRedirect() {
  const router = useRouter();
  
  useEffect(() => {
    // Just redirect to the student-access page
    setTimeout(() => {
      router.push('/student-access');
    }, 1000);
  }, [router]);
  
  return (
    <Container>
      <LoadingPage>
        <LoadingSpinner size="large" />
        <Message>
          Taking you to the student login page...
        </Message>
      </LoadingPage>
    </Container>
  );
}'use client';

import { useState, useEffect, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import { isValidRoomCode } from '@/lib/utils/room-codes';

// Steps for joining a room
enum JoinStep {
  ROOM_CODE = 'room_code',
  STUDENT_NAME = 'student_name',
  JOINING = 'joining',
  COMPLETE = 'complete'
}

const PageWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 400px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const InputStyled = styled(Input)`
  text-align: center;
  font-size: 1.2rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.primary};
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary}30;
  }
`;

const RoomCodeInput = styled(InputStyled)`
  text-transform: uppercase;
  letter-spacing: 0.2em;
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

const ErrorAlert = styled(Alert)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const CodeBox = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.md} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

const LoadingFallback = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
`;

function JoinRoomContent() {
  const [currentStep, setCurrentStep] = useState<JoinStep>(JoinStep.ROOM_CODE);
  const [roomCode, setRoomCode] = useState('');
  const [studentName, setStudentName] = useState('');
  const [roomId, setRoomId] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  useEffect(() => {
    const codeFromUrl = searchParams?.get('code');
    if (codeFromUrl) {
      setRoomCode(codeFromUrl.toUpperCase());
      
      // If code is provided but can be verified immediately,
      // check if it's valid right away
      if (isValidRoomCode(codeFromUrl.toUpperCase())) {
        // We'll verify the code in this useEffect instead of waiting for submit
        const verifyCodeFromUrl = async () => {
          setIsLoading(true);
          try {
            // Use the API to verify the room code
            const response = await fetch(`/api/student/verify-room-code?code=${codeFromUrl.toUpperCase()}`, {
              method: 'GET',
              credentials: 'include'
            });
            
            if (!response.ok) {
              // Don't set error yet - let the user edit the code manually
              console.warn('Room code from URL not found or invalid:', codeFromUrl);
              setIsLoading(false);
              return;
            }
            
            const data = await response.json();
            
            if (!data.room) {
              console.warn('Room code from URL returned no room data:', codeFromUrl);
              setIsLoading(false);
              return;
            }

            if (!data.room.is_active) {
              setError('This room is currently inactive. Please contact your teacher.');
              setIsLoading(false);
              return;
            }

            // Room code is valid, move to next step automatically
            setRoomId(data.room.room_id);
            setCurrentStep(JoinStep.STUDENT_NAME);
          } catch (err) {
            console.error('Error validating room code from URL:', err);
            // Silently fail - don't set error so user can edit code manually
          } finally {
            setIsLoading(false);
          }
        };
        
        verifyCodeFromUrl();
      }
    }
  }, [searchParams, supabase]);

  const verifyRoomCode = async () => {
    setIsLoading(true);
    setError('');

    if (!roomCode.trim()) {
      setError('Please enter a room code');
      setIsLoading(false);
      return false;
    }
    
    const formattedCode = roomCode.toUpperCase();
    
    // Validate the room code format
    if (!isValidRoomCode(formattedCode)) {
      setError('Invalid room code format. Codes should be 6 characters (letters and numbers).');
      setIsLoading(false);
      return false;
    }

    try {
      // Use the API to verify the room code - this bypasses any RLS issues
      const response = await fetch(`/api/student/verify-room-code?code=${formattedCode}`, {
        method: 'GET',
        credentials: 'include'
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('API error when looking up room code:', formattedCode, errorData);
        
        if (response.status === 404) {
          throw new Error('Room not found. Please check the code and try again.');
        } else {
          throw new Error(errorData.error || 'Error verifying room code. Please try again.');
        }
      }
      
      const data = await response.json();
      
      if (!data.room) {
        console.error('No room found for code:', formattedCode);
        throw new Error('Room not found. Please check the code and try again.');
      }

      if (!data.room.is_active) {
        throw new Error('This room is currently inactive. Please contact your teacher.');
      }

      setRoomId(data.room.room_id);
      return true;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
      return false;
    } finally {
      setIsLoading(false);
    }
  };

  const handleRoomCodeSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    const isValid = await verifyRoomCode();
    if (isValid) {
      setCurrentStep(JoinStep.STUDENT_NAME);
    }
  };

  const handleStudentNameSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    if (!studentName.trim()) {
      setError('Please enter your name');
      setIsLoading(false);
      return;
    }

    try {
      setCurrentStep(JoinStep.JOINING);

      // Instead of doing auth directly, use our server API that uses admin client
      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          room_code: roomCode,
          student_name: studentName,
          skip_auth: true
        }),
        credentials: 'include'
      });

      if (!response.ok) {
        // Try to get detailed error
        try {
          const errorData = await response.json();
          throw new Error(errorData.error || `Error joining room: ${response.status}`);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (_error) {
          // If JSON parsing fails, use status
          // We need to catch the error but don't use it directly
          throw new Error(`Error joining room: ${response.status}`);
        }
      }

      // Parse the successful response
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'Failed to join room');
      }
      
      // Get userId from the response for future use
      const userId = data.userId;
      
      if (!userId) {
        console.warn('User ID not returned in join-room response');
      }
      
      // Room ID might be in the response, but we already have it from earlier steps
      const joinedRoomId = data.roomId || roomId;
      
      // Capture the user ID to pass via URL parameters if cookies/session fails
      const uidParam = userId || data.userId;
      console.log('[Join Room] Captured user ID for URL params if needed:', uidParam);

      // 6. Set complete status and redirect to chat
      setCurrentStep(JoinStep.COMPLETE);
      
      // 7. First, try to find a chatbot for this room
      try {
        // Use the room-chatbots API for reliable access
        const roomChatbotsResponse = await fetch(`/api/student/room-chatbots?roomId=${joinedRoomId}`, {
          method: 'GET',
          credentials: 'include'
        });
        
        // Parse response first to avoid trying to parse it twice
        let chatbotData;
        try {
          chatbotData = await roomChatbotsResponse.json();
        } catch (parseError) {
          console.error('Error parsing chatbot data:', parseError);
          // No chatbot data, go to room selection with UID param for fallback auth
          setTimeout(() => {
            router.push(`/room/${joinedRoomId}${uidParam ? `?uid=${uidParam}` : ''}`);
          }, 1500);
          return;
        }
        
        if (!roomChatbotsResponse.ok || !chatbotData.chatbots?.length) {
          console.warn('No chatbots found for room, redirecting to room selection page');
          // No chatbot found, go to room selection with UID param for fallback auth
          setTimeout(() => {
            router.push(`/room/${joinedRoomId}${uidParam ? `?uid=${uidParam}` : ''}`);
          }, 1500);
          return;
        }
        
        // Always redirect to the room first, regardless of the number of chatbots
        console.log(`Found ${chatbotData.chatbots.length} chatbots, redirecting to room selection`);
        setTimeout(() => {
          // Include UID param for fallback auth
          router.push(`/room/${joinedRoomId}${uidParam ? `?uid=${uidParam}` : ''}`);
        }, 1500);
      } catch (error) {
        console.error('Error finding chatbots:', error);
        // Fall back to just room selection with UID param
        setTimeout(() => {
          router.push(`/room/${joinedRoomId}${uidParam ? `?uid=${uidParam}` : ''}`);
        }, 1500);
      }

    } catch (err) {
      console.error('Error in student creation:', err);
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
      setCurrentStep(JoinStep.STUDENT_NAME);
    } finally {
      setIsLoading(false);
    }
  };

  // Step 1: Enter Room Code
  if (currentStep === JoinStep.ROOM_CODE) {
    return (
      <PageWrapper>
        <JoinCard>
          <Title>Join Classroom</Title>
          
          <Text>
            Enter your classroom code to get started. You&apos;ll be asked to provide your name after this step.
          </Text>
          
          {error && <ErrorAlert variant="error">{error}</ErrorAlert>}
          
          <Form onSubmit={handleRoomCodeSubmit}>
            <RoomCodeInput
              type="text"
              value={roomCode}
              onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
              placeholder="ROOM CODE"
              maxLength={6}
              autoFocus
              readOnly={false}
              disabled={isLoading}
            />
            
            <Button 
              type="submit" 
              disabled={isLoading} 
              style={{ width: '100%' }} 
              size="large"
            >
              {isLoading ? 'Checking...' : 'Continue'}
            </Button>
          </Form>
        </JoinCard>
      </PageWrapper>
    );
  }

  // Step 2: Enter Student Name
  if (currentStep === JoinStep.STUDENT_NAME) {
    return (
      <PageWrapper>
        <JoinCard>
          <Title>Join Classroom</Title>
          
          <Text>
            Please enter your name to join the classroom.
          </Text>
          
          <CodeBox>Room: {roomCode}</CodeBox>
          
          {error && <ErrorAlert variant="error">{error}</ErrorAlert>}
          
          <Form onSubmit={handleStudentNameSubmit}>
            <InputStyled
              type="text"
              value={studentName}
              onChange={(e) => setStudentName(e.target.value)}
              placeholder="Your Name"
              autoFocus
              required
              disabled={isLoading}
            />
            <Button 
              type="submit" 
              disabled={isLoading} 
              style={{ width: '100%' }} 
              size="large"
            >
              {isLoading ? 'Joining...' : 'Join Classroom'}
            </Button>
          </Form>
        </JoinCard>
      </PageWrapper>
    );
  }

  // Step 3: Joining (Loading state)
  if (currentStep === JoinStep.JOINING) {
    return (
      <PageWrapper>
        <JoinCard>
          <Title>Joining Classroom</Title>
          <CodeBox>Room: {roomCode}</CodeBox>
          <Text>Setting up your account...</Text>
          <LoadingSpinner />
        </JoinCard>
      </PageWrapper>
    );
  }

  // Step 4: Complete
  return (
    <PageWrapper>
      <JoinCard>
        <Title>Successfully Joined!</Title>
        <CodeBox>Room: {roomCode}</CodeBox>
        <Alert variant="success">Welcome to the classroom, {studentName}!</Alert>
        <Text>Redirecting to your classroom...</Text>
        <LoadingSpinner />
      </JoinCard>
    </PageWrapper>
  );
}

export default function JoinRoomPage() {
  return (
    <Suspense fallback={<LoadingFallback><LoadingSpinner /></LoadingFallback>}>
      <JoinRoomContent />
    </Suspense>
  );
}// src/app/student/assessments/[assessmentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { 
    Container, 
    Card, 
    Button, 
    Alert, 
    Badge
} from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { 
    StudentAssessment, 
    ChatMessage as DbChatMessage 
} from '@/types/database.types';

interface StudentDetailedAssessmentData extends StudentAssessment {
    chatbot_name?: string | null;
    room_name?: string | null; 
    assessed_conversation?: DbChatMessage[];
    student_reflection_text?: string | null;
}

// --- Styled Components (Keep as they were from the version where reflection was removed) ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const PageTitle = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.8rem;
`;

const MainGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr; 
  gap: ${({ theme }) => theme.spacing.xl};
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    grid-template-columns: 1fr; 
  }
`;

const ConversationContextCard = styled(Card)`
  max-height: 75vh; 
  display: flex;
  flex-direction: column;
  overflow: hidden; 
`;

const CardHeader = styled.h2`
  padding-bottom: ${({ theme }) => theme.spacing.md};
  margin: 0 0 ${({ theme }) => theme.spacing.md} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  font-size: 1.3rem;
  color: ${({ theme }) => theme.colors.text};
`;

const MessagesList = styled.div`
  flex-grow: 1;
  overflow-y: auto;
  padding-right: ${({ theme }) => theme.spacing.sm}; 
`;

const AssessmentDetailsCard = styled(Card)`
  align-self: start; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    margin-top: ${({ theme }) => theme.spacing.xl};
  }
`;

const DetailItem = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-size: 0.95rem;
  line-height: 1.6;
  strong { 
    display: block; font-weight: 600; color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.xs}; font-size: 0.85rem;
    text-transform: uppercase; letter-spacing: 0.03em;
  }
  span, p, div.content { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; }
  p { margin: 0; }
`;

const FeedbackBlock = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-top: ${({ theme }) => theme.spacing.xs};
  border-left: 4px solid ${({ theme }) => theme.colors.primary};
`;

const TeacherFeedbackBlock = styled(FeedbackBlock)`
  border-left-color: ${({ theme }) => theme.colors.green};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.lg} 0;
`;

const getStatusBadgeVariant = (status?: StudentAssessment['status']): 'success' | 'warning' | 'error' | 'default' => {
    if (status === 'teacher_reviewed') return 'success';
    if (status === 'ai_completed') return 'default';
    if (status === 'ai_processing') return 'warning';
    return 'default';
};

const getStatusText = (status: StudentAssessment['status'] | undefined): string => {
    if (status === 'ai_processing') return 'AI Processing';
    if (status === 'ai_completed') return 'AI Feedback Ready';
    if (status === 'teacher_reviewed') return 'Teacher Reviewed';
    return status ? String(status).replace(/_/g, ' ') : 'N/A';
};

const LoadingContainer = styled.div` // Added for loading state
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 300px;
  gap: ${({ theme }) => theme.spacing.md};
`;


export default function StudentAssessmentDetailPage() {
  const [assessment, setAssessment] = useState<StudentDetailedAssessmentData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const assessmentIdFromParams = params?.assessmentId as string; // Renamed for clarity

  const fetchAssessmentDetails = useCallback(async () => {
    if (!assessmentIdFromParams) { // Use renamed variable
      setError("Assessment ID is missing from URL.");
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      // MODIFIED FETCH URL
      const response = await fetch(`/api/student/assessment-detail?assessmentId=${assessmentIdFromParams}`); 
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch assessment details (status ${response.status})`);
      }
      const data: StudentDetailedAssessmentData = await response.json();
      setAssessment(data);
    } catch (err) {
      console.error("Error fetching assessment details:", err);
      setError(err instanceof Error ? err.message : "Could not load assessment details.");
      setAssessment(null);
    } finally {
      setLoading(false);
    }
  }, [assessmentIdFromParams]); // Depend on assessmentIdFromParams

  useEffect(() => {
    fetchAssessmentDetails();
  }, [fetchAssessmentDetails]);


  if (loading) {
    return (
      <PageWrapper><Container><LoadingContainer><LoadingSpinner size="large" /><p>Loading assessment details...</p></LoadingContainer></Container></PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper><Container><Alert variant="error">{error}</Alert><Button onClick={() => router.push('/student/dashboard')} style={{ marginTop: '16px' }}>Back to Dashboard</Button></Container></PageWrapper>
    );
  }

  if (!assessment) {
    return (
      <PageWrapper><Container><Alert variant="info">Assessment details not found.</Alert><Button onClick={() => router.push('/student/dashboard')} style={{ marginTop: '16px' }}>Back to Dashboard</Button></Container></PageWrapper>
    );
  }

  const { 
    chatbot_name, 
    room_name, 
    assessed_at, 
    ai_grade_raw, 
    ai_feedback_student, 
    teacher_override_grade, 
    teacher_override_notes,
    status,
    assessed_conversation,
    student_reflection_text 
  } = assessment;

  return (
    <PageWrapper>
      <Container>
        <Header>
          <PageTitle>Assessment Feedback</PageTitle>
          <Button variant="outline" onClick={() => router.push('/student/dashboard')}>
            ← Back to Dashboard
          </Button>
        </Header>

        <MainGrid>
          <ConversationContextCard>
            <CardHeader>Your Conversation</CardHeader>
            <MessagesList>
              {assessed_conversation && assessed_conversation.length > 0 ? (
                assessed_conversation.map(msg => (
                  <ChatMessageComponent
                    key={msg.message_id}
                    message={msg}
                    chatbotName={chatbot_name || 'Assessment Bot'}
                  />
                ))
              ) : (
                <p style={{textAlign: 'center', padding: '20px'}}>Conversation context is not available for this assessment.</p>
              )}
            </MessagesList>
          </ConversationContextCard>

          <AssessmentDetailsCard>
            <CardHeader>Feedback Details</CardHeader>
            <DetailItem><strong>Assessed By:</strong> <span>{chatbot_name || 'N/A'}</span></DetailItem>
            {room_name && <DetailItem><strong>Classroom:</strong> <span>{room_name}</span></DetailItem>}
            <DetailItem>
              <strong>Assessed On:</strong>
              <span>{assessed_at ? new Date(assessed_at).toLocaleString() : 'N/A'}</span>
            </DetailItem>
             <DetailItem><strong>Status:</strong> <Badge variant={getStatusBadgeVariant(status)}>{getStatusText(status)}</Badge></DetailItem>

            <Divider />
            
            <CardHeader style={{fontSize: '1.1rem', marginTop:'0', borderBottom: 'none', marginBottom: '8px'}}>AI Feedback</CardHeader>
            <DetailItem>
                <strong>AI Suggested Grade:</strong> 
                <Badge variant={ai_grade_raw?.toLowerCase().includes('error') ? 'error' : 'default'} style={{marginLeft: '8px'}}>
                    {ai_grade_raw || 'Not graded by AI'}
                </Badge>
            </DetailItem>
            <DetailItem>
                <strong>AI Feedback for You:</strong> 
                <FeedbackBlock><p>{ai_feedback_student || 'No AI feedback was provided.'}</p></FeedbackBlock>
            </DetailItem>

            {(status === 'teacher_reviewed' && (teacher_override_grade || teacher_override_notes)) && (
              <>
                <Divider />
                <CardHeader style={{fontSize: '1.1rem', marginTop:'0', borderBottom: 'none', marginBottom: '8px'}}>Teacher&apos;s Review</CardHeader>
                {teacher_override_grade && (
                    <DetailItem>
                        <strong>Teacher&apos;s Grade:</strong> 
                        <Badge variant="success" style={{marginLeft: '8px'}}>
                            {teacher_override_grade}
                        </Badge>
                    </DetailItem>
                )}
                {teacher_override_notes && (
                    <DetailItem>
                        <strong>Teacher&apos;s Notes:</strong> 
                        <TeacherFeedbackBlock><p>{teacher_override_notes}</p></TeacherFeedbackBlock>
                    </DetailItem>
                )}
              </>
            )}

            {student_reflection_text && (
                 <>
                    <Divider />
                    <CardHeader style={{fontSize: '1.1rem', borderBottom: 'none', marginBottom: '8px'}}>Your Saved Reflection</CardHeader>
                    <FeedbackBlock> 
                        <p>{student_reflection_text}</p>
                    </FeedbackBlock>
                 </>
            )}
          </AssessmentDetailsCard>
        </MainGrid>
      </Container>
    </PageWrapper>
  );
}// src/app/student/dashboard/rebuild.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { Container, Card, Button, Alert, Input } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// createClient import removed as it's not used in this component

// Styled components for dashboard
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const WelcomeHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  h1 {
    font-size: 2rem;
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
  }
  p {
    font-size: 1.1rem;
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const Section = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const JoinRoomSection = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  flex-direction: column;
  @media (min-width: 768px) {
    flex-direction: row;
    align-items: center;
  }
`;

const JoinRoomForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.md};
  width: 100%;
  
  @media (min-width: 768px) {
    flex-direction: row;
    align-items: center;
  }
`;

const JoinRoomInput = styled(Input)`
  text-transform: uppercase;
  letter-spacing: 0.1em;
  font-weight: 600;
  text-align: center;
  
  @media (min-width: 768px) {
    flex: 1;
    margin-right: ${({ theme }) => theme.spacing.md};
  }
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const RoomGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCard = styled(Card)`
  display: flex;
  flex-direction: column;
  justify-content: space-between; 
  h3 {
    font-size: 1.25rem;
    color: ${({ theme }) => theme.colors.primaryDark};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
  }
  .room-code {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.textMuted};
    font-family: ${({ theme }) => theme.fonts.mono};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }
  .chatbot-count {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
`;

const EmptyStateText = styled.p`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.lg} 0;
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 400px;
  gap: ${({ theme }) => theme.spacing.md};
`;

const AccountBanner = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  background-color: ${({ theme }) => theme.colors.primary}10;
  border: 1px solid ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
  
  p {
    margin: 0;
    color: ${({ theme }) => theme.colors.text};
  }
  
  strong {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const SuccessAccountBanner = styled(AccountBanner)`
  background-color: ${({ theme }) => theme.colors.green}10;
  border: 1px solid ${({ theme }) => theme.colors.green};
  
  strong {
    color: ${({ theme }) => theme.colors.green};
  }
`;

// Types for API responses
interface Room {
  room_id: string;
  room_name: string;
  room_code: string;
  is_active: boolean;
  created_at: string;
  teacher_id: string;
}

interface Chatbot {
  chatbot_id: string;
  name: string;
  bot_type: string;
}

interface RoomWithChatbots extends Room {
  chatbots: Chatbot[];
}

interface StudentProfile {
  user_id: string;
  full_name: string | null;
  email: string | null;
  is_anonymous?: boolean;
  username?: string;
  pin_code?: string;
}

// Main dashboard component
export default function RebuiltStudentDashboard() {
  const [studentProfile, setStudentProfile] = useState<StudentProfile | null>(null);
  const [rooms, setRooms] = useState<RoomWithChatbots[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [joinRoomCode, setJoinRoomCode] = useState('');
  const [isJoiningRoom, setIsJoiningRoom] = useState(false);
  const [joinRoomError, setJoinRoomError] = useState<string | null>(null);
  const [joinRoomSuccess, setJoinRoomSuccess] = useState<string | null>(null);
  const [isAnonymousUser, setIsAnonymousUser] = useState(false);
  
  const router = useRouter();
  // Create client but we don't use it directly since we use the API instead
  // (kept for potential future client-side auth needs)
  // const supabase = createClient();
  
  // Function to identify student
  const getStudentId = () => {
    // Check various sources for student ID
    const urlParams = new URLSearchParams(window.location.search);
    const urlUserId = urlParams.get('user_id'); // from dashboard redirect
    const urlUid = urlParams.get('uid');        // from chat/room redirect
    const storedDirectId = localStorage.getItem('student_direct_access_id');
    const storedCurrentId = localStorage.getItem('current_student_id');
    const storedPinLoginId = localStorage.getItem('direct_pin_login_user');
    
    console.log('[Dashboard] Looking for student ID:', {
      urlUserId,
      urlUid,
      storedDirectId,
      storedCurrentId,
      storedPinLoginId
    });
    
    // Return the first valid ID found
    const id = urlUserId || urlUid || storedDirectId || storedCurrentId || storedPinLoginId;
    
    // Also store the ID in localStorage for reliability
    if (id) {
      localStorage.setItem('student_direct_access_id', id);
      localStorage.setItem('current_student_id', id);
    }
    
    return id;
  };

  // Load student profile and rooms using API
  const loadDashboard = async () => {
    setLoading(true);
    setError(null);
    
    try {
      // Get student ID from various sources
      const studentId = getStudentId();
      console.log('Student ID:', studentId);
      
      // Check cookies for emergency access - another place to find student IDs
      const getEmergencyCookieValue = (name: string): string | null => {
        if (typeof document === 'undefined') return null;
        const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
        return match ? decodeURIComponent(match[2]) : null;
      };
      
      const emergencyUserId = getEmergencyCookieValue('emergency_user_id');
      if (emergencyUserId && !studentId) {
        console.log('[Dashboard] Found emergency_user_id cookie:', emergencyUserId);
        // Save it to localStorage for future use
        localStorage.setItem('student_direct_access_id', emergencyUserId);
        localStorage.setItem('current_student_id', emergencyUserId);
      }
      
      // Final ID check, using emergencyUserId as fallback
      const effectiveId = studentId || emergencyUserId;
      
      // Build the API URL - use direct endpoint for reliability
      let apiUrl = '/api/student/direct-dashboard';
      
      // Add studentId as a query parameter if available
      if (effectiveId) {
        apiUrl += `?userId=${effectiveId}`;
      } else {
        console.error('No student ID available');
        throw new Error('Cannot identify student. Please log in again.');
      }
      
      // Fetch dashboard data from API
      const response = await fetch(apiUrl, {
        credentials: 'include'
      });
      
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        
        // If not authenticated and no student ID found, redirect to login
        if (response.status === 401 && !studentId) {
          console.log('Not authenticated. Redirecting to login...');
          setTimeout(() => {
            router.push('/student-access');
          }, 3000);
          throw new Error('Not authenticated. Please log in.');
        }
        
        throw new Error(data.error || 'Failed to load dashboard data');
      }
      
      const data = await response.json();
      
      console.log('Dashboard data loaded:', data);
      
      // Set student profile
      if (data.profile) {
        setStudentProfile(data.profile);
        
        // Check if anonymous/temporary user
        // Directly use isAnonymous from API if available, otherwise determine from profile
        setIsAnonymousUser(
          data.isAnonymous === true || 
          !data.profile.pin_code || 
          !data.profile.username
        );
      } else if (data.studentProfile) {
        // Alternative API response format
        setStudentProfile(data.studentProfile);
        setIsAnonymousUser(data.isAnonymous === true);
      }
      
      // Set rooms
      if (data.rooms) {
        setRooms(data.rooms);
      } else if (data.joinedRooms) {
        // Alternative API response format - convert to our expected format
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        setRooms(data.joinedRooms.map((room: any) => ({
          ...room,
          is_active: true,
          teacher_id: '',
          created_at: room.joined_at
        })));
      } else {
        setRooms([]);
      }
      
    } catch (err) {
      console.error('Error in dashboard initialization:', err);
      setError(err instanceof Error ? err.message : 'Error initializing dashboard. Please try again.');
    } finally {
      setLoading(false);
    }
  };
  
  // Handle room joining
  const handleJoinRoom = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!joinRoomCode.trim()) {
      setJoinRoomError('Please enter a room code');
      return;
    }
    
    setIsJoiningRoom(true);
    setJoinRoomError(null);
    setJoinRoomSuccess(null);
    
    try {
      const studentId = getStudentId();
      
      if (!studentId && !studentProfile?.user_id) {
        setJoinRoomError('Cannot identify student. Please log in again.');
        setIsJoiningRoom(false);
        return;
      }
      
      const userId = studentId || studentProfile?.user_id;
      
      console.log('Joining room with user ID:', userId);
      
      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          room_code: joinRoomCode.trim().toUpperCase(),
          user_id: userId,
          student_name: studentProfile?.full_name || 'Student',
          skip_auth: true // Use direct access mode for reliability
        }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to join room');
      }
      
      setJoinRoomSuccess('Successfully joined room!');
      setJoinRoomCode('');
      
      // Store the returned user ID if provided
      if (data.userId) {
        localStorage.setItem('current_student_id', data.userId);
        localStorage.setItem('student_direct_access_id', data.userId);
      }
      
      // Refresh dashboard data
      loadDashboard();
      
    } catch (err) {
      console.error('Error joining room:', err);
      setJoinRoomError(err instanceof Error ? err.message : 'Failed to join room');
    } finally {
      setIsJoiningRoom(false);
    }
  };
  
  // Enter a specific room
  const enterRoom = (roomId: string) => {
    const studentId = getStudentId() || studentProfile?.user_id;
    if (!studentId) {
      setError('Cannot identify student. Please log in again.');
      return;
    }
    
    // Navigate to room page with all required parameters
    // The URL parameter could be either uid or student_id based on the server component
    router.push(`/room/${roomId}?direct=1&uid=${studentId}`);
  };
  
  // Initialize dashboard on load - called only once due to empty dependency array
  useEffect(() => {
    loadDashboard();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  
  // Show loading state
  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" />
            <p>Loading your dashboard...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }
  
  // Show error state
  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <Button 
            onClick={() => loadDashboard()} 
            style={{ marginTop: '16px' }}
          >
            Retry
          </Button>
        </Container>
      </PageWrapper>
    );
  }
  
  return (
    <PageWrapper>
      <Container>
        <WelcomeHeader>
          <h1>Welcome, {studentProfile?.full_name || 'Student'}!</h1>
          <p>
            {rooms.length > 0 
              ? `You have access to ${rooms.length} ${rooms.length === 1 ? 'classroom' : 'classrooms'} with ${rooms.reduce((total, room) => total + room.chatbots.length, 0)} chatbots.`
              : "You haven't joined any classrooms yet. Join one to get started!"
            }
          </p>
        </WelcomeHeader>
        
        {isAnonymousUser && (
          <AccountBanner>
            <div>
              <p><strong>Important:</strong> Your account is currently only accessible on this device.</p>
              <p>Create a PIN code to access your classrooms from any device.</p>
            </div>
            <Button as={Link} href="/student/pin-setup" variant="primary">
              Create PIN
            </Button>
          </AccountBanner>
        )}
        
        {!isAnonymousUser && studentProfile?.pin_code && studentProfile?.username && (
          <SuccessAccountBanner>
            <div>
              <p><strong>Account Info</strong></p>
              <p>Username: <strong>{studentProfile.username}</strong></p>
              <p>PIN Code: <strong>{studentProfile.pin_code}</strong></p>
              <p>Use these details to log in from any device.</p>
            </div>
          </SuccessAccountBanner>
        )}
        
        <JoinRoomSection>
          <div style={{ width: '100%' }}>
            <SectionTitle style={{ marginBottom: '1rem' }}>Join a New Classroom</SectionTitle>
            {joinRoomError && <Alert variant="error" style={{ marginBottom: '1rem' }}>{joinRoomError}</Alert>}
            {joinRoomSuccess && <Alert variant="success" style={{ marginBottom: '1rem' }}>{joinRoomSuccess}</Alert>}
            <JoinRoomForm onSubmit={handleJoinRoom}>
              <JoinRoomInput
                type="text"
                value={joinRoomCode}
                onChange={(e) => setJoinRoomCode(e.target.value.toUpperCase())}
                placeholder="Enter room code"
                maxLength={6}
              />
              <Button 
                type="submit" 
                disabled={isJoiningRoom} 
                variant="primary"
              >
                {isJoiningRoom ? 'Joining...' : 'Join Room'}
              </Button>
            </JoinRoomForm>
          </div>
        </JoinRoomSection>
        
        <Section>
          <SectionTitle>My Classrooms ({rooms.length})</SectionTitle>
          {rooms.length > 0 ? (
            <RoomGrid>
              {rooms.map(room => (
                <RoomCard key={room.room_id}>
                  <div>
                    <h3>{room.room_name}</h3>
                    <p className="room-code">Code: {room.room_code}</p>
                    <p className="chatbot-count">
                      {room.chatbots.length} {room.chatbots.length === 1 ? 'chatbot' : 'chatbots'} available
                    </p>
                  </div>
                  <Button 
                    onClick={() => enterRoom(room.room_id)} 
                    variant="primary" 
                    style={{width: '100%'}}
                  >
                    Enter Classroom
                  </Button>
                </RoomCard>
              ))}
            </RoomGrid>
          ) : (
            <EmptyStateText>
              You haven&apos;t joined any classrooms yet. Use the form above to join a classroom with a code.
            </EmptyStateText>
          )}
        </Section>
      </Container>
    </PageWrapper>
  );
}// src/app/student/dashboard/page.tsx
'use client';

// Import our completely redesigned dashboard component
import RebuiltStudentDashboard from './rebuild';

// This component simply renders the rebuilt dashboard
export default function StudentDashboardPage() {
  return <RebuiltStudentDashboard />;
}// src/app/student/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';
import StudentProfileCheck from '@/components/student/StudentProfileCheck';

const StudentLayout = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`;

export default function StudentLayoutWrapper({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    // Check if this is a direct redirect from login
    const url = new URL(window.location.href);
    const isDirectLoginRedirect = url.searchParams.has('_t');
    
    // If this is a direct login redirect, skip the usual checks to prevent loops
    if (isDirectLoginRedirect) {
      console.log('Direct login redirect detected - skipping auth check');
      setIsAuthorized(true);
      setIsLoading(false);
      return;
    }
    
    const checkAccess = async () => {
      console.log('Checking student access...');
      try {
        const { data: { user } } = await supabase.auth.getUser();
        console.log('Auth check result:', !!user);
        
        if (!user) {
          console.log('No user found, redirecting to login');
          // Redirect to the auth page with student login tab active instead of join
          router.push('/auth?login=student');
          return;
        }

        // Fetch user profile to check role
        const { data: profile, error } = await supabase
          .from('profiles')
          .select('role, username, pin_code')
          .eq('user_id', user.id)
          .single();

        console.log('User has authenticated, checking profile:', { 
          userId: user.id, 
          hasProfile: !!profile, 
          role: profile?.role,
          error: error?.message
        });

        // If there's no profile or the user is not a student, redirect to home
        if (!profile) {
          console.log('No profile found, creating one for user:', user.id);
          
          // Instead of redirecting, attempt to create a basic profile
          const { error: insertError } = await supabase
            .from('profiles')
            .insert({
              user_id: user.id,
              role: 'student',
              full_name: user.user_metadata?.full_name || 'Student',
              email: user.email
            });
            
          if (insertError) {
            console.error('Error creating profile:', insertError);
            router.push('/');
            return;
          }
        } else if (profile.role !== 'student') {
          console.log('User is not a student, redirecting to home');
          router.push('/');
          return;
        }

        setIsAuthorized(true);
      } catch (error) {
        console.error('Error checking access:', error);
        // Redirect to student login page instead of join
        router.push('/auth?login=student');
      } finally {
        setIsLoading(false);
      }
    };

    checkAccess();
  }, [router, supabase]);

  if (isLoading) {
    return (
      <LoadingOverlay>
        <div>Loading...</div>
      </LoadingOverlay>
    );
  }

  if (!isAuthorized) {
    return null; // Will redirect
  }

  return (
    <StudentLayout>
      {/* Add StudentProfileCheck to automatically repair profiles if needed */}
      <StudentProfileCheck />
      <MainContent>
        <Container>
          {children}
        </Container>
      </MainContent>
      <Footer />
    </StudentLayout>
  );
}'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, FormGroup, Label, Input, Button, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const SetupCard = styled(Card)`
  width: 100%;
  max-width: 450px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const Subtitle = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
  text-align: left;
`;

const HelpText = styled.div`
  font-size: 0.9rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
`;

const SuccessBox = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  background: ${({ theme }) => theme.colors.green}10;
  border: 1px solid ${({ theme }) => theme.colors.green};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  text-align: center;
`;

export default function StudentAccountSetup() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    // Validation
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      setIsLoading(false);
      return;
    }

    if (password.length < 6) {
      setError('Password must be at least 6 characters');
      setIsLoading(false);
      return;
    }

    try {
      // First get the current user
      const { data: userData, error: userError } = await supabase.auth.getUser();
      
      if (userError || !userData.user) {
        throw new Error('You must be logged in to set up your account');
      }

      // Update the user's email and password
      const { error: updateError } = await supabase.auth.updateUser({
        email: email,
        password: password
      });

      if (updateError) {
        throw updateError;
      }

      // Update the profile email as well
      const { error: profileError } = await supabase
        .from('profiles')
        .update({ email: email, is_anonymous: false })
        .eq('user_id', userData.user.id);

      if (profileError) {
        console.error('Error updating profile:', profileError);
      }

      setSuccess(true);
      
      // Redirect after a delay
      setTimeout(() => {
        router.push('/student/dashboard');
      }, 3000);
    } catch (err) {
      console.error('Error setting up student account:', err);
      setError(err instanceof Error ? err.message : 'Failed to set up account');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <PageWrapper>
      <SetupCard>
        <Title>Set Up Your Account</Title>
        <Subtitle>
          Create a permanent account to access your classrooms from any device. 
          Set your email and password below.
        </Subtitle>

        {error && <Alert variant="error">{error}</Alert>}
        
        {success ? (
          <SuccessBox>
            <h3>Account Successfully Created!</h3>
            <p>You can now use your email and password to log in from any device.</p>
            <p>Redirecting to your dashboard...</p>
            <LoadingSpinner size="small" />
          </SuccessBox>
        ) : (
          <Form onSubmit={handleSubmit}>
            <FormGroup>
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                placeholder="Enter your email"
                required
              />
              <HelpText>You&apos;ll use this email to log in to your account</HelpText>
            </FormGroup>
            
            <FormGroup>
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Create a password"
                required
              />
            </FormGroup>
            
            <FormGroup>
              <Label htmlFor="confirmPassword">Confirm Password</Label>
              <Input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                placeholder="Confirm your password"
                required
              />
            </FormGroup>
            
            <Button 
              type="submit" 
              disabled={isLoading} 
              style={{ width: '100%' }} 
              size="large"
            >
              {isLoading ? 'Setting Up...' : 'Create Account'}
            </Button>
          </Form>
        )}
      </SetupCard>
    </PageWrapper>
  );
}// src/app/student/page.tsx
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents'; // For basic layout if needed during redirect
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // For a brief loading display

const RedirectPageWrapper = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 80vh; // Take up most of the viewport
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
`;

const Message = styled.p`
  margin-top: ${({ theme }) => theme.spacing.lg};
  font-size: 1.1rem;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function StudentRedirectPage() {
  const router = useRouter();

  useEffect(() => {
    // Perform the redirect as soon as the component mounts
    console.log('[Student Page] Redirecting to /student/dashboard...');
    router.replace('/student/dashboard'); // Use replace to not add this page to history
  }, [router]);

  // Display a loading/redirecting message while the redirect happens
  return (
    <Container>
      <RedirectPageWrapper>
        <LoadingSpinner size="large" />
        <Message>Redirecting to your dashboard...</Message>
      </RedirectPageWrapper>
    </Container>
  );
}'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, FormGroup, Label, Input, Button, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 80vh;
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const SetupCard = styled(Card)`
  width: 100%;
  max-width: 450px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const Subtitle = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
  text-align: left;
`;

const HelpText = styled.div`
  font-size: 0.9rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
`;

const SuccessBox = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  background: ${({ theme }) => theme.colors.green}10;
  border: 1px solid ${({ theme }) => theme.colors.green};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  text-align: center;
`;

const PinDisplay = styled.div`
  margin: ${({ theme }) => theme.spacing.xl} 0;
  padding: ${({ theme }) => theme.spacing.lg};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border: 2px dashed ${({ theme }) => theme.colors.primary};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2.5rem;
  font-weight: bold;
  letter-spacing: 0.5rem;
  color: ${({ theme }) => theme.colors.primary};
`;

const UsernameBadge = styled.div`
  display: inline-block;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.primary}10;
  border: 1px solid ${({ theme }) => theme.colors.primary};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  font-weight: bold;
  color: ${({ theme }) => theme.colors.primary};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

export default function StudentPinSetup() {
  // Username is now computed from full_name instead of being tracked separately
  // const [username, setUsername] = useState('');
  const [pin, setPin] = useState('');
  const [confirmPin, setConfirmPin] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const [generatedPin, setGeneratedPin] = useState<string | null>(null);
  const [currentUsername, setCurrentUsername] = useState<string | null>(null);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    // Fetch the current user's details
    const fetchUserDetails = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          router.push('/');
          return;
        }

        // Get their profile details
        const { data: profile } = await supabase
          .from('profiles')
          .select('full_name')
          .eq('user_id', user.id)
          .single();

        if (profile?.full_name) {
          // Use the user's name as their username but simplified
          // Remove spaces and special characters, convert to lowercase
          const simplifiedName = profile.full_name
            .toLowerCase()
            .replace(/[^a-z0-9]/g, '')
            .substring(0, 15); // Limit to 15 chars
            
          setCurrentUsername(simplifiedName);
        }
      } catch (err) {
        console.error('Error fetching user details:', err);
      }
    };

    fetchUserDetails();
  }, [supabase, router]);

  // Generate a random 4-digit PIN
  const generateRandomPin = () => {
    // Generate a 4-digit PIN
    const newPin = Math.floor(1000 + Math.random() * 9000).toString();
    setGeneratedPin(newPin);
    setPin(newPin);
    setConfirmPin(newPin);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    // Validation
    if (pin !== confirmPin) {
      setError('PINs do not match');
      setIsLoading(false);
      return;
    }

    if (pin.length !== 4 || !/^\d{4}$/.test(pin)) {
      setError('PIN must be exactly 4 digits');
      setIsLoading(false);
      return;
    }

    try {
      // First get the current user
      const { data: userData, error: userError } = await supabase.auth.getUser();
      
      if (userError || !userData.user) {
        throw new Error('You must be logged in to set up your PIN');
      }

      // Set the PIN and username in the user's metadata
      const { error: updateError } = await supabase.auth.updateUser({
        data: {
          pin_code: pin,
          username: currentUsername
        }
      });

      if (updateError) {
        throw updateError;
      }

      // Update the profile with the PIN as well
      const { error: profileError } = await supabase
        .from('profiles')
        .update({ 
          pin_code: pin, 
          username: currentUsername,
          is_anonymous: false 
        })
        .eq('user_id', userData.user.id);

      if (profileError) {
        console.error('Error updating profile:', profileError);
        throw new Error('Error updating profile');
      }

      setSuccess(true);
      
      // Redirect after a delay
      setTimeout(() => {
        router.push('/student/dashboard');
      }, 5000);
    } catch (err) {
      console.error('Error setting up PIN:', err);
      setError(err instanceof Error ? err.message : 'Failed to set up PIN');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <PageWrapper>
      <SetupCard>
        <Title>Set Up Your Access Code</Title>
        <Subtitle>
          Create a simple PIN code to access your classrooms from any device.
        </Subtitle>

        {error && <Alert variant="error">{error}</Alert>}
        
        {success ? (
          <SuccessBox>
            <h3>PIN Successfully Created!</h3>
            <p>Remember your username and PIN to log in from any device:</p>
            <UsernameBadge>{currentUsername}</UsernameBadge>
            <PinDisplay>{pin}</PinDisplay>
            <p>This is the only time you&apos;ll see your PIN, so write it down or memorize it.</p>
            <p>Redirecting to your dashboard in a few seconds...</p>
            <LoadingSpinner size="small" />
          </SuccessBox>
        ) : (
          <>
            {currentUsername && (
              <div style={{ marginBottom: '1.5rem' }}>
                <h3>Your Username</h3>
                <UsernameBadge>{currentUsername}</UsernameBadge>
                <HelpText>This username is based on your name and will be used to log in</HelpText>
              </div>
            )}
            
            <Form onSubmit={handleSubmit}>
              <FormGroup>
                <Label htmlFor="pin">4-Digit PIN</Label>
                <div style={{ display: 'flex', gap: '1rem', marginBottom: '0.5rem' }}>
                  <Input
                    id="pin"
                    type="text"
                    value={pin}
                    onChange={(e) => {
                      const value = e.target.value.replace(/\D/g, '').substring(0, 4);
                      setPin(value);
                    }}
                    placeholder="4-digit PIN"
                    maxLength={4}
                    inputMode="numeric"
                    pattern="\d{4}"
                    required
                    style={{ textAlign: 'center', letterSpacing: '0.5rem', fontWeight: 'bold' }}
                  />
                  <Button 
                    type="button" 
                    variant="outline"
                    onClick={generateRandomPin}
                  >
                    Generate
                  </Button>
                </div>
                <HelpText>Choose a 4-digit PIN code that you can easily remember</HelpText>
              </FormGroup>
              
              <FormGroup>
                <Label htmlFor="confirmPin">Confirm PIN</Label>
                <Input
                  id="confirmPin"
                  type="text"
                  value={confirmPin}
                  onChange={(e) => {
                    const value = e.target.value.replace(/\D/g, '').substring(0, 4);
                    setConfirmPin(value);
                  }}
                  placeholder="Confirm 4-digit PIN"
                  maxLength={4}
                  inputMode="numeric"
                  pattern="\d{4}"
                  required
                  style={{ textAlign: 'center', letterSpacing: '0.5rem', fontWeight: 'bold' }}
                />
              </FormGroup>
              
              {generatedPin && (
                <Alert variant="info" style={{ marginBottom: '1.5rem' }}>
                  A PIN has been generated for you: <strong>{generatedPin}</strong>. Write this down or memorize it.
                </Alert>
              )}
              
              <Button 
                type="submit" 
                disabled={isLoading} 
                style={{ width: '100%' }} 
                size="large"
              >
                {isLoading ? 'Setting Up...' : 'Create PIN'}
              </Button>
            </Form>
          </>
        )}
      </SetupCard>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/assessments/[assessmentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// createClient is not strictly needed here anymore if PATCH is via API route,
// but keeping it in case you want direct client-side Supabase calls for other things.
// import { createClient } from '@/lib/supabase/client'; 
import {
    Container, Card, Button, Alert, Badge,
    FormGroup, Label, Input, TextArea,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type {
    StudentAssessment,
    ChatMessage as DbChatMessage,
    AssessmentStatusEnum
} from '@/types/database.types';

interface DetailedAssessmentData extends StudentAssessment {
    student_name?: string | null;
    student_email?: string | null;
    chatbot_name?: string | null;
    assessed_conversation?: DbChatMessage[];
}

// ... (Styled Components: PageWrapper, Header, PageTitle, BackButton, MainGrid, etc. remain THE SAME as in content-reply-032)
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const PageTitle = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.8rem;
`;

const BackButton = styled(Button)``;

const MainGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr; 
  gap: ${({ theme }) => theme.spacing.xl};
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    grid-template-columns: 1fr; 
  }
`;

const ConversationContextCard = styled(Card)`
  max-height: 75vh; 
  display: flex;
  flex-direction: column;
  overflow: hidden; 
`;

const CardHeader = styled.h2`
  padding-bottom: ${({ theme }) => theme.spacing.md};
  margin: 0 0 ${({ theme }) => theme.spacing.md} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  font-size: 1.3rem;
  color: ${({ theme }) => theme.colors.text};
`;

const MessagesList = styled.div`
  flex-grow: 1;
  overflow-y: auto;
  padding-right: ${({ theme }) => theme.spacing.sm}; 
`;

const AssessmentDetailsCard = styled(Card)`
  align-self: start; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    margin-top: ${({ theme }) => theme.spacing.xl};
  }
`;

const DetailItem = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-size: 0.9rem;
  line-height: 1.5;
  strong { 
    display: block; font-weight: 600; color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.xs}; font-size: 0.8rem;
    text-transform: uppercase; letter-spacing: 0.03em;
  }
  span, p, div.content { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; }
  p { margin: 0; }
`;

const AnalysisBlock = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  font-size: 0.875rem;
  margin-top: ${({ theme }) => theme.spacing.xs};
  ul { list-style-position: inside; padding-left: ${({ theme }) => theme.spacing.sm}; margin-top: ${({ theme }) => theme.spacing.xs}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }
`;

const TeacherReviewForm = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;

// Simple Divider styled-component
const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.lg} 0;
`;


export default function AssessmentDetailPage() {
  const [assessment, setAssessment] = useState<DetailedAssessmentData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [teacherGrade, setTeacherGrade] = useState('');
  const [teacherNotes, setTeacherNotes] = useState('');
  const [currentStatus, setCurrentStatus] = useState<AssessmentStatusEnum>('ai_processing'); // Default
  const [isSubmittingReview, setIsSubmittingReview] = useState(false);
  const [reviewError, setReviewError] = useState<string | null>(null);
  const [reviewSuccess, setReviewSuccess] = useState<string | null>(null);

  const params = useParams();
  const router = useRouter();
  // const supabase = createClient(); // Not needed if PATCH is through API route
  const assessmentId = params?.assessmentId as string;

  const fetchAssessmentDetails = useCallback(async () => {
    if (!assessmentId) { /* ... */ setError("Assessment ID is missing."); setLoading(false); return; }
    setLoading(true); setError(null);
    try {
      const response = await fetch(`/api/teacher/assessments?assessmentId=${assessmentId}`);
      if (!response.ok) { /* ... error handling ... */ throw new Error('Failed to fetch assessment details'); }
      const data: DetailedAssessmentData = await response.json();
      setAssessment(data);
      setTeacherGrade(data.teacher_override_grade || data.ai_grade_raw || '');
      setTeacherNotes(data.teacher_override_notes || '');
      setCurrentStatus(data.status || 'ai_completed'); // Default to ai_completed if status is null
    } catch (err) { /* ... error handling ... */ setError(err instanceof Error ? err.message : 'Could not load details.'); }
    finally { setLoading(false); }
  }, [assessmentId]);

  useEffect(() => {
    if (assessmentId) { // Ensure assessmentId is present before fetching
        fetchAssessmentDetails();
    } else {
        setError("Assessment ID not found in URL.");
        setLoading(false);
    }
  }, [assessmentId, fetchAssessmentDetails]); // fetchAssessmentDetails is stable due to useCallback

  // ***** UPDATED handleReviewSubmit *****
  const handleReviewSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!assessment) return;

    setIsSubmittingReview(true);
    setReviewError(null);
    setReviewSuccess(null);

    const payload = {
        teacher_override_grade: teacherGrade.trim() === '' ? null : teacherGrade.trim(),
        teacher_override_notes: teacherNotes.trim() === '' ? null : teacherNotes.trim(),
        status: currentStatus,
    };

    try {
        const response = await fetch(`/api/teacher/assessments?assessmentId=${assessment.assessment_id}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
        });

        const responseData = await response.json();

        if (!response.ok) {
            throw new Error(responseData.error || 'Failed to save teacher review.');
        }

        setReviewSuccess("Teacher review saved successfully!");
        // Update local assessment state with the successfully saved data from the API response
        setAssessment(prev => prev ? ({ ...prev, ...responseData }) : null); 
        // Or, if you prefer to update fields directly from form state:
        // setAssessment(prev => prev ? ({
        //     ...prev,
        //     teacher_override_grade: payload.teacher_override_grade,
        //     teacher_override_notes: payload.teacher_override_notes,
        //     status: payload.status,
        //     updated_at: new Date().toISOString() // Or use updated_at from responseData
        // }) : null);

    } catch (err) {
        setReviewError(err instanceof Error ? err.message : 'An unknown error occurred.');
    } finally {
        setIsSubmittingReview(false);
    }
  };
  // ***** END OF UPDATED handleReviewSubmit *****


  if (loading) { /* ... loading UI ... */ }
  if (error) { /* ... error UI ... */ }
  if (!assessment) { /* ... no assessment UI ... */ }

  // (Make sure to destructure all fields you need from assessment)
  const student_name = assessment?.student_name;
  const student_email = assessment?.student_email;
  const chatbot_name = assessment?.chatbot_name;
  const assessed_at = assessment?.assessed_at;
  const teacher_assessment_criteria_snapshot = assessment?.teacher_assessment_criteria_snapshot;
  const ai_feedback_student = assessment?.ai_feedback_student;
  const ai_grade_raw = assessment?.ai_grade_raw;
  const ai_assessment_details_teacher = assessment?.ai_assessment_details_teacher;
  const assessed_conversation = assessment?.assessed_conversation;


  return (
    <PageWrapper>
      <Container>
        <Header>
          <PageTitle>Review Assessment: {student_name || 'Student'}</PageTitle>
          <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard/assessments')}>
            {'<'} All Assessments
          </BackButton>
        </Header>

        <MainGrid>
          <ConversationContextCard>
            {/* ... Conversation display ... */}
            <CardHeader>Assessed Conversation Snippet</CardHeader>
            <MessagesList>
              {assessed_conversation && assessed_conversation.length > 0 ? (
                assessed_conversation.map(msg => (
                  <ChatMessageComponent
                    key={msg.message_id}
                    message={msg}
                    chatbotName={chatbot_name || 'Assessment Bot'}
                  />
                ))
              ) : (
                <p>No conversation snippet available for this assessment.</p>
              )}
            </MessagesList>
          </ConversationContextCard>

          <AssessmentDetailsCard>
            <CardHeader>AI Assessment & Teacher Review</CardHeader>
            {/* ... Display of assessment details (student, bot, criteria, AI grade, AI feedback, AI analysis) ... */}
            {/* This part remains largely the same as in content-reply-032 */}
            <DetailItem><strong>Student:</strong> <span>{student_name || 'N/A'} ({student_email || 'No email'})</span></DetailItem>
            <DetailItem><strong>Assessment Bot:</strong> <span>{chatbot_name || 'N/A'}</span></DetailItem>
            <DetailItem>
              <strong>Assessed On:</strong>
              <span>
                {assessed_at ? new Date(assessed_at).toLocaleString() : 'N/A'}
              </span>
            </DetailItem>
            <DetailItem><strong>Teacher&apos;s Criteria Used:</strong> <p style={{whiteSpace: 'pre-wrap', fontStyle: 'italic', color: '#555'}}>{teacher_assessment_criteria_snapshot || 'N/A'}</p></DetailItem>
            
            <Divider />
            <CardHeader style={{fontSize: '1.1rem', marginTop:'1rem', borderBottom: 'none'}}>AI Generated Assessment</CardHeader>
            <DetailItem><strong>AI Suggested Grade:</strong> <Badge variant={ai_grade_raw?.toLowerCase().includes('error') ? 'error' : 'default'}>{ai_grade_raw || 'Not graded by AI'}</Badge></DetailItem>
            <DetailItem><strong>AI Feedback to Student:</strong> <p>{ai_feedback_student || 'No AI feedback provided.'}</p></DetailItem>
            
            {ai_assessment_details_teacher && (
              <DetailItem>
                <strong>AI Analysis for Teacher:</strong>
                <AnalysisBlock>
                  {ai_assessment_details_teacher.summary && <p><strong>Summary:</strong> {ai_assessment_details_teacher.summary}</p>}
                  {ai_assessment_details_teacher.strengths && ai_assessment_details_teacher.strengths.length > 0 && ( <> <p style={{marginTop: '8px'}}><strong>Strengths:</strong></p> <ul>{ai_assessment_details_teacher.strengths.map((s, i) => <li key={`s-${i}`}>{s}</li>)}</ul> </> )}
                  {ai_assessment_details_teacher.areas_for_improvement && ai_assessment_details_teacher.areas_for_improvement.length > 0 && ( <> <p style={{marginTop: '8px'}}><strong>Areas for Improvement:</strong></p> <ul>{ai_assessment_details_teacher.areas_for_improvement.map((a, i) => <li key={`a-${i}`}>{a}</li>)}</ul> </> )}
                  {ai_assessment_details_teacher.grading_rationale && <p style={{marginTop: '8px'}}><strong>Rationale:</strong> {ai_assessment_details_teacher.grading_rationale}</p>}
                </AnalysisBlock>
              </DetailItem>
            )}

            <TeacherReviewForm onSubmit={handleReviewSubmit}>
              <CardHeader style={{fontSize: '1.1rem', borderBottom: 'none'}}>Teacher&apos;s Review & Override</CardHeader>
              {reviewError && <Alert variant="error">{reviewError}</Alert>}
              {reviewSuccess && <Alert variant="success">{reviewSuccess}</Alert>}
              <FormGroup>
                <Label htmlFor="teacherGrade">Override Grade (optional)</Label>
                <Input type="text" id="teacherGrade" value={teacherGrade} onChange={(e) => setTeacherGrade(e.target.value)} placeholder="e.g., B+, 9/10, Meets Standard" />
              </FormGroup>
              <FormGroup>
                <Label htmlFor="teacherNotes">Teacher Notes/Feedback (optional)</Label>
                <TextArea id="teacherNotes" value={teacherNotes} onChange={(e) => setTeacherNotes(e.target.value)} rows={4} placeholder="Your observations, final feedback, or notes for records..." />
              </FormGroup>
              <FormGroup>
                <Label htmlFor="assessmentStatus">Update Status</Label>
                <StyledSelect id="assessmentStatus" value={currentStatus} onChange={(e) => setCurrentStatus(e.target.value as AssessmentStatusEnum)}>
                    {/* Keep ai_processing if you want teachers to manually move it out of this state */}
                    {/* <option value="ai_processing">AI Processing</option>  */}
                    <option value="ai_completed">AI Completed (Ready for Review)</option>
                    <option value="teacher_reviewed">Teacher Reviewed</option>
                </StyledSelect>
              </FormGroup>
              <Button type="submit" disabled={isSubmittingReview} style={{width: '100%'}}>
                {isSubmittingReview ? 'Saving Review...' : 'Save Teacher Review'}
              </Button>
            </TeacherReviewForm>
          </AssessmentDetailsCard>
        </MainGrid>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/assessments/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation'; // For linking to detail page
import {
    Container, Card, Button, Alert, Badge,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types from your database.types.ts
import type { AssessmentListSummary, PaginatedAssessmentsResponse, AssessmentStatusEnum } from '@/types/database.types';

// Styled Components for this page
const PageWrapper = styled(Container)` // Use Container as base
  padding-top: ${({ theme }) => theme.spacing.xl};
  padding-bottom: ${({ theme }) => theme.spacing.xl};
`;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;



const PageTitle = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto; /* Enable horizontal scrolling on smaller viewports */
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; /* Ensure table has a minimum width */
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    white-space: nowrap; /* Prevent text wrapping in cells initially */
  }

  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
  }

  td {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.text};
  }

  td.actions {
    white-space: nowrap;
    width: 1%; /* Allow this column to be just wide enough for content */
  }
  
  .truncate {
    max-width: 150px; /* Adjust as needed */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const PaginationControls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const EmptyStateCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
`;

// Helper to get display text for status
const getStatusText = (status?: AssessmentStatusEnum): string => {
    if (!status) return 'N/A';
    switch (status) {
        case 'ai_processing': return 'AI Processing';
        case 'ai_completed': return 'AI Completed (Ready for Review)';
        case 'teacher_reviewed': return 'Teacher Reviewed';
        default: return status;
    }
};
const getStatusBadgeVariant = (status?: AssessmentStatusEnum): 'success' | 'warning' | 'error' | 'default' => {
    if (!status) return 'default';
    switch (status) {
        case 'ai_processing': return 'default';
        case 'ai_completed': return 'warning'; // Yellow/Orange indicating action needed
        case 'teacher_reviewed': return 'success';
        default: return 'default';
    }
};


export default function AssessmentsListPage() {
  const [assessments, setAssessments] = useState<AssessmentListSummary[]>([]);
  const [pagination, setPagination] = useState({
    currentPage: 0,
    pageSize: 10,
    totalCount: 0,
    totalPages: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [statusFilter, setStatusFilter] = useState<AssessmentStatusEnum | ''>(''); // Empty string for 'all'

  const router = useRouter();

  const fetchAssessments = useCallback(async (pageToFetch: number, currentStatusFilter: AssessmentStatusEnum | '') => {
    setLoading(true);
    setError(null);
    console.log(`[AssessmentsPage] Fetching assessments. Page: ${pageToFetch}, Status: ${currentStatusFilter || 'all'}`);

    try {
      const queryParams = new URLSearchParams({
        page: pageToFetch.toString(),
        limit: pagination.pageSize.toString(),
      });
      if (currentStatusFilter) {
        queryParams.append('status', currentStatusFilter);
      }

      const response = await fetch(`/api/teacher/assessments?${queryParams.toString()}`);
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch assessments (status ${response.status})`);
      }
      const data: PaginatedAssessmentsResponse = await response.json();
      setAssessments(data.assessments || []);
      setPagination(data.pagination || { currentPage: 0, pageSize: 10, totalCount: 0, totalPages: 0 });
    } catch (err) {
      console.error("Error fetching assessments:", err);
      setError(err instanceof Error ? err.message : 'Could not load assessments.');
      setAssessments([]); // Clear on error
    } finally {
      setLoading(false);
    }
  }, [pagination.pageSize]); // pageSize can be a dependency if you allow changing it

  useEffect(() => {
    fetchAssessments(0, statusFilter); // Fetch initial page on mount or when filter changes
  }, [statusFilter, fetchAssessments]); // fetchAssessments is stable due to useCallback

  const handlePageChange = (newPage: number) => {
    if (newPage >= 0 && newPage < pagination.totalPages) {
      fetchAssessments(newPage, statusFilter);
    }
  };

  const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setStatusFilter(e.target.value as AssessmentStatusEnum | '');
    // useEffect will trigger refetch due to statusFilter change
  };

  const handleViewDetails = (assessmentId: string) => {
    router.push(`/teacher-dashboard/assessments/${assessmentId}`);
  };

  if (loading && assessments.length === 0) { // Show full page loader only on initial load
    return (
      <PageWrapper>
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner size="large" />
          <p>Loading assessments...</p>
        </Card>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <PageHeader>
        <PageTitle>Student Assessments</PageTitle>
        {/* Add a button to create new assessment type or similar if needed in future */}
      </PageHeader>

      <FilterControls>
        <label htmlFor="statusFilter">Filter by Status:</label>
        <StyledSelect id="statusFilter" value={statusFilter} onChange={handleFilterChange} disabled={loading}>
          <option value="">All Statuses</option>
          <option value="ai_processing">AI Processing</option>
          <option value="ai_completed">AI Completed (Ready for Review)</option>
          <option value="teacher_reviewed">Teacher Reviewed</option>
        </StyledSelect>
      </FilterControls>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      
      {loading && assessments.length > 0 && <Alert variant='info' style={{textAlign:'center'}}>Loading more...</Alert>} {/* Subtle loading more indicator */}


      {!loading && assessments.length === 0 && !error ? (
        <EmptyStateCard>
          <h3>No Assessments Found</h3>
          <p>There are no assessments matching your current filters, or no assessments have been processed yet.</p>
        </EmptyStateCard>
      ) : assessments.length > 0 ? (
        <Card> {/* Wrap table in a card for consistent styling */}
          <TableContainer>
            <Table>
              <thead>
                <tr>
                  <th>Student</th>
                  <th>Room</th>
                  <th>Assessment Bot</th>
                  <th>AI Grade</th>
                  <th>Teacher Grade</th>
                  <th>Status</th>
                  <th>Date Assessed</th>
                  <th className="actions">Actions</th>
                </tr>
              </thead>
              <tbody>
                {assessments.map((asmnt) => (
                  <tr key={asmnt.assessment_id}>
                    <td className="truncate" title={asmnt.student_name || undefined}>{asmnt.student_name || 'N/A'}</td>
                    <td className="truncate" title={asmnt.room_name || undefined}>{asmnt.room_name || 'N/A'}</td>
                    <td className="truncate" title={asmnt.chatbot_name || undefined}>{asmnt.chatbot_name || 'N/A'}</td>
                    <td>{asmnt.ai_grade_raw || '-'}</td>
                    <td>{asmnt.teacher_override_grade || '-'}</td>
                    <td>
                      <Badge variant={getStatusBadgeVariant(asmnt.status)}>
                        {getStatusText(asmnt.status)}
                      </Badge>
                    </td>
                    <td>{new Date(asmnt.assessed_at).toLocaleDateString()}</td>
                    <td className="actions">
                      <Button size="small" onClick={() => handleViewDetails(asmnt.assessment_id)}>
                        Review Details
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </Table>
          </TableContainer>
        </Card>
      ) : null}

      {pagination.totalPages > 1 && (
        <PaginationControls>
          <Button
            onClick={() => handlePageChange(pagination.currentPage - 1)}
            disabled={pagination.currentPage === 0 || loading}
            variant="outline"
          >
            Previous
          </Button>
          <span>
            Page {pagination.currentPage + 1} of {pagination.totalPages}
          </span>
          <Button
            onClick={() => handlePageChange(pagination.currentPage + 1)}
            disabled={pagination.currentPage >= pagination.totalPages - 1 || loading}
            variant="outline"
          >
            Next
          </Button>
        </PaginationControls>
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient as createStandardSupabaseClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';
import TeacherNav from '@/components/teacher/TeacherNav';
import TeacherProfileCheck from '@/components/auth/teacherProfileCheck';

const DashboardLayoutContainer = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0; 
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.textLight};
  z-index: 1000;
`;

type AuthStatus = 'loading' | 'authorized' | 'unauthorized';

export default function TeacherDashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [authStatus, setAuthStatus] = useState<AuthStatus>('loading');
  const router = useRouter();
  const supabase = createStandardSupabaseClient();

  useEffect(() => {
    console.log('[TDL] useEffect for auth check triggered.');

    const checkAuth = async (sessionUser: User | null) => {
      if (sessionUser) {
        console.log('[TDL] User found. Fetching profile for user_id:', sessionUser.id);
        try {
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', sessionUser.id)
            .single();

          if (profileError) {
            console.error('[TDL] Profile fetch error:', profileError.message, 'Redirecting to /auth.');
            setAuthStatus('unauthorized');
            router.push('/auth');
          } else if (profile && profile.role === 'teacher') {
            console.log('[TDL] User is teacher. Authorized.');
            setAuthStatus('authorized');
          } else {
            console.log('[TDL] User is not teacher or profile missing. Unauthorized. Redirecting to /.');
            setAuthStatus('unauthorized');
            router.push('/');
          }
        } catch (e) {
          console.error('[TDL] Exception during profile fetch:', e, 'Redirecting to /auth.');
          setAuthStatus('unauthorized');
          router.push('/auth');
        }
      } else {
        console.log('[TDL] No user in session. Unauthorized. Redirecting to /auth.');
        setAuthStatus('unauthorized');
        router.push('/auth');
      }
    };

    // Initial check
    supabase.auth.getSession().then(({ data: { session } }) => {
        console.log('[TDL] Initial getSession result:', session);
        // Only process if onAuthStateChange hasn't already set a definitive state
        if (authStatus === 'loading') { // Check current authStatus
            checkAuth(session?.user || null);
        }
    });
    
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log(`[TDL] onAuthStateChange event: ${event}`, session);
        // Re-check auth whenever the state changes
        // This will also handle the INITIAL_SESSION event which is often the first one on load
        checkAuth(session?.user || null);
      }
    );

    return () => {
      console.log('[TDL] Unsubscribing from onAuthStateChange.');
      authListener.subscription?.unsubscribe();
    };
  }, [router, supabase, authStatus]); // Added authStatus to deps to re-evaluate if it changes to loading by another means

  console.log('[TDL] Render. AuthStatus:', authStatus);

  if (authStatus === 'loading') {
    return (
      <LoadingOverlay>
        <div>Loading Teacher Dashboard (Auth)...</div>
      </LoadingOverlay>
    );
  }

  if (authStatus === 'unauthorized') {
    console.log('[TDL] Rendering null because unauthorized (redirect initiated).');
    return null; 
  }

  // authStatus === 'authorized'
  console.log('[TDL] Rendering dashboard content.');
  return (
    <DashboardLayoutContainer>
      {/* Add the profile check component that will automatically repair
          teacher profiles if needed */}
      <TeacherProfileCheck />
      <Container>
        <TeacherNav />
        <MainContent>
            {children}
        </MainContent>
      </Container>
      <Footer />
    </DashboardLayoutContainer>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/edit/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useParams, useRouter } from 'next/navigation';
import styled from 'styled-components';
import {
    Container, Card, Button, FormGroup, Label, Input, TextArea, Alert,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Chatbot, Document as KnowledgeDocument, BotTypeEnum as BotType, CreateChatbotPayload } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const HeaderControls = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const BackButton = styled(Button)`
  margin-right: ${({ theme }) => theme.spacing.lg};
`;

const MainTitle = styled.h1`
    font-size: 1.8rem;
    color: ${({ theme }) => theme.colors.text};
`;

const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  input[type="checkbox"] {
    width: 1.15em;
    height: 1.15em;
    cursor: pointer;
  }
`;

const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.xl} 0;
`;

const SectionTitle = styled.h2`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 1.5rem;
`;

const LoadingCard = styled(Card)`
    text-align: center;
    padding: ${({ theme }) => theme.spacing.xl};
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: ${({ theme }) => theme.spacing.md};
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const AssessmentCriteriaSection = styled(FormGroup)`
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
`;

const RubricInfoText = styled(HelpText)`
  font-style: italic;
  margin-top: ${({ theme }) => theme.spacing.md};
`;

const LoadingStateContainer = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
    padding: ${({ theme }) => theme.spacing.lg};
    color: ${({ theme }) => theme.colors.textLight};
`;

// MODIFIED: Styled component for URL input section
const UrlInputSection = styled.div`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  padding: ${({ theme }) => theme.spacing.lg};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background}; // Slightly different background
`;

const UrlInputForm = styled.form`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: flex-start; // Align items to the start for better layout with potential error messages

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
  }
`;

const UrlInput = styled(Input)`
  flex-grow: 1;
`;

const AddUrlButton = styled(Button)`
  white-space: nowrap; // Prevent button text from wrapping
  min-width: 120px; // Ensure button has a decent minimum width

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;


const initialChatbotState: Chatbot = {
    chatbot_id: '',
    name: '',
    description: '',
    system_prompt: `You are a helpful AI assistant.`,
    teacher_id: '',
    model: 'openai/gpt-4.1-nano',
    max_tokens: 1000,
    temperature: 0.7,
    enable_rag: false,
    bot_type: 'learning',
    assessment_criteria_text: null,
    welcome_message: null,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
};

export default function ConfigureChatbotPage() {
  const [chatbot, setChatbot] = useState<Chatbot>(initialChatbotState);
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [isCreateMode, setIsCreateMode] = useState(false);
  const [pageLoading, setPageLoading] = useState(true);
  const [docsLoading, setDocsLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);
  const [docsError, setDocsError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  // MODIFIED: Added states for URL input
  const [webpageUrl, setWebpageUrl] = useState('');
  const [isAddingUrl, setIsAddingUrl] = useState(false);
  const [urlError, setUrlError] = useState<string | null>(null);


  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotIdFromParams = params?.chatbotId as string;

  const fetchChatbotData = useCallback(async (id: string, teacherId: string) => {
    setFormError(null);
    try {
      const { data, error } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', id)
        .eq('teacher_id', teacherId)
        .single();

      if (error) throw error;
      if (!data) throw new Error('Chatbot not found or you do not have permission.');

      const fetchedData = data as Chatbot;
      if (!fetchedData.bot_type) {
        fetchedData.bot_type = 'learning';
      }
      fetchedData.welcome_message = fetchedData.welcome_message || null;
      setChatbot(fetchedData);

    } catch (err) {
      setFormError(err instanceof Error ? err.message : 'Failed to load chatbot data.');
      setChatbot(initialChatbotState);
    } finally {
      setPageLoading(false);
    }
  }, [supabase]);

  useEffect(() => {
    const initializePage = async () => {
        setPageLoading(true);
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
            router.push('/auth');
            return;
        }
        setCurrentUserId(user.id);

        if (chatbotIdFromParams === 'new') {
            setIsCreateMode(true);
            setChatbot({ ...initialChatbotState, teacher_id: user.id });
            setDocuments([]);
            setPageLoading(false);
        } else {
            setIsCreateMode(false);
            await fetchChatbotData(chatbotIdFromParams, user.id);
        }
    };
    if (chatbotIdFromParams) {
        initializePage();
    }
  }, [chatbotIdFromParams, router, supabase, fetchChatbotData]);

  const fetchDocumentsData = useCallback(async (currentChatbotId: string) => {
    if (!currentChatbotId) return;
    setDocsLoading(true);
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/documents?chatbotId=${currentChatbotId}`);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
        throw new Error(errorData.error || `Failed to fetch documents (status ${response.status})`);
      }
      const dataResult: KnowledgeDocument[] = await response.json();
      setDocuments(dataResult);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not load documents.');
    } finally {
      setDocsLoading(false);
    }
  }, []);

  useEffect(() => {
    if (!isCreateMode && chatbot.chatbot_id && chatbot.bot_type === 'learning' && chatbot.enable_rag) {
        fetchDocumentsData(chatbot.chatbot_id);
    } else if (!isCreateMode && chatbot.chatbot_id && (chatbot.bot_type !== 'learning' || !chatbot.enable_rag)) {
        setDocuments([]);
    }
  }, [chatbot.chatbot_id, chatbot.bot_type, chatbot.enable_rag, isCreateMode, fetchDocumentsData]);


  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!currentUserId) {
        setFormError("User session expired. Please refresh.");
        return;
    }

    setSaving(true);
    setFormError(null);
    setSuccessMessage(null);

    const currentBotType = chatbot.bot_type || 'learning';

    const supabaseUpdatePayload: Partial<Omit<Chatbot, 'chatbot_id' | 'created_at' | 'updated_at' | 'teacher_id'>> & { teacher_id?: string } = {
        name: chatbot.name,
        description: chatbot.description || undefined,
        system_prompt: chatbot.system_prompt,
        model: chatbot.model,
        max_tokens: (chatbot.max_tokens === undefined || chatbot.max_tokens === null || String(chatbot.max_tokens).trim() === ``) ? null : Number(chatbot.max_tokens),
        temperature: (chatbot.temperature === undefined || chatbot.temperature === null || String(chatbot.temperature).trim() === ``) ? null : Number(chatbot.temperature),
        enable_rag: currentBotType === 'learning' ? (chatbot.enable_rag || false) : false,
        bot_type: currentBotType,
        assessment_criteria_text: currentBotType === 'assessment' ? (chatbot.assessment_criteria_text || null) : null,
        welcome_message: chatbot.welcome_message || null,
    };
    if (supabaseUpdatePayload.description === undefined) delete supabaseUpdatePayload.description;

    try {
        if (isCreateMode) {
            const apiCreatePayload: CreateChatbotPayload = {
                name: chatbot.name,
                system_prompt: chatbot.system_prompt,
                description: chatbot.description || undefined,
                model: chatbot.model || 'qwen/qwen3-235b-a22b',
                max_tokens: supabaseUpdatePayload.max_tokens,
                temperature: supabaseUpdatePayload.temperature,
                enable_rag: supabaseUpdatePayload.enable_rag,
                bot_type: supabaseUpdatePayload.bot_type,
                assessment_criteria_text: supabaseUpdatePayload.assessment_criteria_text,
                welcome_message: supabaseUpdatePayload.welcome_message,
            };

            const response = await fetch('/api/teacher/chatbots', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(apiCreatePayload),
            });
            const responseData = await response.json();
            if (!response.ok) throw new Error(responseData.error || 'Failed to create chatbot');

            setSuccessMessage('Chatbot created successfully! You can now configure its knowledge base if RAG is enabled.');
            const newBotData = responseData as Chatbot;
            setChatbot(newBotData);
            setIsCreateMode(false);
            router.replace(`/teacher-dashboard/chatbots/${newBotData.chatbot_id}/edit`, { scroll: false });

        } else {
            const updateDataForSupabase = { ...supabaseUpdatePayload };
            delete updateDataForSupabase.teacher_id;

            const { error: updateError } = await supabase
                .from('chatbots')
                .update({ ...updateDataForSupabase, updated_at: new Date().toISOString() })
                .eq('chatbot_id', chatbot.chatbot_id)
                .eq('teacher_id', currentUserId);

            if (updateError) throw updateError;
            setSuccessMessage('Chatbot updated successfully!');
        }
    } catch (err) {
        setFormError(err instanceof Error ? err.message : (isCreateMode ? 'Failed to create chatbot.' : 'Failed to update chatbot.'));
    } finally {
        setSaving(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    let processedValue: string | number | boolean | undefined | null | BotType = value;

    if (name === "max_tokens" || name === "temperature") {
        processedValue = value === `` ? null : Number(value);
    } else if (name === "bot_type") {
        processedValue = value as BotType;
    } else if (name === "enable_rag") {
        return;
    }
    else if ((name === "welcome_message" || name === "assessment_criteria_text") && value.trim() === "") {
        processedValue = null;
    }

    setChatbot(prev => ({ ...prev, [name]: processedValue } as Chatbot));
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setChatbot(prev => ({ ...prev, [name]: checked } as Chatbot));
  };

  const handleProcessDocument = async (documentId: string) => {
    if (isCreateMode || !chatbot.chatbot_id) return;
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/chatbots/${chatbot.chatbot_id}/vectorize`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ documentId }),
      });
      if (!response.ok) { const data = await response.json().catch(() => ({})); throw new Error(data.error || 'Failed to start document processing'); }
      setDocuments(prevDocs => prevDocs.map(doc => doc.document_id === documentId ? { ...doc, status: 'processing' } : doc));
      setViewingDocumentId(documentId);
      setSuccessMessage('Document processing started. You can monitor its status below.');
    } catch (err) { setDocsError(err instanceof Error ? err.message : 'Could not process document.'); }
  };

  const handleDeleteDocument = async (documentId: string) => {
    if (isCreateMode || !chatbot.chatbot_id) return;
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/documents?documentId=${documentId}`, { method: 'DELETE' });
      if (!response.ok) { const data = await response.json().catch(() => ({})); throw new Error(data.error || 'Failed to delete document'); }
      setDocuments(prevDocs => prevDocs.filter(doc => doc.document_id !== documentId));
      if (viewingDocumentId === documentId) { setViewingDocumentId(null); }
      setSuccessMessage('Document deleted successfully.');
    } catch (err) { setDocsError(err instanceof Error ? err.message : 'Could not delete document.'); }
  };

  const getViewingDocument = (): KnowledgeDocument | null => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  // MODIFIED: Function to handle adding a webpage URL
  const handleAddWebpage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!webpageUrl.trim() || !chatbot.chatbot_id) {
      setUrlError('Please enter a valid URL.');
      return;
    }
    if (!/^https?:\/\//i.test(webpageUrl)) {
      setUrlError('URL must start with http:// or https://');
      return;
    }

    setIsAddingUrl(true);
    setUrlError(null);
    setSuccessMessage(null);
    setDocsError(null);

    const formData = new FormData();
    formData.append('url', webpageUrl);
    formData.append('chatbotId', chatbot.chatbot_id);

    try {
      const response = await fetch('/api/teacher/documents', { // Uses the same POST endpoint
        method: 'POST',
        body: formData, // API will detect it's a URL based on form data
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Failed to add webpage');
      }
      setSuccessMessage(data.message || 'Webpage added successfully! Refreshing list...');
      setWebpageUrl(''); // Clear input
      fetchDocumentsData(chatbot.chatbot_id); // Refresh the document list
    } catch (err) {
      setUrlError(err instanceof Error ? err.message : 'Could not add webpage.');
      console.error("Error adding webpage:", err);
    } finally {
      setIsAddingUrl(false);
    }
  };


  if (pageLoading) {
    return ( <PageWrapper><Container><LoadingCard><LoadingSpinner size="large" /><p>{`Loading configuration page...`}</p></LoadingCard></Container></PageWrapper> );
  }
  if (!isCreateMode && !chatbot.chatbot_id && !pageLoading) {
     return ( <PageWrapper><Container><Alert variant="error">{formError || `Chatbot data could not be initialized. Please go back and try again.`}</Alert></Container></PageWrapper> );
  }

  const displayBotType = chatbot.bot_type || 'learning';

  return (
    <PageWrapper>
      <Container>
        <HeaderControls>
          <MainTitle>{isCreateMode ? `Create New Chatbot` : `Edit Chatbot: ${chatbot.name}`}</MainTitle>
          <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard/chatbots')}>
            {`<`} Back to Chatbots
          </BackButton>
        </HeaderControls>

        <Card>
          {formError && <Alert variant="error" style={{ marginBottom: '16px'}}>{formError}</Alert>}
          {successMessage && <Alert variant="success" style={{ marginBottom: '16px'}}>{successMessage}</Alert>}

          <form onSubmit={handleSubmit}>
            {/* ... (chatbot configuration form fields: name, description, bot_type, etc.) ... */}
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input id="name" name="name" value={chatbot.name || ``} onChange={handleChange} required />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input id="description" name="description" value={chatbot.description || ``} onChange={handleChange} />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="bot_type">Bot Type</Label>
              <StyledSelect id="bot_type" name="bot_type" value={displayBotType} onChange={handleChange}>
                <option value="learning">Learning Bot</option>
                <option value="assessment">Assessment Bot</option>
              </StyledSelect>
              <HelpText>{`'Learning' bots are for general interaction. 'Assessment' bots can evaluate student responses based on criteria you define.`}</HelpText>
            </FormGroup>
            {displayBotType === 'assessment' && (
              <AssessmentCriteriaSection>
                <Label htmlFor="assessment_criteria_text">Define Assessment Rubric / Criteria</Label>
                <TextArea id="assessment_criteria_text" name="assessment_criteria_text" value={chatbot.assessment_criteria_text || ``} onChange={handleChange} rows={5} placeholder={`Clearly describe what the AI should assess. For example:\n1. Accuracy of answers to key concepts.\n2. Clarity of student's explanations.\n3. Use of specific examples or evidence.\n4. Critical thinking demonstrated.`} required={displayBotType === 'assessment'} />
                <HelpText>This text will guide the AI in evaluating student responses. Be specific.</HelpText>
                <RubricInfoText>{`For now, provide a text-based summary here. In the future, you may be able to upload structured rubric documents after saving.`}</RubricInfoText>
              </AssessmentCriteriaSection>
            )}
            <FormGroup>
              <Label htmlFor="system_prompt">{`System Prompt (AI's Persona & Core Instructions)`}</Label>
              <TextArea id="system_prompt" name="system_prompt" value={chatbot.system_prompt || ``} onChange={handleChange} required rows={displayBotType === 'assessment' ? 3 : 5} placeholder={ displayBotType === 'assessment' ? `e.g., 'You are an assessment assistant...'` : `e.g., 'You are a friendly history tutor...'` }/>
              <HelpText>{`This defines the AI's general behavior.`}{displayBotType === 'assessment' && ` For Assessment Bots, instructions from 'Assessment Criteria' are key.`}</HelpText>
            </FormGroup>

            <FormGroup>
              <Label htmlFor="welcome_message">Welcome Message (Optional)</Label>
              <TextArea
                id="welcome_message"
                name="welcome_message"
                value={chatbot.welcome_message || ''}
                onChange={handleChange}
                rows={3}
                placeholder="e.g., Hi there! I'm here to help you with [topic]. What would you like to discuss first?"
              />
              <HelpText>
                This message will be shown to students as the first message from the chatbot when they start a new chat. Leave blank for no welcome message.
              </HelpText>
            </FormGroup>

            <FormGroup>
              <Label htmlFor="model">AI Model (for Chatting)</Label>
              <StyledSelect id="model" name="model" value={chatbot.model || 'qwen/qwen3-235b-a22b'} onChange={handleChange}>
                  <option value="openai/gpt-4.1-nano">OpenAI GPT-4.1 Nano</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B</option> 
              </StyledSelect>
              <HelpText>This model is used for general chat. Assessment evaluation will use Qwen3 235B.</HelpText>
            </FormGroup>
            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens (Chat Response Length)</Label>
              <Input id="max_tokens" name="max_tokens" type="number" value={chatbot.max_tokens === null || chatbot.max_tokens === undefined ? `` : chatbot.max_tokens} onChange={handleChange} min="100" max="8000" placeholder="e.g., 1000" />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="temperature">Temperature (Chat Creativity)</Label>
              <Input id="temperature" name="temperature" type="number" value={chatbot.temperature === null || chatbot.temperature === undefined ? `` : chatbot.temperature} onChange={handleChange} min="0" max="2" step="0.1" placeholder="e.g., 0.7"/>
               <HelpText>{`0.0 = most deterministic, 2.0 = most creative. Default is 0.7.`}</HelpText>
            </FormGroup>
            {displayBotType === 'learning' && (
                <FormGroup>
                <Label htmlFor="enable_rag">Knowledge Base (RAG)</Label>
                <CheckboxGroup>
                    <input id="enable_rag" name="enable_rag" type="checkbox" checked={!!chatbot.enable_rag} onChange={handleCheckboxChange} />
                    <span>Enable RAG: Allow chatbot to use uploaded documents to answer questions.</span>
                </CheckboxGroup>
                <HelpText>If enabled, this learning bot can use documents you upload below. (Save first to enable uploads if creating a new bot).</HelpText>
                </FormGroup>
            )}
            <Button type="submit" disabled={saving || pageLoading} style={{ width: `100%`, marginTop: `16px` }}>
              {saving ? (isCreateMode ? 'Creating...' : 'Saving...') : (isCreateMode ? 'Create & Configure Chatbot' : 'Save Changes')}
            </Button>
          </form>

          {/* MODIFIED: Knowledge Base Section */}
          {!isCreateMode && displayBotType === 'learning' && chatbot.enable_rag && chatbot.chatbot_id && (
            <>
                <Divider />
                <SectionTitle>Knowledge Base Documents (for RAG)</SectionTitle>
                
                {/* URL Input Section */}
                <UrlInputSection>
                    <Label htmlFor="webpageUrl">Add Webpage by URL</Label>
                    <UrlInputForm onSubmit={handleAddWebpage}>
                        <UrlInput
                            type="url"
                            id="webpageUrl"
                            name="webpageUrl"
                            value={webpageUrl}
                            onChange={(e) => { setWebpageUrl(e.target.value); setUrlError(null); }}
                            placeholder="https://example.com/your-article-here"
                            disabled={isAddingUrl}
                        />
                        <AddUrlButton type="submit" variant="outline" disabled={isAddingUrl || !webpageUrl.trim()}>
                            {isAddingUrl ? 'Adding...' : 'Add URL'}
                        </AddUrlButton>
                    </UrlInputForm>
                    {urlError && <Alert variant="error" style={{ marginTop: '8px' }}>{urlError}</Alert>}
                    <HelpText style={{marginTop: '8px'}}>
                        The system will attempt to extract the main content from the provided URL.
                    </HelpText>
                </UrlInputSection>

                {/* Existing Document Uploader */}
                <HelpText>{`Alternatively, upload PDF, Word, or TXT files directly.`}</HelpText>
                {docsError && <Alert variant="error">{docsError}</Alert>}
                <DocumentUploader 
                    chatbotId={chatbot.chatbot_id} 
                    onUploadSuccess={() => { 
                        setSuccessMessage("Document uploaded. Refreshing list..."); 
                        fetchDocumentsData(chatbot.chatbot_id!); 
                    }} 
                />
                
                {/* Document List and Status */}
                {viewingDocumentId && getViewingDocument() && (
                    <EmbeddingStatus
                      document={{ ...getViewingDocument()!, updated_at: getViewingDocument()!.updated_at ?? new Date().toISOString() }}
                      chatbotId={chatbot.chatbot_id!}
                      onRefresh={() => { 
                          setSuccessMessage("Document status refreshed."); 
                          fetchDocumentsData(chatbot.chatbot_id!); 
                        }}
                    />
                )}
                {docsLoading ? ( <LoadingStateContainer><LoadingSpinner size="small"/><span>Loading documents...</span></LoadingStateContainer> ) : (
                    <DocumentList
                      documents={documents.map(doc => ({ ...doc, updated_at: doc.updated_at ?? new Date().toISOString() }))}
                      onProcessDocument={handleProcessDocument}
                      onDeleteDocument={handleDeleteDocument}
                      onViewStatus={setViewingDocumentId}
                    />
                )}
            </>
          )}
          {isCreateMode && displayBotType === 'learning' && (
            <HelpText style={{marginTop: '20px', textAlign: 'center', fontStyle: 'italic'}}>Save this chatbot first to enable RAG document uploads and URL additions.</HelpText>
          )}
        </Card>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/knowledge-base/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Document as KnowledgeDocument } from '@/types/knowledge-base.types'; // Ensure path

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  gap: ${({ theme }) => theme.spacing.md};
`;

const BackButton = styled(Button)`
  /* Add specific styles if BackButton needs to differ from general Button */
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.7rem; // Slightly smaller if needed
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  text-align: center; // Center text if using p tag
`;

const Section = styled(Card)` // Use Card as base for sections
    margin-bottom: ${({ theme }) => theme.spacing.xl};
    h2 {
        margin-top: 0;
        margin-bottom: ${({ theme }) => theme.spacing.sm};
    }
    p {
        color: ${({ theme }) => theme.colors.textLight};
        font-size: 0.9rem;
        margin-bottom: ${({ theme }) => theme.spacing.lg};
    }
`;


export default function KnowledgeBasePage() {
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [chatbotName, setChatbotName] = useState<string>('');
  const [loading, setLoading] = useState(true); // For initial page load (chatbot name + initial docs)
  const [docsLoading, setDocsLoading] = useState(false); // For subsequent document list refreshes
  const [pageError, setPageError] = useState<string | null>(null); // Renamed from error
  const [docsError, setDocsError] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  const fetchChatbotInfo = useCallback(async () => {
    if(!chatbotId) return;
    try {
      const { data: chatbot, error: chatbotError } = await supabase
        .from('chatbots')
        .select('name, teacher_id') // Also get teacher_id for auth check
        .eq('chatbot_id', chatbotId)
        .single();

      if (chatbotError) throw chatbotError;
      if (!chatbot) throw new Error("Chatbot not found.");

      // Authorization check: ensure current user owns this chatbot
      const { data: { user } } = await supabase.auth.getUser();
      if (!user || user.id !== chatbot.teacher_id) {
        throw new Error("You are not authorized to manage this chatbot's knowledge base.");
      }
      setChatbotName(chatbot.name);
    } catch (err) {
      console.error('Error fetching chatbot info:', err);
      setPageError(err instanceof Error ? err.message : 'Failed to fetch chatbot information');
    }
  }, [chatbotId, supabase]);

  const fetchDocuments = useCallback(async () => {
    if (!chatbotId) return;
    setDocsLoading(true);
    setDocsError(null);
    try {
      // << MODIFICATION: Use new API endpoint >>
      const response = await fetch(`/api/teacher/documents?chatbotId=${chatbotId}`);
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to fetch documents');
      }
      const data: KnowledgeDocument[] = await response.json();
      setDocuments(data);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not load documents.');
    } finally {
      setDocsLoading(false);
    }
  }, [chatbotId]);

  useEffect(() => {
    const loadInitialData = async () => {
        setLoading(true);
        await fetchChatbotInfo();
        await fetchDocuments();
        setLoading(false);
    }
    if (chatbotId) {
        loadInitialData();
    } else {
        setPageError("Chatbot ID is missing from the URL.");
        setLoading(false);
    }
  }, [chatbotId, fetchChatbotInfo, fetchDocuments]);

  const handleProcessDocument = async (documentId: string) => {
    setDocsError(null);
    setSuccessMessage(null);
    try {
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, { // Assuming vectorize endpoint remains nested
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId }),
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to start document processing');
      }
      setSuccessMessage("Document processing started.");
      setDocuments(prevDocs => 
        prevDocs.map(doc => 
          doc.document_id === documentId ? { ...doc, status: 'processing' } : doc
        )
      );
      setViewingDocumentId(documentId);
    } catch (err) {
      console.error('Error processing document:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not process document.');
    }
  };

  const handleDeleteDocument = async (documentId: string) => {
    setDocsError(null);
    setSuccessMessage(null);
    try {
      // << MODIFICATION: Use new API endpoint >>
      const response = await fetch(`/api/teacher/documents?documentId=${documentId}`, { 
          method: 'DELETE' 
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to delete document');
      }
      setSuccessMessage("Document deleted successfully.");
      setDocuments(prevDocs => prevDocs.filter(doc => doc.document_id !== documentId));
      if (viewingDocumentId === documentId) {
        setViewingDocumentId(null);
      }
    } catch (err) {
      console.error('Error deleting document:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not delete document.');
    }
  };

  const getViewingDocument = (): KnowledgeDocument | null => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  if (loading) {
    return (
        <PageWrapper>
            <Container>
                <LoadingContainer><p>Loading knowledge base...</p></LoadingContainer>
            </Container>
        </PageWrapper>
    );
  }

  if (pageError) {
    return (
        <PageWrapper>
            <Container>
                <Alert variant="error" style={{marginTop: '20px'}}>{pageError}</Alert>
                <Button onClick={() => router.push('/teacher-dashboard/chatbots')} style={{marginTop: '16px'}}>
                    Back to Chatbots
                </Button>
            </Container>
        </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <Title>Knowledge Base: {chatbotName || "Chatbot"}</Title>
          <BackButton 
            variant="outline" 
            onClick={() => router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`)} // Link back to edit page
          >
            ← Back to Chatbot Config
          </BackButton>
        </Header>
        
        {successMessage && <Alert variant="success" style={{marginBottom: '16px'}}>{successMessage}</Alert>}
        {docsError && <Alert variant="error" style={{marginBottom: '16px'}}>{docsError}</Alert>}
        
        <Section>
          <h2>Add Documents</h2>
          <p>Upload PDF, Word, or TXT files. These will be processed and made available for your chatbot to use when RAG is enabled.</p>
          <DocumentUploader 
            chatbotId={chatbotId} 
            onUploadSuccess={() => {
                setSuccessMessage("Document uploaded! Refreshing list...");
                fetchDocuments();
            }}
          />
        </Section>
        
        <Section>
            <h2>Uploaded Documents</h2>
            {getViewingDocument() && (
              <EmbeddingStatus 
                document={getViewingDocument()!} 
                chatbotId={chatbotId}
                onRefresh={() => {
                    setSuccessMessage("Document status refreshed.");
                    fetchDocuments();
                }}
              />
            )}
            
            {docsLoading && documents.length === 0 ? ( // Show loading only if no docs are displayed yet
              <LoadingContainer><p>Loading documents...</p></LoadingContainer>
            ) : (
              <DocumentList 
                documents={documents}
                onProcessDocument={handleProcessDocument}
                onDeleteDocument={handleDeleteDocument}
                onViewStatus={setViewingDocumentId}
              />
            )}
        </Section>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/test-chat/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { Container, Alert, Button as StyledButton } from '@/styles/StyledComponents'; // Renamed Button to avoid conflict
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: calc(100vh - 120px); // Adjust based on your header/footer height
  display: flex;
  flex-direction: column;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const ChatbotInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.75rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
    margin: 0;
  }
`;

const BackButton = styled(StyledButton)`
  // specific styles if needed
`;


export default function TestChatPage() {
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const chatbotId = params?.chatbotId as string;

  // Define a consistent "dummy" room ID for teacher test chats for this chatbot
  // This allows message history to be segmented per chatbot test.
  const testRoomId = `teacher_test_room_for_${chatbotId}`;

  const fetchChatbotData = useCallback(async () => {
    if (!chatbotId) {
      setError("Chatbot ID is missing.");
      setLoading(false);
      return;
    }
    console.log(`[TestChatPage] Fetching chatbot data for ID: ${chatbotId}`);
    setLoading(true);
    setError(null);
    try {
      // Use the API endpoint instead of direct Supabase query to avoid RLS issues
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}`);
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        console.error('[TestChatPage] Error fetching chatbot:', errorData);
        throw new Error(errorData.error || `Failed to fetch chatbot data (status ${response.status})`);
      }
      
      const chatbotData = await response.json();
      
      if (!chatbotData) {
        throw new Error('Chatbot not found or you do not have permission to access it.');
      }
      console.log('[TestChatPage] Chatbot data fetched:', chatbotData);
      setChatbot(chatbotData);
    } catch (err) {
      console.error('[TestChatPage] CATCH Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to load chatbot for testing.');
    } finally {
      setLoading(false);
    }
  }, [chatbotId]);

  useEffect(() => {
    fetchChatbotData();
  }, [fetchChatbotData]);

  const handleBack = () => {
    router.push('/teacher-dashboard/chatbots'); // Go back to the chatbots list
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
          <LoadingSpinner size="large" />
          <p style={{ marginTop: '16px' }}>Loading chatbot for testing...</p>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!chatbot) {
    // This case should ideally be caught by the error state if fetch fails
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Chatbot not available for testing.</Alert>
           <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
        <Header>
          <ChatbotInfo>
            <h1>Test: {chatbot.name}</h1>
            <p>You are interacting with your chatbot for testing purposes.</p>
          </ChatbotInfo>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Header>
        
        {/* 
          The Chat component needs a roomId. We'll use our dummy testRoomId.
          The Chat component also expects a full Chatbot object.
        */}
        <Chat 
          roomId={testRoomId} 
          chatbot={chatbot} 
        />
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Button, Alert, Card } from '@/styles/StyledComponents';
import ChatbotList from '@/components/teacher/ChatbotList';
import ChatbotForm from '@/components/teacher/ChatbotForm'; // For the modal
// import DeleteModal from '@/components/teacher/DeleteModal'; // We'll integrate delete later
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  font-size: 1.8rem;
`;

export default function ChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  // const [deleteInfo, setDeleteInfo] = useState<{ id: string; name: string } | null>(null);
  const router = useRouter();

  const fetchChatbots = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/teacher/chatbots');
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${response.status})`);
      }
      const data: Chatbot[] = await response.json();
      setChatbots(data);
    } catch (err) {
      console.error("Error fetching chatbots:", err);
      setError(err instanceof Error ? err.message : 'Could not load chatbots.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchChatbots(); // Refresh the list
  };

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbot = async (chatbotId: string, chatbotName: string) => {
    // For now, just a confirm. We will integrate DeleteModal later.
    if (window.confirm(`Are you sure you want to delete chatbot "${chatbotName}"? This will also delete associated documents.`)) {
      try {
        // We'll need a DELETE API route: /api/teacher/chatbots/[chatbotId]
        // const response = await fetch(`/api/teacher/chatbots/${chatbotId}`, { method: 'DELETE' });
        // if (!response.ok) throw new Error('Failed to delete chatbot');
        alert(`DELETE /api/teacher/chatbots/${chatbotId} would be called. Feature to be fully implemented.`);
        // fetchChatbots(); // Refresh list
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to delete chatbot.');
      }
    }
  };

  return (
    <div>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={() => setShowChatbotForm(true)}>+ Create Chatbot</Button>
      </PageHeader>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

            {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading chatbots...</Card>
      ) : (
        <ChatbotList
          chatbots={chatbots}
          onEdit={handleEditChatbot}
          onDelete={handleDeleteChatbot}
          viewMode="card" // Or "list", depending on desired default
        />
      )}

      {showChatbotForm && (
        <ChatbotForm
          onClose={() => setShowChatbotForm(false)}
          onSuccess={handleChatbotCreated}
        />
      )}

      {/* {deleteInfo && (
        <DeleteModal
          itemType="Chatbot"
          itemName={deleteInfo.name}
          onConfirm={() => {
            // actual delete logic
            setDeleteInfo(null);
          }}
          onCancel={() => setDeleteInfo(null)}
          isDeleting={false} // manage this state
        />
      )} */}
    </div>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import styled, { useTheme } from 'styled-components';
// import { useRouter } from 'next/navigation';
import { Button, Alert, Card, Input, Select as StyledSelect, FormGroup, Label } from '@/styles/StyledComponents';
import ChatbotList, { type ChatbotListProps } from '@/components/teacher/ChatbotList'; // Ensure type ChatbotListProps is imported
import ChatbotForm from '@/components/teacher/ChatbotForm';
import type { Chatbot, BotTypeEnum } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  /* Add any specific wrapper styles if needed */
`;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg}; 
  flex-wrap: wrap; 
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0; 
`;

const ControlsContainer = styled(Card)`
  padding: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  background-color: ${({ theme }) => theme.colors.background}; 
`;

const FilterGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.md};
  align-items: flex-end; 
`;

const ViewToggleContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-left: auto; 
  
  @media (max-width: 768px) { 
    margin-left: 0;
    width: 100%;
    justify-content: flex-start; 
    margin-top: ${({ theme }) => theme.spacing.md};
  }
`;


export default function ManageChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  // router will be used for navigation in future updates
  // const router = useRouter();
  const theme = useTheme(); 

  const [searchTerm, setSearchTerm] = useState('');
  const [selectedBotType, setSelectedBotType] = useState<BotTypeEnum | ''>('');
  const [selectedRagStatus, setSelectedRagStatus] = useState<'any' | 'true' | 'false'>('any');
  const [sortBy, setSortBy] = useState('created_at_desc');
  const [viewMode, setViewMode] = useState<'card' | 'list'>('card');
  
  // Modal state
  const [showEditModal, setShowEditModal] = useState(false);
  const [editChatbot, setEditChatbot] = useState<Chatbot | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState(searchTerm);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 500); 

    return () => {
      clearTimeout(handler);
    };
  }, [searchTerm]);

  const fetchChatbots = useCallback(async () => {
    console.log('[ChatbotsPage] Fetching chatbots with filters:', 
        { debouncedSearchTerm, selectedBotType, selectedRagStatus, sortBy });
    setIsLoading(true);
    setError(null);
    try {
      const params = new URLSearchParams();
      if (debouncedSearchTerm) {
        params.append('searchTerm', debouncedSearchTerm);
      }
      if (selectedBotType) {
        params.append('botType', selectedBotType);
      }
      if (selectedRagStatus !== 'any') {
        params.append('ragEnabled', selectedRagStatus);
      }
      if (sortBy) {
        params.append('sortBy', sortBy);
      }

      const response = await fetch(`/api/teacher/chatbots?${params.toString()}`);
      if (!response.ok) {
        let errorMessage = `Failed to fetch chatbots (status ${response.status})`;
        try {
            const errData = await response.json();
            errorMessage = errData.error || errorMessage;
        } catch {}
        throw new Error(errorMessage);
      }
      const data = await response.json();
      if (Array.isArray(data)) {
        setChatbots(data as Chatbot[]);
      } else {
        console.warn('[ChatbotsPage] API returned non-array data for chatbots:', data);
        setChatbots([]);
      }
    } catch (err) {
      console.error('[ChatbotsPage] Error fetching chatbots:', err);
      setError(err instanceof Error ? err.message : 'Could not load your chatbots.');
      setChatbots([]);
    } finally {
      setIsLoading(false);
    }
  }, [debouncedSearchTerm, selectedBotType, selectedRagStatus, sortBy]);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleEditChatbot = useCallback((chatbotId: string) => {
      // Find the chatbot in the array
      const chatbotToEdit = chatbots.find(bot => bot.chatbot_id === chatbotId);
      
      if (chatbotToEdit) {
        setEditChatbot(chatbotToEdit);
        setShowEditModal(true);
        setIsCreating(false);
      } else {
        console.error(`Chatbot with ID ${chatbotId} not found`);
        setError(`Chatbot with ID ${chatbotId} not found`);
      }
  }, [chatbots]);

  const handleDeleteChatbot = useCallback(async (chatbotId: string, chatbotName: string) => {
      if (window.confirm(`Are you sure you want to delete the chatbot "${chatbotName}"? This will also delete associated documents and knowledge base entries if RAG was used.`)) {
          setError(null);
          try {
              const response = await fetch(`/api/teacher/chatbots?chatbotId=${chatbotId}`, { method: 'DELETE' }); 
              if (!response.ok) {
                  let errorMessage = `Failed to delete chatbot (status ${response.status})`;
                  try {
                      const errData = await response.json();
                      errorMessage = errData.error || errorMessage;
                  } catch {}
                  throw new Error(errorMessage);
              }
              const result = await response.json();
              alert(result.message || `Chatbot "${chatbotName}" deleted successfully.`);
              fetchChatbots(); 
          } catch (err) {
              const errorMessage = err instanceof Error ? err.message : 'Failed to delete chatbot.';
              setError(errorMessage);
          }
      }
  }, [fetchChatbots]); 
  
  const handleCreateNewChatbot = useCallback(() => {
      setEditChatbot(null);
      setShowEditModal(true);
      setIsCreating(true);
  }, []);
  
  const handleFormClose = useCallback(() => {
    setShowEditModal(false);
    setEditChatbot(null);
  }, []);
  
  const handleFormSuccess = useCallback(() => {
    setShowEditModal(false);
    setEditChatbot(null);
    fetchChatbots();
    // chatbotId parameter is not used here
  }, [fetchChatbots]);

  const content = useMemo(() => {
    if (isLoading && chatbots.length === 0) { 
      return (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner /> Loading your chatbots...
        </Card>
      );
    } 
    if (!isLoading && !error && chatbots.length === 0) {
      return (
        <Card style={{ textAlign: 'center', padding: '20px' }}>
          <p>No chatbots found matching your current filters. Try adjusting them or create a new chatbot!</p>
        </Card>
      );
    }
    if (chatbots.length > 0) {
      const propsForChatbotList: ChatbotListProps = { 
        chatbots: chatbots,
        onEdit: handleEditChatbot,     
        onDelete: handleDeleteChatbot,
        viewMode: viewMode
      };
      return (
        <ChatbotList {...propsForChatbotList} /> 
      );
    }
    return null; 
  }, [isLoading, error, chatbots, handleEditChatbot, handleDeleteChatbot, viewMode]);


  return (
    <PageWrapper>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={handleCreateNewChatbot}>+ Create New Chatbot</Button>
      </PageHeader>

      <ControlsContainer $accentSide="top" $accentColor={theme.colors.blue}>
        <FilterGrid>
          <FormGroup style={{ marginBottom: 0 }}> 
            <Label htmlFor="searchTerm">Search</Label>
            <Input
              type="text"
              id="searchTerm"
              placeholder="Search by name or description..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </FormGroup>
          <FormGroup style={{ marginBottom: 0 }}>
            <Label htmlFor="botTypeFilter">Bot Type</Label>
            <StyledSelect
              id="botTypeFilter"
              value={selectedBotType}
              onChange={(e) => setSelectedBotType(e.target.value as BotTypeEnum | '')}
            >
              <option value="">All Types</option>
              <option value="learning">Learning</option>
              <option value="assessment">Assessment</option>
            </StyledSelect>
          </FormGroup>
          <FormGroup style={{ marginBottom: 0 }}>
            <Label htmlFor="ragStatusFilter">RAG Status</Label>
            <StyledSelect
              id="ragStatusFilter"
              value={selectedRagStatus}
              onChange={(e) => setSelectedRagStatus(e.target.value as 'any' | 'true' | 'false')}
            >
              <option value="any">Any RAG Status</option>
              <option value="true">RAG Enabled</option>
              <option value="false">RAG Disabled</option>
            </StyledSelect>
          </FormGroup>
          <FormGroup style={{ marginBottom: 0 }}>
            <Label htmlFor="sortBy">Sort By</Label>
            <StyledSelect
              id="sortBy"
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value)}
            >
              <option value="created_at_desc">Newest First</option>
              <option value="created_at_asc">Oldest First</option>
              <option value="name_asc">Name (A-Z)</option>
              <option value="name_desc">Name (Z-A)</option>
              <option value="updated_at_desc">Last Modified</option>
            </StyledSelect>
          </FormGroup>
          <ViewToggleContainer>
            <Button
              variant={viewMode === 'card' ? 'primary' : 'outline'}
              onClick={() => setViewMode('card')}
              size="small"
              title="Card View"
            >
              🗂️ Card
            </Button>
            <Button
              variant={viewMode === 'list' ? 'primary' : 'outline'}
              onClick={() => setViewMode('list')}
              size="small"
              title="List View"
            >
              📄 List
            </Button>
          </ViewToggleContainer>
        </FilterGrid>
      </ControlsContainer>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      
      {isLoading && chatbots.length > 0 && (
        <div style={{ textAlign: 'center', padding: '10px' }}>
          <LoadingSpinner size="small" /> Updating list...
        </div>
      )}
      {content}

      {/* Modal Form for Creating/Editing Chatbots */}
      {showEditModal && (
        <ChatbotForm 
          onClose={handleFormClose} 
          onSuccess={handleFormSuccess}
          initialData={editChatbot ? {
            chatbot_id: editChatbot.chatbot_id,
            name: editChatbot.name,
            description: editChatbot.description || '',
            system_prompt: editChatbot.system_prompt,
            model: editChatbot.model || 'openai/gpt-4.1-nano',
            max_tokens: editChatbot.max_tokens || undefined,
            temperature: editChatbot.temperature || undefined,
            enable_rag: editChatbot.enable_rag || false,
            bot_type: editChatbot.bot_type || 'learning',
            assessment_criteria_text: editChatbot.assessment_criteria_text || '',
            welcome_message: editChatbot.welcome_message || '',
          } : undefined}
          editMode={!isCreating}
        />
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/[roomId]/students/[studentId]/page.tsx
// This file has been updated to include magic link generation for students
'use client';

import { useState, useEffect, useCallback, useRef, FormEvent } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { Container, Card, Button, Alert, Badge } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import StudentChatHistory from '@/components/teacher/StudentChatHistory'; // To be used in a tab

import type { 
    Profile, 
    StudentAssessment, 
    FlaggedMessage, 
    Chatbot as RoomChatbotType // Type for chatbots in the room
} from '@/types/database.types';

// --- Data Structures for Page State ---
interface AssessmentSummaryForStudent extends Pick<StudentAssessment, 'assessment_id' | 'chatbot_id' | 'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'> {
  chatbot_name?: string | null;
}

interface ConcernSummaryForStudent extends Pick<FlaggedMessage, 'flag_id' | 'concern_type' | 'concern_level' | 'created_at' | 'status'> {
  message_preview?: string | null;
}

interface StudentRoomAllDetails {
  student: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null;
  assessments: AssessmentSummaryForStudent[];
  concerns: ConcernSummaryForStudent[];
  // We also need the list of chatbots available in this room for the StudentChatHistory component
  roomChatbots: Pick<RoomChatbotType, 'chatbot_id' | 'name'>[];
}

// --- Styled Components ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const StudentInfoBar = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.8rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1rem;
    margin: 0;
  }
`;

const TabContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const TabButton = styled.button<{ $isActive: boolean }>`
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border: none;
  background: none;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  color: ${({ theme, $isActive }) => $isActive ? theme.colors.primary : theme.colors.textLight};
  border-bottom: 3px solid ${({ theme, $isActive }) => $isActive ? theme.colors.primary : 'transparent'};
  transition: all 0.2s ease;

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const TabContent = styled.div`
  padding-top: ${({ theme }) => theme.spacing.lg};
`;

const SummarySection = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const SectionTitle = styled.h3`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.3rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SummaryList = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
`;

const SummaryListItem = styled.li`
  padding: ${({ theme }) => theme.spacing.sm} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};

  &:last-child {
    border-bottom: none;
  }

  .info {
    flex-grow: 1;
  }
  .title {
    font-weight: 500;
    color: ${({ theme }) => theme.colors.text};
    text-decoration: none;
    &:hover { text-decoration: underline; }
  }
  .date {
    font-size: 0.85rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
  .preview {
    font-size: 0.85rem;
    color: ${({ theme }) => theme.colors.textLight};
    font-style: italic;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
  gap: ${({ theme }) => theme.spacing.md};
`;

const MagicLinkBox = styled.div`
  background: ${({ theme }) => theme.colors.background};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  position: relative;
  overflow: hidden;
`;

const MagicLinkText = styled.div`
  font-family: monospace;
  background: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  overflow-x: auto;
  white-space: nowrap;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 0.9rem;
  max-width: 100%;
  
  &::-webkit-scrollbar {
    height: 4px;
  }
  
  &::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => theme.colors.borderDark};
    border-radius: 3px;
  }
  
  &::-webkit-scrollbar-track {
    background: transparent;
  }
`;

const getStatusBadgeVariant = (status?: StudentAssessment['status'] | FlaggedMessage['status']): 'success' | 'warning' | 'error' | 'default' => {
    if (!status) return 'default';
    // Assessment Statuses
    if (status === 'teacher_reviewed') return 'success';
    if (status === 'ai_completed') return 'warning';
    if (status === 'ai_processing') return 'default';
    // Concern Statuses
    if (status === 'resolved') return 'success';
    if (status === 'false_positive') return 'default';
    if (status === 'reviewing') return 'warning';
    if (status === 'pending') return 'error';
    return 'default';
};

const getStatusText = (status?: StudentAssessment['status'] | FlaggedMessage['status']): string => {
    if (!status) return 'N/A';
    // Assessment Statuses
    if (status === 'ai_processing') return 'AI Processing';
    if (status === 'ai_completed') return 'AI Completed';
    if (status === 'teacher_reviewed') return 'Teacher Reviewed';
    // Concern Statuses (assuming they are distinct from assessment statuses)
    if (status === 'pending') return 'Pending';
    if (status === 'reviewing') return 'Reviewing';
    if (status === 'resolved') return 'Resolved';
    if (status === 'false_positive') return 'False Positive';
    return String(status).replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};


type TabName = 'overview' | 'chats' | 'assessments' | 'concerns';

export default function StudentRoomDetailPage() {
  const [details, setDetails] = useState<StudentRoomAllDetails | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<TabName>('overview');
  const [pinCode, setPinCode] = useState<string>('');
  const [username, setUsername] = useState<string>('');
  const [isLoadingPin, setIsLoadingPin] = useState(false);
  const [pinError, setPinError] = useState<string | null>(null);
  const [showCopiedMessage, setShowCopiedMessage] = useState(false);
  const copyTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [regeneratingPin, setRegeneratingPin] = useState(false);
  
  // Magic link states
  const [magicLink, setMagicLink] = useState<string>('');
  const [isLoadingMagicLink, setIsLoadingMagicLink] = useState(false);
  const [magicLinkError, setMagicLinkError] = useState<string | null>(null);
  const [showMagicLinkCopied, setShowMagicLinkCopied] = useState(false);
  const [regeneratingMagicLink, setRegeneratingMagicLink] = useState(false);
  const magicLinkTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  const params = useParams();
  const router = useRouter();
  const roomId = params?.roomId as string;
  const studentId = params?.studentId as string;

  // Function to copy pin to clipboard
  const copyPinToClipboard = () => {
    if (pinCode) {
      navigator.clipboard.writeText(`${username}: ${pinCode}`).then(() => {
        setShowCopiedMessage(true);
        if (copyTimeoutRef.current) {
          clearTimeout(copyTimeoutRef.current);
        }
        copyTimeoutRef.current = setTimeout(() => {
          setShowCopiedMessage(false);
        }, 3000);
      });
    }
  };

  // Function to regenerate pin
  const handleRegeneratePin = async (e: FormEvent) => {
    e.preventDefault();
    if (!studentId) return;
    
    setRegeneratingPin(true);
    setPinError(null);
    
    try {
      const response = await fetch('/api/teacher/students/pin-code', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ studentId }),
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to regenerate PIN (status ${response.status})`);
      }
      
      const data = await response.json();
      setPinCode(data.pin_code || '');
      setUsername(data.username || '');
      
    } catch (err) {
      console.error('Error regenerating PIN:', err);
      setPinError(err instanceof Error ? err.message : 'Failed to regenerate PIN code');
    } finally {
      setRegeneratingPin(false);
    }
  };
  
  const fetchStudentRoomDetails = useCallback(async () => {
    if (!roomId || !studentId) {
      setError("Room ID or Student ID not found in URL.");
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      // API for student's aggregated details (profile, assessment summaries, concern summaries)
      const studentDetailsResponse = await fetch(`/api/teacher/student-room-details?roomId=${roomId}&studentId=${studentId}`);
      if (!studentDetailsResponse.ok) {
        const errorData = await studentDetailsResponse.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch student details (status ${studentDetailsResponse.status})`);
      }
      const studentData: StudentRoomAllDetails = await studentDetailsResponse.json();

      // API for room's general details (to get chatbots for StudentChatHistory)
      // We could combine this into the above API, but for now, separate for clarity
      const roomGenDetailsResponse = await fetch(`/api/teacher/room-details?roomId=${roomId}`);
       if (!roomGenDetailsResponse.ok) {
        const errorData = await roomGenDetailsResponse.json().catch(() => ({}));
        console.warn(errorData.error || `Failed to fetch room general details (status ${roomGenDetailsResponse.status})`);
        // Don't fail entirely, StudentChatHistory might handle missing chatbots gracefully
        setDetails({ ...studentData, roomChatbots: [] });
      } else {
        const roomGenData = await roomGenDetailsResponse.json();
        setDetails({
          ...studentData,
          roomChatbots: roomGenData.chatbots || [],
        });
      }

    } catch (err) {
      console.error("Error fetching student room details:", err);
      setError(err instanceof Error ? err.message : "Could not load student details.");
      setDetails(null);
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId]);

  useEffect(() => {
    fetchStudentRoomDetails();
    
  }, [fetchStudentRoomDetails]);
  
  // Fetch PIN info
  useEffect(() => {
    const fetchPinCode = async () => {
      if (!studentId) return;
      
      setIsLoadingPin(true);
      setPinError(null);
      
      try {
        const response = await fetch(`/api/teacher/students/pin-code?studentId=${studentId}`);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to fetch PIN (status ${response.status})`);
        }
        
        const data = await response.json();
        setPinCode(data.pin_code || '');
        setUsername(data.username || '');
        
      } catch (err) {
        console.error('Error fetching PIN:', err);
        setPinError(err instanceof Error ? err.message : 'Failed to fetch PIN code');
      } finally {
        setIsLoadingPin(false);
      }
    };
    
    fetchPinCode();
  }, [studentId]);
  
  // Fetch magic link
  useEffect(() => {
    const fetchMagicLink = async () => {
      if (!studentId || !roomId) return;
      
      setIsLoadingMagicLink(true);
      setMagicLinkError(null);
      
      try {
        const response = await fetch(`/api/teacher/students/magic-link?studentId=${studentId}&roomId=${roomId}`);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to fetch magic link (status ${response.status})`);
        }
        
        const data = await response.json();
        setMagicLink(data.magicLink || '');
        
      } catch (err) {
        console.error('Error fetching magic link:', err);
        setMagicLinkError(err instanceof Error ? err.message : 'Failed to fetch magic link');
      } finally {
        setIsLoadingMagicLink(false);
      }
    };
    
    fetchMagicLink();
  }, [studentId, roomId]);
  
  // Function to copy magic link to clipboard
  const copyMagicLinkToClipboard = () => {
    if (magicLink) {
      navigator.clipboard.writeText(magicLink).then(() => {
        setShowMagicLinkCopied(true);
        if (magicLinkTimeoutRef.current) {
          clearTimeout(magicLinkTimeoutRef.current);
        }
        magicLinkTimeoutRef.current = setTimeout(() => {
          setShowMagicLinkCopied(false);
        }, 3000);
      });
    }
  };
  
  // Function to regenerate magic link
  const handleRegenerateMagicLink = async (e: FormEvent) => {
    e.preventDefault();
    if (!studentId || !roomId) return;
    
    setRegeneratingMagicLink(true);
    setMagicLinkError(null);
    
    try {
      const response = await fetch('/api/teacher/students/magic-link', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ studentId, roomId }),
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to regenerate magic link (status ${response.status})`);
      }
      
      const data = await response.json();
      setMagicLink(data.magicLink || '');
      
    } catch (err) {
      console.error('Error regenerating magic link:', err);
      setMagicLinkError(err instanceof Error ? err.message : 'Failed to regenerate magic link');
    } finally {
      setRegeneratingMagicLink(false);
    }
  };

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleString();
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" /> <p>Loading student details...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.back()} style={{ marginTop: '16px' }}>
            ← Back
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  if (!details || !details.student) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Student details not found.</Alert>
          <Button onClick={() => router.back()} style={{ marginTop: '16px' }}>
            ← Back
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  const { student, assessments, concerns, roomChatbots } = details;

  return (
    <PageWrapper>
      <Container>
        <Header>
          <StudentInfoBar>
            <h1>{student.full_name || 'Student'}</h1>
            <p>{student.email || 'No email provided'}</p>
            
            {/* Compact Access Section */}
            <div style={{ marginTop: '15px' }}>
              <SummarySection>
                <SectionTitle>Student Access Details</SectionTitle>
                {(isLoadingPin || isLoadingMagicLink) ? (
                  <p>Loading access details...</p>
                ) : (pinError || magicLinkError) ? (
                  <Alert variant="error">{pinError || magicLinkError}</Alert>
                ) : (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '16px' }}>
                    {/* PIN Section */}
                    <div>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
                        <h4 style={{ margin: '0', fontSize: '1rem' }}>Login PIN</h4>
                        <Button 
                          onClick={handleRegeneratePin}
                          variant="secondary"
                          size="small"
                          disabled={regeneratingPin}
                          style={{ padding: '4px 8px', fontSize: '0.8rem' }}
                        >
                          {regeneratingPin ? 'Regenerating...' : 'Regenerate'}
                        </Button>
                      </div>
                      <div style={{ 
                        display: 'flex', 
                        alignItems: 'center', 
                        gap: '10px', 
                        background: '#f5f5f5',
                        padding: '8px',
                        borderRadius: '4px'
                      }}>
                        <div style={{ flex: '1' }}>
                          <span style={{ fontWeight: 'bold', marginRight: '6px' }}>Username:</span>
                          <span>{username || 'Not set'}</span>
                          <span style={{ margin: '0 8px' }}>|</span>
                          <span style={{ fontWeight: 'bold', marginRight: '6px' }}>PIN:</span>
                          <span style={{ letterSpacing: '1px' }}>{pinCode || 'Not set'}</span>
                        </div>
                        <Button 
                          onClick={copyPinToClipboard} 
                          variant="outline"
                          size="small"
                          disabled={!pinCode}
                          style={{ padding: '2px 8px', fontSize: '0.8rem', whiteSpace: 'nowrap' }}
                        >
                          {showCopiedMessage ? 'Copied!' : 'Copy'}
                        </Button>
                      </div>
                    </div>
                    
                    {/* Magic Link Section */}
                    <div>
                      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '8px' }}>
                        <h4 style={{ margin: '0', fontSize: '1rem' }}>Magic Link</h4>
                        <Button 
                          onClick={handleRegenerateMagicLink}
                          variant="secondary"
                          size="small"
                          disabled={regeneratingMagicLink}
                          style={{ padding: '4px 8px', fontSize: '0.8rem' }}
                        >
                          {regeneratingMagicLink ? 'Regenerating...' : 'Regenerate'}
                        </Button>
                      </div>
                      <div style={{ display: 'flex', alignItems: 'flex-start', gap: '10px' }}>
                        <MagicLinkText style={{ flex: 1, maxWidth: 'calc(100% - 70px)' }}>
                          {magicLink || 'No magic link available'}
                        </MagicLinkText>
                        <Button 
                          onClick={copyMagicLinkToClipboard} 
                          variant="outline"
                          size="small"
                          disabled={!magicLink}
                          style={{ padding: '2px 8px', fontSize: '0.8rem', flexShrink: 0, marginTop: '2px' }}
                        >
                          {showMagicLinkCopied ? 'Copied!' : 'Copy'}
                        </Button>
                      </div>
                    </div>
                    
                    <p style={{ fontSize: '0.8rem', color: '#666', margin: '0' }}>
                      Note: The PIN code can be used for regular login. The magic link provides direct access to this room.
                    </p>
                  </div>
                )}
              </SummarySection>
            </div>
          </StudentInfoBar>
          <Button variant="outline" onClick={() => router.push(`/teacher-dashboard/rooms/${roomId}`)}>
            ← Back to Room Overview
          </Button>
        </Header>

        <TabContainer>
          <TabButton $isActive={activeTab === 'overview'} onClick={() => setActiveTab('overview')}>Overview</TabButton>
          <TabButton $isActive={activeTab === 'chats'} onClick={() => setActiveTab('chats')}>Chat History</TabButton>
          <TabButton $isActive={activeTab === 'assessments'} onClick={() => setActiveTab('assessments')}>Assessments</TabButton>
          <TabButton $isActive={activeTab === 'concerns'} onClick={() => setActiveTab('concerns')}>Concerns</TabButton>
        </TabContainer>

        <TabContent>
          {activeTab === 'overview' && (
            <div>
              <SummarySection>
                <SectionTitle>Recent Assessments ({assessments.length})</SectionTitle>
                {assessments.length > 0 ? (
                  <SummaryList>
                    {assessments.slice(0, 5).map(asmnt => ( // Show first 5
                      <SummaryListItem key={asmnt.assessment_id}>
                        <div className="info">
                           <Link href={`/teacher-dashboard/assessments/${asmnt.assessment_id}`} className="title">
                             Assessment with {asmnt.chatbot_name || 'Bot'}
                           </Link>
                          <p className="date">Date: {formatDate(asmnt.assessed_at)}</p>
                        </div>
                        <div>
                            Grade: {asmnt.teacher_override_grade || asmnt.ai_grade_raw || 'N/A'}
                            <Badge 
                                variant={getStatusBadgeVariant(asmnt.status)} 
                                style={{marginLeft: '10px'}}
                            >
                                {getStatusText(asmnt.status)}
                            </Badge>
                        </div>
                      </SummaryListItem>
                    ))}
                  </SummaryList>
                ) : <p>No assessments found for this student in this room.</p>}
                 {assessments.length > 5 && <Button variant="outline" onClick={() => setActiveTab('assessments')} style={{marginTop: '10px'}}>View All Assessments ({assessments.length})</Button>}
              </SummarySection>

              <SummarySection>
                <SectionTitle>Recent Concerns ({concerns.length})</SectionTitle>
                {concerns.length > 0 ? (
                  <SummaryList>
                    {concerns.slice(0, 5).map(cncrn => ( // Show first 5
                      <SummaryListItem key={cncrn.flag_id}>
                        <div className="info">
                          <Link href={`/teacher-dashboard/concerns/${cncrn.flag_id}`} className="title">
                            {cncrn.concern_type.replace(/_/g, ' ')} (Level {cncrn.concern_level})
                          </Link>
                          <p className="date">Date: {formatDate(cncrn.created_at)}</p>
                          {cncrn.message_preview && <p className="preview">&quot;{cncrn.message_preview}&quot;</p>}
                        </div>
                         <Badge 
                            variant={getStatusBadgeVariant(cncrn.status)}
                         >
                            {getStatusText(cncrn.status)}
                        </Badge>
                      </SummaryListItem>
                    ))}
                  </SummaryList>
                ) : <p>No concerns flagged for this student in this room.</p>}
                {concerns.length > 5 && <Button variant="outline" onClick={() => setActiveTab('concerns')} style={{marginTop: '10px'}}>View All Concerns ({concerns.length})</Button>}
              </SummarySection>
            </div>
          )}

          {activeTab === 'chats' && (
            <Card> {/* Wrap StudentChatHistory in a Card for consistent styling */}
              <StudentChatHistory
                roomId={roomId}
                studentId={studentId}
                studentName={student.full_name || 'Student'}
                chatbots={roomChatbots || []} // Pass the fetched chatbots for the room
              />
            </Card>
          )}

          {activeTab === 'assessments' && (
            <Card>
              <SectionTitle>All Assessments ({assessments.length})</SectionTitle>
              {assessments.length > 0 ? (
                <SummaryList>
                  {assessments.map(asmnt => (
                    <SummaryListItem key={asmnt.assessment_id}>
                      <div className="info">
                        <Link href={`/teacher-dashboard/assessments/${asmnt.assessment_id}`} className="title">
                            Assessment with {asmnt.chatbot_name || 'Bot'}
                        </Link>
                        <p className="date">Date: {formatDate(asmnt.assessed_at)}</p>
                      </div>
                      <div>
                        Grade: {asmnt.teacher_override_grade || asmnt.ai_grade_raw || 'N/A'}
                         <Badge 
                            variant={getStatusBadgeVariant(asmnt.status)} 
                            style={{marginLeft: '10px'}}
                         >
                            {getStatusText(asmnt.status)}
                        </Badge>
                      </div>
                    </SummaryListItem>
                  ))}
                </SummaryList>
              ) : <p>No assessments found for this student in this room.</p>}
            </Card>
          )}

          {activeTab === 'concerns' && (
            <Card>
              <SectionTitle>All Concerns ({concerns.length})</SectionTitle>
               {concerns.length > 0 ? (
                <SummaryList>
                  {concerns.map(cncrn => (
                    <SummaryListItem key={cncrn.flag_id}>
                      <div className="info">
                        <Link href={`/teacher-dashboard/concerns/${cncrn.flag_id}`} className="title">
                            {cncrn.concern_type.replace(/_/g, ' ')} (Level {cncrn.concern_level})
                        </Link>
                        <p className="date">Date: {formatDate(cncrn.created_at)}</p>
                        {cncrn.message_preview && <p className="preview">&quot;{cncrn.message_preview}&quot;</p>}
                      </div>
                      <Badge 
                        variant={getStatusBadgeVariant(cncrn.status)}
                      >
                        {getStatusText(cncrn.status)}
                      </Badge>
                    </SummaryListItem>
                  ))}
                </SummaryList>
              ) : <p>No concerns flagged for this student in this room.</p>}
            </Card>
          )}
        </TabContent>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { Container, Card, Button, Alert, Badge } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import StudentCsvUpload from '@/components/teacher/StudentCsvUpload';
import ArchivePanel from '@/components/teacher/ArchivePanel';
import type { Room, Chatbot, Profile } from '@/types/database.types'; // Base types

// --- Data Structure for the Page State ---
interface StudentInRoom extends Pick<Profile, 'user_id' | 'full_name' | 'email'> {
  joined_at: string;
}

interface RoomDetailsData {
  room: Room;
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'description' | 'bot_type'>[];
  students: StudentInRoom[];
}

// MagicLinkResponse interface removed

// --- Styled Components ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md} 0;
  }
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1.5rem;
    }
  }
  
  .room-code {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-top: ${({ theme }) => theme.spacing.xs};
    font-size: 1.1rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1rem;
    }
  }
`;

const BackButton = styled(Button)`
  // No specific styles needed if general Button styling is sufficient
`;

const Section = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const SectionTitle = styled.h2`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

// Chatbots Section
const ChatbotGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const ChatbotCard = styled(Card)`
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.2rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    min-height: 40px; /* Ensure some consistent height */
  }
  .bot-type {
    font-size: 0.8rem;
    font-style: italic;
  }
`;

// Students Section
const StudentListTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  }
  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
  }
  
  // Styled Link for student names in table
  td a { // Target <a> rendered by <Link>
    color: ${({ theme }) => theme.colors.text};
    text-decoration: none;
    font-weight: 500;
    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      text-decoration: underline;
    }
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; // Hide table on smaller screens
  }
`;

const StudentListMobile = styled.div`
  display: none;
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block; // Show cards on smaller screens
  }
`;

const StudentCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};

  .student-name-link { // Use a class for the Link component itself
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    display: block;
    text-decoration: none;
     &:hover {
        text-decoration: underline;
     }
  }
  .student-email, .joined-at {
    font-size: 0.85rem;
    color: ${({ theme }) => theme.colors.textMuted};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
  }
`;


const EmptyStateText = styled.p`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.lg} 0;
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
  gap: ${({ theme }) => theme.spacing.md};
`;

// Magic link styled components removed



export default function TeacherRoomDetailPage() {
  const [roomDetails, setRoomDetails] = useState<RoomDetailsData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showCsvUpload, setShowCsvUpload] = useState(false);
  const [studentToArchive, setStudentToArchive] = useState<StudentInRoom | null>(null);
  const [showArchiveModal, setShowArchiveModal] = useState(false);
  const [showArchivedStudents, setShowArchivedStudents] = useState(false);
  const [archivingStudents, setArchivingStudents] = useState<Record<string, boolean>>({});
  
  const params = useParams();
  const router = useRouter();
  const roomId = params?.roomId as string;

  const fetchRoomDetails = useCallback(async () => {
    if (!roomId) {
      setError("Room ID not found in URL.");
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/teacher/room-details?roomId=${roomId}`);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch room details (status ${response.status})`);
      }
      const data: RoomDetailsData = await response.json();
      setRoomDetails(data);
    } catch (err) {
      console.error("Error fetching room details:", err);
      setError(err instanceof Error ? err.message : "Could not load room details.");
      setRoomDetails(null);
    } finally {
      setLoading(false);
    }
  }, [roomId]);

  useEffect(() => {
    fetchRoomDetails();
  }, [fetchRoomDetails]);

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return 'N/A';
    try {
      return new Date(dateString).toLocaleDateString();
    } catch {
      return 'Invalid Date';
    }
  };
  
  const openArchiveModal = (student: StudentInRoom) => {
    setStudentToArchive(student);
    setShowArchiveModal(true);
  };
  
  const closeArchiveModal = () => {
    setShowArchiveModal(false);
    setStudentToArchive(null);
  };
  
  const archiveStudent = async (studentId: string) => {
    // Mark student as archiving
    setArchivingStudents(prev => ({ ...prev, [studentId]: true }));
    
    try {
      const response = await fetch(`/api/teacher/students/archive`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          studentId,
          roomId
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to archive student (${response.status})`);
      }
      
      // Remove the student from the list
      if (roomDetails) {
        setRoomDetails({
          ...roomDetails,
          students: roomDetails.students.filter(s => s.user_id !== studentId)
        });
      }
      
      closeArchiveModal();
    } catch (err) {
      console.error('Error archiving student:', err);
      setError(err instanceof Error ? err.message : 'Failed to archive student');
      
      // Reset archiving state
      setArchivingStudents(prev => {
        const newState = { ...prev };
        delete newState[studentId];
        return newState;
      });
      
      closeArchiveModal();
    }
  };
  
  // Magic link related functions removed

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" />
            <p>Loading room details...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.push('/teacher-dashboard/rooms')} style={{ marginTop: '16px' }}>
            Back to Rooms
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  if (!roomDetails) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Room details not found.</Alert>
           <Button onClick={() => router.push('/teacher-dashboard/rooms')} style={{ marginTop: '16px' }}>
            Back to Rooms
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  const { room, chatbots, students } = roomDetails;

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p className="room-code">Room Code: {room.room_code}</p>
          </RoomInfo>
          <BackButton 
            variant="outline"
            onClick={() => router.push('/teacher-dashboard/rooms')}
          >
            ← All Rooms
          </BackButton>
        </Header>

        <Section>
          <SectionTitle>Assigned Chatbots ({chatbots.length})</SectionTitle>
          {chatbots.length > 0 ? (
            <ChatbotGrid>
              {chatbots.map(bot => (
                <ChatbotCard key={bot.chatbot_id}>
                  <h3>{bot.name}</h3>
                  <p>{bot.description || 'No description provided.'}</p>
                  <Badge variant={bot.bot_type === 'assessment' ? 'warning' : 'default'}>
                    Type: {bot.bot_type || 'Learning'}
                  </Badge>
                </ChatbotCard>
              ))}
            </ChatbotGrid>
          ) : (
            <EmptyStateText>No chatbots are currently assigned to this room.</EmptyStateText>
          )}
        </Section>

        <Section>
          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <SectionTitle>Enrolled Students ({students.length})</SectionTitle>
            <div style={{ display: 'flex', gap: '10px' }}>
              <Button
                variant="outline"
                size="small"
                onClick={() => setShowArchivedStudents(!showArchivedStudents)}
              >
                {showArchivedStudents ? 'Hide Archived Students' : 'View Archived Students'}
              </Button>
              <Button 
                variant="primary" 
                size="small"
                onClick={() => setShowCsvUpload(true)}
              >
                Import from CSV
              </Button>
            </div>
          </div>
          
          {students.length > 0 ? (
            <>
              <StudentListTable>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Email</th>
                    <th>Joined On</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {students.map(student => (
                    <tr key={student.user_id}>
                      <td>
                        {/* Corrected Link usage: No <a> child */}
                        <Link href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`}>
                           {student.full_name}
                        </Link>
                      </td>
                      <td>{student.email}</td>
                      <td>{formatDate(student.joined_at)}</td>
                      <td>
                        <div style={{ display: 'flex', gap: '8px' }}>
                          <Button 
                            size="small" 
                            as={Link} 
                            href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`}
                            variant="outline"
                          >
                            View Details
                          </Button>
                          {archivingStudents[student.user_id] ? (
                            <Button size="small" disabled>
                              <LoadingSpinner size="small" /> Archiving...
                            </Button>
                          ) : (
                            <Button
                              size="small"
                              variant="secondary"
                              onClick={() => openArchiveModal(student)}
                            >
                              Archive
                            </Button>
                          )}
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </StudentListTable>

              <StudentListMobile>
                {students.map(student => (
                  <StudentCard key={`mobile-${student.user_id}`}>
                    {/* Corrected Link usage: No <a> child */}
                    <Link href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`} className="student-name-link">
                        {student.full_name}
                    </Link>
                    <p className="student-email">{student.email}</p>
                    <p className="joined-at">Joined: {formatDate(student.joined_at)}</p>
                     <div style={{ display: 'flex', gap: '8px', marginTop: '8px', marginBottom: '8px' }}>
                        <Button 
                          size="small" 
                          as={Link} 
                          href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`}
                          variant="outline"
                          style={{flex: 1}}
                        >
                          View Details
                        </Button>
                        {archivingStudents[student.user_id] ? (
                          <Button size="small" disabled style={{flex: 1}}>
                            <LoadingSpinner size="small" /> Archiving...
                          </Button>
                        ) : (
                          <Button
                            size="small"
                            variant="secondary"
                            onClick={() => openArchiveModal(student)}
                            style={{flex: 1}}
                          >
                            Archive
                          </Button>
                        )}
                      </div>
                      
                      {/* Magic link functionality removed */}
                  </StudentCard>
                ))}
              </StudentListMobile>
            </>
          ) : (
            <EmptyStateText>No students have joined this room yet.</EmptyStateText>
          )}
        </Section>

        {showArchivedStudents && (
          <ArchivePanel 
            type="students"
            roomId={roomId}
            onItemRestored={fetchRoomDetails}
          />
        )}

      </Container>
      
      {/* CSV Upload Modal */}
      {showCsvUpload && (
        <StudentCsvUpload
          roomId={roomId}
          roomName={room.room_name}
          onClose={() => {
            setShowCsvUpload(false);
            // Refresh the room details to show newly added students
            fetchRoomDetails();
          }}
        />
      )}
      
      {/* Archive Confirmation Modal */}
      {showArchiveModal && studentToArchive && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'rgba(0, 0, 0, 0.6)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 1000
        }}>
          <Card style={{
            width: '100%',
            maxWidth: '400px',
            padding: '24px',
            textAlign: 'center'
          }}>
            <h3 style={{ marginBottom: '16px' }}>Archive Student</h3>
            <p>Are you sure you want to remove <strong>{studentToArchive.full_name}</strong> from this room?</p>
            <p style={{ marginTop: '8px' }}>The student will no longer have access to this room, but their account and data will be preserved.</p>
            <div style={{ 
              display: 'flex', 
              justifyContent: 'center', 
              gap: '16px', 
              marginTop: '24px' 
            }}>
              <Button variant="outline" onClick={closeArchiveModal}>
                Cancel
              </Button>
              <Button 
                variant="secondary" 
                onClick={() => archiveStudent(studentToArchive.user_id)}
              >
                Archive Student
              </Button>
            </div>
          </Card>
        </div>
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled, { useTheme } from 'styled-components';
// No longer need useRouter if not used directly on this page for navigation
// import { useRouter } from 'next/navigation';
import { Button, Alert, Card, Container } from '@/styles/StyledComponents';
import RoomList from '@/components/teacher/RoomList';
import RoomForm from '@/components/teacher/RoomForm';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import ArchivePanel from '@/components/teacher/ArchivePanel';
import type { Room as BaseRoom, Chatbot, TeacherRoom } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div``;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

// Styled components for DeleteModal
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 450px;
  margin: 20px;
  position: relative;
  text-align: center;
  border-top: none !important;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

interface DeleteModalProps {
  isOpen: boolean;
  itemType: 'Room';
  itemName: string;
  onConfirm: () => Promise<void>;
  onCancel: () => void;
  isDeleting: boolean;
}

function DeleteModal({ isOpen, itemType, itemName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete {itemType}</ModalTitle>
        <ModalText>
          Are you sure you want to delete the {itemType.toLowerCase()} &quot;
          <strong>{itemName}</strong>
          &quot;? This action cannot be undone and may affect associated data (e.g., student memberships, chat history).
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
             variant="danger"
             onClick={onConfirm}
             disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : `Yes, Delete ${itemType}`}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}


export default function ManageRoomsPage() {
  const [rooms, setRooms] = useState<TeacherRoom[]>([]);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null);
  const [showArchivedRooms, setShowArchivedRooms] = useState(false);
  const theme = useTheme();
  // const router = useRouter(); // Removed if not used

  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    type: 'Room';
    id: string | null;
    name: string;
  }>({ isOpen: false, type: 'Room', id: null, name: '' });
  const [isDeleting, setIsDeleting] = useState(false);
  const [archiveModal, setArchiveModal] = useState<{
    isOpen: boolean;
    id: string | null;
    name: string;
  }>({ isOpen: false, id: null, name: '' });
  const [isArchiving, setIsArchiving] = useState(false);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [roomsResponse, chatbotsResponse] = await Promise.all([
        fetch('/api/teacher/rooms'),
        fetch('/api/teacher/chatbots')
      ]);

      if (!roomsResponse.ok) {
        const errData = await roomsResponse.json().catch(()=>({error: `Failed to parse rooms error response (status ${roomsResponse.status})`}));
        throw new Error(errData.error || `Failed to fetch rooms (status ${roomsResponse.status})`);
      }
      if (!chatbotsResponse.ok) {
        const errData = await chatbotsResponse.json().catch(()=>({error: `Failed to parse chatbots error response (status ${chatbotsResponse.status})`}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`);
      }

      const roomsData: TeacherRoom[] = await roomsResponse.json();
      const chatbotsData: Chatbot[] = await chatbotsResponse.json();

      setRooms(roomsData);
      setChatbots(chatbotsData);
    } catch (err) {
      console.error("Error fetching page data:", err);
      setError(err instanceof Error ? err.message : 'Could not load data.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleRoomCreatedOrUpdated = () => {
    setShowRoomForm(false);
    setEditingRoom(null);
    fetchData();
  };

  const openDeleteModal = (room: BaseRoom) => {
    setDeleteModal({ isOpen: true, type: 'Room', id: room.room_id, name: room.room_name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, type: 'Room', id: null, name: '' });
  };
  
  const openArchiveModal = (room: BaseRoom) => {
    setArchiveModal({ isOpen: true, id: room.room_id, name: room.room_name });
  };
  
  const closeArchiveModal = () => {
    setArchiveModal({ isOpen: false, id: null, name: '' });
  };
  
  const handleArchiveRoom = async () => {
    if (!archiveModal.id) return;
    
    setIsArchiving(true);
    setError(null);
    
    try {
      const response = await fetch(`/api/teacher/rooms/archive`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          roomId: archiveModal.id,
          archive: true
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to archive room`);
      }
      
      console.log(`Room ${archiveModal.id} archived successfully.`);
      closeArchiveModal();
      fetchData();
    } catch (error) {
      console.error(`Error archiving Room:`, error);
      setError(error instanceof Error ? error.message : `Failed to archive Room.`);
    } finally {
      setIsArchiving(false);
    }
  };

  const handleDeleteConfirm = async () => {
    if (!deleteModal.id) return;

    setIsDeleting(true);
    setError(null);

    try {
        const response = await fetch(`/api/teacher/rooms/${deleteModal.id}`, { method: 'DELETE' });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete room`);
        }

        console.log(`Room ${deleteModal.id} deleted successfully.`);
        closeDeleteModal();
        fetchData();
    } catch (error) {
        console.error(`Error deleting Room:`, error);
        setError(error instanceof Error ? error.message : `Failed to delete Room.`);
    } finally {
        setIsDeleting(false);
    }
  };

  const handleEditRoom = (room: BaseRoom) => {
    setEditingRoom(room);
  };

  const handleCloseEditRoom = () => {
    setEditingRoom(null);
  };

  const handleRoomEditSuccess = () => {
    setEditingRoom(null);
    fetchData();
  };


  return (
    <PageWrapper>
      <Container>
        <PageHeader>
          <Title>Classroom Rooms</Title>
          <div style={{ display: 'flex', gap: '10px' }}>
            <Button
              variant="outline"
              onClick={() => setShowArchivedRooms(!showArchivedRooms)}
            >
              {showArchivedRooms ? 'Hide Archived Rooms' : 'View Archived Rooms'}
            </Button>
            <Button
              onClick={() => setShowRoomForm(true)}
              disabled={chatbots.length === 0 && !isLoading}
              title={chatbots.length === 0 && !isLoading ? "Create a chatbot before creating a room" : "Create New Room"}
            >
              + Create New Room
            </Button>
          </div>
        </PageHeader>

        {chatbots.length === 0 && !isLoading && !error && (
          <Alert variant='info' style={{marginBottom: '16px'}}>
              You need to create at least one chatbot before you can create a classroom room.
          </Alert>
        )}

        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        {isLoading ? (
          <Card style={{ textAlign: 'center', padding: '40px' }}>
            <LoadingSpinner /> Loading rooms...
          </Card>
        ) : error ? null : (
          <RoomList
            rooms={rooms}
            onUpdate={fetchData}
            onEditRoom={handleEditRoom}
            onDeleteRoom={openDeleteModal}
            onArchiveRoom={openArchiveModal}
            // 👇 CORRECTED: Pass the blue (skolrCyan) color from the theme
            accentColor={theme.colors.blue}
          />
        )}
        
        {showArchivedRooms && (
          <ArchivePanel 
            type="rooms"
            onItemRestored={fetchData}
          />
        )}
      </Container>

      {showRoomForm && (
        <RoomForm
          chatbots={chatbots}
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreatedOrUpdated}
        />
      )}

      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={handleCloseEditRoom}
          onSuccess={handleRoomEditSuccess}
        />
      )}

      <DeleteModal
        isOpen={deleteModal.isOpen}
        itemType={deleteModal.type}
        itemName={deleteModal.name}
        onConfirm={handleDeleteConfirm}
        onCancel={closeDeleteModal}
        isDeleting={isDeleting}
      />
      
      {/* Archive Modal */}
      {archiveModal.isOpen && (
        <ModalOverlay>
          <ModalContent>
            <ModalTitle>Archive Room</ModalTitle>
            <ModalText>
              Are you sure you want to archive the room &quot;
              <strong>{archiveModal.name}</strong>
              &quot;? The room will still be accessible but won't appear in your active rooms list.
            </ModalText>
            <ModalActions>
              <Button variant="outline" onClick={closeArchiveModal} disabled={isArchiving}>
                Cancel
              </Button>
              <Button
                 variant="secondary"
                 onClick={handleArchiveRoom}
                 disabled={isArchiving}
              >
                {isArchiving ? 'Archiving...' : 'Archive Room'}
              </Button>
            </ModalActions>
          </ModalContent>
        </ModalOverlay>
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/page.tsx
'use client';

import styled from 'styled-components';
import { useState, useEffect } from 'react';
import DashboardOverview from '@/components/teacher/DashboardOverview'; 
import { createClient as createStandardSupabaseClient } from '@/lib/supabase/client';

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 2rem;
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.125rem;
`;

export default function TeacherDashboardPage() {
  const [teacherName, setTeacherName] = useState<string | null>(null);
  const supabase = createStandardSupabaseClient();

  useEffect(() => {
    async function fetchTeacherProfile() {
      try {
        const { data: { session } } = await supabase.auth.getSession();
        
        if (session?.user?.id) {
          const { data: profile, error } = await supabase
            .from('profiles')
            .select('full_name')
            .eq('user_id', session.user.id)
            .single();
            
          if (error) {
            console.error('[TeacherDashboard] Error fetching profile:', error);
          } else if (profile) {
            setTeacherName(profile.full_name);
          }
        }
      } catch (error) {
        console.error('[TeacherDashboard] Error in fetchTeacherProfile:', error);
      }
    }
    
    fetchTeacherProfile();
  }, [supabase]);

  console.log('[TeacherDashboardPage] Rendering with DashboardOverview...');
  
  return (
    <div>
      <PageHeader>
        <Title>Teacher Dashboard</Title>
        <Subtitle>Welcome {teacherName ? `${teacherName}` : ''}! Here&apos;s a summary of your Skolr activities.</Subtitle>
      </PageHeader>
      <DashboardOverview />
    </div>
  );
}// src/app/teacher-dashboard/concerns/page.tsx
'use client';

import styled, { useTheme } from 'styled-components'; // Import useTheme
import ConcernsList from '@/components/teacher/ConcernsList';
import { Container } from '@/styles/StyledComponents';

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.8rem; 
`;

export default function ConcernsPage() {
  const theme = useTheme(); // Get the theme object

  return (
    <Container>
      <PageHeader>
        <Title>Student Welfare Concerns</Title>
      </PageHeader>
      {/* Pass the desired accent color to ConcernsList */}
      <ConcernsList accentColor={theme.colors.green} /> 
    </Container>
  );
}// src/app/teacher-dashboard/concerns/[flagId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// Import necessary components and styles
import { Container, Card, Button, Alert, Badge, TextArea, Label, Select as StyledSelect } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types (ensure Profile includes full_name)
import type { FlaggedMessage, ConcernStatus, ChatMessage as DatabaseChatMessage, Profile, Room } from '@/types/database.types'; // Import necessary base types


// Interface for the data structure returned by the API GET request
// This includes the nested objects directly as returned by the join syntax used
// and the flattened fields for easier use, plus surroundingMessages
interface FlagDetailsResponse extends FlaggedMessage {
    student: Pick<Profile, 'full_name' | 'email'> | null; // Nested original
    room: Pick<Room, 'room_name'> | null; // Nested original
    message: DatabaseChatMessage | null; // Nested original
    student_name: string | null; // Flattened
    student_email: string | null; // Flattened
    room_name: string | null; // Flattened
    message_content: string | null; // Flattened
    surroundingMessages: DatabaseChatMessage[];
}


// --- Styled Components (Keep as previously defined) ---
const PageWrapper = styled.div` padding: ${({ theme }) => theme.spacing.xl} 0; min-height: 100vh; `;
const Header = styled.div` display: flex; justify-content: space-between; align-items: center; margin-bottom: ${({ theme }) => theme.spacing.xl}; flex-wrap: wrap; gap: ${({ theme }) => theme.spacing.md}; `;
const Title = styled.h1` color: ${({ theme }) => theme.colors.text}; margin: 0; font-size: 1.8rem; @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) { font-size: 1.5rem; } `;
const BackButton = styled(Button)``;
const Grid = styled.div` display: grid; grid-template-columns: 3fr 2fr; gap: ${({ theme }) => theme.spacing.xl}; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { grid-template-columns: 1fr; } `;
const ConversationContext = styled(Card)` max-height: 75vh; display: flex; flex-direction: column; overflow: hidden; `;
const ContextHeader = styled.h3` padding: 0 0 ${({ theme }) => theme.spacing.md} 0; margin: 0 0 ${({ theme }) => theme.spacing.md} 0; border-bottom: 1px solid ${({ theme }) => theme.colors.border}; font-size: 1.2rem; `;
const MessagesList = styled.div` flex: 1; overflow-y: auto; padding-right: ${({ theme }) => theme.spacing.sm}; margin-right: -${({ theme }) => theme.spacing.sm}; &::-webkit-scrollbar { width: 6px; } &::-webkit-scrollbar-thumb { background-color: ${({ theme }) => theme.colors.borderDark}; border-radius: 3px; } &::-webkit-scrollbar-track { background: transparent; } `;
const FlaggedMessageHighlight = styled.div` border: 3px solid ${({ theme }) => theme.colors.red}; border-radius: ${({ theme }) => theme.borderRadius.large}; margin: ${({ theme }) => theme.spacing.md} 0; background-color: rgba(248, 127, 127, 0.08); padding: 2px; & > div { margin-bottom: 0; } `;
const ConcernDetailsCard = styled(Card)` align-self: start; position: sticky; top: 80px; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { position: static; margin-top: ${({ theme }) => theme.spacing.xl}; } `;
const DetailsHeader = styled.h3` margin-bottom: ${({ theme }) => theme.spacing.lg}; font-size: 1.2rem; `;
const DetailItem = styled.div` margin-bottom: ${({ theme }) => theme.spacing.md}; font-size: 0.9rem; line-height: 1.5; strong { display: block; margin-bottom: ${({ theme }) => theme.spacing.xs}; color: ${({ theme }) => theme.colors.textLight}; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; } span, p { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; } p { margin-bottom: 0; } `;
const AnalysisText = styled.p` font-style: italic; color: ${({ theme }) => theme.colors.textLight}; background-color: ${({ theme }) => theme.colors.backgroundDark}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin-top: ${({ theme }) => theme.spacing.xs}; `;
const ActionForm = styled.form` margin-top: ${({ theme }) => theme.spacing.lg}; padding-top: ${({ theme }) => theme.spacing.lg}; border-top: 1px solid ${({ theme }) => theme.colors.border}; `;
const FormActions = styled.div` margin-top: ${({ theme }) => theme.spacing.lg}; `;
const CustomSelect = styled(StyledSelect)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; `; // Use imported Select
const StyledTextArea = styled(TextArea)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; min-height: 100px; `;
// --- End Styled Components ---

// --- Helper Functions ---
function getConcernTypeText(type: string | undefined): string { if (!type) return 'Unknown'; return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); }
function getConcernLevelText(level: number | undefined): string { if (level === undefined) return 'N/A'; if (level >= 5) return 'Critical'; if (level >= 4) return 'High'; if (level >= 3) return 'Significant'; if (level >= 2) return 'Moderate'; if (level >= 1) return 'Minor'; return 'Low'; }
// -----------------------

export default function ConcernDetailPage() {
    const [concern, setConcern] = useState<FlagDetailsResponse | null>(null); // Use the more specific type for fetched data
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [actionError, setActionError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [selectedStatus, setSelectedStatus] = useState<ConcernStatus>('pending');
    const [notes, setNotes] = useState('');

    const params = useParams();
    const router = useRouter();
    const flagId = params?.flagId as string;
    const flaggedMessageRef = useRef<HTMLDivElement>(null);

    const fetchConcernDetails = useCallback(async () => {
        if (!flagId) { setError("Flag ID missing from page parameters."); setLoading(false); return; }
        setLoading(true); setError(null); setActionError(null);
        try {
            console.log(`Fetching details for flag: ${flagId}`);
            // --- FIX: Fetch using query parameter to the collection route ---
            const response = await fetch(`/api/teacher/concerns?flagId=${flagId}`);
            // -------------------------------------------------------------
            if (!response.ok) {
                const data = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                throw new Error(data.error || `Failed to fetch concern details (status: ${response.status})`);
            }
            const data: FlagDetailsResponse = await response.json(); // Use the correct response type
            console.log("Fetched Concern Data:", data);
            
            // Debug info for AI analysis explanation
            console.log("AI Analysis Explanation:", {
                exists: !!data.analysis_explanation,
                value: data.analysis_explanation,
                type: typeof data.analysis_explanation,
                length: data.analysis_explanation ? data.analysis_explanation.length : 0
            });
            
            setConcern(data);
            setSelectedStatus(data.status || 'pending');
            setNotes(data.notes || '');
        } catch (err) {
            console.error("Error fetching concern:", err);
            setError(err instanceof Error ? err.message : 'Failed to load concern details');
            setConcern(null);
        } finally { setLoading(false); }
    }, [flagId]); // Keep flagId as dependency

    useEffect(() => { fetchConcernDetails(); }, [fetchConcernDetails]);

    useEffect(() => {
        const timer = setTimeout(() => {
            if (concern && flaggedMessageRef.current) {
                console.log("Scrolling to flagged message ref");
                flaggedMessageRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
        return () => clearTimeout(timer);
    }, [concern]);

    const handleStatusUpdate = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!concern?.flag_id) return; // Ensure we have the concern and its ID

        setIsSubmitting(true); setActionError(null);
        try {
            console.log(`Updating flag ${concern.flag_id} with status ${selectedStatus}`);
            // --- FIX: Send PATCH to collection route, include flagId in body ---
            const response = await fetch(`/api/teacher/concerns`, { // Target the collection route
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    flagId: concern.flag_id, // Include flagId in the body
                    status: selectedStatus,
                    notes: notes
                 }),
            });
            // --- END FIX ---
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Update failed' }));
                throw new Error(errorData.error || 'Failed to update status');
            }

            const updatedData = await response.json();
            // Update state based on the response from the PATCH request
            setConcern(prev => prev ? ({ ...prev, ...updatedData }) : null);
            setSelectedStatus(updatedData.status);
            setNotes(updatedData.notes || '');
            alert("Status updated successfully!");

        } catch (err) {
            setActionError(err instanceof Error ? err.message : 'Failed to update status');
        } finally {
            setIsSubmitting(false);
        }
    };

    // --- Render Logic ---
    if (loading) { return <PageWrapper><Container><Card><LoadingSpinner /> Loading concern details...</Card></Container></PageWrapper>; }
    if (error) { return <PageWrapper><Container><Alert variant="error">{error}</Alert><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }
    if (!concern) { return <PageWrapper><Container><Card>Concern not found or permission denied.</Card><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }

    // Find the actual flagged message within the surrounding messages (if fetched) or use the direct message object
    const actualFlaggedMessage = concern.surroundingMessages?.find(m => m.message_id === concern.message_id) || concern.message;

    return (
        <PageWrapper>
            <Container>
                <Header>
                    <Title>Review Concern</Title>
                    <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard#concerns')}>← Back to Dashboard</BackButton>
                </Header>
                <Grid>
                    {/* Conversation Context */}
                    <ConversationContext>
                        <ContextHeader>Conversation Context</ContextHeader>
                        <MessagesList>
                            {concern.surroundingMessages?.length > 0 ? (
                                concern.surroundingMessages.map(msg => {
                                    const isFlagged = msg.message_id === concern.message_id;
                                    const chatbotName = concern.room_name || "Chatbot"; // Placeholder name

                                    const messageComponent = ( <ChatMessageComponent key={msg.message_id} message={msg} chatbotName={chatbotName} /> );
                                    return isFlagged ? ( <FlaggedMessageHighlight key={msg.message_id} ref={flaggedMessageRef}>{messageComponent}</FlaggedMessageHighlight> ) : messageComponent;
                                })
                            ) : ( actualFlaggedMessage ? ( <FlaggedMessageHighlight ref={flaggedMessageRef}><ChatMessageComponent key={actualFlaggedMessage.message_id} message={actualFlaggedMessage} chatbotName={concern.room_name || "Chatbot"} /></FlaggedMessageHighlight> )
                                : <p style={{ textAlign: 'center', padding: '20px', color: '#888' }}>Conversation context unavailable.</p>
                            )}
                        </MessagesList>
                    </ConversationContext>

                    {/* Details & Actions */}
                    <ConcernDetailsCard>
                        <DetailsHeader>Concern Details</DetailsHeader>
                        {/* Use flattened properties from FlagDetailsResponse */}
                        <DetailItem><strong>Student:</strong><span>{concern.student_name || 'N/A'} ({concern.student_email || 'No Email'})</span></DetailItem>
                        <DetailItem><strong>Classroom:</strong><span>{concern.room_name || 'N/A'}</span></DetailItem>
                        <DetailItem><strong>Concern Type:</strong><span>{getConcernTypeText(concern.concern_type)}</span></DetailItem>
                        <DetailItem><strong>Assessed Level:</strong><Badge variant="default" style={{ marginLeft: '8px' }}>{getConcernLevelText(concern.concern_level)} (Level {concern.concern_level})</Badge></DetailItem>
                        <DetailItem><strong>Detected At:</strong><span>{new Date(concern.created_at).toLocaleString()}</span></DetailItem>
                        {/* Always show AI Analysis section, with fallback message if missing */}
                        <DetailItem>
                            <strong>AI Analysis:</strong>
                            <AnalysisText>
                                {concern.analysis_explanation || "This message was flagged by the automated safety system. Please review the conversation context."}
                            </AnalysisText>
                        </DetailItem>
                        {concern.reviewed_at && (<DetailItem><strong>Last Reviewed:</strong><span>{new Date(concern.reviewed_at).toLocaleString()}</span></DetailItem>)}

                        <ActionForm onSubmit={handleStatusUpdate}>
                             <Label htmlFor="status">Update Status:</Label>
                            <CustomSelect id="status" value={selectedStatus} onChange={(e) => setSelectedStatus(e.target.value as ConcernStatus)}>
                               <option value="pending">Pending Review</option>
                               <option value="reviewing">Reviewing</option>
                               <option value="resolved">Resolved</option>
                               <option value="false_positive">False Positive</option>
                            </CustomSelect>
                             <Label htmlFor="notes">Review Notes:</Label>
                             <StyledTextArea id="notes" rows={5} value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Add notes on actions taken, observations, or decision rationale..." />
                             {actionError && <Alert variant="error" style={{ marginBottom: '16px' }}>{actionError}</Alert>}
                             <FormActions><Button type="submit" disabled={isSubmitting} style={{ width: '100%' }}>{isSubmitting ? 'Updating...' : 'Update Status & Notes'}</Button></FormActions>
                        </ActionForm>
                    </ConcernDetailsCard>
                </Grid>
            </Container>
        </PageWrapper>
    );
}.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
// src/app/layout.tsx
import { Metadata, Viewport } from 'next';
import Providers from './providers';
import Header from '@/components/layout/Header';
import { APP_NAME, APP_DESCRIPTION } from '@/lib/utils/constants';
import './globals.css';

export const metadata: Metadata = {
  title: APP_NAME,
  description: APP_DESCRIPTION,
};

export const viewport: Viewport = {
  width: 'device-width',
  initialScale: 1.0,
  maximumScale: 1.0,
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>
          <Header />
          {children}
        </Providers>
      </body>
    </html>
  );
}'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Container, Card, Button, Input, Alert } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import { useRouter } from 'next/navigation';

const PageWrapper = styled.div`
  padding: 2rem 0;
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const Title = styled.h1`
  font-size: 2rem;
  color: ${({ theme }) => theme.colors.primary};
  text-align: center;
  margin-bottom: 2rem;
`;

const StyledCard = styled(Card)`
  max-width: 500px;
  margin: 0 auto;
  padding: 2rem;
`;

const StyledForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
`;

const Label = styled.label`
  font-weight: 500;
  margin-bottom: 0.5rem;
  display: block;
`;

const InputGroup = styled.div`
  display: flex;
  flex-direction: column;
`;

const PinInput = styled(Input)`
  letter-spacing: 0.5rem;
  text-align: center;
  font-size: 1.5rem;
  font-weight: bold;
`;

const ResultBox = styled.div`
  margin-top: 1rem;
  padding: 1rem;
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  
  h3 {
    margin-top: 0;
    color: ${({ theme }) => theme.colors.primary};
  }
  
  p {
    margin: 0.5rem 0;
  }
`;

export default function DirectStudentAccess() {
  const [identifier, setIdentifier] = useState('');
  const [pin, setPin] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // Define interface for student data
  interface Student {
    user_id: string;
    full_name?: string;
    email?: string;
    pin_code?: string;
  }
  
  // Define interface for room data
  interface Room {
    room_id: string;
    room_name: string;
    room_code: string;
    teacher_id?: string;
  }
  
  const [student, setStudent] = useState<Student | null>(null);
  const [rooms, setRooms] = useState<Room[]>([]);
  
  const router = useRouter();
  const supabase = createClient();
  
  // Check if we're already logged in
  useEffect(() => {
    const checkLoginStatus = async () => {
      // Check localStorage first
      const storedUserId = localStorage.getItem('student_direct_access_id');
      const storedName = localStorage.getItem('student_direct_access_name');
      
      if (storedUserId && storedName) {
        console.log('Found stored access info, checking validity...');
        try {
          // Verify the student exists in the database
          const { data, error } = await supabase
            .from('profiles')
            .select('user_id, full_name')
            .eq('user_id', storedUserId)
            .single();
            
          if (data && !error) {
            console.log('Valid stored user, loading rooms...');
            setStudent(data);
            fetchStudentRooms(storedUserId);
          } else {
            console.log('Stored user invalid, clearing storage');
            localStorage.removeItem('student_direct_access_id');
            localStorage.removeItem('student_direct_access_name');
          }
        } catch (err) {
          console.error('Error checking stored user:', err);
        }
      }
    };
    
    checkLoginStatus();
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [supabase]); // fetchStudentRooms intentionally omitted
  
  const fetchStudentRooms = async (userId: string) => {
    try {
      const { data, error } = await supabase
        .from('room_memberships')
        .select(`
          rooms (
            room_id,
            room_name,
            room_code
          )
        `)
        .eq('student_id', userId);
        
      if (error) throw error;
      
      // Extract the rooms from the memberships
      // Process with type safety
      const roomsList: Room[] = [];
      if (data && Array.isArray(data)) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        data.forEach((item: any) => {
          if (item && item.rooms) {
            roomsList.push({
              room_id: String(item.rooms.room_id || ''),
              room_name: String(item.rooms.room_name || 'Unnamed Room'),
              room_code: String(item.rooms.room_code || ''),
              teacher_id: item.rooms.teacher_id ? String(item.rooms.teacher_id) : undefined
            });
          }
        });
      }
      
      setRooms(roomsList);
    } catch (err) {
      console.error('Error fetching rooms:', err);
    }
  };
  
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setError(null);
    
    try {
      // Step 1: First use the student lookup API endpoint to verify PIN and get user_id
      const lookupResponse = await fetch('/api/auth/student-username-lookup', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ identifier, pin })
      });
      
      const lookupData = await lookupResponse.json();
      
      if (!lookupResponse.ok) {
        throw new Error(lookupData.error || 'Failed to find student');
      }
      
      if (!lookupData.pin_verified) {
        throw new Error('PIN verification failed');
      }
      
      // Store the relevant user info in localStorage (needed for direct access)
      const studentData = lookupData.best_match || { full_name: 'Student' };
      const userId = lookupData.user_id;
      
      // *** STORE USER INFO IN ALL POSSIBLE FORMATS FOR MAXIMUM COMPATIBILITY ***
      localStorage.setItem('student_direct_access_id', userId);
      localStorage.setItem('student_direct_access_name', studentData.full_name || 'Student');
      localStorage.setItem('current_student_id', userId);
      localStorage.setItem('direct_pin_login', 'true');
      localStorage.setItem('direct_pin_login_time', Date.now().toString());
      localStorage.setItem('direct_pin_login_user', userId);
      
      // Record successful authentication
      console.log("PIN verified successfully, redirecting to dashboard with direct access...");
      
      // SUCCESS! Now redirect directly to dashboard with all necessary params
      // This actually works better than calling the direct-student-login API which has issues
      const redirectParams = new URLSearchParams({
        direct: '1',
        user_id: userId,
        _t: Date.now().toString(), // Cache busting timestamp
        pin_verified: 'true'      // Signal that PIN was verified
      });
      
      // Set directly to window.location for a full page reload with the params
      window.location.href = `/student/dashboard?${redirectParams.toString()}`;
      return;
      
    } catch (err) {
      console.error('Login error:', err);
      setError(err instanceof Error ? err.message : 'Login failed');
      setLoading(false);
    }
  };
  
  const handleRoomClick = (roomId: string) => {
    // Navigate to the room page with direct access parameters
    router.push(`/room/${roomId}?direct=1&student_id=${localStorage.getItem('student_direct_access_id')}`);
  };
  
  // No longer needed - we handle the redirect directly in handleSubmit
  
  const handleLogout = () => {
    setStudent(null);
    setRooms([]);
    localStorage.removeItem('student_direct_access_id');
    localStorage.removeItem('student_direct_access_name');
  };
  
  // Show the login form if not logged in
  if (!student) {
    return (
      <PageWrapper>
        <Container>
          <Title>Student Room Access</Title>
          <StyledCard>
            <p>Enter your name and PIN to access your rooms.</p>
            
            {error && <Alert variant="error">{error}</Alert>}
            
            <StyledForm onSubmit={handleSubmit}>
              <InputGroup>
                <Label htmlFor="identifier">Your Name or Username</Label>
                <Input
                  id="identifier"
                  value={identifier}
                  onChange={(e) => setIdentifier(e.target.value)}
                  placeholder="Enter your name"
                  disabled={loading}
                  required
                />
              </InputGroup>
              
              <InputGroup>
                <Label htmlFor="pin">PIN Code</Label>
                <PinInput
                  id="pin"
                  type="text"
                  inputMode="numeric"
                  maxLength={4}
                  pattern="\d{4}"
                  value={pin}
                  onChange={(e) => {
                    const value = e.target.value.replace(/\D/g, '');
                    setPin(value);
                  }}
                  placeholder="****"
                  disabled={loading}
                  required
                />
              </InputGroup>
              
              <Button type="submit" disabled={loading}>
                {loading ? 'Checking...' : 'Access Rooms'}
              </Button>
            </StyledForm>
          </StyledCard>
        </Container>
      </PageWrapper>
    );
  }
  
  // Show the student's rooms when logged in
  return (
    <PageWrapper>
      <Container>
        <Title>Your Classrooms</Title>
        
        <StyledCard>
          <ResultBox>
            <h3>Welcome, {student.full_name || 'Student'}!</h3>
            <p>You are directly accessing your classrooms.</p>
          </ResultBox>
          
          {rooms.length === 0 ? (
            <Alert variant="info" style={{ marginTop: '1rem' }}>
              You haven&apos;t joined any rooms yet.
            </Alert>
          ) : (
            <div style={{ marginTop: '1rem' }}>
              <p>Select a room to enter:</p>
              {rooms.map(room => (
                <Button
                  key={room.room_id}
                  onClick={() => handleRoomClick(room.room_id)}
                  style={{ width: '100%', marginBottom: '0.5rem' }}
                >
                  {room.room_name}
                </Button>
              ))}
            </div>
          )}
          
          <Button 
            variant="outline" 
            style={{ marginTop: '1rem' }}
            onClick={handleLogout}
          >
            Log Out
          </Button>
        </StyledCard>
      </Container>
    </PageWrapper>
  );
}// src/app/api/room/direct-access/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');

    // Validate required parameters
    if (!roomId || !studentId) {
      return NextResponse.json(
        { error: 'Missing required parameters: roomId and studentId are required' },
        { status: 400 }
      );
    }

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    // Verify student exists
    const { data: studentProfile, error: studentError } = await supabaseAdmin
      .from('profiles')
      .select('user_id, full_name, role')
      .eq('user_id', studentId)
      .eq('role', 'student')
      .single();

    if (studentError || !studentProfile) {
      console.error('[API GET /room/direct-access] Student not found:', studentId);
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Verify the room exists
    const { data: room, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('room_id, room_name, room_code, is_active')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      console.error('[API GET /room/direct-access] Room not found:', roomId);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    if (!room.is_active) {
      return NextResponse.json({ error: 'Room is not active' }, { status: 403 });
    }

    // Check for membership
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    // If not a member and the room exists, add membership
    if ((!membership || membershipError) && room) {
      const { error: insertError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: roomId,
          student_id: studentId
        });

      if (insertError) {
        console.error('[API GET /room/direct-access] Error adding student to room:', insertError);
        return NextResponse.json(
          { error: 'Failed to add student to room' },
          { status: 500 }
        );
      }
    }

    // Get room chatbots
    const { data: chatbots, error: chatbotsError } = await supabaseAdmin
      .from('room_chatbots')
      .select(`
        chatbots (
          chatbot_id,
          name,
          description,
          bot_type
        )
      `)
      .eq('room_id', roomId);

    if (chatbotsError) {
      console.error('[API GET /room/direct-access] Error fetching chatbots:', chatbotsError);
    }

    // Extract chatbot data from the join result
    const roomChatbots = chatbots
      ? chatbots
          .map((item) => item.chatbots)
          .filter((chatbot) => chatbot !== null)
      : [];

    // Return room details with access confirmation
    return NextResponse.json({
      success: true,
      room: {
        room_id: room.room_id,
        room_name: room.room_name,
        room_code: room.room_code
      },
      student: {
        user_id: studentProfile.user_id,
        full_name: studentProfile.full_name
      },
      chatbots: roomChatbots,
      membership_status: membership ? 'existing' : 'added'
    });
  } catch (error) {
    console.error('[API GET /room/direct-access] General error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown server error' },
      { status: 500 }
    );
  }
}// src/app/api/magic-link/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const studentId = searchParams.get('studentId');
    const roomId = searchParams.get('roomId');
    
    console.log('[Magic Link API] GET request received with params:', { studentId, roomId, url: request.url });

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    // Get the student details
    const { data: student, error: studentError } = await supabase
      .from('profiles')
      .select('full_name')
      .eq('user_id', studentId)
      .single();

    if (studentError || !student) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      return NextResponse.json(
        { error: 'Student is not a member of this room' },
        { status: 404 }
      );
    }

    // Generate the magic link using the format: roomCode_userId_encodedStudentName
    const encodedName = encodeURIComponent(student.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Magic Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    return NextResponse.json({
      magicLink,
      studentName: student.full_name,
      code: simpleLinkCode
    });
  } catch (error) {
    console.error('Error generating student magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { studentId, roomId } = body;
    
    console.log('[Magic Link API] POST request received with body:', { studentId, roomId });

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    // Get the student details
    const { data: student, error: studentError } = await supabase
      .from('profiles')
      .select('full_name')
      .eq('user_id', studentId)
      .single();

    if (studentError || !student) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      return NextResponse.json(
        { error: 'Student is not a member of this room' },
        { status: 404 }
      );
    }

    // Generate the magic link
    const encodedName = encodeURIComponent(student.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Magic Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    return NextResponse.json({
      magicLink,
      studentName: student.full_name,
      code: simpleLinkCode,
      regenerated: true
    });
  } catch (error) {
    console.error('Error regenerating student magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to regenerate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/test/route.ts
import { NextResponse } from 'next/server';

export async function GET() {
  console.log('Test API endpoint called');
  return NextResponse.json({ message: 'API is working!' });
}// src/app/api/chat/[roomId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateEmbedding } from '@/lib/openai/embeddings';
import { queryVectors } from '@/lib/pinecone/utils';
import { checkMessageSafety, initialConcernCheck } from '@/lib/safety/monitoring';
import type { ChatMessage, Room } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
// This is still the internal command identifier used by the backend
const ASSESSMENT_TRIGGER_COMMAND = "/assess";
// Number of messages to include in the assessment context
const ASSESSMENT_CONTEXT_MESSAGE_COUNT = 5;

const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// --- GET Function ---
export async function GET(request: NextRequest) {
    try {
        const pathname = request.nextUrl.pathname;
        const segments = pathname.split('/');
        const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
        const { searchParams } = new URL(request.url);
        const chatbotIdFilter = searchParams.get('chatbotId');
        const instanceIdFilter = searchParams.get('instanceId');

        if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

        // Check for direct access headers from API
        const directAccessKey = request.headers.get('x-direct-access-admin-key');
        const bypassUserId = request.headers.get('x-bypass-auth-user-id');
        let user;

        // Always use the admin client to bypass RLS policies
        const supabaseAdmin = createAdminClient();

        if (directAccessKey && bypassUserId && directAccessKey === (process.env.DIRECT_ACCESS_ADMIN_KEY || 'directaccess_key')) {
            console.log(`[API Chat GET] Using bypassed auth for user: ${bypassUserId}`);
            // Use admin client to verify the user exists
            const { data: userData, error: userError } = await supabaseAdmin
                .from('profiles')
                .select('user_id, role')
                .eq('user_id', bypassUserId)
                .maybeSingle();

            if (userError || !userData) {
                console.error(`[API Chat GET] Error verifying bypassed user ${bypassUserId}:`, userError);
                return NextResponse.json({ error: 'Invalid bypass user ID' }, { status: 401 });
            }

            user = { id: bypassUserId, role: userData.role };
        } else {
            // Standard authentication
            const supabase = await createServerSupabaseClient();
            const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
            if (authError || !authUser) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
            
            // Get user profile with admin client to ensure we have the role
            const { data: userProfile } = await supabaseAdmin
                .from('profiles')
                .select('role')
                .eq('user_id', authUser.id)
                .single();
                
            user = { ...authUser, role: userProfile?.role };
        }
        
        if (!isTeacherTestRoom(roomId)) {
            // Check membership using admin client to bypass RLS recursion
            const { data: roomMembership, error: membershipError } = await supabaseAdmin
                .from('room_memberships')
                .select('room_id')
                .eq('room_id', roomId)
                .eq('student_id', user.id)
                .maybeSingle();

            if (membershipError) {
                console.error(`[API Chat GET] Error checking room membership for user ${user.id} in room ${roomId}:`, membershipError);
            }

            // Get user profile using admin client if not already available
            let userRole = user.role;
            if (!userRole) {
                const { data: profile } = await supabaseAdmin
                    .from('profiles')
                    .select('role')
                    .eq('user_id', user.id)
                    .single();
                    
                userRole = profile?.role;
            }
            
            if (userRole === 'student' && !roomMembership) {
                 console.warn(`[API Chat GET] Student ${user.id} is not a member of room ${roomId}.`);
                 return NextResponse.json({ error: 'Access denied to this room\'s messages.' }, { status: 403 });
            }
        }
        
        const isStudent = user.role === 'student';
        
        // If this is a student and we have an instance ID, use that for filtering
        if (isStudent && instanceIdFilter) {
            console.log(`[API Chat GET] Using instance_id filter ${instanceIdFilter} for student ${user.id}`);
            
            // Verify this instance belongs to the student
            const { data: instance, error: instanceError } = await supabaseAdmin
                .from('student_chatbot_instances')
                .select('instance_id')
                .eq('instance_id', instanceIdFilter)
                .eq('student_id', user.id)
                .single();
                
            if (instanceError || !instance) {
                console.warn(`[API Chat GET] Invalid instance ID ${instanceIdFilter} for student ${user.id}`);
                return NextResponse.json({ error: 'Invalid chatbot instance ID' }, { status: 403 });
            }
            
            // Use instance_id to fetch student-specific messages
            let query = supabaseAdmin
                .from('chat_messages')
                .select('*')
                .eq('room_id', roomId)
                .eq('instance_id', instanceIdFilter);
                
            const { data: messages, error: messagesError } = await query.order('created_at', { ascending: true });
            
            if (messagesError) {
                console.error('[API Chat GET] Error fetching messages by instance_id:', messagesError);
                return NextResponse.json({ error: messagesError.message }, { status: 500 });
            }
            
            console.log(`[API Chat GET] Fetched ${messages?.length || 0} messages for instance ${instanceIdFilter}`);
            return NextResponse.json(messages || []);
        } else {
            // Use admin client to fetch messages to bypass RLS policies
            let query = supabaseAdmin
                .from('chat_messages')
                .select('*')
                .eq('room_id', roomId);
                
            if (isStudent && chatbotIdFilter) {
                // For students, we need to isolate their messages by user_id and chatbot_id
                // Try to find an instance for this student and chatbot
                const { data: instanceData, error: instanceError } = await supabaseAdmin
                    .from('student_chatbot_instances')
                    .select('instance_id')
                    .eq('student_id', user.id)
                    .eq('room_id', roomId)
                    .eq('chatbot_id', chatbotIdFilter)
                    .single();
                    
                if (!instanceError && instanceData?.instance_id) {
                    console.log(`[API Chat GET] Using student instance ${instanceData.instance_id} for filtering`);
                    
                    // If we have an instance, use it for the most precise filtering
                    query = query.eq('instance_id', instanceData.instance_id);
                } else {
                    console.log(`[API Chat GET] No instance found, using fallback filtering for student ${user.id}`);
                    
                    // Fallback: use the traditional filtering method with improved isolation
                    // This is crucial! Instead of AND, use OR with proper conditions to isolate student messages
                    query = query
                        .or(`user_id.eq.${user.id},role.eq.assistant,role.eq.system`)
                        .filter('metadata->>chatbotId', 'eq', chatbotIdFilter)
                        .or(`role.neq.user,user_id.eq.${user.id}`); // Get all assistant messages and only this user's messages
                }
            } else {
                // For teachers or if instance wasn't found, use standard filtering
                query = query
                    .or(`user_id.eq.${user.id},role.eq.assistant,role.eq.system`);
                    
                if (chatbotIdFilter) {
                    query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
                }
            }
    
            const { data: messages, error: messagesError } = await query.order('created_at', { ascending: true });
    
            if (messagesError) {
                console.error('[API Chat GET] Error fetching messages:', messagesError);
                return NextResponse.json({ error: messagesError.message }, { status: 500 });
            }
            console.log(`[API Chat GET] Fetched ${messages?.length || 0} messages for room ${roomId}, user ${user.id}, chatbot ${chatbotIdFilter || 'any'}`);
            return NextResponse.json(messages || []);
        }
    } catch (error) {
        console.error('[API Chat GET] General error:', error);
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Unknown server error' }, { status: 500 });
    }
}


// --- POST Handler ---
export async function POST(request: NextRequest) {
  try {
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
    if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

    // Check for direct access headers from API
    const directAccessKey = request.headers.get('x-direct-access-admin-key');
    const bypassUserId = request.headers.get('x-bypass-auth-user-id');
    let user;
    
    // Always use admin client to bypass RLS policies
    const supabaseAdmin = createAdminClient();
    
    if (directAccessKey && bypassUserId && directAccessKey === (process.env.DIRECT_ACCESS_ADMIN_KEY || 'directaccess_key')) {
      console.log(`[API Chat POST] Using bypassed auth for user: ${bypassUserId}`);
      user = { id: bypassUserId };
    } else {
      // Standard authentication
      const supabase = await createServerSupabaseClient();
      const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
      if (authError || !authUser) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }
      user = authUser;
    }

    // Get user profile with admin client to bypass RLS - include country_code
    const { data: userProfile, error: profileError } = await supabaseAdmin
        .from('profiles')
        .select('role, country_code')
        .eq('user_id', user.id)
        .single();
    if (profileError || !userProfile) { return NextResponse.json({ error: 'User profile not found' }, { status: 403 }); }
    
    // For debugging country code issues
    console.log(`[API Chat POST] User profile country code for ${user.id}: "${userProfile.country_code || 'null'}"`);

    const isStudent = userProfile.role === 'student';
    const isTeacher = userProfile.role === 'teacher';

    const { content, chatbot_id, instance_id, model: requestedModel } = await request.json();
    const trimmedContent = content?.trim();
    if (!trimmedContent || typeof trimmedContent !== 'string') return NextResponse.json({ error: 'Invalid message content' }, { status: 400 });
    if (!chatbot_id) return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    
    // Extra logging for instance ID debugging
    console.log(`[API Chat POST] Request data:
      - user_id: ${user.id}
      - role: ${userProfile.role}
      - chatbot_id: ${chatbot_id}
      - instance_id: ${instance_id || 'not provided'}
      - room_id: ${roomId}
    `);

    // Check for instance_id if user is a student
    let studentChatbotInstanceId = instance_id;
    if (isStudent && !studentChatbotInstanceId) {
      // Try to get the instance_id for this student and chatbot
      const { data: instanceData, error: instanceError } = await supabaseAdmin
        .from('student_chatbot_instances')
        .select('instance_id')
        .eq('student_id', user.id)
        .eq('chatbot_id', chatbot_id)
        .eq('room_id', roomId)
        .single();
        
      if (instanceError || !instanceData) {
        console.warn(`[API Chat POST] Error finding chatbot instance for student ${user.id}, chatbot ${chatbot_id}, room ${roomId}:`, instanceError?.message);
        
        // Create a new instance on-the-fly
        const { data: newInstance, error: createError } = await supabaseAdmin
          .from('student_chatbot_instances')
          .insert({
            student_id: user.id,
            chatbot_id: chatbot_id,
            room_id: roomId
          })
          .select('instance_id')
          .single();
          
        if (createError || !newInstance) {
          console.error(`[API Chat POST] Error creating chatbot instance:`, createError?.message);
          return NextResponse.json({ error: 'Failed to create student chatbot instance.' }, { status: 500 });
        }
        
        studentChatbotInstanceId = newInstance.instance_id;
        console.log(`[API Chat POST] Created new chatbot instance ${studentChatbotInstanceId} for student ${user.id}`);
      } else {
        studentChatbotInstanceId = instanceData.instance_id;
        console.log(`[API Chat POST] Found existing chatbot instance ${studentChatbotInstanceId} for student ${user.id}`);
      }
    }

    // Use admin client for chatbot config
    const { data: chatbotConfig, error: chatbotFetchError } = await supabaseAdmin
        .from('chatbots')
        .select('system_prompt, model, temperature, max_tokens, enable_rag, bot_type, assessment_criteria_text, welcome_message, teacher_id, name')
        .eq('chatbot_id', chatbot_id)
        .single();

    if (chatbotFetchError || !chatbotConfig) {
        console.warn(`[API Chat POST] Error fetching chatbot ${chatbot_id} config:`, chatbotFetchError?.message);
        return NextResponse.json({ error: 'Chatbot configuration not found.' }, { status: 404 });
    }

    let roomForSafetyCheck: Room | null = null;
    let teacherCountryCode: string | null = null;

    if (!isTeacherTestRoom(roomId)) {
        // Use admin client for room data
        const { data: roomData, error: roomFetchError } = await supabaseAdmin
            .from('rooms')
            .select('room_id, teacher_id, room_name, school_id')
            .eq('room_id', roomId)
            .single();
        if (roomFetchError || !roomData) {
            console.error("[API Chat POST] Room fetch error for non-test room:", roomFetchError);
            return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 });
        }
        roomForSafetyCheck = roomData as Room; // Cast is safe here due to checks

        if (roomData.teacher_id) {
            console.log(`[SafetyDiagnostics] ===== TEACHER PROFILE RETRIEVAL TRACKING =====`);
            console.log(`[SafetyDiagnostics] Looking up teacher profile for teacher_id: ${roomData.teacher_id}`);
            
            // Get this specific teacher's profile
            const { data: roomTeacherProfile, error: roomTeacherProfileError } = await supabaseAdmin
                .from('profiles')
                .select('country_code, role, email')
                .eq('user_id', roomData.teacher_id)
                .single();
                
            if (roomTeacherProfileError) {
                console.error(`[SafetyDiagnostics] ERROR fetching teacher profile: ${roomTeacherProfileError.message}`);
                console.warn(`[API Chat POST] Error fetching teacher profile for room's teacher (${roomData.teacher_id}) using admin client:`, roomTeacherProfileError.message);
            } else if (roomTeacherProfile) {
                // Get the country code from the profile and validate it
                console.log(`[SafetyDiagnostics] Teacher profile found. Raw country_code value: "${roomTeacherProfile.country_code}"`);
                console.log(`[SafetyDiagnostics] Teacher profile country_code type: ${typeof roomTeacherProfile.country_code}`);
                
                // Validate and normalize the country code
                const rawCountryCode = roomTeacherProfile.country_code;
                if (rawCountryCode && typeof rawCountryCode === 'string' && rawCountryCode.trim() !== '') {
                    // Convert to uppercase for consistency
                    teacherCountryCode = rawCountryCode.trim().toUpperCase();
                    // Special case handling: convert UK to GB as that's the ISO standard
                    if (teacherCountryCode === 'UK') {
                        teacherCountryCode = 'GB';
                        console.log(`[SafetyDiagnostics] Converted UK to GB for ISO standard`);
                    }
                    console.log(`[SafetyDiagnostics] Set normalized teacherCountryCode to: "${teacherCountryCode}"`);
                } else {
                    // If no valid country code, use null which will result in DEFAULT helplines
                    teacherCountryCode = null;
                    console.warn(`[SafetyDiagnostics] No valid country code found, using null (will fallback to DEFAULT)`);
                }
                
                console.log(`[API Chat POST] Teacher country code for room ${roomId}: "${teacherCountryCode || 'null'}" (Teacher ID: ${roomData.teacher_id})`);
            } else {
                console.error(`[SafetyDiagnostics] No teacher profile found for teacher_id: ${roomData.teacher_id}`);
                console.warn(`[API Chat POST] Teacher profile not found for teacher ${roomData.teacher_id}`);
            }
            console.log(`[SafetyDiagnostics] ===== END TRACKING =====`);
        } else {
            console.warn(`[API Chat POST] Room ${roomId} has no teacher_id set`);
        }
    } else if (isTeacherTestRoom(roomId)) {
        if (!isTeacher) {
            return NextResponse.json({ error: 'Not authorized for this test room' }, { status: 403 });
        }
        roomForSafetyCheck = { // This creates a non-null Room object
            room_id: roomId,
            teacher_id: chatbotConfig.teacher_id,
            room_name: `Test Room for ${chatbotConfig.name || 'Chatbot'}`,
            room_code: 'TEACHER_TEST',
            is_active: true,
            created_at: new Date().toISOString(),
        };
        const { data: designatedTeacherProfile, error: designatedTeacherProfileError } = await supabaseAdmin
            .from('profiles')
            .select('country_code, email, role')
            .eq('user_id', chatbotConfig.teacher_id)
            .single();
            
        if (designatedTeacherProfileError) {
            console.warn(`[API Chat POST] Error fetching designated teacher profile for chatbot (${chatbotConfig.teacher_id}) for test room:`, designatedTeacherProfileError.message);
        } else if (designatedTeacherProfile) {
            // Get and validate the country code from the profile
            console.log(`[SafetyDiagnostics] ===== TEST ROOM COUNTRY CODE TRACKING =====`);
            console.log(`[SafetyDiagnostics] Raw country_code from test room teacher: "${designatedTeacherProfile.country_code}"`);
            
            // Validate and normalize the country code
            const rawCountryCode = designatedTeacherProfile.country_code;
            if (rawCountryCode && typeof rawCountryCode === 'string' && rawCountryCode.trim() !== '') {
                // Convert to uppercase for consistency
                teacherCountryCode = rawCountryCode.trim().toUpperCase();
                // Special case handling: convert UK to GB as that's the ISO standard
                if (teacherCountryCode === 'UK') {
                    teacherCountryCode = 'GB';
                    console.log(`[SafetyDiagnostics] Converted UK to GB for ISO standard in test room`);
                }
                console.log(`[SafetyDiagnostics] Set normalized teacherCountryCode to: "${teacherCountryCode}" for test room`);
            } else {
                // If no valid country code, use null which will result in DEFAULT helplines
                teacherCountryCode = null;
                console.warn(`[SafetyDiagnostics] No valid country code found for test room, using null (will fallback to DEFAULT)`);
            }
            
            console.log(`[API Chat POST] Teacher country code for test room: "${teacherCountryCode || 'null'}" (Teacher ID: ${chatbotConfig.teacher_id})`);
            console.log(`[SafetyDiagnostics] ===== END TRACKING =====`);
        } else {
            console.warn(`[API Chat POST] Teacher profile not found for test room teacher ${chatbotConfig.teacher_id}`);
        }
    }
    // Enhanced debugging for country code and safety system
    console.log(`[API Chat POST] ========= SAFETY SYSTEM PARAMS =========`);
    console.log(`[API Chat POST] Determined teacherCountryCode: "${teacherCountryCode}"`);
    console.log(`[API Chat POST] Teacher profile country_code: "${userProfile.country_code}"`);
    console.log(`[API Chat POST] Country code type: ${typeof teacherCountryCode}`);
    console.log(`[API Chat POST] Initial concern check: ${initialConcernCheck(trimmedContent).hasConcern}`);
    console.log(`[API Chat POST] Concern type: ${initialConcernCheck(trimmedContent).concernType}`); 
    console.log(`[API Chat POST] isStudent: ${isStudent}`);
    console.log(`[API Chat POST] roomId: ${roomId}`);
    console.log(`[API Chat POST] ===========================================`);

    const userMessageToStore: Omit<ChatMessage, 'message_id' | 'created_at' | 'updated_at'> & { metadata: { chatbotId: string }, instance_id?: string } = {
      room_id: roomId, 
      user_id: user.id, 
      role: 'user' as const, 
      content: trimmedContent, 
      metadata: { chatbotId: chatbot_id }
    };
    
    // Add the instance_id for students
    if (isStudent && studentChatbotInstanceId) {
      userMessageToStore.instance_id = studentChatbotInstanceId;
    }
    
    // Use admin client to store message
    const { data: savedUserMessageData, error: userMessageError } = await supabaseAdmin
        .from('chat_messages')
        .insert(userMessageToStore)
        .select('message_id, created_at')
        .single();
    
    if (userMessageError || !savedUserMessageData || !savedUserMessageData.message_id) { 
        console.error('Error storing user message or message_id missing:', userMessageError, savedUserMessageData); 
        return NextResponse.json({ error: 'Failed to store message or retrieve its ID' }, { status: 500 }); 
    }
    
    const currentMessageId: string = savedUserMessageData.message_id; 
    const userMessageCreatedAt = savedUserMessageData.created_at;

    // --- MODIFIED SAFETY CHECK AND MAIN LLM CALL FLOW ---
    const { hasConcern: initialHasConcern, concernType: initialConcernType } = initialConcernCheck(trimmedContent);

    // Condition for triggering safety check AND bypassing main LLM
    // Now we explicitly check if roomForSafetyCheck is not null before using it.
    const triggerSafetyOverride = isStudent &&
                                  initialHasConcern &&
                                  initialConcernType &&
                                  roomForSafetyCheck !== null && // Explicit null check
                                  !isTeacherTestRoom(roomId);

    if (triggerSafetyOverride) {
        console.log(`[API Chat POST] Initial concern detected: ${initialConcernType}. Prioritizing safety response. Bypassing main LLM.`);
        console.log(`[API Chat POST] Country code being passed to safety check: "${teacherCountryCode}"`);
        // Since roomForSafetyCheck is checked for non-null in triggerSafetyOverride,
        // TypeScript knows it's a 'Room' here.
        // Special debug logging to trace the country code issue
        console.log(`[SafetyDiagnostics] ===== ROUTE.TS SAFETY CHECK TRACKING =====`);
        console.log(`[SafetyDiagnostics] API route preparing to call checkMessageSafety`);
        console.log(`[SafetyDiagnostics] roomId: ${roomId}`);
        console.log(`[SafetyDiagnostics] teacherId: ${roomForSafetyCheck!.teacher_id}`);
        console.log(`[SafetyDiagnostics] teacherCountryCode: "${teacherCountryCode}"`);
        console.log(`[SafetyDiagnostics] teacherCountryCode type: ${typeof teacherCountryCode}`);
        console.log(`[SafetyDiagnostics] messageId: ${currentMessageId}`);
        console.log(`[SafetyDiagnostics] studentId: ${user.id}`);
        console.log(`[SafetyDiagnostics] chatbotId: ${chatbot_id}`);
        console.log(`[SafetyDiagnostics] initialConcernType: ${initialConcernType}`);
        console.log(`[SafetyDiagnostics] ===== END TRACKING =====`);
        
        // We're now passing the actual teacher country code instead of forcing it
        console.log(`[API Chat POST] Using actual teacher country code: "${teacherCountryCode}"`);
        
        // Add additional logging right before the call for detailed debugging
        console.log(`[SafetyDiagnostics] ========= SAFETY CALL PARAMETERS =========`);
        console.log(`[SafetyDiagnostics] FINAL CHECK - About to call checkMessageSafety with:`);
        console.log(`[SafetyDiagnostics] - countryCode: "${teacherCountryCode}" (${typeof teacherCountryCode})`);
        console.log(`[SafetyDiagnostics] - roomId: ${roomForSafetyCheck!.room_id}`);
        console.log(`[SafetyDiagnostics] - teacherId: ${roomForSafetyCheck!.teacher_id}`);
        console.log(`[SafetyDiagnostics] - messageId: ${currentMessageId}`);
        console.log(`[SafetyDiagnostics] - studentId: ${user.id}`);
        console.log(`[SafetyDiagnostics] - messageContentLength: ${trimmedContent.length}`);
        console.log(`[SafetyDiagnostics] - original countryCode from profile: "${userProfile.country_code}"`);
        console.log(`[SafetyDiagnostics] ===========================================`);
        
        // For the UK case specifically, ensure we're sending the correct code
        let finalCountryCode = teacherCountryCode;
        if (userProfile.country_code === 'UK') {
            console.log(`[SafetyDiagnostics] Original country code is UK, ensuring we use GB for ISO standard`);
            finalCountryCode = 'GB';
        }
        
        // Call the safety system with the properly processed country code
        checkMessageSafety(supabaseAdmin, trimmedContent, currentMessageId, user.id, roomForSafetyCheck!, finalCountryCode)
            .catch(safetyError => console.error(`[Safety Check Background Error] for message ${currentMessageId}:`, safetyError));

        return NextResponse.json({
            type: "safety_intervention_triggered",
            message: "Your message is being reviewed for safety. Relevant guidance will appear shortly."
        });
    }
    console.log(`[API Chat POST] No safety override. Proceeding with regular chat/assessment flow. isStudent: ${isStudent}, initialHasConcern: ${initialHasConcern}, isTeacherTestRoom: ${isTeacherTestRoom(roomId)}`);
    // --- END OF MODIFIED SAFETY CHECK AND MAIN LLM CALL FLOW ---

    if (isStudent && chatbotConfig.bot_type === 'assessment' && trimmedContent.toLowerCase() === ASSESSMENT_TRIGGER_COMMAND) {
        console.log(`[API Chat POST] Assessment trigger detected for student ${user.id}, bot ${chatbot_id}, room ${roomId}.`);
        // Use admin client for message IDs
        const { data: contextMessagesForAssessment, error: contextMsgsError } = await supabaseAdmin
            .from('chat_messages')
            .select('message_id')
            .eq('room_id', roomId)
            .eq('user_id', user.id)
            .eq('metadata->>chatbotId', chatbot_id)
            .lt('created_at', userMessageCreatedAt)
            .order('created_at', { ascending: false })
            .limit(ASSESSMENT_CONTEXT_MESSAGE_COUNT * 2 + 5);
        if (contextMsgsError) {
            console.error(`[API Chat POST] Error fetching message IDs for assessment context: ${contextMsgsError.message}`);
        }
        const messageIdsToAssess = (contextMessagesForAssessment || []).map(m => m.message_id).reverse();
        const assessmentPayload = { student_id: user.id, chatbot_id: chatbot_id, room_id: roomId, message_ids_to_assess: messageIdsToAssess };
        console.log(`[API Chat POST] Asynchronously calling /api/assessment/process.`);
        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || `http://localhost:${process.env.PORT || 3000}`;
        fetch(`${baseUrl}/api/assessment/process`, {
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(assessmentPayload),
        }).catch(fetchError => console.error(`[API Chat POST] Error calling /api/assessment/process internally:`, fetchError));
        return NextResponse.json({ type: "assessment_pending", message: "Your responses are being submitted for assessment. Feedback will appear here shortly." });
    }

    // --- MAIN LLM CALL (Only if not handled by safety override or assessment trigger) ---
    // Use admin client for context messages
    const { data: contextMessagesData, error: contextError } = await supabaseAdmin
      .from('chat_messages')
      .select('role, content').eq('room_id', roomId).eq('user_id', user.id)
      .filter('metadata->>chatbotId', 'eq', chatbot_id)
      .neq('message_id', currentMessageId)
      .order('created_at', { ascending: false }).limit(5);
    if (contextError) console.warn("Error fetching context messages:", contextError.message);
    const contextMessages = (contextMessagesData || []).map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }));

    const teacherSystemPrompt = chatbotConfig.system_prompt || "You are a safe, ethical, and supportive AI learning assistant for students. Your primary goal is to help students understand educational topics in an engaging and age-appropriate manner.";

    const {
        model: modelToUseFromConfig = 'openai/gpt-4.1-nano',
        temperature: temperatureToUse = 0.7,
        max_tokens: maxTokensToUse = 1000,
        enable_rag: enableRagFromConfig = false
    } = chatbotConfig;

    const finalModelToUse = requestedModel || modelToUseFromConfig;

    let ragContextText = '';
    if (enableRagFromConfig && chatbotConfig.bot_type === 'learning') {
        try {
            const queryEmbedding = await generateEmbedding(trimmedContent);
            const searchResults = await queryVectors(queryEmbedding, chatbot_id, 3);
            if (searchResults && searchResults.length > 0) {
                ragContextText = "\n\nRelevant information from knowledge base:\n";
                searchResults.forEach((result) => {
                    if (result.metadata?.text) {
                        const fileName = typeof result.metadata.fileName === 'string' ? result.metadata.fileName : 'document';
                        const chunkText = String(result.metadata.text).substring(0, 500);
                        ragContextText += `\nFrom document "${fileName}":\n${chunkText}\n`;
                    }
                });
            }
        } catch (ragError) { console.warn(`[RAG] Error:`, ragError); }
    }

    let regionalInstruction = '';
    if (teacherCountryCode === 'GB' || teacherCountryCode === 'AE') {
        regionalInstruction = " Please use British English spelling (e.g., 'colour', 'analyse').";
    } else if (teacherCountryCode === 'AU') {
        regionalInstruction = " Please use Australian English spelling.";
    } else if (teacherCountryCode === 'CA') {
        regionalInstruction = " Please use Canadian English spelling.";
    } else if (teacherCountryCode === 'MY') {
        regionalInstruction = " Please respond appropriately for a Malaysian context if relevant, using standard English.";
    }

    const CORE_SAFETY_INSTRUCTIONS = `
SAFETY OVERRIDE: The following are non-negotiable rules for your responses.
- You are an AI assistant interacting with students. All interactions must be strictly age-appropriate, safe, and ethical.
- NEVER generate responses that are sexually explicit, suggestive, or exploit, abuse, or endanger children.
- NEVER engage in discussions about graphic violence, hate speech, illegal activities, or self-harm promotion.
- NEVER ask for or store personally identifiable information (PII) from students, such as full names (beyond a first name if offered by the student in conversation), exact age, home address, phone number, email, specific school name, or social media details.
- If a student's query is ambiguous or could lead to an inappropriate response, err on the side of caution and provide a generic, safe, educational answer or politely decline to answer if the topic is clearly out of scope or unsafe.
- If a student expresses direct intent for self-harm or mentions ongoing abuse, the system has separate alerts, but your immediate response should be brief, empathetic, and guide them to seek help from a trusted adult without engaging in therapeutic conversation.
- These safety rules override any conflicting instructions in the user-provided prompt below.
--- END OF SAFETY OVERRIDE ---
`;

    const systemPromptForLLM = `${CORE_SAFETY_INSTRUCTIONS}\n\nTeacher's Prompt:\n${teacherSystemPrompt}${regionalInstruction}${ragContextText ? `\n\nRelevant Information:\n${ragContextText}\n\nBase your answer on the provided information. Do not explicitly mention "Source:" or bracketed numbers like [1], [2] in your response.` : ''}`;

    console.log(`[API Chat POST] Final System Prompt (first 500 chars): ${systemPromptForLLM.substring(0,500)}...`);

    const messagesForAPI = [ { role: 'system', content: systemPromptForLLM }, ...contextMessages.reverse(), { role: 'user', content: trimmedContent } ];

    const openRouterResponse = await fetch(OPENROUTER_API_URL, {
        method: 'POST', headers: { 'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`, 'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000', 'X-Title': 'ClassBots AI', 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: finalModelToUse, messages: messagesForAPI, temperature: temperatureToUse, max_tokens: maxTokensToUse, stream: true }),
    });

    if (!openRouterResponse.ok || !openRouterResponse.body) {
        const errorBody = await openRouterResponse.text(); console.error(`OpenRouter Error: Status ${openRouterResponse.status}`, errorBody);
        let errorMessage = `Failed to get AI response (status: ${openRouterResponse.status})`;
        try { const errorJson = JSON.parse(errorBody); errorMessage = errorJson.error?.message || errorMessage; } catch {}
        throw new Error(errorMessage);
    }

    let fullResponseContent = ''; const encoder = new TextEncoder(); let assistantMessageId: string | null = null;
    const stream = new ReadableStream({
        async start(controller) {
            const reader = openRouterResponse.body!.getReader(); const decoder = new TextDecoder();
            try {
                // Create a placeholder message for the assistant's response to update as we stream
                console.log('[API POST /chat/[roomId]] Creating assistant message placeholder');
                const messageData: any = { 
                  room_id: roomId, 
                  user_id: user.id, 
                  role: 'assistant', 
                  content: '', 
                  metadata: { 
                    chatbotId: chatbot_id,
                    isStreaming: true 
                  }
                };
                
                // Add the instance_id for students
                if (isStudent && studentChatbotInstanceId) {
                  messageData.instance_id = studentChatbotInstanceId;
                }
                
                const { data: initData, error: initError } = await supabaseAdmin
                    .from('chat_messages')
                    .insert(messageData)
                    .select('message_id').single();
                
                if (initError || !initData) {
                  console.error('[API POST /chat/[roomId]] Error creating placeholder assistant message:', initError);
                } else {
                  console.log(`[API POST /chat/[roomId]] Created placeholder message with ID: ${initData.message_id}`);
                  assistantMessageId = initData.message_id;
                }

                while (true) {
                    const { done, value } = await reader.read(); 
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true }); 
                    const lines = chunk.split('\n').filter(l => l.trim().startsWith('data:'));
                    
                    for (const line of lines) {
                        const dataContent = line.substring(6).trim(); 
                        if (dataContent === '[DONE]') continue;
                        
                        try { 
                            const parsed = JSON.parse(dataContent);
                            const piece = parsed.choices?.[0]?.delta?.content; 
                            
                            if (typeof piece === 'string') { 
                                fullResponseContent += piece; 
                                
                                // Update the message in the database periodically
                                // This helps with long responses
                                if (assistantMessageId && fullResponseContent.length % 200 === 0) {
                                    try {
                                        // Execute background update without awaiting
                                        (async () => {
                                            try {
                                                const { error } = await supabaseAdmin
                                                    .from('chat_messages')
                                                    .update({ 
                                                        content: fullResponseContent,
                                                        updated_at: new Date().toISOString()
                                                    })
                                                    .eq('message_id', assistantMessageId);
                                                    
                                                if (error) {
                                                    console.warn('[API POST /chat/[roomId]] Stream interim update error:', error);
                                                }
                                            } catch (dbError) {
                                                console.warn('[API POST /chat/[roomId]] Stream interim update exception:', dbError);
                                            }
                                        })(); // Execute IIFE without awaiting
                                    } catch (updateError) {
                                        console.warn('[API POST /chat/[roomId]] Error during interim update:', updateError);
                                    }
                                }
                                
                                // Try to enqueue data for streaming to client
                                try {
                                    controller.enqueue(encoder.encode(`data: ${JSON.stringify({ content: piece })}\n\n`));
                                } catch (enqueueError) {
                                    console.warn('[API POST /chat/[roomId]] Controller enqueue error:', enqueueError);
                                    // Just continue with response collection even if streaming fails
                                }
                            } 
                        }
                        catch (parseError) { 
                            console.warn('[API POST /chat/[roomId]] Stream parse error:', parseError, "Data:", dataContent); 
                        }
                    }
                }
            } catch (streamError) { 
                console.error('Stream error:', streamError); 
                // Try to send error
                try {
                    controller.error(streamError);
                } catch (controllerError) {
                    console.warn('Controller error while handling stream error:', controllerError);
                }
            }
            finally {
                // Clean up the final content
                let finalContent = fullResponseContent.trim();
                // Remove citation patterns
                finalContent = finalContent.replace(/\s*Source:\s*\[\d+\]\s*$/gm, '').trim();
                finalContent = finalContent.replace(/\s*\[\d+\]\s*$/gm, '').trim();
                // Normalize whitespace
                finalContent = finalContent.replace(/(\r\n|\n|\r){2,}/gm, '$1').replace(/ +/g, ' ');

                console.log(`[API POST /chat/[roomId]] Stream complete. Final content length: ${finalContent.length}`);
                
                if (assistantMessageId && finalContent) {
                    // Use admin client to update the final message with streaming flag removed
                    console.log(`[API POST /chat/[roomId]] Updating final message content for ID: ${assistantMessageId}`);
                    
                    try {
                        const updateData: any = { 
                            content: finalContent, 
                            updated_at: new Date().toISOString(),
                            metadata: { 
                                chatbotId: chatbot_id,
                                isStreaming: false 
                            }
                        };
                        
                        // We don't need to update instance_id as it was set during creation
                        
                        const { error: updateError } = await supabaseAdmin
                            .from('chat_messages')
                            .update(updateData)
                            .eq('message_id', assistantMessageId);
                            
                        if (updateError) {
                            console.error(`[API POST /chat/[roomId]] Error updating assistant message ${assistantMessageId}:`, updateError);
                        } else {
                            console.log(`[API POST /chat/[roomId]] Assistant message ${assistantMessageId} updated with final content.`);
                        }
                    } catch (finalUpdateError) {
                        console.error(`[API POST /chat/[roomId]] Exception during final message update:`, finalUpdateError);
                    }
                } else if (!assistantMessageId && finalContent) {
                    // Fallback if the placeholder message creation failed
                    console.warn("[API POST /chat/[roomId]] Fallback: Assistant message placeholder not created, inserting full message.");
                    
                    try {
                        const fallbackMessageData: any = { 
                            room_id: roomId, 
                            user_id: user.id, 
                            role: 'assistant', 
                            content: finalContent, 
                            metadata: { chatbotId: chatbot_id } 
                        };
                        
                        // Add the instance_id for students
                        if (isStudent && studentChatbotInstanceId) {
                            fallbackMessageData.instance_id = studentChatbotInstanceId;
                        }
                        
                        const { error: insertError } = await supabaseAdmin
                            .from('chat_messages')
                            .insert(fallbackMessageData);
                            
                        if (insertError) {
                            console.error(`[API POST /chat/[roomId]] Error inserting fallback assistant message:`, insertError);
                        } else {
                            console.log(`[API POST /chat/[roomId]] Fallback assistant message inserted successfully.`);
                        }
                    } catch (fallbackInsertError) {
                        console.error(`[API POST /chat/[roomId]] Exception during fallback message insert:`, fallbackInsertError);
                    }
                }
                
                // Attempt to close the stream controller
                try {
                    controller.close();
                    console.log("[API POST /chat/[roomId]] Server stream closed successfully.");
                } catch (closeError) {
                    console.warn("[API POST /chat/[roomId]] Error while closing controller:", closeError);
                }
            }
        }
    });
    return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'X-Content-Type-Options': 'nosniff' } });
    // --- END OF MAIN LLM CALL ---

  } catch (error) {
      console.error('Error in POST /api/chat/[roomId]:', error);
      return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to process message' }, { status: 500 });
  }
}// src/app/api/chat/direct-access/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
// We don't directly use this type here but keep for reference
// import type { ChatMessage } from '@/types/database.types';

export async function GET(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const userId = searchParams.get('userId');
    const chatbotId = searchParams.get('chatbotId');
    const instanceId = searchParams.get('instanceId');

    // Validate required parameters
    if (!roomId || !userId) {
      return NextResponse.json(
        { error: 'Missing required parameters: roomId and userId are required' },
        { status: 400 }
      );
    }

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    // Verify user exists - try both methods for compatibility
    let userExists = false;
    
    try {
      // Method 1: Try using auth.admin.getUserById if available
      if (supabaseAdmin.auth.admin && typeof supabaseAdmin.auth.admin.getUserById === 'function') {
        const { data: userCheck, error: userError } = await supabaseAdmin.auth.admin.getUserById(userId);
        if (!userError && userCheck.user) {
          userExists = true;
        }
      }
    } catch (authMethodError) {
      console.warn('[API GET /chat/direct-access] Error with auth.admin.getUserById:', authMethodError);
    }
    
    if (!userExists) {
      // Method 2: Fall back to checking the profiles table
      const { data: userProfile, error: profileError } = await supabaseAdmin
        .from('profiles')
        .select('user_id')
        .eq('user_id', userId)
        .maybeSingle();
      
      if (profileError || !userProfile) {
        console.error('[API GET /chat/direct-access] User not found in profiles:', userId);
        return NextResponse.json({ error: 'User not found' }, { status: 404 });
      }
      
      userExists = true;
    }
    
    if (!userExists) {
      console.error('[API GET /chat/direct-access] User not found:', userId);
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Verify the user has access to the room
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('student_id', userId)
      .maybeSingle();

    if (membershipError) {
      console.error('[API GET /chat/direct-access] Error checking membership:', membershipError);
    }

    // If not a member, add to room
    if (!membership) {
      console.log('[API GET /chat/direct-access] User not in room, adding membership');
      const { error: insertError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: roomId,
          student_id: userId
        });

      if (insertError) {
        console.error('[API GET /chat/direct-access] Error adding user to room:', insertError);
        return NextResponse.json(
          { error: 'Failed to add user to room' },
          { status: 500 }
        );
      }
    }

    // Check if we have a student-specific instance to use
    let studentChatbotInstanceId = instanceId;
    
    if (chatbotId && !studentChatbotInstanceId) {
      // Try to find the student's instance for this chatbot
      const { data: instanceData, error: instanceError } = await supabaseAdmin
        .from('student_chatbot_instances')
        .select('instance_id')
        .eq('student_id', userId)
        .eq('room_id', roomId)
        .eq('chatbot_id', chatbotId)
        .single();
        
      if (!instanceError && instanceData?.instance_id) {
        console.log(`[API GET /chat/direct-access] Found instance ${instanceData.instance_id} for student ${userId}`);
        studentChatbotInstanceId = instanceData.instance_id;
      } else {
        // Create a new instance on-the-fly
        console.log(`[API GET /chat/direct-access] Creating new instance for student ${userId}`);
        
        const { data: newInstance, error: createError } = await supabaseAdmin
          .from('student_chatbot_instances')
          .insert({
            student_id: userId,
            chatbot_id: chatbotId,
            room_id: roomId
          })
          .select('instance_id')
          .single();
          
        if (!createError && newInstance) {
          studentChatbotInstanceId = newInstance.instance_id;
          console.log(`[API GET /chat/direct-access] Created new instance ${studentChatbotInstanceId}`);
        } else {
          console.error(`[API GET /chat/direct-access] Error creating instance:`, createError);
        }
      }
    }
    
    // Fetch messages using admin client to bypass RLS policies
    let query = supabaseAdmin
      .from('chat_messages')
      .select('*')
      .eq('room_id', roomId);
      
    if (studentChatbotInstanceId) {
      // If we have an instance ID, use that for precise filtering
      console.log(`[API GET /chat/direct-access] Using instance ${studentChatbotInstanceId} for filtering`);
      query = query.eq('instance_id', studentChatbotInstanceId);
    } else {
      // Fallback to traditional filtering
      console.log(`[API GET /chat/direct-access] Using traditional filtering without instance ID`);
      query = query.or(`user_id.eq.${userId},role.eq.assistant,role.eq.system`);
      
      if (chatbotId) {
        query = query.filter('metadata->>chatbotId', 'eq', chatbotId);
      }
    }

    const { data: messages, error: messagesError } = await query.order('created_at', { ascending: true });

    if (messagesError) {
      console.error('[API GET /chat/direct-access] Error fetching messages:', messagesError);
      return NextResponse.json({ error: messagesError.message }, { status: 500 });
    }

    console.log(`[API GET /chat/direct-access] Fetched ${messages?.length || 0} messages for room ${roomId}, user ${userId}, chatbot ${chatbotId || 'any'}`);
    
    return NextResponse.json(messages || []);
  } catch (error) {
    console.error('[API GET /chat/direct-access] General error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown server error' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const userId = searchParams.get('userId');
    const instanceId = searchParams.get('instanceId');
    
    if (!roomId || !userId) {
      return NextResponse.json(
        { error: 'Missing required parameters: roomId and userId are required' },
        { status: 400 }
      );
    }

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    // Verify user exists - try both methods for compatibility
    let userExists = false;
    
    try {
      // Method 1: Try using auth.admin.getUserById if available
      if (supabaseAdmin.auth.admin && typeof supabaseAdmin.auth.admin.getUserById === 'function') {
        const { data: userCheck, error: userError } = await supabaseAdmin.auth.admin.getUserById(userId);
        if (!userError && userCheck.user) {
          userExists = true;
        }
      }
    } catch (authMethodError) {
      console.warn('[API POST /chat/direct-access] Error with auth.admin.getUserById:', authMethodError);
    }
    
    if (!userExists) {
      // Method 2: Fall back to checking the profiles table
      const { data: userProfile, error: profileError } = await supabaseAdmin
        .from('profiles')
        .select('user_id')
        .eq('user_id', userId)
        .maybeSingle();
      
      if (profileError || !userProfile) {
        console.error('[API POST /chat/direct-access] User not found in profiles:', userId);
        return NextResponse.json({ error: 'User not found' }, { status: 404 });
      }
      
      userExists = true;
    }
    
    if (!userExists) {
      console.error('[API POST /chat/direct-access] User not found:', userId);
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Get body content
    const { content, chatbot_id, model, instance_id } = await request.json();
    
    if (!content || !chatbot_id) {
      return NextResponse.json({ error: 'Missing content or chatbot_id in request body' }, { status: 400 });
    }
    
    // Use instance_id from either URL parameters or request body
    const effectiveInstanceId = instanceId || instance_id;

    // Verify and ensure room membership
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('student_id', userId)
      .maybeSingle();

    if (membershipError) {
      console.error('[API POST /chat/direct-access] Error checking membership:', membershipError);
    }

    if (!membership) {
      console.log('[API POST /chat/direct-access] User not in room, adding membership');
      const { error: insertError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: roomId,
          student_id: userId
        });

      if (insertError) {
        console.error('[API POST /chat/direct-access] Error adding user to room:', insertError);
        return NextResponse.json(
          { error: 'Failed to add user to room' },
          { status: 500 }
        );
      }
    }

    // Find or create instance ID if not provided
    let studentChatbotInstanceId = effectiveInstanceId;
    
    if (!studentChatbotInstanceId) {
      console.log(`[API POST /chat/direct-access] No instance ID provided, finding or creating one`);
      
      // Try to find an existing instance
      const { data: existingInstance, error: findError } = await supabaseAdmin
        .from('student_chatbot_instances')
        .select('instance_id')
        .eq('student_id', userId)
        .eq('room_id', roomId)
        .eq('chatbot_id', chatbot_id)
        .single();
        
      if (!findError && existingInstance?.instance_id) {
        studentChatbotInstanceId = existingInstance.instance_id;
        console.log(`[API POST /chat/direct-access] Found existing instance ${studentChatbotInstanceId}`);
      } else {
        // Create a new instance
        const { data: newInstance, error: createError } = await supabaseAdmin
          .from('student_chatbot_instances')
          .insert({
            student_id: userId,
            chatbot_id: chatbot_id,
            room_id: roomId
          })
          .select('instance_id')
          .single();
          
        if (!createError && newInstance) {
          studentChatbotInstanceId = newInstance.instance_id;
          console.log(`[API POST /chat/direct-access] Created new instance ${studentChatbotInstanceId}`);
        } else {
          console.error(`[API POST /chat/direct-access] Error creating instance:`, createError);
        }
      }
    }
    
    // Store user message using admin client
    const userMessageToStore: any = {
      room_id: roomId,
      user_id: userId,
      role: 'user',
      content: content.trim(),
      metadata: { chatbotId: chatbot_id }
    };
    
    // Add instance_id if we have one
    if (studentChatbotInstanceId) {
      userMessageToStore.instance_id = studentChatbotInstanceId;
    }

    const { data: savedUserMessage, error: messageError } = await supabaseAdmin
      .from('chat_messages')
      .insert(userMessageToStore)
      .select('message_id, created_at')
      .single();

    if (messageError || !savedUserMessage) {
      console.error('[API POST /chat/direct-access] Error storing message:', messageError);
      return NextResponse.json({ error: 'Failed to store message' }, { status: 500 });
    }

    // Forward the request to the main chat API internally
    // This is a workaround since we can't easily reuse the complex chat handling logic
    // Use the full URL to avoid parsing issues in production
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'https://skolr.app';
    const forwardedUrl = new URL(`/api/chat/${roomId}`, baseUrl).toString();
    
    console.log(`[API POST /chat/direct-access] Forwarding request to ${forwardedUrl}`);
    
    // Add special headers for direct access
    // These headers let the main chat API know to use the admin client
    // and bypass normal auth checks
    const directAccessKey = process.env.DIRECT_ACCESS_ADMIN_KEY || 'directaccess_key';
    
    try {
      const response = await fetch(forwardedUrl, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'x-direct-access-admin-key': directAccessKey,
          'x-bypass-auth-user-id': userId
        },
        body: JSON.stringify({
          content: content.trim(),
          chatbot_id,
          model,
          message_id: savedUserMessage.message_id,
          instance_id: studentChatbotInstanceId
        })
      });
    
    
    // Log error for debugging if request fails
    if (!response.ok) {
      try {
        const errorText = await response.text();
        console.error(`[API POST /chat/direct-access] Forwarded request failed with status ${response.status}:`, errorText);
      } catch (readError) {
        console.error(`[API POST /chat/direct-access] Forwarded request failed with status ${response.status} (could not read error details)`);
      }
      
      return NextResponse.json({ 
        error: `Chat API request failed with status ${response.status}` 
      }, { status: response.status });
    }

    // Return the streaming response
    return new Response(response.body, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
      }
    });
  } catch (error) {
    console.error('[API POST /chat/direct-access] General error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to process message' },
      { status: 500 }
    );
  }
}// src/app/api/auth/magic-link/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();
    
    const { token, room_code } = await request.json();
    
    if (!token || !room_code) {
      return NextResponse.json({ 
        error: 'Missing required parameters: token and room_code' 
      }, { status: 400 });
    }
    
    console.log('[Magic Link API] Processing request for room code:', room_code);
    
    // Find the room by code first - use admin client for reliable permissions
    let roomId: string;
    // Room code is already available in room_code variable, no need to redefine
    
    try {
      // Using admin client to bypass any RLS policies
      const { data: rooms, error: roomError } = await supabaseAdmin
        .from('rooms')
        .select('room_id, is_active, room_code')
        .eq('room_code', room_code.toUpperCase());
        
      if (roomError) {
        console.error('[Magic Link API] Database error looking up room:', roomError);
        return NextResponse.json({ 
          error: 'Database error when looking up room' 
        }, { status: 500 });
      }
      
      if (!rooms || rooms.length === 0) {
        console.error('[Magic Link API] Room not found for code:', room_code);
        return NextResponse.json({ 
          error: 'Room not found. Please check the code and try again.' 
        }, { status: 404 });
      }
      
      const room = rooms[0];
      console.log('[Magic Link API] Found room:', room.room_id, 'with code:', room.room_code);
      
      // Check if room is active
      if (!room.is_active) {
        console.warn('[Magic Link API] Room is inactive:', room.room_code);
        return NextResponse.json({
          error: 'This classroom is currently inactive. Please contact your teacher.'
        }, { status: 403 });
      }
      
      // Save the room ID for use later
      roomId = room.room_id;
      // We don't use roomCode after validating, so we don't need to store it
      // roomCode = room.room_code;
    } catch (roomLookupError) {
      console.error('[Magic Link API] Error in room lookup process:', roomLookupError);
      return NextResponse.json({ 
        error: 'Failed to verify room code'
      }, { status: 500 });
    }

    // Parse student name from URL parameters
    const nameParam = new URLSearchParams(request.url.split('?')[1] || '').get('name') || 
                      new URLSearchParams(request.headers.get('referer')?.split('?')[1] || '').get('name');
    const studentName = nameParam ? decodeURIComponent(nameParam) : 'Student';
    
    console.log('[Magic Link API] Student name:', studentName);
    
    // Create a temporary user account
    const { data: tempUser, error: tempUserError } = await supabaseAdmin.auth.admin.createUser({
      email: `student-${Date.now()}-${Math.random().toString(36).substring(2, 10)}@temp.classbots.ai`,
      password: Math.random().toString(36).substring(2, 14),
      user_metadata: {
        role: 'student',
        is_anonymous: true,
        full_name: studentName,
      },
    });
    
    if (tempUserError || !tempUser?.user) {
      console.error('[Magic Link API] Error creating temp user:', tempUserError);
      return NextResponse.json({ 
        error: 'Failed to create temporary account' 
      }, { status: 500 });
    }
    
    const userId = tempUser.user.id;
    
    // Create or update profile
    const { error: profileError } = await supabase
      .from('profiles')
      .insert({
        user_id: userId,
        email: tempUser.user.email || '',
        full_name: studentName,
        role: 'student',
        is_anonymous: true
      });
      
    if (profileError) {
      console.error('[Magic Link API] Error creating profile:', profileError);
      // Continue anyway - the profile might have been created by a trigger
    }
    
    // Add user to room
    const { error: joinError } = await supabase
      .from('room_memberships')
      .insert({
        room_id: roomId,
        student_id: userId
      });
      
    if (joinError) {
      console.error('[Magic Link API] Error adding student to room:', joinError);
      return NextResponse.json({ 
        error: 'Failed to add student to room' 
      }, { status: 500 });
    }
    
    // Set auth cookie for the user
    // Handle different Supabase versions with compatibility layer
    let sessionData;
    let sessionError;
    
    try {
      console.log('[Magic Link API] Creating session for user');
      // @ts-expect-error - We're handling API differences at runtime
      const adminAuthFn = supabaseAdmin.auth.admin.createSession || supabaseAdmin.auth.admin.signInWithUserId;
      
      if (!adminAuthFn) {
        throw new Error('No compatible session creation method found');
      }
      
      // Try the function with both argument styles
      let result;
      try {
        // Try createSession style first
        result = await adminAuthFn({ user_id: userId });
      } catch {
        // If that fails, try signInWithUserId style without needing the error
        result = await adminAuthFn(userId, { expiresIn: 604800 });
      }
      
      sessionData = result.data;
      sessionError = result.error;
    } catch (error) {
      console.error('[Magic Link API] Error in session creation:', error);
      sessionError = error;
    }
    
    if (sessionError) {
      console.error('[Magic Link API] Error creating session:', sessionError);
      return NextResponse.json({ 
        error: 'Failed to create session' 
      }, { status: 500 });
    }
    
    // Return success with room ID
    console.log('[Magic Link API] Successfully authenticated user via magic link');
    
    // Create the response with the user and room info
    const response = NextResponse.json({ 
      success: true, 
      user_id: userId,
      room_id: roomId
    });
    
    // Add the session cookie
    if (sessionData.session) {
      response.cookies.set('supabase-auth-token', JSON.stringify(sessionData.session), {
        path: '/',
        maxAge: 60 * 60 * 24 * 7, // 1 week
        httpOnly: true,
        secure: process.env.NODE_ENV === 'production',
        sameSite: 'lax'
      });
    }
    
    return response;
  } catch (error) {
    console.error('[Magic Link API] General error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to authenticate with magic link' },
      { status: 500 }
    );
  }
}// src/app/api/auth/student-username-lookup/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

// Public API to look up a student by name, username, or email and check if the PIN matches
// This avoids requiring client-side permissions to read from the profiles table
export async function POST(request: NextRequest) {
  try {
    const supabaseAdmin = createAdminClient();
    console.log('Student lookup API called');
    
    // Get identifier (name or email) and PIN from request body
    const { identifier, pin } = await request.json();
    
    if (!identifier) {
      return NextResponse.json({ 
        error: 'Name or email is required' 
      }, { status: 400 });
    }
    
    const cleanIdentifier = identifier.trim();
    console.log(`Looking up student: ${cleanIdentifier}`);
    
    // First, try to match by username (most specific)
    const { data: usernameProfiles } = await supabaseAdmin
      .from('profiles')
      .select('user_id, full_name, email, pin_code, username, role')
      .eq('role', 'student')
      .ilike('username', cleanIdentifier)
      .limit(5);
      
    let profiles = usernameProfiles;
    
    // If not found by username, try full_name
    if (!profiles || profiles.length === 0) {
      console.log(`Not found by username, trying name: ${cleanIdentifier}`);
      const { data: nameProfiles } = await supabaseAdmin
        .from('profiles')
        .select('user_id, full_name, email, pin_code, username, role')
        .eq('role', 'student')
        .ilike('full_name', cleanIdentifier)
        .limit(5);
        
      if (nameProfiles && nameProfiles.length > 0) {
        profiles = nameProfiles;
      }
    }
      
    // If not found by name, try email
    if (!profiles || profiles.length === 0) {
      console.log(`Not found by name, trying email: ${cleanIdentifier}`);
      const { data: emailProfiles } = await supabaseAdmin
        .from('profiles')
        .select('user_id, full_name, email, pin_code, username, role')
        .eq('role', 'student')
        .ilike('email', cleanIdentifier)
        .limit(5);
        
      if (emailProfiles && emailProfiles.length > 0) {
        profiles = emailProfiles;
      }
    }
    
    // If still not found, try fuzzy matching on any field
    if (!profiles || profiles.length === 0) {
      console.log(`Not found by exact matches, trying fuzzy match: ${cleanIdentifier}`);
      
      // Get all student profiles
      const { data: allStudents } = await supabaseAdmin
        .from('profiles')
        .select('user_id, full_name, email, pin_code, username, role')
        .eq('role', 'student')
        .limit(30);
      
      if (allStudents && allStudents.length > 0) {
        console.log(`Searching among ${allStudents.length} student profiles`);
        console.log('Available usernames:', allStudents.map(s => s.username));
        
        // Try fuzzy matching on name, email, or username
        const matches = allStudents.filter(student => {
          const name = (student.full_name || '').toLowerCase();
          const email = (student.email || '').toLowerCase();
          const username = (student.username || '').toLowerCase();
          const searchTerm = cleanIdentifier.toLowerCase();
          
          return name.includes(searchTerm) || 
                 searchTerm.includes(name) ||
                 email.includes(searchTerm) || 
                 searchTerm.includes(email) ||
                 username.includes(searchTerm) ||
                 searchTerm.includes(username);
        });
        
        if (matches.length > 0) {
          console.log(`Found ${matches.length} fuzzy matches`);
          console.log('Matched usernames:', matches.map(s => s.username));
          profiles = matches;
        }
      }
    }
    
    // If no profile found, return error
    if (!profiles || profiles.length === 0) {
      console.log('No matches found for:', cleanIdentifier);
      return NextResponse.json({
        error: 'Student not found',
        status: 'not_found',
        identifier: cleanIdentifier
      }, { status: 404 });
    }
    
    // Find the best match if we have multiple
    const bestMatch = profiles[0]; // Default to first match
    
    console.log(`Best match found: ${bestMatch.full_name} (${bestMatch.username})`);
    
    // If PIN is provided, verify it matches
    if (pin) {
      console.log(`Verifying PIN for: ${bestMatch.full_name}`);
      console.log(`Expected PIN: ${bestMatch.pin_code}, Provided PIN: ${pin}`);
      
      if (!bestMatch.pin_code) {
        return NextResponse.json({
          error: 'Student does not have a PIN set',
          status: 'no_pin',
          user_id: null
        }, { status: 401 });
      }
        
      if (bestMatch.pin_code !== pin) {
        return NextResponse.json({
          error: 'Incorrect PIN',
          status: 'incorrect_pin',
          user_id: null
        }, { status: 401 });
      }
      
      // PIN matches, return success with user_id for login
      return NextResponse.json({
        success: true,
        status: 'success',
        user_id: bestMatch.user_id,
        pin_verified: true,
        best_match: {
          full_name: bestMatch.full_name,
          email: bestMatch.email,
          username: bestMatch.username
        }
      });
    }
    
    // If just looking up without verifying PIN, return info about matches
    return NextResponse.json({
      success: true,
      status: 'student_found',
      matches: profiles.map(p => ({
        full_name: p.full_name,
        email: p.email,
        username: p.username
      })),
      match_count: profiles.length,
      best_match: {
        full_name: bestMatch.full_name,
        email: bestMatch.email,
        username: bestMatch.username
      },
      user_id: null, // Don't leak the user_id if PIN wasn't verified
      pin_required: true
    });
    
  } catch (error) {
    console.error('Student lookup error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Student lookup failed' },
      { status: 500 }
    );
  }
}// src/app/api/auth/student-pin-login/route.ts
import { NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function POST(request: Request) {
  try {
    const supabaseAdmin = createAdminClient();
    
    // Get parameters from request
    const { user_id, pin_code } = await request.json();
    
    // Validate inputs
    if (!user_id || !pin_code) {
      return NextResponse.json({ 
        error: 'Missing user_id or pin_code'
      }, { status: 400 });
    }
    
    // Verify PIN matches in profiles table
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('user_id, pin_code')
      .eq('user_id', user_id)
      .single();
      
    if (profileError || !profile) {
      console.error('Error looking up profile:', profileError);
      return NextResponse.json({ 
        error: 'User not found'
      }, { status: 404 });
    }
    
    // Verify PIN matches
    if (profile.pin_code !== pin_code) {
      return NextResponse.json({ 
        error: 'Incorrect PIN' 
      }, { status: 403 });
    }
    
    // Create a new session for the user using the admin API
    // Note: In newer Supabase versions, admin.createSession was replaced with admin.signInWithUserId
    console.log('Creating session for user_id:', user_id);
    
    // Check which method is available based on Supabase version
    // Use Record<string, unknown> instead of any for better type safety
    let sessionData: Record<string, unknown> | null = null;
    let sessionError: unknown = null;
    
    try {
      // Try the simplest direct approach first - using service key to get a direct token
      try {
        console.log('Trying service key approach first');
        
        // Get the user details first to ensure they exist
        const { data: userDetails, error: userError } = await supabaseAdmin.auth.admin.getUserById(user_id);
        
        if (userError || !userDetails?.user) {
          console.error('Error getting user details:', userError);
          throw new Error('User not found');
        }
        // userError is used above to check validity, so this isn't an unused variable
        
        // Don't use service role key directly in the browser
        // Instead, let's try to use an admin API to generate a token
        
        // Just get email and try to use emailLink instead
        const { email } = userDetails.user;
        if (!email) {
          throw new Error('User has no email address');
        }
        
        // Try to create a sign-in link (and use the token directly without redirecting)
        // This is more secure than exposing the service role key
        const { data: signInData, error: signInError } = await supabaseAdmin.auth.admin.generateLink({
          type: 'magiclink',
          email: email,
          options: {
            redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'}/student/dashboard`
          }
        });
        
        if (signInError || !signInData?.properties?.hashed_token) {
          throw new Error('Failed to generate login token');
        }
        
        // Use the token to sign in
        const { data: verifyData, error: verifyError } = await supabaseAdmin.auth.verifyOtp({
          email: email,
          token: signInData.properties.hashed_token,
          type: 'magiclink'
        });
        
        if (verifyError) {
          throw new Error('Failed to verify token: ' + verifyError.message);
        }
        
        sessionData = verifyData;
        
        console.log('Created admin token session');
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      } catch (_error) {
        // error variable is caught but not used explicitly
        console.log('Direct token approach failed, trying other methods');
      }
      
      // If direct approach failed, try the standard methods
      if (!sessionData) {
        try {
          console.log('Trying alternative session creation methods');
          // @ts-expect-error - We're handling API differences at runtime
          const adminAuthFn = supabaseAdmin.auth.admin.createSession || supabaseAdmin.auth.admin.signInWithUserId;
          
          if (!adminAuthFn) {
            throw new Error('No compatible session creation method found');
          }
          
          // Try the function with both argument styles
          let result;
          try {
            // Try createSession style first
            result = await adminAuthFn({ 
              user_id: user_id,
              expires_in: 604800 // 7 days in seconds 
            });
          } catch {
            // If that fails, try signInWithUserId style
            result = await adminAuthFn(
              user_id,
              { expiresIn: 604800 } // 7 days in seconds
            );
          }
          
          sessionData = result.data;
          sessionError = result.error;
        } catch (error) {
          console.error('Error in session creation:', error);
          sessionError = error;
        }
      }
      // Try with alternative method for older versions
      // Try direct sign-in approach (if createSession is not available but we can get the user's email)
      else {
        console.log('Using direct student lookup for sign-in');
        
        // Get the student's email from the profiles and auth.users table
        const { data: userData, error: userError } = await supabaseAdmin
          .from('profiles')
          .select('user_id, email, full_name')
          .eq('user_id', user_id)
          .single();
          
        if (userError || !userData?.email) {
          console.error('Error finding student:', userError);
          
          // Try looking directly in auth.users table
          const { data: authUser, error: authUserError } = await supabaseAdmin.auth.admin.getUserById(user_id);
          
          if (authUserError || !authUser?.user?.email) {
            console.error('Error finding user in auth:', authUserError);
            throw new Error('Could not find user email for authentication');
          }
          
          // Use the email from auth.users
          const signInResult = await supabaseAdmin.auth.signInWithPassword({
            email: authUser.user.email,
            password: `PINLOGIN-${pin_code}`, // We don't actually know their password
          });
          
          if (signInResult.error) {
            // If password login fails, try a magic link approach
            if (typeof supabaseAdmin.auth.admin.generateLink === 'function') {
              console.log('Attempting passwordless login with magic link');
              
              const linkResult = await supabaseAdmin.auth.admin.generateLink({
                type: 'magiclink',
                email: authUser.user.email,
                options: {
                  redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/student/dashboard`,
                }
              });
              
              if (linkResult.data?.properties?.hashed_token) {
                const otpResult = await supabaseAdmin.auth.verifyOtp({
                  email: authUser.user.email,
                  token: linkResult.data.properties.hashed_token,
                  type: 'magiclink',
                });
                
                sessionData = otpResult.data;
                sessionError = otpResult.error;
              } else {
                throw new Error('Failed to generate magic link');
              }
            } else {
              console.error('No authentication methods available');
              throw new Error('Cannot authenticate: method not available');
            }
          } else {
            sessionData = signInResult.data;
            sessionError = signInResult.error;
          }
        } else {
          // Use the email from profiles
          console.log('Found student email, attempting to authenticate');
          
          if (typeof supabaseAdmin.auth.admin.generateLink === 'function') {
            // Passwordless auth approach
            const linkResult = await supabaseAdmin.auth.admin.generateLink({
              type: 'magiclink',
              email: userData.email,
              options: {
                redirectTo: `${process.env.NEXT_PUBLIC_SITE_URL}/student/dashboard`,
              }
            });
            
            if (linkResult.data?.properties?.hashed_token) {
              const otpResult = await supabaseAdmin.auth.verifyOtp({
                email: userData.email,
                token: linkResult.data.properties.hashed_token,
                type: 'magiclink',
              });
              
              sessionData = otpResult.data;
              sessionError = otpResult.error;
            } else {
              throw new Error('Failed to generate magic link');
            }
          } else {
            throw new Error('No authentication methods available');
          }
        }
      }
      
      // If we got here without a session, log available methods to help with debugging
      if (!sessionData) {
        console.error('Admin auth methods not available:', 
          supabaseAdmin.auth.admin ? Object.keys(supabaseAdmin.auth.admin) : 'admin not available',
          'Auth methods:', Object.keys(supabaseAdmin.auth)
        );
        throw new Error('No compatible authentication method available');
      }
    } catch (err) {
      console.error('Session creation error:', err);
      sessionError = err;
    }
    
    if (sessionError) {
      const errorMessage = sessionError instanceof Error 
        ? sessionError.message 
        : JSON.stringify(sessionError);
        
      console.error('Error creating session:', errorMessage);
      
      return NextResponse.json({ 
        error: `Failed to create session: ${errorMessage}`,
        details: sessionError
      }, { status: 500 });
    }
    
    // Return success with cookies
    // Handle sessionData typing safely
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const session = sessionData && (sessionData as any).session ? {
      // Send a simplified version of the session back to the client for debugging
      // Don't include the actual tokens for security
      user: {
        id: user_id, // We know the user_id from input
        email: '',   // Don't need to expose email
        role: 'student'
      },
      expires_at: Math.floor(Date.now() / 1000) + 604800 // 7 days from now
    } : null;
    
    const response = NextResponse.json({ 
      success: true,
      redirect_to: '/student/dashboard', // Explicitly tell client where to redirect
      session: session
    });
    
    console.log('Standard student login successful for user:', user_id);
    
    // Check and set the session cookie
    // Note: We might have different session data structures based on the auth method used
    console.log('Session data available:', !!sessionData);
    console.log('Session object available:', !!sessionData?.session);
    
    // Add session info to response for debug
    response.headers.set('X-Session-Status', sessionData?.session ? 'available' : 'missing');
    
    if (sessionData?.session) {
      console.log('Setting cookies for session...');
      console.log('Session data keys:', Object.keys(sessionData));
      console.log('Session object keys:', Object.keys(sessionData.session));
      
      // Extract project reference from Supabase URL
      const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
      let cookiePrefix = 'sb';
      
      try {
        if (supabaseUrl) {
          const url = new URL(supabaseUrl);
          const hostname = url.hostname;
          const projectRef = hostname.split('.')[0];
          
          if (projectRef) {
            cookiePrefix = 'sb-' + projectRef;
          }
        }
      } catch (urlError) {
        console.error('Error parsing Supabase URL:', urlError);
        cookiePrefix = 'sb-auth';
      }
      
      console.log(`Using cookie prefix: ${cookiePrefix}`);
      
      // Set auth token cookie
      const sessionJson = JSON.stringify(sessionData.session);
      console.log(`Session data length: ${sessionJson.length} characters`);
      
      try {
        // Set up the cookies exactly like Supabase expects them
        // Cookie names are very important and must match exactly
        response.cookies.set(`${cookiePrefix}-auth-token`, sessionJson, {
          path: '/',
          maxAge: 60 * 60 * 24 * 7, // 1 week
          sameSite: 'lax',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production'
        });
        
        // This is the most important cookie - the client SDK looks for this one
        response.cookies.set('supabase-auth-token', sessionJson, {
          path: '/',
          maxAge: 60 * 60 * 24 * 7,
          sameSite: 'lax',
          httpOnly: true,
          secure: process.env.NODE_ENV === 'production'
        });
        
        // Event cookie for client-side auth state sync
        response.cookies.set(`${cookiePrefix}-auth-event`, JSON.stringify({
          type: 'SIGNED_IN',
          session: sessionData.session
        }), {
          path: '/',
          maxAge: 100, // Very short-lived
          sameSite: 'lax',
          httpOnly: false
        });
        
        // Our custom cookie to track user ID
        response.cookies.set('auth-user-id', user_id, {
          path: '/',
          maxAge: 60 * 60 * 24 * 7,
          sameSite: 'lax',
          httpOnly: false
        });
        
        console.log('Cookies set successfully');
      } catch (cookieError) {
        console.error('Error setting cookies:', cookieError);
      }
    } else {
      console.warn('No session data available to set cookies');
    }
    
    return response;
  } catch (error) {
    console.error('Student PIN login error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to log in' },
      { status: 500 }
    );
  }
}// src/app/api/auth/direct-student-login/route.ts
import { NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
// We're using admin client instead of regular client
// import { createClient } from '@supabase/supabase-js';

/**
 * This is a fallback direct login method that works when the regular session methods are failing.
 * It creates a minimal session that's enough to get the RLS policies working.
 */
export async function POST(request: Request) {
  try {
    const supabaseAdmin = createAdminClient();
    
    // Get parameters from request
    const { user_id, pin_code } = await request.json();
    
    // Validate inputs
    if (!user_id || !pin_code) {
      return NextResponse.json({ 
        error: 'Missing user_id or pin_code'
      }, { status: 400 });
    }
    
    // Verify PIN matches in profiles table
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('user_id, pin_code, email, full_name, role')
      .eq('user_id', user_id)
      .single();
      
    if (profileError || !profile) {
      console.error('Error looking up profile:', profileError);
      return NextResponse.json({ 
        error: 'User not found'
      }, { status: 404 });
    }
    
    // Verify PIN matches
    if (profile.pin_code !== pin_code) {
      return NextResponse.json({ 
        error: 'Incorrect PIN' 
      }, { status: 403 });
    }
    
    // Get actual user data from auth system
    const { data: userData, error: userError } = await supabaseAdmin.auth.admin.getUserById(user_id);
    
    if (userError) {
      console.error('Error fetching user data:', userError);
      return NextResponse.json({ 
        error: 'Failed to fetch user data' 
      }, { status: 500 });
    }
    
    // We need to create a bypass mechanism for authentication
    // instead of trying to use Supabase's auth system
    
    // First, make sure we have the user data
    const userObject = userData.user || {
      id: user_id,
      email: profile.email,
      role: profile.role || 'student',
      app_metadata: {
        provider: 'pin',
      },
      user_metadata: {
        full_name: profile.full_name,
      },
    };
    
    // Create a session that will work with the client - use the anon key as the token
    // The anon key is public anyway, so this is safe
    const expiresIn = 60 * 60 * 24 * 7; // 7 days in seconds
    const expiresAt = Math.floor(Date.now() / 1000) + expiresIn;
    
    // Create a JWT-like token that includes the sub claim
    // This is a simplified version without real JWT signing
    // but it will allow bypassing the auth check
    // Commented out since we don't use it directly anymore
    // const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || '';
    
    // Basic JWT structure with required fields - commented out since we use bypass token approach
    // const tokenPayload = {
    //   sub: user_id, // This is the critical field - the subject claim
    //   email: userObject.email,
    //   role: 'authenticated',
    //   exp: expiresAt,
    // };
    
    // Instead of creating a fake JWT token, which caused parsing issues,
    // let's use a completely different approach:
    // 1. Create a special "bypass token" cookie
    // 2. Set the actual Supabase token cookies with minimal data
    
    // Generate a bypass token that's easy to validate
    const bypassToken = `BYPASS_${user_id}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
    
    // Create a simple session object without any JWT complications
    const session = {
      // Instead of trying to create a valid JWT, just store a reference to the user
      access_token: `DIRECT_${user_id}`,
      expires_at: expiresAt,
      expires_in: expiresIn,
      refresh_token: null,
      token_type: 'bearer',
      user: userObject
    };
    
    // Set up response with cookies
    const response = NextResponse.json({ 
      success: true,
      message: 'Direct login successful',
      redirect_to: `/student/dashboard?_t=${Date.now()}&direct=1&user_id=${user_id}`, // Add timestamp, direct flag, and user_id
      user: {
        id: user_id,
        name: profile.full_name,
        role: profile.role || 'student',
      }
    });
    
    console.log('Direct student login successful for user:', user_id);
    
    // Add X-Auth-Token header for debugging - allows the middleware
    // to identify this response as special
    response.headers.set('X-Auth-Type', 'direct-pin-login');
    
    // Extract project reference from Supabase URL
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
    let cookiePrefix = 'sb';
    
    try {
      if (supabaseUrl) {
        const url = new URL(supabaseUrl);
        const hostname = url.hostname;
        const projectRef = hostname.split('.')[0];
        
        if (projectRef) {
          cookiePrefix = 'sb-' + projectRef;
        }
      }
    } catch (urlError) {
      console.error('Error parsing Supabase URL:', urlError);
      cookiePrefix = 'sb-auth';
    }
    
    const maxAge = 60 * 60 * 24 * 7; // 1 week in seconds
    
    // Set auth cookies
    // Set cookies consistently with Supabase auth requirements
    const sessionJson = JSON.stringify(session);
    
    // Set the project-specific auth token
    response.cookies.set(`${cookiePrefix}-auth-token`, sessionJson, {
      path: '/',
      maxAge: maxAge, 
      sameSite: 'lax',
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production'
    });
    
    // Set the main Supabase auth token that the client SDK looks for
    response.cookies.set('supabase-auth-token', sessionJson, {
      path: '/',
      maxAge: maxAge,
      sameSite: 'lax',
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production'
    });
    
    // Set our special bypass token cookie that our API will recognize
    response.cookies.set('student-pin-auth-bypass', bypassToken, {
      path: '/',
      maxAge: maxAge,
      sameSite: 'lax',
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production'
    });
    
    // Add the auth event cookie for client-side auth state sync
    response.cookies.set(`${cookiePrefix}-auth-event`, JSON.stringify({
      type: 'SIGNED_IN',
      session: session
    }), {
      path: '/',
      maxAge: 100, // Very short-lived
      sameSite: 'lax',
      httpOnly: false
    });
    
    // Our custom user ID cookie
    response.cookies.set('auth-user-id', user_id, {
      path: '/',
      maxAge: maxAge,
      sameSite: 'lax',
      httpOnly: false
    });
    
    return response;
  } catch (error) {
    console.error('Direct student login error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Login failed' },
      { status: 500 }
    );
  }
}// src/app/api/auth/student-account/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const { full_name, email, room_code } = await request.json();
    
    if (!full_name || !email || !room_code) {
      return NextResponse.json({ 
        error: 'Missing required parameters: full_name, email, and room_code' 
      }, { status: 400 });
    }
    
    // Find the room first
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id, is_active')
      .eq('room_code', room_code)
      .single();
      
    if (roomError || !room) {
      return NextResponse.json({ 
        error: 'Room not found or invalid room code' 
      }, { status: 404 });
    }
    
    if (!room.is_active) {
      return NextResponse.json({ 
        error: 'This room is currently inactive' 
      }, { status: 400 });
    }
    
    // Check if email is already registered
    const { data: existingUser } = await supabase
      .from('profiles')
      .select('user_id')
      .eq('email', email)
      .maybeSingle();
      
    if (existingUser) {
      return NextResponse.json({ 
        error: 'Email already registered. Please sign in.' 
      }, { status: 400 });
    }
    
    // Generate a random password for the account
    const generatePassword = () => {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*()';
      return Array(16).fill('0')
        .map(() => chars.charAt(Math.floor(Math.random() * chars.length)))
        .join('');
    };
    
    const password = generatePassword();
    
    // Create a new user
    const { data: signUpData, error: signUpError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: {
          role: 'student',
          full_name: full_name,
        }
      }
    });
    
    if (signUpError || !signUpData.user) {
      console.error('Error creating student account:', signUpError);
      return NextResponse.json({ 
        error: 'Failed to create student account' 
      }, { status: 500 });
    }
    
    // Create profile for the user
    const { error: profileError } = await supabase
      .from('profiles')
      .insert({
        user_id: signUpData.user.id,
        email,
        full_name,
        role: 'student'
      });
      
    if (profileError) {
      console.error('Error creating user profile:', profileError);
      return NextResponse.json({ 
        error: 'Failed to create user profile' 
      }, { status: 500 });
    }
    
    // Add user to room
    const { error: joinError } = await supabase
      .from('room_memberships')
      .insert({
        room_id: room.room_id,
        student_id: signUpData.user.id
      });
      
    if (joinError) {
      console.error('Error adding student to room:', joinError);
      return NextResponse.json({ 
        error: 'Failed to add student to room' 
      }, { status: 500 });
    }
    
    // Return success with session
    return NextResponse.json({ 
      success: true, 
      user_id: signUpData.user.id,
      room_id: room.room_id
    });
  } catch (error) {
    console.error('Student account creation error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create student account' },
      { status: 500 }
    );
  }
}// src/app/api/magic-link-gen/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const studentId = searchParams.get('studentId');
    const roomId = searchParams.get('roomId');
    
    console.log('[Magic Link API] GET request received with params:', { studentId, roomId, url: request.url });

    if (!studentId || !roomId) {
      console.error('[Magic Link API] Missing required parameters');
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.error('[Magic Link API] Authentication error:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code, room_name')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      console.error('[Magic Link API] Room error:', roomError);
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    console.log('[Magic Link API] Found room:', room);

    // Get the student details
    const { data: profile, error: studentError } = await supabase
      .from('profiles')
      .select('full_name, email')
      .eq('user_id', studentId)
      .single();

    if (studentError || !profile) {
      console.error('[Magic Link API] Student error:', studentError);
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    console.log('[Magic Link API] Found student:', profile);

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();
    // Note: 'membership' data is not used but the check is needed to verify if student is in room

    if (membershipError) {
      console.error('[Magic Link API] Membership error:', membershipError);
      if (membershipError.code !== 'PGRST116') { // Not found
        return NextResponse.json(
          { error: 'Error checking room membership' },
          { status: 500 }
        );
      }
    }

    // Generate the magic link using the format: roomCode_userId_encodedStudentName
    const encodedName = encodeURIComponent(profile.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Magic Link Gen API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    console.log('[Magic Link API] Generated link with code:', simpleLinkCode);

    return NextResponse.json({
      magicLink,
      studentName: profile.full_name,
      code: simpleLinkCode,
      roomCode: room.room_code,
      roomName: room.room_name,
      email: profile.email
    });
  } catch (error) {
    console.error('[Magic Link API] Error generating magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { studentId, roomId } = body;
    
    console.log('[Magic Link API] POST request received with body:', { studentId, roomId });

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code, room_name')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    // Get the student details
    const { data: profile, error: studentError } = await supabase
      .from('profiles')
      .select('full_name, email')
      .eq('user_id', studentId)
      .single();

    if (studentError || !profile) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();
    // Note: 'membership' data is not used but the check is needed to verify if student is in room

    if (membershipError && membershipError.code !== 'PGRST116') {
      return NextResponse.json(
        { error: 'Error checking room membership' },
        { status: 500 }
      );
    }

    // Generate the magic link
    const encodedName = encodeURIComponent(profile.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Magic Link Gen API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    console.log('[Magic Link API] Regenerated link with code:', simpleLinkCode);

    return NextResponse.json({
      magicLink,
      studentName: profile.full_name,
      code: simpleLinkCode,
      roomCode: room.room_code,
      roomName: room.room_name,
      email: profile.email,
      regenerated: true
    });
  } catch (error) {
    console.error('[Magic Link API] Error regenerating magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to regenerate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Test database connection
    const { error } = await supabase
      .from('schools')
      .select('count')
      .limit(1);

    if (error) {
      return NextResponse.json({ 
        status: 'error', 
        message: 'Database connection failed',
        error: error.message 
      }, { status: 500 });
    }

    return NextResponse.json({ 
      status: 'healthy',
      database: 'connected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return NextResponse.json({ 
      status: 'error', 
      message: 'Server error',
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}// src/app/api/emergency-room-access/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { v4 as uuidv4 } from 'uuid';

// This is a last-resort emergency endpoint for getting students into a room
// when all other methods fail. It's a simplified version of the join-room API.

export async function POST(request: NextRequest) {
  console.log('[Emergency Access API] Received request');
  
  try {
    // Handle both form data and JSON requests for maximum flexibility
    let roomCode: string | undefined;
    let studentName: string | undefined;
    
    // Check content type to determine how to parse the request
    const contentType = request.headers.get('content-type') || '';
    
    if (contentType.includes('application/json')) {
      // Handle JSON request
      const jsonData = await request.json();
      roomCode = jsonData.roomCode?.toString() || jsonData.room_code?.toString();
      studentName = jsonData.studentName?.toString() || jsonData.student_name?.toString();
      console.log('[Emergency Access API] Parsed JSON data:', { roomCode, studentName });
    } else {
      // Handle form data request (legacy support)
      const formData = await request.formData();
      roomCode = formData.get('room_code')?.toString();
      studentName = formData.get('student_name')?.toString();
      console.log('[Emergency Access API] Parsed form data:', { roomCode, studentName });
    }

    if (!roomCode || !studentName) {
      return NextResponse.json({ error: 'Missing required fields', details: 'Room code and student name are required' }, { status: 400 });
    }
    
    console.log(`[Emergency Access API] Attempting access for ${studentName} to room ${roomCode}`);
    
    // Use admin client for maximum reliability
    const supabaseAdmin = createAdminClient();
    
    // 1. Find the room
    const { data: rooms, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('room_id, room_name, is_active')
      .eq('room_code', roomCode.toUpperCase())
      .limit(1);
      
    if (roomError || !rooms || rooms.length === 0) {
      console.error(`[Emergency Access API] Room not found: ${roomCode}`);
      // Redirect to the join page with an error
      return new Response(null, {
        status: 302,
        headers: {
          'Location': `/join-room?code=${roomCode}&error=Room+not+found`
        }
      });
    }
    
    const room = rooms[0];
    
    if (!room.is_active) {
      console.warn(`[Emergency Access API] Room is inactive: ${roomCode}`);
      return new Response(null, {
        status: 302,
        headers: {
          'Location': `/join-room?code=${roomCode}&error=Room+is+inactive`
        }
      });
    }
    
    // 2. Create an emergency anonymous user
    // Generate unique identifiers for this emergency user
    const uniqueId = uuidv4();
    const timestamp = Date.now();
    const tempEmail = `emergency-${timestamp}-${uniqueId.substring(0, 8)}@tempuser.classbots.ai`;
    const tempPassword = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    
    try {
      console.log(`[Emergency Access API] Creating anonymous user for ${studentName}`);
      
      const { data: userData, error: userError } = await supabaseAdmin.auth.admin.createUser({
        email: tempEmail,
        password: tempPassword,
        email_confirm: true,
        user_metadata: {
          full_name: studentName,
          role: 'student',
          is_anonymous: true,
          is_emergency: true,
          created_at: new Date().toISOString()
        },
        app_metadata: {
          role: 'student'
        }
      });
      
      if (userError || !userData?.user) {
        console.error(`[Emergency Access API] Failed to create user: ${userError?.message}`);
        return new Response(null, {
          status: 302,
          headers: {
            'Location': `/join-room?code=${roomCode}&error=Failed+to+create+emergency+account`
          }
        });
      }
      
      const userId = userData.user.id;
      
      // 3. Create a profile for this user
      const { error: profileError } = await supabaseAdmin
        .from('profiles')
        .insert({
          user_id: userId,
          full_name: studentName,
          email: tempEmail,
          role: 'student',
          is_anonymous: true
        });
        
      if (profileError) {
        console.warn(`[Emergency Access API] Failed to create profile: ${profileError.message}`);
        // Continue anyway - the auth user is created
      }
      
      // 4. Add the user to the room
      console.log(`[Emergency Access API] Adding ${userId} to room ${room.room_id}`);
      
      const { error: membershipError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: room.room_id,
          student_id: userId
        });
        
      if (membershipError) {
        console.error(`[Emergency Access API] Failed to add to room: ${membershipError.message}`);
        return new Response(null, {
          status: 302,
          headers: {
            'Location': `/join-room?code=${roomCode}&error=Failed+to+add+to+room`
          }
        });
      }
      
      // 5. Create a session - handle different Supabase API versions
      let session;
      let sessionError;
      
      try {
        // @ts-expect-error - Handle Supabase API differences
        const authFn = supabaseAdmin.auth.admin.signInWithUserId || supabaseAdmin.auth.admin.createSession;
        
        if (!authFn) {
          throw new Error('No compatible session creation method available');
        }
        
        // Try different argument styles
        let result;
        try {
          // Try signInWithUserId
          result = await authFn(userId, {
            expiresIn: 604800 // 7 days in seconds
          });
        } catch {
          // Try createSession
          result = await authFn({
            user_id: userId,
            expires_in: 604800 // 7 days in seconds
          });
        }
        
        session = result.data;
        sessionError = result.error;
      } catch (error) {
        console.error('[Emergency Access API] Error creating session:', error);
        sessionError = error;
      }
      
      if (sessionError || !session?.session) {
        console.error(`[Emergency Access API] Failed to create session: ${sessionError?.message}`);
        return new Response(null, {
          status: 302,
          headers: {
            'Location': `/join-room?code=${roomCode}&error=Failed+to+create+session`
          }
        });
      }
      
      console.log(`[Emergency Access API] Successfully created emergency access for ${studentName}`);
      
      // 6. Redirect to chat page with the room ID and set cookies
      const response = new Response(null, {
        status: 302,
        headers: {
          'Location': `/chat/${room.room_id}?emergency=true&uid=${userId}`
        }
      });
      
      // Set all possible auth cookies to maximize chances of success
      try {
        // Extract URL components for cookie name
        const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
        const projectRef = supabaseUrl ? new URL(supabaseUrl).hostname.split('.')[0] : 'sb';
        const cookiePrefix = `sb-${projectRef}`;
        
        // Set various cookie formats
        const headers = response.headers;
        const cookieOptions = 'Path=/; Max-Age=604800; SameSite=Lax';
        
        headers.append('Set-Cookie', 
          `${cookiePrefix}-auth-token=${JSON.stringify(session.session)}; ${cookieOptions}`);
        headers.append('Set-Cookie', 
          `supabase-auth-token=${JSON.stringify(session.session)}; ${cookieOptions}`);
        headers.append('Set-Cookie', 
          `auth-user-id=${userId}; ${cookieOptions}`);
        headers.append('Set-Cookie', 
          `${cookiePrefix}-auth-event=${JSON.stringify({
            type: 'SIGNED_IN',
            session: session.session
          })}; Max-Age=100; Path=/; SameSite=Lax`);
      } catch (cookieError) {
        console.error(`[Emergency Access API] Error setting cookies: ${cookieError}`);
        // Continue anyway - the redirect will still work
      }
      
      return response;
      
    } catch (error) {
      console.error('[Emergency Access API] Fatal error:', error);
      return new Response(null, {
        status: 302,
        headers: {
          'Location': `/join-room?code=${roomCode}&error=Server+error+during+emergency+access`
        }
      });
    }
    
  } catch (error) {
    console.error('[Emergency Access API] Request processing error:', error);
    return NextResponse.json({ error: 'Server error' }, { status: 500 });
  }
}// src/app/api/student/direct-dashboard/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { Room } from '@/types/database.types';

// Simple in-memory cache to reduce database load
interface CacheEntry {
  data: {
    profile: Record<string, unknown>;
    rooms: RoomWithChatbots[];
    isAnonymous: boolean;
  };
  timestamp: number;
}

const CACHE_TIMEOUT = 30 * 1000; // 30 seconds
const dashboardCache = new Map<string, CacheEntry>();

// Define interfaces for the specific data structures we're using
interface RoomWithChatbots extends Room {
  chatbots: ChatbotSummary[];
}

interface ChatbotSummary {
  chatbot_id: string;
  name: string;
  bot_type: string;
}

// Using a more general type for the database response
interface ChatbotAssociation {
  chatbots: {
    chatbot_id: string;
    name: string;
    bot_type?: string;
  } | null;
}

// A simplified API endpoint specifically for direct access
// This doesn't try to use normal auth flow and directly uses the user ID
export async function GET(request: NextRequest) {
  try {
    const url = new URL(request.url);
    const userId = url.searchParams.get('userId');
    
    console.log('[Direct Dashboard API] Request received. User ID:', userId);
    
    if (!userId) {
      console.error('[Direct Dashboard API] No user ID provided');
      return NextResponse.json({ error: 'User ID is required' }, { status: 400 });
    }
    
    // Check cache first
    const cacheKey = `dashboard_${userId}`;
    const cachedData = dashboardCache.get(cacheKey);
    
    if (cachedData && (Date.now() - cachedData.timestamp < CACHE_TIMEOUT)) {
      console.log(`[Direct Dashboard API] Using cached data for user ${userId}`);
      return NextResponse.json(cachedData.data);
    }
    
    // Create admin client (server-side only)
    const supabaseAdmin = createAdminClient();
    
    // 1. Load student profile - don't try to select is_anonymous since it might not exist
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('user_id, full_name, email, username, pin_code')
      .eq('user_id', userId)
      .single();
      
    if (profileError) {
      console.error('[Direct Dashboard API] Error loading profile:', profileError);
      return NextResponse.json({ error: 'Could not load student profile' }, { status: 500 });
    }
    
    console.log('[Direct Dashboard API] Profile loaded:', {
      name: profile.full_name,
      has_username: !!profile.username,
      has_pin: !!profile.pin_code
    });
    
    // 2. Load student's room memberships
    const { data: memberships, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select(`
        room_id,
        joined_at
      `)
      .eq('student_id', userId);
      
    if (membershipError) {
      console.error('[Direct Dashboard API] Error loading room memberships:', membershipError);
      return NextResponse.json({ error: 'Could not load classroom memberships' }, { status: 500 });
    }
    
    console.log('[Direct Dashboard API] Found memberships:', memberships?.length || 0);
    
    // If no memberships, return early with empty rooms
    if (!memberships || memberships.length === 0) {
      // Determine if this is a temporary user based on pin_code/username
      const isAnonymous = !profile.pin_code || !profile.username;
      
      return NextResponse.json({
        profile,
        rooms: [],
        isAnonymous
      });
    }
    
    // Get detailed room info
    const roomIds = memberships.map(m => m.room_id);
    
    const { data: roomsData, error: roomsError } = await supabaseAdmin
      .from('rooms')
      .select(`
        room_id,
        room_name,
        room_code, 
        is_active,
        created_at,
        teacher_id
      `)
      .in('room_id', roomIds)
      .eq('is_active', true);
      
    if (roomsError) {
      console.error('[Direct Dashboard API] Error loading rooms:', roomsError);
      return NextResponse.json({ error: 'Could not load classroom details' }, { status: 500 });
    }
    
    console.log('[Direct Dashboard API] Found active rooms:', roomsData?.length || 0);
    
    // Get chatbots for each room
    const roomsWithChatbots: RoomWithChatbots[] = [];
    
    for (const room of roomsData || []) {
      const { data: chatbotAssociations, error: chatbotsError } = await supabaseAdmin
        .from('room_chatbots')
        .select(`
          chatbots (
            chatbot_id,
            name,
            bot_type
          )
        `)
        .eq('room_id', room.room_id);
        
      if (chatbotsError) {
        console.warn(`[Direct Dashboard API] Error loading chatbots for room ${room.room_id}:`, chatbotsError);
      }
      
      // Type for our chatbots array
      const chatbots: ChatbotSummary[] = [];
      
      if (chatbotAssociations) {
        // Use an explicit unknown cast first for safety, then to our expected type
        (chatbotAssociations as unknown as ChatbotAssociation[]).forEach(assoc => {
          if (assoc.chatbots) {
            chatbots.push({
              chatbot_id: assoc.chatbots.chatbot_id,
              name: assoc.chatbots.name || 'Unnamed Bot',
              bot_type: assoc.chatbots.bot_type || 'learning' // Provide default for bot_type
            });
          }
        });
      }
      
      roomsWithChatbots.push({
        ...room,
        chatbots
      } as RoomWithChatbots);
    }
    
    // Determine if this is a temporary user based on pin_code/username
    const isAnonymous = !profile.pin_code || !profile.username;
    
    console.log('[Direct Dashboard API] User is anonymous:', isAnonymous);
    console.log('[Direct Dashboard API] Returning rooms with chatbots:', roomsWithChatbots.length);
    
    // Prepare response data
    const responseData = {
      profile,
      rooms: roomsWithChatbots,
      isAnonymous
    };
    
    // Store in cache
    dashboardCache.set(cacheKey, {
      data: responseData,
      timestamp: Date.now()
    });
    
    return NextResponse.json(responseData);
  } catch (error) {
    console.error('[Direct Dashboard API] Unhandled error:', error);
    return NextResponse.json(
      { error: 'Failed to load dashboard data' },
      { status: 500 }
    );
  }
}// src/app/api/student/join-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { isValidRoomCode } from '@/lib/utils/room-codes';

// Constants for easier management
const SESSION_EXPIRY_SECONDS = 604800; // 7 days in seconds
const PROFILE_CREATION_DELAY_MS = 500; // Delay for profile creation trigger

export async function POST(request: Request) {
  console.log('[API POST /student/join-room] Received request.');
  try {
    // ALWAYS use the admin client for reliability
    const supabaseAdmin = createAdminClient();
    if (!supabaseAdmin) {
      console.error('[Simple Join API] Failed to create admin client');
      return NextResponse.json({ 
        error: 'Server configuration error: Failed to initialize database connection' 
      }, { status: 500 });
    }
    
    const supabase = await createServerSupabaseClient();
    
    // Get parameters from request
    let requestData;
    try {
      requestData = await request.json();
    } catch (parseError) {
      console.error('[Simple Join API] Error parsing request JSON:', parseError);
      return NextResponse.json({ 
        error: 'Invalid request format' 
      }, { status: 400 });
    }
    
    const { room_code, student_name, user_id, skip_auth } = requestData;
    console.log('[Simple Join API] Request data:', { room_code, student_name, user_id, skip_auth });
    
    // Validate input
    if (!room_code) {
      return NextResponse.json({ error: 'Missing room code' }, { status: 400 });
    }
    
    const formattedCode = room_code.toUpperCase();
    
    if (!isValidRoomCode(formattedCode)) {
      console.warn('[Simple Join API] Invalid room code format:', formattedCode);
      return NextResponse.json({ 
        error: 'Invalid room code format. Please check the code and try again.' 
      }, { status: 400 });
    }
    
    // Always look up the room using admin client to bypass RLS
    const { data: rooms, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('room_id, is_active, room_code')
      .eq('room_code', formattedCode);
      
    if (roomError) {
      console.error('[Simple Join API] Error looking up room:', roomError);
      return NextResponse.json({ 
        error: 'Database error while looking up room' 
      }, { status: 500 });
    }
    
    if (!rooms || rooms.length === 0) {
      console.warn('[Simple Join API] Room not found for code:', formattedCode);
      return NextResponse.json({ 
        error: 'Room not found. Please check the code and try again.' 
      }, { status: 404 });
    }
    
    const room = rooms[0];
    console.log('[Simple Join API] Found room:', room.room_id, 'with code:', room.room_code);
    
    if (!room.is_active) {
      console.warn('[Simple Join API] Room is inactive:', formattedCode);
      return NextResponse.json({ 
        error: 'This classroom is currently inactive. Please contact your teacher.' 
      }, { status: 403 });
    }
    
    // SIMPLIFIED JOIN PROCESS
    // We'll use a consistent approach whether or not skip_auth is true
    // This ensures reliability across all join flows
    let currentUserId = '';
    
    // Try to get current user if available
    if (!skip_auth) {
      const { data: { session } } = await supabase.auth.getSession();
      if (session?.user?.id) {
        currentUserId = session.user.id;
        console.log('[Simple Join API] Using existing authenticated user:', currentUserId);
      }
    }
    
    // If we have a specific user ID provided (from magic link)
    if (user_id && !currentUserId) {
      console.log('[Simple Join API] Using user ID from request:', user_id);
      
      // Verify the user exists
      const { data: existingUser, error: userCheckError } = await supabaseAdmin.auth.admin.getUserById(user_id);
      
      if (userCheckError || !existingUser.user) {
        console.warn('[Simple Join API] Provided user ID not found, will create new user:', userCheckError);
      } else {
        // Use the existing user
        currentUserId = user_id;
        
        // Update the user's metadata if needed
        if (student_name && existingUser.user.user_metadata?.full_name !== student_name) {
          await supabaseAdmin.auth.admin.updateUserById(user_id, {
            user_metadata: {
              ...existingUser.user.user_metadata,
              full_name: student_name
            }
          });
          
          // Also update profile
          await supabaseAdmin
            .from('profiles')
            .update({ full_name: student_name })
            .eq('user_id', user_id)
            .then(res => {
              if (res.error) {
                console.warn('[Simple Join API] Error updating profile name:', res.error);
              }
            });
        }
        
        console.log('[Simple Join API] Using existing user from ID param:', currentUserId);
      }
    }
    
    // If we need to create a new user (either no currentUserId or skip_auth explicitly requested)
    if (!currentUserId) {
      if (!student_name) {
        return NextResponse.json({ error: 'Student name is required for anonymous join' }, { status: 400 });
      }
      
      // Create a new temporary anonymous account
      console.log('[Simple Join API] Creating new temporary user with name:', student_name);
      
      // Generate a unique timestamp to avoid collisions
      const timestamp = Date.now();
      const randomStr = Math.random().toString(36).substring(2, 10);
      // Use an email domain that Supabase will accept
      const tempEmail = `anon-${timestamp}-${randomStr}@example.com`;
      const tempPassword = Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
      
      try {
        console.log('[Simple Join API] Attempting to create user with email:', tempEmail);
        
        // First, check if the email is already used (shouldn't happen but just in case)
        // Note: Supabase API has changed between versions
        let existingUsers;
        try {
          // Try the newer API format with filter object
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const result = await (supabaseAdmin.auth.admin as any).listUsers({
            filter: {
              email: tempEmail,
            },
            limit: 1,
          });
          existingUsers = result.data;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (_apiErr) {
          // If that fails, try the older format directly
          try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const fallbackResult = await (supabaseAdmin.auth.admin as any).listUsers({
              email: tempEmail,
              limit: 1,
            });
            existingUsers = fallbackResult.data;
          } catch (fallbackErr) {
            console.error('[Simple Join API] Error checking for existing users:', fallbackErr);
            // Continue anyway, since we're creating a new user
            existingUsers = { users: [] };
          }
        }
        
        if (existingUsers?.users?.length > 0) {
          // Very unlikely but handle it just in case
          console.warn('[Simple Join API] Temporary email already exists (very rare):', tempEmail);
          // Try again with a more unique email
          const newRandomStr = Math.random().toString(36).substring(2, 15);
          const newTempEmail = `anon-${timestamp}-${randomStr}-${newRandomStr}@tempuser.classbots.ai`;
          console.log('[Simple Join API] Retrying with more unique email:', newTempEmail);
          
          const { data: userResult, error: createUserError } = await supabaseAdmin.auth.admin.createUser({
            email: newTempEmail,
            password: tempPassword,
            email_confirm: true,
            user_metadata: {
              full_name: student_name,
              role: 'student',
              is_anonymous: true,
              created_at: new Date().toISOString()
            },
            app_metadata: {
              // Essential for RLS policies
              role: 'student'
            }
          });
          
          if (createUserError || !userResult?.user) {
            console.error('[Simple Join API] Error creating temporary user on retry:', createUserError);
            return NextResponse.json({ 
              error: 'Failed to create temporary user account. Please try again.' 
            }, { status: 500 });
          }
          
          currentUserId = userResult.user.id;
          console.log('[Simple Join API] Created temp user with ID (on retry):', currentUserId);
        } else {
          // Normal path - email doesn't exist yet
          const { data: userResult, error: createUserError } = await supabaseAdmin.auth.admin.createUser({
            email: tempEmail,
            password: tempPassword,
            email_confirm: true,
            user_metadata: {
              full_name: student_name,
              role: 'student',
              is_anonymous: true,
              created_at: new Date().toISOString()
            },
            app_metadata: {
              // Essential for RLS policies
              role: 'student'
            }
          });
          
          if (createUserError || !userResult?.user) {
            console.error('[Simple Join API] Error creating temporary user:', createUserError);
            return NextResponse.json({ 
              error: 'Failed to create temporary user account' 
            }, { status: 500 });
          }
          
          currentUserId = userResult.user.id;
          console.log('[Simple Join API] Created temp user with ID:', currentUserId);
        }
        
        // Wait a moment to allow auth triggers to process
        await new Promise(resolve => setTimeout(resolve, PROFILE_CREATION_DELAY_MS));
        
        // Create profile - use upsert to handle case where the profile might already exist
        console.log('[Simple Join API] Creating profile for user:', currentUserId);
        const { error: profileError } = await supabaseAdmin
          .from('profiles')
          .upsert({
            user_id: currentUserId,
            email: tempEmail,
            full_name: student_name,
            role: 'student',
            is_anonymous: true,
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'user_id'
          });
          
        if (profileError) {
          console.warn('[Simple Join API] Error upserting profile:', profileError);
          // Make another attempt with a different approach
          console.log('[Simple Join API] Trying alternative profile creation approach...');
          
          try {
            // Try a direct insert as last resort
            const { error: insertError } = await supabaseAdmin
              .from('profiles')
              .insert({
                user_id: currentUserId,
                email: tempEmail,
                full_name: student_name,
                role: 'student',
                is_anonymous: true,
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
              });
              
            if (insertError) {
              console.error('[Simple Join API] Failed alternative profile creation:', insertError);
            } else {
              console.log('[Simple Join API] Successfully created profile with alternative method');
            }
          } catch (insertError) {
            console.error('[Simple Join API] Exception in profile creation attempt:', insertError);
          }
        } else {
          console.log('[Simple Join API] Successfully created profile for:', currentUserId);
        }
      } catch (error) {
        console.error('[Simple Join API] Exception creating user:', error);
        return NextResponse.json({ 
          error: 'Failed to create account. Please try again.' 
        }, { status: 500 });
      }
    }
    
    // At this point we should definitely have a currentUserId
    if (!currentUserId) {
      return NextResponse.json({ 
        error: 'Could not determine user account. Please try again.' 
      }, { status: 500 });
    }
      
    // Now add the student to the room if needed
    // Check if student is already in room
    const { data: existingMembership, error: membershipCheckError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', room.room_id)
      .eq('student_id', currentUserId)
      .maybeSingle();
      
    if (membershipCheckError) {
      console.error('[Simple Join API] Error checking membership:', membershipCheckError);
    }
    
    // Add the student to the room if not already a member
    if (!existingMembership) {
      const { error: joinError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: room.room_id,
          student_id: currentUserId
        });
        
      if (joinError) {
        // Don't fail if it's just a unique violation (student is already in room)
        if (joinError.code === '23505') { // unique_violation
          console.log('[Simple Join API] Student already in room (unique constraint)');
        } else {
          console.error('[Simple Join API] Error adding student to room:', joinError);
          return NextResponse.json({ 
            error: 'Failed to add you to the classroom' 
          }, { status: 500 });
        }
      } else {
        console.log('[Simple Join API] Successfully added student to room');
      }
    } else {
      console.log('[Simple Join API] Student already in room, skipping insert');
    }
    
    // ALWAYS create a fresh session for reliability
    try {
      // Simplified session creation that works with modern Supabase versions
      console.log('[Simple Join API] Creating session for user:', currentUserId);
      
      let sessionData;
      let sessionError;
      
      try {
        // Create session using the Supabase admin API
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const result = await (supabaseAdmin.auth.admin as any).createSession({
          user_id: currentUserId,
          expires_in: SESSION_EXPIRY_SECONDS
        });
        
        sessionData = result.data;
        sessionError = result.error;
        
        console.log('[Simple Join API] Session creation result:', 
          sessionData ? 'success' : 'failed',
          sessionError ? `Error: ${sessionError.message}` : '');
      } catch (sessionCreationError) {
        console.error('[Simple Join API] Session creation failed:', sessionCreationError);
        
        // Create a fallback session that will use URL parameters as backup
        sessionData = {
          session: {
            access_token: `FALLBACK_${Date.now()}_${currentUserId.substring(0, 8)}`,
            refresh_token: `FALLBACK_R_${Date.now()}`,
            expires_at: Math.floor(Date.now() / 1000) + SESSION_EXPIRY_SECONDS,
            user: { id: currentUserId }
          }
        };
        
        console.log('[Simple Join API] Created fallback session object for URL parameter authentication');
      }
      
      if (sessionError) {
        console.error('[Simple Join API] Error creating session:', sessionError);
        return NextResponse.json({ 
          error: 'Failed to create user session. Please try again.' 
        }, { status: 500 });
      }
      
      if (!sessionData?.session) {
        console.error('[Simple Join API] Session created but no session data returned');
        return NextResponse.json({ 
          error: 'Server error: Session creation failed' 
        }, { status: 500 });
      }
      
      console.log('[Simple Join API] Session created successfully. Access token length:', 
        sessionData.session.access_token?.length || 0,
        'Refresh token length:',
        sessionData.session.refresh_token?.length || 0
      );
      
      // Return success with the session
      const response = NextResponse.json({ 
        success: true,
        message: 'Successfully joined room',
        roomId: room.room_id,
        userId: currentUserId,
        // Include a token ID client-side can use if cookies fail
        tokenId: sessionData.session.access_token?.substring(0, 10)
      });
      
      // Add the session cookie with the right settings
      if (sessionData.session) {
        try {
          // Extract the correct name from the URL
          const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
          let cookiePrefix = 'sb';
          
          try {
            if (supabaseUrl) {
              // Parse hostname from URL
              const url = new URL(supabaseUrl);
              const hostname = url.hostname;
              const projectRef = hostname.split('.')[0];
              console.log('[Simple Join API] Extracted project ref for cookie:', projectRef);
              
              if (projectRef) {
                cookiePrefix = 'sb-' + projectRef;
              }
            }
          } catch (urlError) {
            console.error('[Simple Join API] Error parsing Supabase URL:', urlError);
            // Fall back to default
            cookiePrefix = 'sb-auth';
          }
          
          console.log('[Simple Join API] Using cookie prefix:', cookiePrefix);
          
          // Set all cookie variants to maximize compatibility
          
          // 1. The standard Supabase cookie
          response.cookies.set(`${cookiePrefix}-auth-token`, JSON.stringify(sessionData.session), {
            path: '/',
            maxAge: 60 * 60 * 24 * 7, // 1 week
            sameSite: 'lax',
            httpOnly: false // Ensure client-side JavaScript can access it too
          });
          
          // 2. Legacy cookie name for compatibility
          response.cookies.set('supabase-auth-token', JSON.stringify(sessionData.session), {
            path: '/',
            maxAge: 60 * 60 * 24 * 7,
            sameSite: 'lax',
            httpOnly: false
          });
          
          // 3. Store some data in local storage via a special cookie
          response.cookies.set(`${cookiePrefix}-auth-event`, JSON.stringify({
            type: 'SIGNED_IN',
            session: sessionData.session
          }), {
            path: '/',
            maxAge: 100, // Very short-lived, just for the next page load
            sameSite: 'lax',
            httpOnly: false
          });
          
          // 4. Set a basic auth flag cookie for the client
          response.cookies.set('auth-user-id', currentUserId, {
            path: '/',
            maxAge: 60 * 60 * 24 * 7,
            sameSite: 'lax',
            httpOnly: false
          });
          
          console.log('[Simple Join API] Set auth cookies successfully');
        } catch (cookieError) {
          console.error('[Simple Join API] Error setting cookies:', cookieError);
          // Continue anyway - we'll return the session data in the JSON response
        }
      } else {
        console.warn('[Simple Join API] No session data to set in cookies');
      }
      
      return response;
    } catch (sessionCreationError) {
      console.error('[Simple Join API] Exception during session creation:', sessionCreationError);
      
      // For consistency, use the same approach as our main flow
      // but with clearer emergency indicators
      const fallbackResponse = NextResponse.json({ 
        success: true, // We'll count this as success for UX
        message: 'Successfully joined room (using alternative authentication)',
        roomId: room.room_id,
        userId: currentUserId,
        roomCode: room.room_code,
        // Add URL parameter-based auth flags
        directAccess: true,
        // Add a token that can be used in URL params for fallback auth
        tokenId: `DIR_${Date.now()}_${currentUserId.substring(0, 8)}`
      });
      
      // Set a consistent set of cookies for fallback auth
      const fallbackCookies = {
        'auth-user-id': currentUserId,
        'auth-student-name': student_name || 'Student',
        'auth-room-id': room.room_id,
        'current-room-code': room.room_code,
        'auth-direct-access': 'true'
      };
      
      // Set cookies with appropriate expiration (24 hours)
      Object.entries(fallbackCookies).forEach(([key, value]) => {
        fallbackResponse.cookies.set(key, String(value), { 
          path: '/', 
          maxAge: 60 * 60 * 24, // 24 hours
          sameSite: 'lax',
          httpOnly: false // Allow client JS to read
        });
      });
      
      console.log('[Simple Join API] Using fallback auth with URL parameters');
      
      return fallbackResponse;
    }
  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API POST /student/join-room] CATCH BLOCK Error:', 
      typedError?.message, 
      'Code:', typedError?.code, 
      'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to join room' },
      { status: 500 }
    );
  }
}// src/app/api/student/room-chatbot-data/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const chatbotId = searchParams.get('chatbotId');
    const userId = searchParams.get('userId');

    // Validate required parameters
    if (!roomId || !chatbotId) {
      return NextResponse.json({ 
        error: 'Missing required parameters: roomId and chatbotId are required' 
      }, { status: 400 });
    }

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    // Verify user has access to the room if userId is provided
    if (userId) {
      const { data: membership, error: membershipError } = await supabaseAdmin
        .from('room_memberships')
        .select('room_id')
        .eq('room_id', roomId)
        .eq('student_id', userId)
        .maybeSingle();

      if (membershipError) {
        console.error('[API GET /room-chatbot-data] Error checking membership:', membershipError);
        // Continue anyway, we'll create membership if needed
      }

      if (!membership) {
        console.log('[API GET /room-chatbot-data] User not in room, adding membership');
        // Add user to room
        const { error: insertError } = await supabaseAdmin
          .from('room_memberships')
          .insert({
            room_id: roomId,
            student_id: userId
          });

        if (insertError) {
          console.error('[API GET /room-chatbot-data] Error adding user to room:', insertError);
          // Continue anyway, try to get the data
        }
      }
    }

    // Get room data
    const { data: room, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('*')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      console.error('[API GET /room-chatbot-data] Error fetching room:', roomError);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Verify the chatbot is associated with this room
    const { data: roomChatbot, error: rcError } = await supabaseAdmin
      .from('room_chatbots')
      .select('chatbot_id')
      .eq('room_id', roomId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (rcError || !roomChatbot) {
      console.error('[API GET /room-chatbot-data] Chatbot not associated with room:', rcError);
      return NextResponse.json({ 
        error: 'Chatbot is not associated with this room' 
      }, { status: 404 });
    }

    // Get chatbot data
    const { data: chatbot, error: chatbotError } = await supabaseAdmin
      .from('chatbots')
      .select(`
        chatbot_id, 
        name, 
        description, 
        system_prompt, 
        model, 
        max_tokens, 
        temperature, 
        enable_rag, 
        bot_type, 
        assessment_criteria_text,
        welcome_message
      `)
      .eq('chatbot_id', chatbotId)
      .single();

    if (chatbotError || !chatbot) {
      console.error('[API GET /room-chatbot-data] Error fetching chatbot:', chatbotError);
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }

    // Return room and chatbot data
    return NextResponse.json({
      room: {
        room_id: room.room_id,
        room_name: room.room_name,
        room_code: room.room_code,
        teacher_id: room.teacher_id,
        school_id: room.school_id,
        is_active: room.is_active,
        created_at: room.created_at,
        updated_at: room.updated_at,
        room_chatbots: [{
          chatbots: chatbot
        }]
      },
      chatbot: chatbot
    });
  } catch (error) {
    console.error('[API GET /room-chatbot-data] Unexpected error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'An unknown error occurred' },
      { status: 500 }
    );
  }
}// src/app/api/student/room-chatbots/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    // Get room ID from query params
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const userId = searchParams.get('userId'); // Allow direct access mode

    if (!roomId) {
      return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
    }

    // Use admin client to ensure we can access the data regardless of auth state
    const supabaseAdmin = createAdminClient();
    
    // Get the current user ID (either from auth or from userId parameter)
    let studentId: string | null = null;
    
    if (userId) {
      // Direct access mode - validate the user exists
      const { data: userProfile } = await supabaseAdmin
        .from('profiles')
        .select('user_id, role')
        .eq('user_id', userId)
        .single();
        
      if (userProfile && userProfile.role === 'student') {
        studentId = userProfile.user_id;
        console.log('[API GET /student/room-chatbots] Using direct access user ID:', studentId);
      }
    } 
    
    if (!studentId) {
      // Try to get authenticated user
      const supabase = await createServerSupabaseClient();
      const { data: { user } } = await supabase.auth.getUser();
      
      if (user) {
        studentId = user.id;
        console.log('[API GET /student/room-chatbots] Using authenticated user ID:', studentId);
      }
    }
    
    if (!studentId) {
      return NextResponse.json({ error: 'Authenticated user or valid user ID required' }, { status: 401 });
    }

    // First, verify the room exists
    const { data: room, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('room_id, room_name, is_active')
      .eq('room_id', roomId)
      .single();

    if (roomError) {
      console.error('[API GET /student/room-chatbots] Room not found:', roomError);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Check if room is active
    if (!room.is_active) {
      console.warn('[API GET /student/room-chatbots] Room is inactive:', roomId);
      return NextResponse.json({ error: 'Room is inactive' }, { status: 403 });
    }
    
    // Verify student has access to this room
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();
      
    if (membershipError || !membership) {
      console.warn('[API GET /student/room-chatbots] Student not in room:', studentId, roomId);
      return NextResponse.json({ error: 'Access denied to this room' }, { status: 403 });
    }

    // Get student-specific chatbot instances for this room
    const { data: chatbotInstances, error: instancesError } = await supabaseAdmin
      .from('student_chatbot_instances')
      .select(`
        instance_id,
        chatbot_id,
        chatbots (
          chatbot_id,
          name,
          description,
          model,
          bot_type,
          welcome_message
        )
      `)
      .eq('room_id', roomId)
      .eq('student_id', studentId);

    if (instancesError) {
      console.error('[API GET /student/room-chatbots] Error fetching student chatbot instances:', instancesError);
      return NextResponse.json({ error: 'Error fetching chatbot data' }, { status: 500 });
    }

    // If no instances exist yet, create them now
    if (!chatbotInstances || chatbotInstances.length === 0) {
      console.log('[API GET /student/room-chatbots] No chatbot instances found, creating them now');
      
      // First, get all chatbots in the room
      const { data: roomChatbots, error: rcError } = await supabaseAdmin
        .from('room_chatbots')
        .select(`
          chatbot_id,
          chatbots (
            chatbot_id,
            name,
            description,
            model,
            bot_type,
            welcome_message
          )
        `)
        .eq('room_id', roomId);

      if (rcError || !roomChatbots || roomChatbots.length === 0) {
        console.warn('[API GET /student/room-chatbots] No chatbots found for room:', roomId);
        return NextResponse.json({ chatbots: [] });
      }
      
      // Create instances for each chatbot
      const instancesData = roomChatbots.map(rc => ({
        student_id: studentId,
        chatbot_id: rc.chatbot_id,
        room_id: roomId
      }));
      
      const { data: newInstances, error: createError } = await supabaseAdmin
        .from('student_chatbot_instances')
        .upsert(instancesData, { onConflict: 'student_id,chatbot_id,room_id' })
        .select(`
          instance_id,
          chatbot_id,
          chatbots (
            chatbot_id,
            name,
            description,
            model,
            bot_type,
            welcome_message
          )
        `);
        
      if (createError) {
        console.error('[API GET /student/room-chatbots] Error creating chatbot instances:', createError);
        return NextResponse.json({ error: 'Error creating student chatbot instances' }, { status: 500 });
      }
      
      // Format the response to match the expected structure
      const formattedChatbots = (newInstances || []).map(instance => {
        const chatbot = instance.chatbots as any; // Type assertion to avoid TypeScript errors
        return {
          instance_id: instance.instance_id,
          chatbot_id: instance.chatbot_id,
          name: chatbot?.name || 'Unknown Bot',
          description: chatbot?.description || '',
          model: chatbot?.model,
          bot_type: chatbot?.bot_type,
          welcome_message: chatbot?.welcome_message
        };
      });
      
      return NextResponse.json({ 
        chatbots: formattedChatbots,
        roomName: room.room_name
      });
    }
    
    // Format the response with instances
    const formattedChatbots = chatbotInstances.map(instance => {
      const chatbot = instance.chatbots as any; // Type assertion to avoid TypeScript errors
      return {
        instance_id: instance.instance_id, 
        chatbot_id: instance.chatbot_id,
        name: chatbot?.name || 'Unknown Bot',
        description: chatbot?.description || '',
        model: chatbot?.model,
        bot_type: chatbot?.bot_type,
        welcome_message: chatbot?.welcome_message
      };
    });

    return NextResponse.json({ 
      chatbots: formattedChatbots,
      roomName: room.room_name
    });
  } catch (error) {
    console.error('[API GET /student/room-chatbots] Unexpected error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'An unknown error occurred' },
      { status: 500 }
    );
  }
}// src/app/api/student/room-data/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { Chatbot } from '@/types/database.types';

export async function GET(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const userId = searchParams.get('userId');

    // Validate required parameters
    if (!roomId || !userId) {
      return NextResponse.json({ 
        error: 'Missing required parameters: roomId and userId are required' 
      }, { status: 400 });
    }

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    // Verify user exists
    const { data: userCheck, error: userError } = await supabaseAdmin.auth.admin.getUserById(userId);
    
    if (userError || !userCheck.user) {
      console.error('[API GET /student/room-data] User not found:', userId);
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }

    // Verify room exists
    const { data: room, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('*')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      console.error('[API GET /student/room-data] Room not found:', roomId);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Verify room membership or create it
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('student_id', userId)
      .maybeSingle();

    if (membershipError) {
      console.error('[API GET /student/room-data] Error checking membership:', membershipError);
    }

    if (!membership) {
      console.log('[API GET /student/room-data] User not in room, adding membership');
      const { error: insertError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: roomId,
          student_id: userId
        });

      if (insertError) {
        console.error('[API GET /student/room-data] Error adding user to room:', insertError);
        // Continue anyway to return room data
      }
    }

    // Get chatbots for the room
    const { data: roomChatbots, error: chatbotsRelationError } = await supabaseAdmin
      .from('room_chatbots')
      .select('chatbot_id')
      .eq('room_id', roomId);

    if (chatbotsRelationError) {
      console.error('[API GET /student/room-data] Error fetching room chatbots:', chatbotsRelationError);
      return NextResponse.json({ error: 'Error retrieving chatbots' }, { status: 500 });
    }

    // We need to get student-specific chatbot instances instead of just regular chatbots
    let chatbots: any[] = []; // Use any type to accommodate instance_id
    if (roomChatbots && roomChatbots.length > 0) {
      // First, let's check for student-specific instances
      const chatbotIds = roomChatbots.map(rc => rc.chatbot_id);
      
      // Check if student has instances for these chatbots
      const { data: chatbotInstances, error: instancesError } = await supabaseAdmin
        .from('student_chatbot_instances')
        .select(`
          instance_id,
          chatbot_id,
          chatbots (
            chatbot_id,
            name,
            description,
            model,
            bot_type,
            welcome_message
          )
        `)
        .eq('room_id', roomId)
        .eq('student_id', userId)
        .in('chatbot_id', chatbotIds);
        
      if (instancesError) {
        console.error('[API GET /student/room-data] Error fetching student chatbot instances:', instancesError);
      }
      
      // If instances already exist, use them
      if (chatbotInstances && chatbotInstances.length > 0) {
        console.log(`[API GET /student/room-data] Found ${chatbotInstances.length} existing instances for student ${userId}`);
        
        // Format the chatbots with instances
        chatbots = chatbotInstances.map(instance => {
          const chatbot = instance.chatbots as any; // Type assertion to avoid TypeScript errors
          return {
            instance_id: instance.instance_id,
            chatbot_id: instance.chatbot_id,
            name: chatbot?.name || 'Unknown Bot',
            description: chatbot?.description || '',
            model: chatbot?.model,
            bot_type: chatbot?.bot_type,
            welcome_message: chatbot?.welcome_message
          };
        });
      } else {
        // Need to create instances
        console.log(`[API GET /student/room-data] No instances found, getting chatbot details and creating instances`);
        
        // Get the chatbot details first
        const { data: chatbotsData, error: chatbotsError } = await supabaseAdmin
          .from('chatbots')
          .select('*')
          .in('chatbot_id', chatbotIds);
  
        if (chatbotsError) {
          console.error('[API GET /student/room-data] Error fetching chatbot details:', chatbotsError);
          return;
        }
        
        if (chatbotsData && chatbotsData.length > 0) {
          // Create instances for each chatbot
          const instancesData = chatbotsData.map(chatbot => ({
            student_id: userId,
            chatbot_id: chatbot.chatbot_id,
            room_id: roomId
          }));
          
          const { data: newInstances, error: createError } = await supabaseAdmin
            .from('student_chatbot_instances')
            .upsert(instancesData, { onConflict: 'student_id,chatbot_id,room_id' })
            .select(`
              instance_id,
              chatbot_id,
              chatbots (
                chatbot_id,
                name,
                description,
                model,
                bot_type,
                welcome_message
              )
            `);
            
          if (createError) {
            console.error('[API GET /student/room-data] Error creating chatbot instances:', createError);
          } else if (newInstances) {
            console.log(`[API GET /student/room-data] Created ${newInstances.length} new instances for student ${userId}`);
            
            // Format the chatbots with instances
            chatbots = newInstances.map(instance => {
              const chatbot = instance.chatbots as any; // Type assertion to avoid TypeScript errors
              return {
                instance_id: instance.instance_id,
                chatbot_id: instance.chatbot_id,
                name: chatbot?.name || 'Unknown Bot',
                description: chatbot?.description || '',
                model: chatbot?.model,
                bot_type: chatbot?.bot_type,
                welcome_message: chatbot?.welcome_message
              };
            });
          }
        }
      }
    }

    // Return room and chatbots data
    return NextResponse.json({
      room: {
        ...room,
        room_chatbots: []
      },
      chatbots: chatbots
    });
  } catch (error) {
    console.error('[API GET /student/room-data] General error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown server error' },
      { status: 500 }
    );
  }
}// src/app/api/student/verify-user/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    // Get user ID from query string
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');

    if (!userId) {
      return NextResponse.json({ 
        error: 'Missing required parameter: userId is required',
        valid: false
      }, { status: 400 });
    }

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    // Verify user exists
    try {
      const { data: userCheck, error: userError } = await supabaseAdmin.auth.admin.getUserById(userId);
      
      if (userError || !userCheck.user) {
        console.error('[API GET /verify-user] User not found:', userId, userError);
        return NextResponse.json({ 
          error: 'User not found',
          valid: false
        }, { status: 404 });
      }

      // Check for profile existence
      // We check for profile existence, but don't use its data directly
      const { error: profileError } = await supabaseAdmin
        .from('profiles')
        .select('user_id, role')
        .eq('user_id', userId)
        .single();

      if (profileError) {
        console.warn('[API GET /verify-user] Profile not found for user:', userId);
        
        // If user exists in auth but not profile, create profile
        if (userCheck.user.user_metadata?.full_name) {
          const { error: insertError } = await supabaseAdmin
            .from('profiles')
            .insert({
              user_id: userId,
              full_name: userCheck.user.user_metadata.full_name,
              email: userCheck.user.email || '',
              role: userCheck.user.user_metadata.role || 'student'
            });

          if (insertError) {
            console.error('[API GET /verify-user] Error creating profile:', insertError);
          } else {
            console.log('[API GET /verify-user] Created profile for user:', userId);
          }
        }
      }

      // User exists, check for session
      try {
        // Create a session for the user - handle different Supabase versions
        let sessionData;
        let sessionError;
        
        try {
          // Try the newer API with createSession
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          const result = await (supabaseAdmin.auth.admin as any).createSession({
            user_id: userId
          });
          sessionData = result.data;
          sessionError = result.error;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        } catch (createSessionError) {
          // Fall back to older signInWithUserId API
          try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const fallbackResult = await (supabaseAdmin.auth.admin as any).signInWithUserId(
              userId,
              { expiresIn: 604800 } // 7 days
            );
            sessionData = fallbackResult.data;
            sessionError = fallbackResult.error;
          } catch (signInError) {
            console.error('[API GET /verify-user] Both session creation methods failed:', signInError);
            sessionError = signInError;
          }
        }

        if (sessionError) {
          console.warn('[API GET /verify-user] Could not create session:', sessionError);
          // Continue anyway - we'll proceed with just the user ID
        } else if (sessionData?.session) {
          // Add session cookie
          const response = NextResponse.json({ valid: true, userId });
          
          // Set auth cookies
          const supabaseCookieName = 'sb-' + process.env.NEXT_PUBLIC_SUPABASE_URL?.split('//')[1]?.split('.')[0] + '-auth-token';
          
          response.cookies.set(supabaseCookieName, JSON.stringify(sessionData.session), {
            path: '/',
            maxAge: 60 * 60 * 24 * 7,
            sameSite: 'lax',
            httpOnly: false
          });
          
          return response;
        }
      } catch (sessionError) {
        console.error('[API GET /verify-user] Session error:', sessionError);
        // Continue without session
      }

      return NextResponse.json({ valid: true, userId });
    } catch (err) {
      console.error('[API GET /verify-user] Error checking user:', err);
      return NextResponse.json({ 
        error: 'Failed to verify user',
        valid: false
      }, { status: 500 });
    }
  } catch (error) {
    console.error('[API GET /verify-user] Unexpected error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'An unknown error occurred',
        valid: false
      },
      { status: 500 }
    );
  }
}// src/app/api/student/repair-profile/route.ts
import { NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { createServerSupabaseClient } from '@/lib/supabase/server';

/**
 * Repair student profile endpoint
 * 
 * This endpoint ensures that student profiles exist and have the correct role.
 * It can be called as a fallback mechanism when normal triggers fail.
 */
export async function POST(request: Request) {
  console.log('[API POST /student/repair-profile] Received request.');

  try {
    // Create admin client to bypass RLS
    const supabaseAdmin = createAdminClient();
    if (!supabaseAdmin) {
      console.error('[Student Profile Repair] Failed to create admin client');
      return NextResponse.json({ 
        error: 'Server configuration error' 
      }, { status: 500 });
    }

    // Get regular client for user session
    const supabase = await createServerSupabaseClient();
    
    // Parse request body
    const requestData = await request.json().catch(() => ({}));
    const { userId, fullName, email, isAnonymous } = requestData;

    // If no userId provided, try to get the current user
    let userIdToRepair = userId;
    if (!userIdToRepair) {
      const { data: { session } } = await supabase.auth.getSession();
      userIdToRepair = session?.user?.id;
      
      if (!userIdToRepair) {
        return NextResponse.json({ 
          error: 'User ID is required or user must be authenticated' 
        }, { status: 400 });
      }
    }

    console.log(`[Student Profile Repair] Repairing profile for user: ${userIdToRepair}`);

    // Get user details if available
    let userEmail = email;
    let userName = fullName;
    
    if (!userEmail || !userName) {
      try {
        // Get user data from Supabase Auth
        const { data: userData, error: userError } = await supabaseAdmin.auth.admin.getUserById(userIdToRepair);
        
        if (!userError && userData?.user) {
          userEmail = userEmail || userData.user.email || `${userIdToRepair}@example.com`;
          userName = userName || userData.user.user_metadata?.full_name || 'Student';
        }
      } catch (error) {
        console.error('[Student Profile Repair] Error fetching user details:', error);
        // Continue anyway with defaults
      }
    }

    // Ensure we have values
    userEmail = userEmail || `${userIdToRepair}@example.com`;
    userName = userName || 'Student';

    // First check if profile exists
    const { data: existingProfile } = await supabaseAdmin
      .from('profiles')
      .select('*')
      .eq('user_id', userIdToRepair)
      .maybeSingle();

    let result;
    
    if (existingProfile) {
      // Update existing profile
      console.log(`[Student Profile Repair] Updating existing profile for: ${userIdToRepair}`);
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const updateData: any = {
        updated_at: new Date().toISOString()
      };
      
      // Only update fields that were provided or needed
      if (userEmail && existingProfile.email !== userEmail) {
        updateData['email'] = userEmail;
      }
      
      if (userName && existingProfile.full_name !== userName) {
        updateData['full_name'] = userName;
      }
      
      // Always ensure role is student for this endpoint
      if (existingProfile.role !== 'student') {
        updateData['role'] = 'student';
      }
      
      // Set anonymous flag if provided
      if (isAnonymous !== undefined && existingProfile.is_anonymous !== isAnonymous) {
        updateData['is_anonymous'] = isAnonymous;
      }
      
      // Only update if there are changes
      if (Object.keys(updateData).length > 1) { // More than just updated_at
        const { error: updateError } = await supabaseAdmin
          .from('profiles')
          .update(updateData)
          .eq('user_id', userIdToRepair);
          
        if (updateError) {
          console.error('[Student Profile Repair] Error updating profile:', updateError);
          return NextResponse.json({ 
            error: 'Failed to update profile' 
          }, { status: 500 });
        }
        
        result = { action: 'updated', userId: userIdToRepair };
      } else {
        result = { action: 'none', message: 'No changes needed', userId: userIdToRepair };
      }
    } else {
      // Create new profile
      console.log(`[Student Profile Repair] Creating new profile for: ${userIdToRepair}`);
      
      const { error: createError } = await supabaseAdmin
        .from('profiles')
        .insert({
          user_id: userIdToRepair,
          email: userEmail,
          full_name: userName,
          role: 'student',
          is_anonymous: isAnonymous === undefined ? false : isAnonymous,
          created_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        });
        
      if (createError) {
        console.error('[Student Profile Repair] Error creating profile:', createError);
        return NextResponse.json({ 
          error: 'Failed to create profile' 
        }, { status: 500 });
      }
      
      result = { action: 'created', userId: userIdToRepair };
    }

    console.log(`[Student Profile Repair] Successfully repaired profile for: ${userIdToRepair}`);
    return NextResponse.json({ 
      success: true,
      result: result
    });
  } catch (error) {
    console.error('[Student Profile Repair] Unhandled error:', error);
    return NextResponse.json({ 
      error: error instanceof Error ? error.message : 'Unknown error occurred' 
    }, { status: 500 });
  }
}// src/app/api/student/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

// Define proper interfaces for the exact Supabase query structure
interface ChatbotData {
  chatbot_id: string;
  name: string;
  description: string | null;
}

interface RoomChatbotRelation {
  chatbots: ChatbotData;
}

interface RoomData {
  room_id: string;
  room_name: string;
  room_code: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: RoomChatbotRelation[] | null;
}

interface MembershipData {
  joined_at: string;
  rooms: RoomData | null;
}

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a student
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'student') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Fetch rooms the student has joined with chatbot info - MODIFIED QUERY
    const { data: membershipData, error } = await supabase
      .from('room_memberships')
      .select(`
        joined_at,
        rooms!inner(
          room_id,
          room_name,
          room_code,
          is_active,
          created_at,
          room_chatbots(
            chatbots(
              chatbot_id,
              name,
              description
            )
          )
        )
      `)
      .eq('student_id', user.id);

    if (error) {
      throw error;
    }

    // Use unknown first, then cast to our type
    const typedMembershipData = membershipData as unknown as MembershipData[];

    // Transform the data to match expected format
    const rooms = typedMembershipData?.map(membership => {
      const room = membership.rooms;
      if (!room) return null;
      
      // Extract chatbots from room_chatbots
      const chatbots: ChatbotData[] = [];
      if (room.room_chatbots && room.room_chatbots.length > 0) {
        room.room_chatbots.forEach((rc: RoomChatbotRelation) => {
          if (rc.chatbots) {
            chatbots.push(rc.chatbots);
          }
        });
      }
      
      return {
        ...room,
        joined_at: membership.joined_at,
        chatbots
      };
    }).filter((room): room is NonNullable<typeof room> => room !== null);

    return NextResponse.json(rooms || []);
  } catch (error) {
    console.error('Error fetching student rooms:', error);
    return NextResponse.json(
      { error: 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}// src/app/api/student/assessment-detail/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { 
    StudentAssessment, 
    ChatMessage as DbChatMessage
} from '@/types/database.types';

// StudentDetailedAssessmentResponse interface remains the same
export interface StudentDetailedAssessmentResponse extends StudentAssessment {
    chatbot_name?: string | null;
    room_name?: string | null;
    assessed_conversation?: DbChatMessage[];
}

export async function GET(request: NextRequest) { // Removed the second 'params' argument
  const { searchParams } = new URL(request.url);
  const assessmentId = searchParams.get('assessmentId'); // Get assessmentId from query params

  console.log(`[API GET /student/assessment-detail] Received request for assessmentId: ${assessmentId}`);

  if (!assessmentId) {
    return NextResponse.json({ error: 'Assessment ID query parameter is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn(`[API GET /student/assessment-detail] Not authenticated:`, authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: assessment, error: assessmentError } = await supabase
      .from('student_assessments')
      .select('*')
      .eq('assessment_id', assessmentId)
      .eq('student_id', user.id)
      .single();

    if (assessmentError || !assessment) {
      console.warn(`[API GET /student/assessment-detail] Assessment ${assessmentId} not found or student ${user.id} not authorized:`, assessmentError?.message);
      return NextResponse.json({ error: 'Assessment not found or you are not authorized to view it.' }, { status: 404 });
    }
    console.log(`[API GET /student/assessment-detail] Assessment ${assessmentId} found and student ${user.id} authorized.`);

    let chatbotName: string | null = null;
    if (assessment.chatbot_id) {
      const { data: chatbotData } = await supabase
        .from('chatbots')
        .select('name')
        .eq('chatbot_id', assessment.chatbot_id)
        .single();
      chatbotName = chatbotData?.name || 'Assessment Bot';
    }

    let roomName: string | null = null;
    if (assessment.room_id && !assessment.room_id.startsWith('teacher_test_room_')) {
        const { data: roomData } = await supabase
            .from('rooms')
            .select('room_name')
            .eq('room_id', assessment.room_id)
            .single();
        roomName = roomData?.room_name || null;
    } else if (assessment.room_id && assessment.room_id.startsWith('teacher_test_room_')) {
        roomName = 'Teacher Test Chat';
    }

    let assessedConversation: DbChatMessage[] = [];
    if (assessment.assessed_message_ids && Array.isArray(assessment.assessed_message_ids) && assessment.assessed_message_ids.length > 0) {
      const { data: messagesData, error: messagesError } = await supabase
        .from('chat_messages')
        .select('*')
        .in('message_id', assessment.assessed_message_ids)
        .order('created_at', { ascending: true });

      if (messagesError) {
        console.error(`[API GET /student/assessment-detail] Error fetching assessed conversation for ${assessmentId}:`, messagesError.message);
      } else {
        assessedConversation = (messagesData || []) as DbChatMessage[];
      }
    }
    console.log(`[API GET /student/assessment-detail] Fetched ${assessedConversation.length} messages for ${assessmentId}.`);

    const responseData: StudentDetailedAssessmentResponse = {
      ...(assessment as StudentAssessment),
      chatbot_name: chatbotName,
      room_name: roomName,
      assessed_conversation: assessedConversation,
    };
    
    console.log(`[API GET /student/assessment-detail] Successfully prepared data for ${assessmentId}. Returning response.`);
    return NextResponse.json(responseData);

  } catch (error) {
    const typedError = error as Error;
    console.error(`[API GET /student/assessment-detail] CATCH BLOCK Error for ${assessmentId}:`, typedError.message);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch assessment details' },
      { status: 500 }
    );
  }
}// src/app/api/student/verify-membership/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const userId = searchParams.get('userId');

    // Validate required parameters
    if (!roomId || !userId) {
      return NextResponse.json({ 
        error: 'Missing required parameters: roomId and userId are required' 
      }, { status: 400 });
    }

    // Use admin client to check membership reliably
    const supabaseAdmin = createAdminClient();

    // Verify user exists
    const { data: userCheck, error: userError } = await supabaseAdmin.auth.admin.getUserById(userId);
    
    if (userError || !userCheck.user) {
      console.error('[API GET /verify-membership] User not found:', userId, userError);
      return NextResponse.json({ error: 'User not found', isMember: false }, { status: 404 });
    }

    // Verify room exists
    const { data: room, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('room_id, is_active')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      console.error('[API GET /verify-membership] Room not found:', roomId, roomError);
      return NextResponse.json({ error: 'Room not found', isMember: false }, { status: 404 });
    }

    if (!room.is_active) {
      return NextResponse.json({ error: 'Room is inactive', isMember: false }, { status: 403 });
    }

    // Check if user is a member of the room
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('student_id', userId)
      .maybeSingle();

    if (membershipError) {
      console.error('[API GET /verify-membership] Error checking membership:', membershipError);
      return NextResponse.json({ 
        error: 'Error checking membership', 
        isMember: false 
      }, { status: 500 });
    }

    const isMember = !!membership;

    // If not a member but the user exists and the room is active, add them
    if (!isMember) {
      console.log('[API GET /verify-membership] User not a member, adding membership');
      const { error: insertError } = await supabaseAdmin
        .from('room_memberships')
        .insert({
          room_id: roomId,
          student_id: userId
        });

      if (insertError) {
        console.error('[API GET /verify-membership] Error adding membership:', insertError);
        return NextResponse.json({ 
          error: 'Failed to add user to room', 
          isMember: false 
        }, { status: 500 });
      }

      // Successfully added
      return NextResponse.json({ 
        isMember: true, 
        message: 'User successfully added to room' 
      });
    }

    // Already a member
    return NextResponse.json({ 
      isMember: true, 
      message: 'User is already a member of this room' 
    });
  } catch (error) {
    console.error('[API GET /verify-membership] Unexpected error:', error);
    return NextResponse.json(
      { 
        error: error instanceof Error ? error.message : 'An unknown error occurred',
        isMember: false 
      },
      { status: 500 }
    );
  }
}// src/app/api/student/dashboard-data/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { 
    Room, 
    Chatbot, 
    StudentAssessment,
    Profile
} from '@/types/database.types';

// --- Interfaces for API Response ---

interface JoinedRoomForDashboard extends Pick<Room, 'room_id' | 'room_name' | 'room_code'> {
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type'>[]; // Added bot_type
  joined_at: string;
}

interface AssessmentSummaryForDashboard extends Pick<StudentAssessment, 'assessment_id' | 'ai_grade_raw' | 'ai_feedback_student' | 'assessed_at' | 'status'> {
  room_id: string;
  room_name: string | null;
  chatbot_id: string;
  chatbot_name: string | null;
}

interface StudentDashboardDataResponse {
  joinedRooms: JoinedRoomForDashboard[];
  recentAssessments: AssessmentSummaryForDashboard[];
  studentProfile: Pick<Profile, 'user_id' | 'full_name' | 'email' | 'pin_code' | 'username'> | null;
}

// Helper type for Supabase query for joined rooms
interface MembershipWithRoomAndChatbots {
  joined_at: string;
  rooms: { // Nullable if inner join fails or no room
    room_id: string;
    room_name: string;
    room_code: string;
    is_active: boolean;
    created_at: string;
    room_chatbots: { // Nullable array
      chatbots: { // Nullable chatbot
        chatbot_id: string;
        name: string;
        description: string | null;
        bot_type: Chatbot['bot_type']; // Ensure bot_type is selected
      } | null;
    }[] | null;
  } | null;
}


export async function GET(request: NextRequest) {
  console.log('[API GET /student/dashboard-data] Received request.');
  
  // Check for direct login flag
  const url = new URL(request.url);
  const isDirect = url.searchParams.get('direct') === '1';
  const hasTimestamp = url.searchParams.has('_t');
  
  // Check for our special bypass token cookie
  const bypassToken = request.cookies.get('student-pin-auth-bypass')?.value;
  const hasBypassToken = !!bypassToken;
  
  // Log all cookies for debugging
  const allCookies = request.cookies.getAll();
  console.log('[API GET /student/dashboard-data] Available cookies:', 
    allCookies.map(c => c.name));
  
  // Try to get user ID from bypass token if available
  let bypassUserId = null;
  if (bypassToken && bypassToken.startsWith('BYPASS_')) {
    bypassUserId = bypassToken.split('_')[1];
    console.log(`[API GET /student/dashboard-data] Found bypass token with user ID: ${bypassUserId}`);
  }
  
  // Extract user ID from the URL
  const urlUserId = url.searchParams.get('user_id');
  
  // Check if we have a valid bypass session
  const isDirectBypass = isDirect && (hasTimestamp || hasBypassToken) && (bypassUserId || urlUserId);
  
  try {
    const supabase = await createServerSupabaseClient();
    
    // We'll still try to get the user/session for normal flow
    let user = null;
    let authError = null;
    
    if (!isDirectBypass) {
      // Try normal auth flow
      const authResult = await supabase.auth.getUser();
      user = authResult.data.user;
      authError = authResult.error;
      
      // Also get session info for logging
      const sessionResult = await supabase.auth.getSession();
      
      console.log('[API GET /student/dashboard-data] Auth check:', { 
        hasUser: !!user, 
        hasSession: !!sessionResult.data.session,
        isDirect: isDirect,
        hasTimestamp: hasTimestamp,
        hasBypassToken: hasBypassToken,
        userError: authError?.message,
        sessionError: sessionResult.error?.message
      });
      
      // Check for normal auth failure
      if (authError || !user) {
        console.warn('[API GET /student/dashboard-data] Normal auth failed:', 
          authError?.message || 'No valid user');
          
        // If we don't have a bypass, return auth error
        if (!isDirectBypass) {
          return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }
      }
    } else {
      console.log('[API GET /student/dashboard-data] Using direct bypass authentication');
    }

    // Get the effective user ID from various sources (in order of preference)
    // 1. URL param (most reliable for bypass)
    // 2. Bypass token 
    // 3. Normal auth user
    const effectiveUserId = urlUserId || bypassUserId || user?.id;
    const pinVerified = url.searchParams.get('pin_verified') === 'true';
    
    if (!effectiveUserId) {
      console.error('[API GET /student/dashboard-data] No effective user ID available');
      return NextResponse.json({ error: 'User ID not available' }, { status: 400 });
    }
    
    console.log(`[API GET /student/dashboard-data] Using effective user ID: ${effectiveUserId}`);
    console.log(`[API GET /student/dashboard-data] PIN verification status: ${pinVerified ? 'Verified' : 'Unknown'}`);
    
    // Verify user is a student
    try {
      // Let's try to be extra careful about database connections
      const { data: profile, error: profileError } = await supabase
        .from('profiles')
        .select('user_id, role, full_name, email') // Fetch full_name and email too
        .eq('user_id', effectiveUserId)
        .single();

    if (profileError || !profile) {
      console.warn(`[API GET /student/dashboard-data] Profile error for user ${effectiveUserId}:`, profileError?.message);
      
      // SPECIAL CASE: If PIN was verified but profile lookup failed, we trust the verification
      // and create a very basic temporary profile to show the dashboard
      if (pinVerified || (isDirect && hasTimestamp)) {
        console.log(`[API GET /student/dashboard-data] Creating a basic profile for PIN-verified user ${effectiveUserId}`);
        
        // Generate a dummy profile since we already verified the PIN but DB lookup failed
        const tempProfile = {
          user_id: effectiveUserId,
          role: 'student',
          full_name: 'Student',
          email: null
        };
        
        return NextResponse.json({
          studentProfile: tempProfile,
          joinedRooms: [],
          recentAssessments: [],
          message: 'Using temporary profile for authenticated student'
        });
      }
      
      // If not PIN verified, try regular profile creation flow
      if (isDirect && hasTimestamp) {
        console.log(`[API GET /student/dashboard-data] Direct login - trying to create profile for ${effectiveUserId}`);
        
        try {
          // Create a basic profile with PIN code and username
          const username = `student-${Date.now()}`;
          const pinCode = Math.floor(1000 + Math.random() * 9000).toString(); // 4-digit PIN
          
          // Try to create a basic profile directly (don't try to use auth.admin which is failing)
          const { error: insertError } = await supabase
            .from('profiles')
            .insert({
              user_id: effectiveUserId,
              role: 'student',
              full_name: 'Student',
              pin_code: pinCode,
              username: username,
              last_pin_change: new Date().toISOString(),
              pin_change_by: 'system'
            });
            
          if (insertError) {
            console.error('[API GET /student/dashboard-data] Failed to create profile:', insertError);
          } else {
            console.log('[API GET /student/dashboard-data] Successfully created profile with PIN:', pinCode);
            
            // Try to get the profile again
            const { data: newProfile } = await supabase
              .from('profiles')
              .select('user_id, role, full_name, email')
              .eq('user_id', effectiveUserId)
              .single();
              
            if (newProfile) {
              console.log('[API GET /student/dashboard-data] Successfully retrieved new profile');
              return NextResponse.json({
                studentProfile: newProfile,
                joinedRooms: [],
                recentAssessments: [],
                message: 'New profile created' 
              });
            }
          }
        } catch (err) {
          console.error('[API GET /student/dashboard-data] Error creating profile:', err);
        }
      }
      
      // If we still don't have a profile, return an error
      return NextResponse.json({ error: 'User profile not found.' }, { status: 403 });
    }
    
    if (profile.role !== 'student') {
      console.warn(`[API GET /student/dashboard-data] User ${effectiveUserId} is not a student. Role: ${profile.role}`);
      return NextResponse.json({ error: 'Not authorized (user is not a student)' }, { status: 403 });
    }
    } catch (err) {
      console.error('[API GET /student/dashboard-data] Error checking user profile:', err);
      
      // If profile check fails but PIN was verified, create a temporary profile
      if (pinVerified) {
        const tempProfile = {
          user_id: effectiveUserId,
          role: 'student',
          full_name: 'Student',
          email: null
        };
        
        return NextResponse.json({
          studentProfile: tempProfile,
          joinedRooms: [],
          recentAssessments: [],
          message: 'Using temporary profile after exception'
        });
      }
      
      return NextResponse.json({ error: 'Error checking user profile' }, { status: 500 });
    }
    
    console.log(`[API GET /student/dashboard-data] User ${effectiveUserId} authenticated as student.`);
    
    // Since we've already verified the user is a student,
    // let's fetch the profile data again to ensure we have it for this scope
    // Include pin_code and username in the selection
    const { data: userProfile } = await supabase
      .from('profiles')
      .select('user_id, full_name, email, pin_code, username')
      .eq('user_id', effectiveUserId)
      .single();
      
    // Extended profile info to include pin_code and username
    const studentProfileInfo = {
        user_id: effectiveUserId, // We already have validated effectiveUserId
        full_name: userProfile?.full_name || 'Student',
        email: userProfile?.email || '',
        pin_code: userProfile?.pin_code || null,
        username: userProfile?.username || null
    };

    // Simplify our approach - just use the admin client directly for reliability
    // Create an admin client to bypass RLS policies that might be causing issues
    const supabaseAdmin = createAdminClient();
    console.log('[API GET /student/dashboard-data] Using admin client to fetch rooms');
    
    // Fetch joined rooms with admin client
    const { data: membershipsData, error: roomsError } = await supabaseAdmin
      .from('room_memberships')
      .select(`
        joined_at,
        rooms(
          room_id,
          room_name,
          room_code,
          is_active,
          created_at,
          room_chatbots(
            chatbots(
              chatbot_id,
              name,
              description,
              bot_type
            )
          )
        )
      `)
      .eq('student_id', effectiveUserId)
      .eq('rooms.is_active', true); // Only fetch active rooms
      
    console.log(`[API GET /student/dashboard-data] Admin query returned ${membershipsData?.length || 0} rooms`);

    if (roomsError) {
      console.error('[API GET /student/dashboard-data] Error fetching student rooms:', roomsError.message);
      // Don't fail entirely, dashboard might still show assessments
    }

    // Process the room memberships with improved error handling
    console.log('[API GET /student/dashboard-data] Processing room memberships data');
    const typedMembershipsData = (membershipsData || []) as unknown as MembershipWithRoomAndChatbots[];
    
    const joinedRooms: JoinedRoomForDashboard[] = [];
    
    // Safely process each membership
    typedMembershipsData.forEach(membership => {
      try {
        const room = membership.rooms;
        if (!room || !room.room_id) return; // Skip invalid rooms
        
        // Make sure room is active (double-check)
        if (room.is_active !== true) return;
        
        const chatbotsInRoom: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type'>[] = [];
        
        // Process chatbots with error handling
        if (room.room_chatbots && Array.isArray(room.room_chatbots)) {
          room.room_chatbots.forEach(rc => {
            try {
              if (rc && rc.chatbots) {
                chatbotsInRoom.push({
                  chatbot_id: rc.chatbots.chatbot_id,
                  name: rc.chatbots.name || 'Unnamed Bot',
                  bot_type: rc.chatbots.bot_type || 'learning',
                });
              }
            } catch (chatbotError) {
              console.warn('[API GET /student/dashboard-data] Error processing chatbot:', chatbotError);
              // Continue to next chatbot
            }
          });
        }
        
        // Add this room to the result
        joinedRooms.push({
          room_id: room.room_id,
          room_name: room.room_name || 'Unnamed Room',
          room_code: room.room_code || '???',
          chatbots: chatbotsInRoom,
          joined_at: membership.joined_at || new Date().toISOString(),
        });
      } catch (roomError) {
        console.warn('[API GET /student/dashboard-data] Error processing room:', roomError);
        // Continue to next room
      }
    });
    
    console.log(`[API GET /student/dashboard-data] Processed ${joinedRooms.length} active rooms for student`);
    console.log(`[API GET /student/dashboard-data] Fetched ${joinedRooms.length} joined active rooms.`);


    // 2. Fetch recent assessments (e.g., last 5-10 completed or reviewed by teacher)
    // For assessments, we need joins to get room_name and chatbot_name
    const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey"; // FK from student_assessments to chatbots
                                                                        // If room_id in student_assessments is TEXT and not a direct FK, we'll need a two-step fetch or careful query

    // Check if room_id in student_assessments is a direct FK to rooms.room_id
    // For now, assuming student_assessments.room_id is TEXT and might be 'teacher_test_room_...',
    // so a direct join on rooms might only work for actual UUID room_ids.
    // Let's fetch assessments and then enrich with room names.

    // Simply use admin client for assessments as well
    // Continue using the same admin client from above
    const { data: assessmentsData, error: assessmentsError } = await supabaseAdmin
      .from('student_assessments')
      .select(`
        assessment_id,
        room_id, 
        chatbot_id,
        ai_grade_raw,
        ai_feedback_student,
        assessed_at,
        status,
        chatbot:chatbots${chatbotForeignKeyHint}(name) 
      `)
      .eq('student_id', effectiveUserId)
      .order('assessed_at', { ascending: false })
      .limit(10); // Limit to recent ones
      
    console.log(`[API GET /student/dashboard-data] Admin query returned ${assessmentsData?.length || 0} assessments`);

    if (assessmentsError) {
      console.error('[API GET /student/dashboard-data] Error fetching student assessments:', assessmentsError.message);
      // Don't fail entirely
    }
    
    let recentAssessments: AssessmentSummaryForDashboard[] = [];
    if (assessmentsData && assessmentsData.length > 0) {
        const roomIdsFromAssessments = [...new Set(
            assessmentsData.map(a => a.room_id).filter(id => id && !id.startsWith('teacher_test_room_'))
        )] as string[];

        const roomNamesMap: Map<string, string> = new Map();
        if (roomIdsFromAssessments.length > 0) {
            // Use the admin client consistently for room names as well
            const { data: roomNameData, error: roomNameError } = await supabaseAdmin
                .from('rooms')
                .select('room_id, room_name')
                .in('room_id', roomIdsFromAssessments);
            if (roomNameError) {
                console.warn('[API GET /student/dashboard-data] Error fetching room names for assessments:', roomNameError.message);
            } else {
                roomNameData?.forEach(r => roomNamesMap.set(r.room_id, r.room_name));
            }
        }

        recentAssessments = assessmentsData.map(asmnt => {
            const chatbotData = asmnt.chatbot as { name?: string | null } | null;
            let roomNameDisplay = 'N/A';
            if (asmnt.room_id) {
                if (asmnt.room_id.startsWith('teacher_test_room_')) {
                    // This case should ideally not appear for student-facing dashboard
                    // but handled just in case tests by teachers appear in their own 'student_assessments'
                    roomNameDisplay = 'Test Environment'; 
                } else {
                    roomNameDisplay = roomNamesMap.get(asmnt.room_id) || `Room ID: ${asmnt.room_id.substring(0,6)}`;
                }
            }

            return {
                assessment_id: asmnt.assessment_id,
                room_id: asmnt.room_id,
                room_name: roomNameDisplay,
                chatbot_id: asmnt.chatbot_id,
                chatbot_name: chatbotData?.name || 'Assessment Bot',
                ai_grade_raw: asmnt.ai_grade_raw,
                ai_feedback_student: asmnt.ai_feedback_student,
                assessed_at: asmnt.assessed_at,
                status: asmnt.status
            };
        });
    }
    console.log(`[API GET /student/dashboard-data] Fetched ${recentAssessments.length} recent assessments.`);


    const responsePayload: StudentDashboardDataResponse = {
      studentProfile: studentProfileInfo,
      joinedRooms,
      recentAssessments,
    };

    console.log('[API GET /student/dashboard-data] Successfully prepared data. Returning response.');
    return NextResponse.json(responsePayload);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string };
    console.error('[API GET /student/dashboard-data] CATCH BLOCK Error:', typedError.message, 'Code:', typedError.code, 'Details:', typedError.details);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch student dashboard data' },
      { status: 500 }
    );
  }
}// src/app/api/student/verify-room-code/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { isValidRoomCode } from '@/lib/utils/room-codes';

export async function GET(request: NextRequest) {
  try {
    // Get room code from query params
    const { searchParams } = new URL(request.url);
    const roomCode = searchParams.get('code');

    if (!roomCode) {
      return NextResponse.json({ error: 'Room code is required' }, { status: 400 });
    }

    const formattedCode = roomCode.toUpperCase();

    // Validate the room code format
    if (!isValidRoomCode(formattedCode)) {
      return NextResponse.json({ 
        error: 'Invalid room code format. Codes should be 6 characters (letters and numbers).' 
      }, { status: 400 });
    }

    // Use admin client to ensure we can access the data regardless of auth state
    const supabaseAdmin = createAdminClient();

    // Verify the room exists
    console.log('[API GET /verify-room-code] Looking up room code:', formattedCode);
    const { data: room, error: roomError } = await supabaseAdmin
      .from('rooms')
      .select('room_id, room_name, is_active')
      .eq('room_code', formattedCode)
      .single();

    if (roomError) {
      console.error('[API GET /verify-room-code] Error fetching room:', roomError);
      if (roomError.code === 'PGRST116') {
        return NextResponse.json({ error: 'Room not found' }, { status: 404 });
      }
      return NextResponse.json({ error: 'Database error: ' + roomError.message }, { status: 500 });
    }

    if (!room) {
      console.warn('[API GET /verify-room-code] No room found for code:', formattedCode);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Get chatbots for this room
    const { data: roomChatbots, error: chatbotError } = await supabaseAdmin
      .from('room_chatbots')
      .select('chatbot_id')
      .eq('room_id', room.room_id);

    // Return the room info and available chatbots
    return NextResponse.json({
      room: {
        room_id: room.room_id,
        room_name: room.room_name,
        is_active: room.is_active
      },
      hasChatbots: !chatbotError && roomChatbots && roomChatbots.length > 0,
      chatbotCount: !chatbotError && roomChatbots ? roomChatbots.length : 0
    });
  } catch (error) {
    console.error('[API GET /verify-room-code] Unexpected error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'An unknown error occurred' },
      { status: 500 }
    );
  }
}// src/app/api/student/safety-message/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    // Get parameters from query string
    const { searchParams } = new URL(request.url);
    const messageId = searchParams.get('messageId');
    const userId = searchParams.get('userId');
    const roomId = searchParams.get('roomId');

    // Different query modes:
    // 1. By messageId: Get a specific safety message
    // 2. By userId + roomId: Get the latest safety message for a user in a room

    // Use admin client to bypass RLS
    const supabaseAdmin = createAdminClient();

    let message;
    
    if (messageId && userId) {
      // Mode 1: Get specific message by ID
      console.log(`[Safety Message API] Fetching specific safety message: ${messageId} for user ${userId}`);
      
      const { data, error } = await supabaseAdmin
        .from('chat_messages')
        .select('*')
        .eq('message_id', messageId)
        .eq('user_id', userId)
        .eq('role', 'system')
        .single();

      if (error || !data) {
        console.error('[Safety Message API] Error fetching message:', error);
        return NextResponse.json({ 
          error: 'Message not found or access denied',
          details: error?.message 
        }, { status: 404 });
      }
      
      message = data;
    } 
    else if (userId && roomId) {
      // Mode 2: Get latest safety message for user in room
      console.log(`[Safety Message API] Fetching latest safety message for user ${userId} in room ${roomId}`);
      
      const { data, error } = await supabaseAdmin
        .from('chat_messages')
        .select('*')
        .eq('user_id', userId)
        .eq('room_id', roomId)
        .eq('role', 'system')
        .filter('metadata->isSystemSafetyResponse', 'eq', true)
        .order('created_at', { ascending: false })
        .limit(1)
        .maybeSingle(); // Use maybeSingle to avoid throwing an error if no results

      if (error) {
        console.error('[Safety Message API] Error fetching safety message:', error);
        return NextResponse.json({ 
          error: 'Error fetching safety message',
          details: error?.message 
        }, { status: 500 });
      }
      
      // No safety message found is a valid result (returns null)
      message = data;
    }
    else {
      return NextResponse.json({ 
        error: 'Missing required parameters: either messageId+userId OR userId+roomId are required' 
      }, { status: 400 });
    }

    // If no message found, return empty result (not an error)
    if (!message) {
      console.log('[Safety Message API] No safety message found');
      return NextResponse.json({ 
        message: null,
        found: false
      });
    }

    // Make sure this is a safety message by checking metadata
    if (!message.metadata?.isSystemSafetyResponse) {
      console.warn('[Safety Message API] Requested message is not a safety message:', message.message_id);
      return NextResponse.json({ message: null, found: false, reason: 'Not a safety message' });
    }

    // Extract key information for debugging - more detailed logging
    console.log('[Safety Message API] Successfully retrieved safety message:', {
      messageId: message.message_id,
      content: message.content.substring(0, 100) + '...', // Show start of content
      // Country code info
      countryCode: message.metadata?.countryCode,
      effectiveCountryCode: message.metadata?.effectiveCountryCode,
      displayCountryCode: message.metadata?.displayCountryCode,
      rawCountryCode: message.metadata?.rawCountryCode,
      // Helpline info
      helplines: message.metadata?.helplines,
      helplineCount: message.metadata?.helplineCount || 
                    (message.metadata?.helplines ? message.metadata.helplines.split(',').length : 0),
      // Check for critical markers in content
      hasHelplineMarkers: message.content.includes('===== MANDATORY HELPLINES') && 
                         message.content.includes('===== END OF MANDATORY HELPLINES'),
      // Version info                   
      safetyMessageVersion: message.metadata?.safetyMessageVersion || '1.0'
    });

    // Make sure the message metadata includes all country code information
    // This normalizes different versions of safety messages
    const enhancedMessage = {
      ...message,
      metadata: {
        ...message.metadata,
        // Ensure all country code fields are present and consistent
        isSystemSafetyResponse: true, // Always ensure this flag is set
        rawCountryCode: message.metadata?.rawCountryCode || message.metadata?.countryCode || null,
        countryCode: message.metadata?.countryCode || null,
        effectiveCountryCode: message.metadata?.effectiveCountryCode || message.metadata?.countryCode || 'DEFAULT',
        // Ensure the displayCountryCode is set correctly for UI
        displayCountryCode: 
          message.metadata?.displayCountryCode || 
          message.metadata?.effectiveCountryCode || 
          message.metadata?.countryCode || 
          'DEFAULT',
        // Add version info if not present
        safetyMessageVersion: message.metadata?.safetyMessageVersion || '2.1'
      }
    };
    
    // Log the enhanced message's country code information
    console.log('[Safety Message API] Enhanced message country codes:', {
      original: {
        countryCode: message.metadata?.countryCode,
        effectiveCountryCode: message.metadata?.effectiveCountryCode,
        displayCountryCode: message.metadata?.displayCountryCode
      },
      enhanced: {
        rawCountryCode: enhancedMessage.metadata.rawCountryCode,
        countryCode: enhancedMessage.metadata.countryCode,
        effectiveCountryCode: enhancedMessage.metadata.effectiveCountryCode,
        displayCountryCode: enhancedMessage.metadata.displayCountryCode,
        version: enhancedMessage.metadata.safetyMessageVersion
      }
    });

    return NextResponse.json({ 
      message: enhancedMessage,
      found: true 
    });
  } catch (error) {
    console.error('[Safety Message API] Unexpected error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown server error' },
      { status: 500 }
    );
  }
}// src/app/api/homepage-chat/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { createServerSupabaseClient } from '@/lib/supabase/server';

/**
 * GET handler for homepage chat data
 * This is a simplified endpoint that only returns the most recent messages for the homepage
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const chatbotId = searchParams.get('chatbotId');
    
    if (!roomId) {
      return NextResponse.json({ error: 'roomId is required' }, { status: 400 });
    }
    
    // Get current user
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Use admin client to bypass RLS policies completely
    const supabaseAdmin = createAdminClient();
    
    // Get profile for role check
    const { data: profile, error: profileError } = await supabaseAdmin
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();
      
    if (profileError) {
      console.error('[Homepage Chat API] Profile error:', profileError);
      return NextResponse.json({ error: 'Failed to get user profile' }, { status: 500 });
    }
    
    // For students, verify room membership
    if (profile.role === 'student') {
      const { data: membership, error: membershipError } = await supabaseAdmin
        .from('room_memberships')
        .select('room_id')
        .eq('room_id', roomId)
        .eq('student_id', user.id)
        .maybeSingle();
        
      if (membershipError) {
        console.error('[Homepage Chat API] Membership check error:', membershipError);
      }
      
      if (!membership) {
        return NextResponse.json({ error: 'Not a member of this room' }, { status: 403 });
      }
    }
    
    // Query for messages
    let query = supabaseAdmin
      .from('chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .or(`user_id.eq.${user.id},role.eq.assistant,role.eq.system`);
      
    if (chatbotId) {
      query = query.filter('metadata->>chatbotId', 'eq', chatbotId);
    }
    
    // Limit to most recent 20 messages
    const { data: messages, error: messagesError } = await query
      .order('created_at', { ascending: true })
      .limit(20);
      
    if (messagesError) {
      console.error('[Homepage Chat API] Error fetching messages:', messagesError);
      return NextResponse.json({ error: 'Failed to fetch messages' }, { status: 500 });
    }
    
    return NextResponse.json(messages || []);
  } catch (error) {
    console.error('[Homepage Chat API] Unhandled error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown server error' },
      { status: 500 }
    );
  }
}// src/app/api/assessment/process/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { DocumentType } from '@/types/knowledge-base.types'; // For extractTextFromFile
import { extractTextFromFile } from '@/lib/document-processing/extractor';
// Import AssessmentStatusEnum for setting status
import type { AssessmentStatusEnum } from '@/types/database.types';

// Define interface for global cache
interface GlobalWithCache {
  [key: string]: string;
}

// Add type declaration for globalThis
declare global {
  // eslint-disable-next-line no-var
  var documentCache: GlobalWithCache;
}

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const ASSESSMENT_LLM_MODEL = 'google/gemini-2.5-flash-preview'; // Or your preferred model like 'microsoft/phi-3-medium-128k-instruct'

interface ProcessAssessmentPayload {
  student_id: string; // For teacher tests, this will be the teacher's user_id
  chatbot_id: string;
  room_id: string; // Will be "teacher_test_room_for_..." for teacher tests
  message_ids_to_assess: string[];
}

// Helper function to identify teacher test rooms
const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// Define expected structure for LLM's JSON response (the content part)
interface LLMAssessmentOutput {
    grade: string;
    student_feedback: string;
    teacher_analysis: {
        summary: string;
        strengths: string[];
        areas_for_improvement: string[];
        grading_rationale: string;
    };
}

export async function POST(request: NextRequest) {
  console.log('--------------------------------------------------');
  console.log('[API /assessment/process] Received assessment processing request.');
  const adminSupabase = createAdminClient();
  
  // Initialize global document cache if not exists
  if (!global.documentCache) {
    global.documentCache = {};
  }

  try {
    const payload: ProcessAssessmentPayload = await request.json();
    const { student_id: userId, chatbot_id, room_id, message_ids_to_assess } = payload;
    const isTestByTeacher = isTeacherTestRoom(room_id);

    console.log(`[API /assessment/process] Payload: userId=${userId}, chatbot_id=${chatbot_id}, room_id=${room_id}, isTestByTeacher=${isTestByTeacher}, messages_count=${message_ids_to_assess.length}`);

    // 1. Fetch the Assessment Bot's configuration
    const { data: assessmentBotConfig, error: botConfigError } = await adminSupabase
      .from('chatbots')
      .select('assessment_criteria_text, enable_rag, teacher_id')
      .eq('chatbot_id', chatbot_id)
      .eq('bot_type', 'assessment')
      .single();

    if (botConfigError || !assessmentBotConfig) {
      console.error(`[API /assessment/process] CRITICAL: Error fetching assessment bot ${chatbot_id} config:`, botConfigError?.message);
      return NextResponse.json({ error: 'Assessment bot configuration not found or not an assessment bot.' }, { status: 404 });
    }
    if (!assessmentBotConfig.assessment_criteria_text) {
      console.warn(`[API /assessment/process] CRITICAL: Assessment bot ${chatbot_id} has no assessment criteria defined.`);
        await adminSupabase.from('chat_messages').insert({
            room_id: room_id, user_id: userId, role: 'system',
            content: "This assessment bot doesn't have its criteria defined by the teacher yet. Please set the criteria in the chatbot configuration.",
            metadata: { chatbotId: chatbot_id, isAssessmentFeedback: true, error: "Missing assessment criteria" }
        });
        return NextResponse.json({ success: true, message: "Assessment criteria missing, user notified." });
    }
    console.log(`[API /assessment/process] Fetched bot config. RAG enabled: ${assessmentBotConfig.enable_rag}`);

    // 2. Fetch the conversation segment to be assessed
    const { data: conversationMessages, error: messagesError } = await adminSupabase
      .from('chat_messages')
      .select('role, content, user_id')
      .in('message_id', message_ids_to_assess)
      .order('created_at', { ascending: true });

    if (messagesError || !conversationMessages || conversationMessages.length === 0) {
      console.error(`[API /assessment/process] CRITICAL: Error fetching conversation messages for assessment:`, messagesError?.message);
      return NextResponse.json({ error: 'Could not retrieve conversation for assessment.' }, { status: 500 });
    }
    console.log(`[API /assessment/process] Fetched ${conversationMessages.length} conversation messages.`);

    const conversationSegmentForPrompt = conversationMessages
      .map(m => `${m.user_id === userId ? (isTestByTeacher ? 'Tester (Teacher)' : 'Student') : 'Quiz Bot'}: ${m.content}`)
      .join('\n');

    // 3. Fetch the original passage/document text if this bot is RAG-enabled
    let originalPassageText = "No specific passage was used by the Quiz Bot for these questions, or it could not be retrieved for this assessment.";
    if (assessmentBotConfig.enable_rag) {
      console.log(`[API /assessment/process] Bot has RAG. Fetching primary document for passage context.`);
      
      // First check if this is a document we've processed recently and might have cached
      // Using the chatbot_id as a simple cache key
      const cacheKey = `document_text_${chatbot_id}`;
      const cachedText = global.documentCache[cacheKey];
      
      if (cachedText) {
        console.log(`[API /assessment/process] Using cached document text for chatbot ${chatbot_id} (length: ${cachedText.length})`);
        originalPassageText = cachedText;
      } else {
        // Query for document with preloaded extraction if available
        const { data: botDocument, error: docError } = await adminSupabase
          .from('documents')
          .select('file_path, file_type, extracted_text')
          .eq('chatbot_id', chatbot_id)
          .order('created_at', { ascending: false })
          .limit(1)
          .single();

        if (docError || !botDocument) {
          console.warn(`[API /assessment/process] No document found for RAG-enabled assessment bot ${chatbot_id}, or error:`, docError?.message);
        } else if (botDocument.extracted_text) {
          // Use pre-extracted text if available (from vectorization process)
          originalPassageText = botDocument.extracted_text;
          // Cache the result for future use
          global.documentCache[cacheKey] = originalPassageText;
          console.log(`[API /assessment/process] Using pre-extracted text from document (length: ${originalPassageText.length}).`);
        } else {
          try {
            console.log(`[API /assessment/process] Downloading document: ${botDocument.file_path}`);
            const { data: fileData, error: downloadError } = await adminSupabase.storage.from('documents').download(botDocument.file_path);
            if (!downloadError && fileData) {
              originalPassageText = await extractTextFromFile(Buffer.from(await fileData.arrayBuffer()), botDocument.file_type as DocumentType);
              // Cache the result for future use
              global.documentCache[cacheKey] = originalPassageText;
              console.log(`[API /assessment/process] Extracted text from passage (length: ${originalPassageText.length}).`);
            } else { 
              console.warn(`[API /assessment/process] Failed to download document ${botDocument.file_path}:`, downloadError?.message); 
            }
          } catch (extractionError) { 
            console.warn(`[API /assessment/process] Error extracting text from document ${botDocument.file_path}:`, extractionError); 
          }
        }
      }
    }

    // 4. Construct the detailed assessment prompt for the LLM
    const finalAssessmentPrompt = `
You are an AI teaching assistant. Your task is to evaluate a student's (or tester's) interaction based on the teacher's criteria, the original passage (if provided), and the conversation history.

Teacher's Assessment Criteria:
--- TEACHER'S CRITERIA START ---
${assessmentBotConfig.assessment_criteria_text}
--- TEACHER'S CRITERIA END ---

Original Passage Context (if applicable, MCQs should be based on this):
--- ORIGINAL PASSAGE START ---
${originalPassageText}
--- ORIGINAL PASSAGE END ---

Note: If your chatbot is giving multiple-choice questions, instruct students to "PAUSE – Reflect, then reply with your answer (A/B/C/D)." instead of asking them to say "Continue".

Conversation History to Assess (User is '${isTestByTeacher ? 'Tester (Teacher)' : 'Student'}'):
--- CONVERSATION HISTORY START ---
${conversationSegmentForPrompt}
--- CONVERSATION HISTORY END ---

Provide your evaluation ONLY as a single, valid JSON object matching the following structure EXACTLY:
{
  "grade": "string (e.g., 'Meets Expectations', '8/10', 'B', 'Needs Improvement'. Be concise.)",
  "student_feedback": "string (2-4 sentences of constructive feedback for the student, directly addressing their performance against the criteria. Start with 'Here is some feedback on your interaction:')",
  "teacher_analysis": {
    "summary": "string (A 1-2 sentence overall summary of the student's performance for the teacher.)",
    "strengths": [
      "string (A specific strength observed, referencing criteria/conversation. Be specific.)",
      "string (Another specific strength, if any. Up to 2-3 strengths total.)"
    ],
    "areas_for_improvement": [
      "string (A specific area for improvement, referencing criteria/conversation. Be specific.)",
      "string (Another specific area, if any. Up to 2-3 areas total.)"
    ],
    "grading_rationale": "string (A brief explanation of how the grade was derived based on the criteria and the student's performance in the conversation.)"
  }
}

Ensure all string values are properly escaped within the JSON. Do not include any text outside of this JSON object.
`;

    // 5. Call the Assessment LLM
    console.log(`[API /assessment/process] STEP 5: Calling Assessment LLM: ${ASSESSMENT_LLM_MODEL}.`);
    let llmOutput: LLMAssessmentOutput = {
        grade: "Error: AI Grade Not Generated",
        student_feedback: "An error occurred during AI assessment. The AI could not generate feedback based on your interaction. Please inform your teacher.",
        teacher_analysis: {
            summary: "AI assessment could not be completed due to an error or unexpected LLM response.",
            strengths: [],
            areas_for_improvement: [],
            grading_rationale: "Error during LLM processing or response parsing."
        }
    };
    let aiAssessmentDetailsRaw = JSON.stringify({ error: "LLM call not successfully completed or parsing failed." }); // Full raw response from LLM provider
    let llmCallSuccessful = false;

    try {
        const assessmentLLMResponse = await fetch(OPENROUTER_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
                'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
                'X-Title': 'ClassBots AI - Assessment Processing'
            },
            body: JSON.stringify({
                model: ASSESSMENT_LLM_MODEL,
                messages: [{ role: 'user', content: finalAssessmentPrompt }],
                temperature: 0.3,
                max_tokens: 800,
                response_format: { type: "json_object" },
                stream: true // Enable streaming
            })
        });

        // Handle streaming response similar to chat API
        if (!assessmentLLMResponse.ok || !assessmentLLMResponse.body) {
            console.error(`[API /assessment/process] LLM CALL FAILED: Status ${assessmentLLMResponse.status}`);
            aiAssessmentDetailsRaw = JSON.stringify({ error: `LLM Call Failed: Status ${assessmentLLMResponse.status}` });
        } else {
            // Process the stream and collect the full response
            let fullResponseText = '';
            const reader = assessmentLLMResponse.body.getReader();
            const decoder = new TextDecoder();
            
            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n').filter(l => l.trim().startsWith('data:'));
                    
                    for (const line of lines) {
                        const dataContent = line.substring(6).trim();
                        if (dataContent === '[DONE]') continue;
                        
                        try {
                            const parsed = JSON.parse(dataContent);
                            const piece = parsed.choices?.[0]?.delta?.content;
                            if (typeof piece === 'string') {
                                fullResponseText += piece;
                            }
                        } catch (e) {
                            console.warn('[API /assessment/process] Stream parse error:', e, "Data:", dataContent);
                        }
                    }
                }
                
                // Create a properly formatted OpenRouter response structure
                const formattedResponse = {
                    choices: [{
                        message: {
                            content: fullResponseText
                        }
                    }]
                };
                
                aiAssessmentDetailsRaw = JSON.stringify(formattedResponse);
                console.log(`[API /assessment/process] Streaming completed, collected ${fullResponseText.length} characters`);
                
            } catch (streamError) {
                console.error('[API /assessment/process] Stream error:', streamError);
                aiAssessmentDetailsRaw = JSON.stringify({ error: `Stream Error: ${streamError instanceof Error ? streamError.message : String(streamError)}` });
            }
        }

        // Now parse the collected JSON response
        try {
            // Parse the collected full response text
            const formattedResponse = JSON.parse(aiAssessmentDetailsRaw);
            const contentString = formattedResponse.choices?.[0]?.message?.content;
            
            if (typeof contentString === 'string') {
                console.log("[API /assessment/process] Extracted content string for JSON parse (first 500 chars):", 
                  contentString.substring(0, 500) + "...");
                
                let jsonStringToParse = contentString.trim();
                
                // Handle if model wraps in markdown code block
                const markdownJsonMatch = jsonStringToParse.match(/```json\s*([\s\S]*?)\s*```/);
                if (markdownJsonMatch && markdownJsonMatch[1]) {
                    jsonStringToParse = markdownJsonMatch[1].trim();
                    console.log("[API /assessment/process] Extracted JSON from markdown block.");
                }
                
                const parsedAssessment = JSON.parse(jsonStringToParse);
                
                // Validate and use the parsed JSON
                if (
                    parsedAssessment &&
                    typeof parsedAssessment.grade === 'string' &&
                    typeof parsedAssessment.student_feedback === 'string' &&
                    typeof parsedAssessment.teacher_analysis === 'object' &&
                    parsedAssessment.teacher_analysis !== null
                ) {
                    llmOutput = {
                        grade: parsedAssessment.grade,
                        student_feedback: parsedAssessment.student_feedback,
                        teacher_analysis: {
                            summary: parsedAssessment.teacher_analysis.summary || "No summary provided.",
                            strengths: Array.isArray(parsedAssessment.teacher_analysis.strengths) 
                                ? parsedAssessment.teacher_analysis.strengths 
                                : [],
                            areas_for_improvement: Array.isArray(parsedAssessment.teacher_analysis.areas_for_improvement) 
                                ? parsedAssessment.teacher_analysis.areas_for_improvement 
                                : [],
                            grading_rationale: parsedAssessment.teacher_analysis.grading_rationale || "No rationale provided."
                        }
                    };
                    
                    llmCallSuccessful = true;
                    console.log(`[API /assessment/process] Successfully parsed assessment JSON. Grade: ${llmOutput.grade}`);
                } else {
                    console.warn("[API /assessment/process] Parsed JSON missing required fields:", parsedAssessment);
                }
            } else {
                console.error("[API /assessment/process] Content string not found in response");
            }
        } catch (parseError) {
            console.error(`[API /assessment/process] Error parsing JSON response:`, parseError);
        }
    } catch (llmCallException) {
        console.error(`[API /assessment/process] EXCEPTION during Assessment LLM call:`, llmCallException);
        aiAssessmentDetailsRaw = JSON.stringify({ error: `LLM Call Exception: ${llmCallException instanceof Error ? llmCallException.message : String(llmCallException)}` });
    }
    
    let savedAssessmentId: string | null = null;
    const assessmentStatusToSave: AssessmentStatusEnum = llmCallSuccessful ? 'ai_completed' : 'ai_processing';

    if (!isTestByTeacher) {
      console.log(`[API /assessment/process] STEP 6: Attempting to save student assessment. Student ID: ${userId}, LLM Call Successful: ${llmCallSuccessful}, Status to Save: ${assessmentStatusToSave}`);
      const insertPayload = {
        student_id: userId,
        chatbot_id: chatbot_id,
        room_id: room_id,
        assessed_message_ids: message_ids_to_assess,
        teacher_id: assessmentBotConfig.teacher_id,
        teacher_assessment_criteria_snapshot: assessmentBotConfig.assessment_criteria_text,
        ai_feedback_student: llmOutput.student_feedback,
        ai_assessment_details_raw: aiAssessmentDetailsRaw,
        ai_grade_raw: llmOutput.grade,
        ai_assessment_details_teacher: llmOutput.teacher_analysis,
        status: assessmentStatusToSave,
      };
      // console.log("[API /assessment/process] Payload for student_assessments insert:", JSON.stringify(insertPayload, null, 2));

      const { data: savedAssessmentData, error: assessmentSaveError } = await adminSupabase
        .from('student_assessments')
        .insert(insertPayload)
        .select('assessment_id').single();

      if (assessmentSaveError) {
        console.error(`[API /assessment/process] CRITICAL: Error saving student assessment to DB:`, assessmentSaveError.message, assessmentSaveError.details, assessmentSaveError.hint);
      } else if (savedAssessmentData) {
        savedAssessmentId = savedAssessmentData.assessment_id;
        console.log(`[API /assessment/process] Student assessment ${savedAssessmentId} saved successfully with status: ${assessmentStatusToSave}.`);
      } else {
        console.warn(`[API /assessment/process] Student assessment insert attempt completed but no data/ID returned, and no explicit error.`);
      }
    } else {
        console.log(`[API /assessment/process] STEP 6: Teacher test assessment. LLM Call Successful: ${llmCallSuccessful}. Skipping save to student_assessments table.`);
    }

    console.log(`[API /assessment/process] STEP 7: Inserting feedback message into chat_messages for user ${userId}. Feedback snippet: "${String(llmOutput.student_feedback).substring(0, 100)}..."`);
    
    // Insert feedback message directly - more efficient approach
    const { data: messageData, error: messageError } = await adminSupabase
        .from('chat_messages')
        .insert({
            room_id: room_id, 
            user_id: userId,
            role: 'assistant',
            content: llmOutput.student_feedback,
            metadata: {
                chatbotId: chatbot_id, 
                isAssessmentFeedback: true,
                assessmentId: savedAssessmentId,
                processedWithStreaming: true // Flag to indicate this was processed with streaming
            }
        })
        .select('message_id')
        .single();
    
    if (messageError) {
        console.error(`[API /assessment/process] Error inserting feedback message for user ${userId}:`, 
            messageError.message, messageError.details, messageError.hint);
    } else if (messageData) {
        console.log(`[API /assessment/process] Feedback message ${messageData.message_id} successfully inserted for user ${userId}.`);
    } else {
        console.warn(`[API /assessment/process] Feedback message insert completed but no message ID returned.`);
    }

    console.log('[API /assessment/process] Processing complete. Returning response.');
    console.log('--------------------------------------------------');
    return NextResponse.json({ success: true, message: 'Assessment processed.', assessmentId: savedAssessmentId });

  } catch (error) {
    console.error('[API /assessment/process] CRITICAL UNHANDLED error:', error);
    console.log('--------------------------------------------------');
    return NextResponse.json({ error: 'Failed to process assessment due to a critical internal server error.' }, { status: 500 });
  }
}// src/app/api/teacher/assessments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
// Ensure all necessary types from database.types.ts are imported
import type {
    StudentAssessment,
    Profile,
    ChatMessage as DbChatMessage,
    AssessmentStatusEnum,
    AssessmentListSummary,      // These should be in your database.types.ts now
    PaginatedAssessmentsResponse,
    DetailedAssessmentResponse,
    UpdateAssessmentPayload
} from '@/types/database.types';


// getSingleDetailedAssessment function (remains exactly as in your provided code)
async function getSingleDetailedAssessment(
    assessmentId: string,
    requestingUserId: string,
    adminSupabase: ReturnType<typeof createAdminClient>
): Promise<NextResponse> {
    console.log(`[API GET /assessments?assessmentId=${assessmentId}] Fetching single assessment details.`);
    const { data: assessment, error: assessmentError } = await adminSupabase.from('student_assessments').select('*').eq('assessment_id', assessmentId).single();
    if (assessmentError || !assessment) { return NextResponse.json({ error: 'Assessment not found or error fetching it.' }, { status: 404 }); }
    const { data: chatbotOwner, error: chatbotOwnerError } = await adminSupabase.from('chatbots').select('teacher_id, name').eq('chatbot_id', assessment.chatbot_id).single();
    if (chatbotOwnerError || !chatbotOwner || chatbotOwner.teacher_id !== requestingUserId) { return NextResponse.json({ error: 'Not authorized to view this assessment' }, { status: 403 });}
    let studentProfile: Pick<Profile, 'full_name' | 'email'> | null = null;
    if (assessment.student_id) {
        const { data: studentData } = await adminSupabase.from('profiles').select('full_name, email').eq('user_id', assessment.student_id).single();
        studentProfile = studentData;
    }
    let assessedConversation: DbChatMessage[] = [];
    if (assessment.assessed_message_ids && Array.isArray(assessment.assessed_message_ids) && assessment.assessed_message_ids.length > 0) {
        const { data: messagesData } = await adminSupabase.from('chat_messages').select('*').in('message_id', assessment.assessed_message_ids).order('created_at', { ascending: true });
        assessedConversation = (messagesData || []) as DbChatMessage[];
    }
    const responseData: DetailedAssessmentResponse = {
        ...(assessment as StudentAssessment), student_name: studentProfile?.full_name || null, student_email: studentProfile?.email || null,
        chatbot_name: chatbotOwner?.name || null, assessed_conversation: assessedConversation,
    };
    return NextResponse.json(responseData);
}


export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const assessmentId = searchParams.get('assessmentId');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const statusFilter = searchParams.get('status') as AssessmentStatusEnum | null;
    const roomIdFilter = searchParams.get('roomId');
    const studentIdFilter = searchParams.get('studentId');

    console.log(`[API GET /assessments] Request: assessmentId=${assessmentId||'list'}, page=${page}, limit=${limit}, status=${statusFilter||'all'}`);

    const supabaseUserClient = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();

    const { data: { user }, error: authError } = await supabaseUserClient.auth.getUser();
    if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }

    const { data: profile, error: profileError } = await supabaseUserClient.from('profiles').select('role').eq('user_id', user.id).single();
    if (profileError || !profile || profile.role !== 'teacher') { return NextResponse.json({ error: 'Not authorized' }, { status: 403 });}
    
    if (assessmentId) {
        return getSingleDetailedAssessment(assessmentId, user.id, adminSupabase);
    } else {
        console.log(`[API GET /assessments] Fetching list for teacher ${user.id}. Filters: status=${statusFilter}, room=${roomIdFilter}, student=${studentIdFilter}`);
        const offset = page * limit;
        try {
            const studentForeignKeyHint = "!student_assessments_student_id_fkey"; // Using the name from your FK list
            const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey"; // Using the name from your FK list

            let query = adminSupabase
                .from('student_assessments')
                .select(`
                    assessment_id,
                    student_id,
                    chatbot_id,
                    room_id,
                    teacher_id, 
                    assessed_at,
                    ai_grade_raw,
                    teacher_override_grade,
                    status,
                    student:profiles${studentForeignKeyHint}!inner(full_name), 
                    chatbot:chatbots${chatbotForeignKeyHint}!inner(name)
                `, { count: 'exact' })
                .eq('teacher_id', user.id) 
                .order('assessed_at', { ascending: false })
                .range(offset, offset + limit - 1);

            if (statusFilter) query = query.eq('status', statusFilter);
            if (roomIdFilter) query = query.eq('room_id', roomIdFilter);
            if (studentIdFilter) query = query.eq('student_id', studentIdFilter);

            const { data, error, count } = await query;

            if (error) {
                console.error(`[API GET /assessments] DB Error fetching list (initial query):`, JSON.stringify(error, null, 2));
                throw error;
            }

            if (!data) { // Should not happen if error is null, but good check
                console.warn("[API GET /assessments] No assessment data returned from initial query, though no explicit error.");
                 return NextResponse.json({ assessments: [], pagination: { currentPage: page, pageSize: limit, totalCount: 0, totalPages: 0 }});
            }
            
            // Step 2: Fetch room names separately for valid UUID room_ids
            const roomIdsToFetchNames = [...new Set(
                data.map(item => item.room_id).filter(id => id && !id.startsWith('teacher_test_room_'))
            )] as string[]; // Ensure it's an array of strings

            const roomNamesMap: Map<string, string> = new Map();
            if (roomIdsToFetchNames.length > 0) {
                const { data: roomData, error: roomNameError } = await adminSupabase
                    .from('rooms')
                    .select('room_id, room_name')
                    .in('room_id', roomIdsToFetchNames);
                
                if (roomNameError) {
                    console.warn("[API GET /assessments] Error fetching room names separately:", roomNameError.message);
                } else if (roomData) {
                    roomData.forEach(room => roomNamesMap.set(room.room_id, room.room_name));
                }
            }

            const assessments: AssessmentListSummary[] = data.map(item => {
                const studentData = item.student as { full_name?: string | null } | null;
                const chatbotData = item.chatbot as { name?: string | null } | null;
                
                let resolvedRoomName = 'N/A';
                if (item.room_id) {
                    if (item.room_id.startsWith('teacher_test_room_')) {
                        resolvedRoomName = 'Teacher Test Chat';
                    } else if (roomNamesMap.has(item.room_id)) {
                        resolvedRoomName = roomNamesMap.get(item.room_id)!;
                    } else {
                        // Fallback if room_id is a UUID but not found in rooms table (e.g., room deleted)
                        resolvedRoomName = `Room ID: ${item.room_id.substring(0,8)}...`;
                    }
                }

                return {
                    assessment_id: item.assessment_id, student_id: item.student_id, chatbot_id: item.chatbot_id,
                    room_id: item.room_id, teacher_id: item.teacher_id, assessed_at: item.assessed_at,
                    ai_grade_raw: item.ai_grade_raw, teacher_override_grade: item.teacher_override_grade, status: item.status,
                    student_name: studentData?.full_name || 'N/A',
                    chatbot_name: chatbotData?.name || 'N/A',
                    room_name: resolvedRoomName
                };
            });
            
            const totalCount = count || 0;
            const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;
            const responsePayload: PaginatedAssessmentsResponse = {
                assessments,
                pagination: { currentPage: page, pageSize: limit, totalCount, totalPages }
            };
            console.log(`[API GET /assessments] Returning ${assessments.length} assessments. Total: ${totalCount}`);
            return NextResponse.json(responsePayload);

        } catch (error) {
            console.error(`[API GET /assessments] CATCH BLOCK fetching list:`, error);
            return NextResponse.json({ error: 'Failed to fetch assessments list' }, { status: 500 });
        }
    }
}

// PATCH handler (remains exactly as you provided)
export async function PATCH(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const assessmentId = searchParams.get('assessmentId');
    if (!assessmentId) { return NextResponse.json({ error: 'Assessment ID is required for PATCH' }, { status: 400 });}
    console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] Request to update.`);
    const supabaseUserClient = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();
    try {
        const { data: { user }, error: authError } = await supabaseUserClient.auth.getUser();
        if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }
        const { data: assessment, error: fetchError } = await adminSupabase.from('student_assessments').select('chatbot_id').eq('assessment_id', assessmentId).single();
        if (fetchError || !assessment) { return NextResponse.json({ error: 'Assessment not found' }, { status: 404 });}
        const { data: chatbotOwner, error: chatbotOwnerError } = await adminSupabase.from('chatbots').select('teacher_id').eq('chatbot_id', assessment.chatbot_id).single();
        if (chatbotOwnerError || !chatbotOwner || chatbotOwner.teacher_id !== user.id) { return NextResponse.json({ error: 'Not authorized' }, { status: 403 });}
        const body: UpdateAssessmentPayload = await request.json();
        const updateData: Partial<Omit<StudentAssessment, 'created_at' | 'assessment_id'>> = {};
        if (body.hasOwnProperty('teacher_override_grade')) updateData.teacher_override_grade = body.teacher_override_grade;
        if (body.hasOwnProperty('teacher_override_notes')) updateData.teacher_override_notes = body.teacher_override_notes;
        if (body.status) {
            const validStatuses: AssessmentStatusEnum[] = ['ai_processing', 'ai_completed', 'teacher_reviewed'];
            if (validStatuses.includes(body.status)) updateData.status = body.status;
            else console.warn(`[API PATCH /assessments?assessmentId=${assessmentId}] Invalid status: ${body.status}`);
        }
        updateData.updated_at = new Date().toISOString();
        if (Object.keys(updateData).length <= 1 && updateData.updated_at) { console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] No data fields to update.`); }
        console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] Updating with:`, updateData);
        const { data: updatedAssessment, error: updateError } = await adminSupabase.from('student_assessments').update(updateData).eq('assessment_id', assessmentId).select().single();
        if (updateError) { return NextResponse.json({ error: 'Failed to update assessment', details: updateError.message }, { status: 500 });}
        return NextResponse.json(updatedAssessment);
    } catch (error) {
        console.error(`[API PATCH /assessments?assessmentId=${assessmentId}] General error:`, error);
        if (error instanceof SyntaxError) return NextResponse.json({ error: 'Invalid JSON payload.' }, { status: 400 });
        return NextResponse.json({ error: 'Internal server error during PATCH.' }, { status: 500 });
    }
}// src/app/api/teacher/student-room-details/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { Profile, StudentAssessment, FlaggedMessage } from '@/types/database.types';

// Simplified types for summaries
interface AssessmentSummaryForStudent extends Pick<StudentAssessment, 'assessment_id' | 'chatbot_id' | 'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'> {
  chatbot_name?: string | null;
}

interface ConcernSummaryForStudent extends Pick<FlaggedMessage, 'flag_id' | 'concern_type' | 'concern_level' | 'created_at' | 'status'> {
  message_preview?: string | null;
}

interface StudentRoomDetailsResponse {
  student: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null;
  assessments: AssessmentSummaryForStudent[];
  concerns: ConcernSummaryForStudent[];
  // We could add a flag like hasChatHistory: boolean;
}

export async function GET(request: NextRequest) {
  console.log('[API GET /teacher/student-room-details] Received request.');
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');

    if (!roomId || !studentId) {
      console.warn('[API GET /student-room-details] roomId or studentId query parameter is missing.');
      return NextResponse.json({ error: 'Room ID and Student ID are required' }, { status: 400 });
    }
    console.log(`[API GET /student-room-details] Processing for roomId: ${roomId}, studentId: ${studentId}`);

    const supabase = await createServerSupabaseClient(); // User-context client
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /student-room-details] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify teacher role
    const { data: teacherProfile, error: teacherProfileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (teacherProfileError || !teacherProfile || teacherProfile.role !== 'teacher') {
      console.warn(`[API GET /student-room-details] User ${user.id} not a teacher or profile error.`);
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }
    console.log(`[API GET /student-room-details] User ${user.id} authenticated as teacher.`);

    // Verify teacher owns the room
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !roomData) {
      console.warn(`[API GET /student-room-details] Room ${roomId} not found or teacher ${user.id} not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    // Verify student is a member of this room
    const { data: membership, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      console.warn(`[API GET /student-room-details] Student ${studentId} is not a member of room ${roomId}:`, membershipError?.message);
      return NextResponse.json({ error: 'Student not found in this room' }, { status: 404 });
    }
    console.log(`[API GET /student-room-details] Verified teacher ownership and student membership for room ${roomId}, student ${studentId}.`);

    const adminSupabase = createAdminClient();

    // Fetch student profile - use a more robust approach with fallbacks
    let studentProfileData = null;
    let studentProfileFetchError = null;
    
    try {
      // First attempt: Try standard profile lookup
      const { data, error } = await adminSupabase
        .from('profiles')
        .select('user_id, full_name, email')
        .eq('user_id', studentId)
        .single();
        
      if (error) {
        throw error;
      }
      
      if (data) {
        studentProfileData = data;
      }
    } catch (profileError) {
      console.error(`[API GET /student-room-details] Error in primary fetch of profile for student ${studentId}:`, profileError);
      studentProfileFetchError = profileError;
      
      try {
        // Fallback: Try using room membership to confirm student exists
        console.log(`[API GET /student-room-details] Attempting fallback profile creation for ${studentId}`);
        
        // Create a placeholder profile as a backup
        const { error: upsertError } = await adminSupabase
          .from('profiles')
          .upsert({
            user_id: studentId,
            full_name: 'Student',
            role: 'student',
            created_at: new Date().toISOString(),
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'user_id'
          });
          
        if (upsertError) {
          console.error(`[API GET /student-room-details] Error in fallback profile creation:`, upsertError);
        } else {
          console.log(`[API GET /student-room-details] Successfully created backup profile for ${studentId}`);
          
          // Try to fetch the profile again
          const { data: retryData } = await adminSupabase
            .from('profiles')
            .select('user_id, full_name, email')
            .eq('user_id', studentId)
            .single();
            
          if (retryData) {
            studentProfileData = retryData;
          }
        }
      } catch (fallbackError) {
        console.error(`[API GET /student-room-details] Error in fallback profile handling:`, fallbackError);
      }
    }
    
    // Create a profile object even if we couldn't fetch one - at least provide the ID
    const studentInfo: Pick<Profile, 'user_id' | 'full_name' | 'email'> = studentProfileData 
        ? { 
            user_id: studentProfileData.user_id, 
            full_name: studentProfileData.full_name || 'Student', 
            email: studentProfileData.email || 'No email' 
          } 
        : { 
            user_id: studentId, 
            full_name: 'Student', 
            email: 'No email'
          };

    // Fetch assessments for this student in this room (limit for summary, e.g., last 10)
    // Re-using the foreign key hint strategy from the main assessments list API
    const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey";
    const { data: assessmentsData, error: assessmentsError } = await adminSupabase
      .from('student_assessments')
      .select(`
        assessment_id,
        chatbot_id,
        assessed_at,
        ai_grade_raw,
        teacher_override_grade,
        status,
        chatbot:chatbots${chatbotForeignKeyHint}!inner(name)
      `)
      .eq('student_id', studentId)
      .eq('room_id', roomId) // Filter by room
      .eq('teacher_id', user.id) // And ensure teacher owns the assessment bot
      .order('assessed_at', { ascending: false })
      .limit(10); // Example limit

    if (assessmentsError) {
      console.error(`[API GET /student-room-details] Error fetching assessments for student ${studentId} in room ${roomId}:`, assessmentsError.message);
    }
    const assessments: AssessmentSummaryForStudent[] = (assessmentsData || []).map(item => {
        const chatbotData = item.chatbot as { name?: string | null } | null; // Type assertion
        return {
            assessment_id: item.assessment_id,
            chatbot_id: item.chatbot_id,
            assessed_at: item.assessed_at,
            ai_grade_raw: item.ai_grade_raw,
            teacher_override_grade: item.teacher_override_grade,
            status: item.status,
            chatbot_name: chatbotData?.name || 'N/A'
        };
    });
    console.log(`[API GET /student-room-details] Fetched ${assessments.length} assessments for student ${studentId} in room ${roomId}.`);

    // Fetch flagged concerns for this student in this room (limit for summary)
    const { data: concernsData, error: concernsError } = await adminSupabase
      .from('flagged_messages')
      .select('flag_id, concern_type, concern_level, created_at, status, message:chat_messages!fk_message(content)') // Include message content for preview
      .eq('student_id', studentId)
      .eq('room_id', roomId) // Filter by room
      .eq('teacher_id', user.id) // Ensure teacher owns the concern record
      .order('created_at', { ascending: false })
      .limit(10); // Example limit

    if (concernsError) {
      console.error(`[API GET /student-room-details] Error fetching concerns for student ${studentId} in room ${roomId}:`, concernsError.message);
    }
    const concerns: ConcernSummaryForStudent[] = (concernsData || []).map(item => {
        const messageData = item.message as { content?: string | null } | null; // Type assertion
        return {
            flag_id: item.flag_id,
            concern_type: item.concern_type,
            concern_level: item.concern_level,
            created_at: item.created_at,
            status: item.status,
            message_preview: messageData?.content?.substring(0, 50) + (messageData?.content && messageData.content.length > 50 ? '...' : '') || null
        };
    });
    console.log(`[API GET /student-room-details] Fetched ${concerns.length} concerns for student ${studentId} in room ${roomId}.`);

    const responsePayload: StudentRoomDetailsResponse = {
      student: studentInfo,
      assessments,
      concerns,
    };

    console.log(`[API GET /student-room-details] Successfully prepared data. Returning response.`);
    return NextResponse.json(responsePayload);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string };
    console.error('[API GET /student-room-details] CATCH BLOCK Error:', typedError.message, 'Code:', typedError.code, 'Details:', typedError.details);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch student room details' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/student-chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface ChatbotInfoFromDB {
  chatbot_id: string;
  name: string;
}

interface RoomChatbotResponseFromDB {
  chatbot_id: string;
  chatbots: ChatbotInfoFromDB;
}

export async function GET(request: NextRequest) {
  try {
    // Extract query parameters instead of path parameters
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');
    const chatbotIdFilter = searchParams.get('chatbotId');

    console.log("Fetching chats for student:", studentId, "in room:", roomId);

    if (!roomId || !studentId) {
      return NextResponse.json({ error: 'Room ID and Student ID are required' }, { status: 400 });
    }

    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.error("Room fetch error or unauthorized:", roomError);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    // Use admin client to bypass RLS policies
    const supabaseAdmin = createAdminClient();
    
    // Check membership using admin client to avoid RLS recursion
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('student_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      console.error("Membership fetch error or not a member:", membershipError);
      return NextResponse.json({ error: 'Student is not a member of this room' }, { status: 404 });
    }

    // Use admin client for chat messages query too
    let query = supabaseAdmin
      .from('chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .eq('user_id', studentId)
      .order('created_at', { ascending: true });

    if (chatbotIdFilter) {
      query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
    }

    const { data: messagesData, error: messagesError } = await query;

    if (messagesError) {
      console.error("Error fetching messages:", messagesError);
      return NextResponse.json({ error: 'Failed to fetch chat messages' }, { status: 500 });
    }

    const allMessages: DatabaseChatMessage[] = (messagesData as DatabaseChatMessage[] | null) || [];

    const { data: roomChatbotsDataRaw, error: chatbotsError } = await supabase
      .from('room_chatbots')
      .select(`
        chatbot_id,
        chatbots:chatbots!inner(
          chatbot_id,
          name
        )
      `)
      .eq('room_id', roomId);

    if (chatbotsError) {
      console.error("Error fetching room chatbots:", chatbotsError);
    }

    const availableChatbots: Array<{ chatbot_id: string; name: string }> = [];
    if (roomChatbotsDataRaw && roomChatbotsDataRaw.length > 0) {
      const typedRoomChatbots = roomChatbotsDataRaw as unknown as RoomChatbotResponseFromDB[];
      typedRoomChatbots.forEach(item => {
        if (item.chatbots && typeof item.chatbots === 'object') {
          availableChatbots.push({
            chatbot_id: item.chatbots.chatbot_id,
            name: item.chatbots.name
          });
        }
      });
    }

    const conversations: Conversation[] = [];
    let currentConversation: Conversation | null = null;
    let currentChatbotIdForConversation: string | null = null;

    for (const message of allMessages) {
      const msgChatbotId = message.metadata?.chatbotId || null;

      if (currentConversation === null || msgChatbotId !== currentChatbotIdForConversation) {
        if (currentConversation) {
          conversations.push(currentConversation);
        }
        const matchingChatbot = availableChatbots.find(c => c.chatbot_id === msgChatbotId);
        currentChatbotIdForConversation = msgChatbotId;
        currentConversation = {
          chatbot_id: msgChatbotId,
          chatbot_name: matchingChatbot ? matchingChatbot.name : (msgChatbotId ? 'Unknown Chatbot' : 'General Chat'),
          started_at: message.created_at,
          messages: [message],
        };
      } else {
        currentConversation.messages.push(message);
      }
    }

    if (currentConversation) {
      conversations.push(currentConversation);
    }

    return NextResponse.json({
      conversations,
      chatbots: availableChatbots,
      pagination: { hasMore: false }
    });

  } catch (error) {
    console.error('Error fetching student chats:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.message, error.stack);
    }
    return NextResponse.json(
      { error: 'Failed to fetch student chats' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/magic-link/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const studentId = searchParams.get('studentId');
    const roomId = searchParams.get('roomId');
    
    console.log('[Magic Link API] GET request received with params:', { studentId, roomId, url: request.url });

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    // Get the student details
    const { data: student, error: studentError } = await supabase
      .from('profiles')
      .select('full_name')
      .eq('user_id', studentId)
      .single();

    if (studentError || !student) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      return NextResponse.json(
        { error: 'Student is not a member of this room' },
        { status: 404 }
      );
    }

    // Generate the magic link using the format: roomCode_userId_encodedStudentName
    const encodedName = encodeURIComponent(student.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Student Magic Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    return NextResponse.json({
      magicLink,
      studentName: student.full_name,
      code: simpleLinkCode
    });
  } catch (error) {
    console.error('Error generating student magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    // This is basically the same as GET but intended for regeneration
    // It follows the same procedure but can be tracked differently on the client
    
    const body = await request.json();
    const { studentId, roomId } = body;
    
    console.log('[Magic Link API] POST request received with body:', { studentId, roomId });

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    // Get the student details
    const { data: student, error: studentError } = await supabase
      .from('profiles')
      .select('full_name')
      .eq('user_id', studentId)
      .single();

    if (studentError || !student) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { data: membership, error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      return NextResponse.json(
        { error: 'Student is not a member of this room' },
        { status: 404 }
      );
    }

    // Generate the magic link
    const encodedName = encodeURIComponent(student.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Student Magic Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    return NextResponse.json({
      magicLink,
      studentName: student.full_name,
      code: simpleLinkCode,
      regenerated: true
    });
  } catch (error) {
    console.error('Error regenerating student magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to regenerate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/archive/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function POST(request: Request) {
  try {
    // Authentication check
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Get request body
    const { studentId, roomId } = await request.json();

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Missing required fields: studentId and roomId are required' },
        { status: 400 }
      );
    }
    
    // Verify the teacher owns the room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();
    
    if (roomError || !room) {
      console.error('Room access error:', roomError);
      return NextResponse.json(
        { error: 'No permission to access this room or room not found' },
        { status: 403 }
      );
    }

    // Use admin client for the deletion to bypass RLS
    const adminClient = createAdminClient();
    
    // Archive the student's room membership instead of deleting it
    const { error: archiveError } = await adminClient
      .from('room_memberships')
      .update({ 
        is_archived: true,
        updated_at: new Date().toISOString()
      })
      .eq('room_id', roomId)
      .eq('student_id', studentId);
      
    if (archiveError) {
      console.error('Error archiving student room membership:', archiveError);
      return NextResponse.json(
        { error: 'Failed to archive student room membership: ' + archiveError.message },
        { status: 500 }
      );
    }
    
    return NextResponse.json({
      success: true,
      message: 'Student successfully archived from room'
    });
    
  } catch (error) {
    console.error('Error in student archive endpoint:', error);
    return NextResponse.json(
      { error: 'Server error while processing request' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/pin-code/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

// Get student's PIN code
export async function GET(request: NextRequest) {
  try {
    // Create Supabase server client
    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();
    
    // Get student ID from query params
    const url = new URL(request.url);
    const studentId = url.searchParams.get('studentId');
    
    if (!studentId) {
      return NextResponse.json(
        { error: 'Student ID is required' },
        { status: 400 }
      );
    }
    
    // Get current user (teacher) to verify permissions
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    // Check if user is a teacher
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();
    
    if (profileError || !profile || profile.role !== 'teacher') {
      return NextResponse.json(
        { error: 'Unauthorized - Teacher role required' },
        { status: 403 }
      );
    }
    
    // Use admin client to fetch student info to ensure we can find them
    const { data: student, error: studentError } = await supabaseAdmin
      .from('profiles')
      .select('full_name, pin_code, username')
      .eq('user_id', studentId)
      .maybeSingle(); // Use maybeSingle instead of single to avoid the error
    
    // Check if student exists
    if (!student) {
      console.error('Student not found error:', studentError);
      
      // If student doesn't exist in profiles, check if they exist in auth.users
      const { data: authUser, error: authUserError } = await supabaseAdmin.auth.admin.getUserById(studentId);
      
      if (authUserError || !authUser?.user) {
        return NextResponse.json(
          { error: 'Student not found in auth system' },
          { status: 404 }
        );
      }
      
      // Student exists in auth but not in profiles, create profile
      const newUsername = authUser.user.email?.split('@')[0] || `student${Math.floor(Math.random() * 10000)}`;
      const newPin = Math.floor(1000 + Math.random() * 9000).toString();
      
      const { data: newProfile, error: insertError } = await supabaseAdmin
        .from('profiles')
        .insert({
          user_id: studentId,
          full_name: authUser.user.user_metadata?.full_name || 'Student',
          email: authUser.user.email,
          role: 'student',
          pin_code: newPin,
          username: newUsername.toLowerCase().replace(/[^a-z0-9]/g, ''),
          last_pin_change: new Date().toISOString(),
          pin_change_by: user.id
        })
        .select('full_name, pin_code, username')
        .single();
      
      if (insertError || !newProfile) {
        console.error('Error creating student profile:', insertError);
        return NextResponse.json(
          { error: 'Failed to create student profile' },
          { status: 500 }
        );
      }
      
      return NextResponse.json({
        pin_code: newProfile.pin_code || '',
        username: newProfile.username || '',
        studentName: newProfile.full_name,
        newlyCreated: true
      });
    }
    
    return NextResponse.json({
      pin_code: student.pin_code || '',
      username: student.username || '',
      studentName: student.full_name
    });
    
  } catch (error) {
    console.error('Error retrieving student PIN:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Regenerate PIN code
export async function POST(request: NextRequest) {
  try {
    // Create Supabase clients
    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();
    
    // Get request body
    const body = await request.json();
    const { studentId } = body;
    
    if (!studentId) {
      return NextResponse.json(
        { error: 'Student ID is required' },
        { status: 400 }
      );
    }
    
    // Get current user (teacher) to verify permissions
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    
    if (authError || !user) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }
    
    // Check if user is a teacher
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();
    
    if (profileError || !profile || profile.role !== 'teacher') {
      return NextResponse.json(
        { error: 'Unauthorized - Teacher role required' },
        { status: 403 }
      );
    }
    
    // Generate new PIN (4-digit number)
    const newPin = Math.floor(1000 + Math.random() * 9000).toString();
    
    // Get student's current info - use admin client to ensure we find them
    const { data: student } = await supabaseAdmin
      .from('profiles')
      .select('full_name, username')
      .eq('user_id', studentId)
      .maybeSingle(); // Use maybeSingle to avoid errors
    // studentError is removed as it was unused
    
    // If student doesn't exist, create a profile
    if (!student) {
      // Check if user exists in auth
      const { data: authUser, error: authUserError } = await supabaseAdmin.auth.admin.getUserById(studentId);
      
      if (authUserError || !authUser?.user) {
        return NextResponse.json(
          { error: 'Student not found in auth system' },
          { status: 404 }
        );
      }
      
      // Generate username from email or random
      const username = authUser.user.email 
        ? authUser.user.email.split('@')[0].toLowerCase().replace(/[^a-z0-9]/g, '')
        : `student${Math.floor(100 + Math.random() * 900)}`;
      
      // Create profile
      const { data: newProfile, error: insertError } = await supabaseAdmin
        .from('profiles')
        .insert({
          user_id: studentId,
          full_name: authUser.user.user_metadata?.full_name || 'Student',
          email: authUser.user.email,
          role: 'student',
          pin_code: newPin,
          username: username,
          last_pin_change: new Date().toISOString(),
          pin_change_by: user.id
        })
        .select('full_name, username')
        .single();
      
      if (insertError || !newProfile) {
        console.error('Error creating student profile:', insertError);
        return NextResponse.json(
          { error: 'Failed to create student profile' },
          { status: 500 }
        );
      }
      
      return NextResponse.json({
        pin_code: newPin,
        username: newProfile.username,
        studentName: newProfile.full_name,
        regenerated: true,
        newlyCreated: true
      });
    }
    
    // Generate username if it doesn't exist
    let username = student.username;
    if (!username) {
      // Generate username from name
      username = student.full_name
        .toLowerCase()
        .replace(/[^a-z0-9]/g, '') // Remove special chars
        .substring(0, 20); // Limit length
      
      // Add random suffix to ensure uniqueness
      const randomSuffix = Math.floor(100 + Math.random() * 900).toString();
      username = `${username}${randomSuffix}`;
    }
    
    // Update PIN in profiles table
    const { error: updateError } = await supabaseAdmin
      .from('profiles')
      .update({
        pin_code: newPin,
        username: username,
        last_pin_change: new Date().toISOString(),
        pin_change_by: user.id
      })
      .eq('user_id', studentId);
    
    if (updateError) {
      console.error('Error updating PIN:', updateError);
      return NextResponse.json(
        { error: 'Failed to update PIN code' },
        { status: 500 }
      );
    }
    
    return NextResponse.json({
      pin_code: newPin,
      username: username,
      studentName: student.full_name,
      regenerated: true
    });
    
  } catch (error) {
    console.error('Error regenerating PIN:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server'; // For initial auth and room check
import { createAdminClient } from '@/lib/supabase/admin';         // << IMPORT ADMIN CLIENT

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient(); // Standard client for user context
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API /teacher/students] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API /teacher/students] Authenticated user:', user.id);

    // Verify teacher owns the room using the standard client (respects RLS)
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.warn(`[API /teacher/students] Room not found (ID: ${roomId}) or teacher (ID: ${user.id}) not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }
    console.log(`[API /teacher/students] Teacher ${user.id} authorized for room ${roomId}.`);

    // Fetch memberships using the standard client (respects RLS)
    const { data: memberships, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id, joined_at')
      .eq('room_id', roomId);

    if (membershipError) {
      console.error(`[API /teacher/students] Failed to fetch room memberships for room ${roomId}:`, membershipError.message);
      return NextResponse.json(
        { error: `Failed to fetch room memberships: ${membershipError.message}` },
        { status: 500 }
      );
    }

    if (!memberships || memberships.length === 0) {
      console.log(`[API /teacher/students] No student memberships found for room ${roomId}.`);
      return NextResponse.json([]); // No students in the room
    }

    const studentIds = memberships.map(m => m.student_id);
    console.log(`[API /teacher/students] Student IDs in room ${roomId}:`, studentIds);

    // >> MODIFICATION: Use Admin Client to fetch profiles <<
    const adminSupabase = createAdminClient(); 

    const { data: profilesData, error: profilesError } = await adminSupabase
      .from('profiles')
      .select('user_id, full_name, email') // Select only necessary fields
      .in('user_id', studentIds);

    if (profilesError) {
      console.error(`[API /teacher/students] Admin client failed to fetch profiles for student IDs (${studentIds.join(', ')}):`, profilesError.message);
      // Fall through, error will be handled by studentData mapping if profilesData is null/empty
    } else {
        console.log('[API /teacher/students] Profiles data fetched with admin client:', profilesData);
    }
    
    const studentData = await Promise.all(
      memberships.map(async (membership) => {
        const profile = profilesData?.find(p => p.user_id === membership.student_id);
        
        let name = "Student"; 
        let email = "No email available";

        if (profile) {
          if (profile.full_name) name = profile.full_name;
          else if (profile.email) name = profile.email.split('@')[0]; // Fallback to email username if full_name is missing
          
          if (profile.email) email = profile.email;
        }
        console.log(`[API /teacher/students] Student ${membership.student_id} initial data from profiles: Name='${name}', Email='${email}'`);

        // Fallback to auth.admin.getUserById if profile info is still default,
        // AND if the admin client was available (service_role key is set)
        if ((name === "Student" || email === "No email available") && process.env.SUPABASE_SERVICE_ROLE_KEY) {
          console.log(`[API /teacher/students] Profile for ${membership.student_id} still default, trying auth.admin.getUserById.`);
          try {
            // Use the adminSupabase instance for auth.admin calls too
            const { data: authUserData, error: authUserError } = await adminSupabase.auth.admin.getUserById(membership.student_id);

            if (authUserError) {
              console.warn(`[API /teacher/students] auth.admin.getUserById error for student ${membership.student_id}:`, authUserError.message);
            } else if (authUserData?.user) {
              const fetchedUser = authUserData.user;
              console.log(`[API /teacher/students] auth.admin.getUserById success for ${membership.student_id}. Email: ${fetchedUser.email}, Metadata:`, fetchedUser.user_metadata);
              if (name === "Student") { // Only overwrite if still default
                if (fetchedUser.user_metadata?.full_name) name = fetchedUser.user_metadata.full_name;
                else if (fetchedUser.user_metadata?.name) name = fetchedUser.user_metadata.name;
                else if (fetchedUser.email) name = fetchedUser.email.split('@')[0];
              }
              if (email === "No email available" && fetchedUser.email) { // Only overwrite if still default
                email = fetchedUser.email;
              }
            } else {
              console.log(`[API /teacher/students] auth.admin.getUserById for ${membership.student_id} returned no user data.`);
            }
          } catch (e) {
            console.error(`[API /teacher/students] Exception calling auth.admin.getUserById for ${membership.student_id}:`, e);
          }
        }
        
        console.log(`[API /teacher/students] Final data for student ${membership.student_id}: Name='${name}', Email='${email}'`);
        return {
          user_id: membership.student_id,
          name,
          email,
          joined_at: membership.joined_at,
        };
      })
    );

    return NextResponse.json(studentData);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API /teacher/students] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to fetch students' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/restore/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function POST(request: Request) {
  try {
    // Authentication check
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Get request body
    const { studentId, roomId } = await request.json();

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Missing required fields: studentId and roomId are required' },
        { status: 400 }
      );
    }
    
    // Verify the teacher owns the room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();
    
    if (roomError || !room) {
      console.error('Room access error:', roomError);
      return NextResponse.json(
        { error: 'No permission to access this room or room not found' },
        { status: 403 }
      );
    }

    // Use admin client for the update to bypass RLS
    const adminClient = createAdminClient();
    
    // Restore the student's room membership
    const { error: restoreError } = await adminClient
      .from('room_memberships')
      .update({ 
        is_archived: false,
        updated_at: new Date().toISOString()
      })
      .eq('room_id', roomId)
      .eq('student_id', studentId);
      
    if (restoreError) {
      console.error('Error restoring student room membership:', restoreError);
      return NextResponse.json(
        { error: 'Failed to restore student room membership: ' + restoreError.message },
        { status: 500 }
      );
    }
    
    return NextResponse.json({
      success: true,
      message: 'Student successfully restored to room'
    });
    
  } catch (error) {
    console.error('Error in student restore endpoint:', error);
    return NextResponse.json(
      { error: 'Server error while processing request' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/link/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const studentId = searchParams.get('studentId');
    const roomId = searchParams.get('roomId');
    
    console.log('[Magic Link API] GET request received with params:', { studentId, roomId, url: request.url });

    if (!studentId || !roomId) {
      console.error('[Magic Link API] Missing required parameters');
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.error('[Magic Link API] Authentication error:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code, room_name')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      console.error('[Magic Link API] Room error:', roomError);
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    console.log('[Magic Link API] Found room:', room);

    // Get the student details
    const { data: profile, error: studentError } = await supabase
      .from('profiles')
      .select('full_name, email')
      .eq('user_id', studentId)
      .single();

    if (studentError || !profile) {
      console.error('[Magic Link API] Student error:', studentError);
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    console.log('[Magic Link API] Found student:', profile);

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();
    // Note: 'membership' data is not used but the check is needed to verify if student is in room

    if (membershipError) {
      console.error('[Magic Link API] Membership error:', membershipError);
      if (membershipError.code !== 'PGRST116') { // Not found
        return NextResponse.json(
          { error: 'Error checking room membership' },
          { status: 500 }
        );
      }
    }

    // Generate the magic link using the format: roomCode_userId_encodedStudentName
    const encodedName = encodeURIComponent(profile.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Teacher Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    console.log('[Magic Link API] Generated link with code:', simpleLinkCode);

    return NextResponse.json({
      magicLink,
      studentName: profile.full_name,
      code: simpleLinkCode,
      roomCode: room.room_code,
      roomName: room.room_name,
      email: profile.email
    });
  } catch (error) {
    console.error('[Magic Link API] Error generating magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { studentId, roomId } = body;
    
    console.log('[Magic Link API] POST request received with body:', { studentId, roomId });

    if (!studentId || !roomId) {
      return NextResponse.json(
        { error: 'Both studentId and roomId are required' },
        { status: 400 }
      );
    }

    // Get the teacher's authentication
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get the room to verify ownership and get room code
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code, room_name')
      .eq('room_id', roomId)
      .single();

    if (roomError || !room) {
      return NextResponse.json(
        { error: 'Room not found or you do not have permission to access it' },
        { status: 404 }
      );
    }

    // Get the student details
    const { data: profile, error: studentError } = await supabase
      .from('profiles')
      .select('full_name, email')
      .eq('user_id', studentId)
      .single();

    if (studentError || !profile) {
      return NextResponse.json({ error: 'Student not found' }, { status: 404 });
    }

    // Check if student is in the room
    const supabaseAdmin = createAdminClient();
    const { error: membershipError } = await supabaseAdmin
      .from('room_memberships')
      .select('*')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();
    // Note: 'membership' data is not used but the check is needed to verify if student is in room

    if (membershipError && membershipError.code !== 'PGRST116') {
      return NextResponse.json(
        { error: 'Error checking room membership' },
        { status: 500 }
      );
    }

    // Generate the magic link
    const encodedName = encodeURIComponent(profile.full_name);
    const simpleLinkCode = `${room.room_code}_${studentId}_${encodedName}`;
    
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Teacher Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/m/${simpleLinkCode}`;

    console.log('[Magic Link API] Regenerated link with code:', simpleLinkCode);

    return NextResponse.json({
      magicLink,
      studentName: profile.full_name,
      code: simpleLinkCode,
      roomCode: room.room_code,
      roomName: room.room_name,
      email: profile.email,
      regenerated: true
    });
  } catch (error) {
    console.error('[Magic Link API] Error regenerating magic link:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to regenerate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/room-chatbots-associations/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { UpdateRoomChatbotsPayload } from '@/types/database.types';

// GET current chatbots for a room
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');
  
  console.log(`[API GET /room-chatbots-associations] Request for roomId: ${roomId}`);

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID query parameter is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    const { data: roomChatbots, error } = await supabase
      .from('room_chatbots')
      .select('chatbot_id') 
      .eq('room_id', roomId);

    if (error) {
      console.error(`[API GET /room-chatbots-associations] Error fetching room chatbots for ${roomId}:`, error);
      return NextResponse.json({ error: 'Failed to fetch room chatbots' }, { status: 500 });
    }
    
    return NextResponse.json(roomChatbots || []); 

  } catch (error) {
    console.error('[API GET /room-chatbots-associations] Catch error:', error);
    return NextResponse.json(
      { error: 'Internal server error fetching room chatbots' },
      { status: 500 }
    );
  }
}

// PUT (update) chatbots for a room
export async function PUT(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');

  console.log(`[API PUT /room-chatbots-associations] Request for roomId: ${roomId}`);

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID query parameter is required for PUT' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const body: UpdateRoomChatbotsPayload = await request.json();

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    // Perform in a transaction if Supabase JS client supported it easily,
    // otherwise, it's two separate operations.
    const { error: deleteError } = await supabase
      .from('room_chatbots')
      .delete()
      .eq('room_id', roomId);

    if (deleteError) {
      console.error(`[API PUT /room-chatbots-associations] Error deleting existing room chatbots for ${roomId}:`, deleteError);
      return NextResponse.json({ error: 'Failed to clear existing chatbots for room', details: deleteError.message }, { status: 500 });
    }

    if (body.chatbot_ids && body.chatbot_ids.length > 0) {
      const newEntries = body.chatbot_ids.map(chatbotId => ({
        room_id: roomId,
        chatbot_id: chatbotId,
      }));
      const { error: insertError } = await supabase
        .from('room_chatbots')
        .insert(newEntries);

      if (insertError) {
        console.error(`[API PUT /room-chatbots-associations] Error inserting new room chatbots for ${roomId}:`, insertError);
        // Potentially try to rollback delete, or just report error.
        return NextResponse.json({ error: 'Failed to insert new chatbots for room', details: insertError.message }, { status: 500 });
      }
    }
    
    console.log(`[API PUT /room-chatbots-associations] Room chatbots updated successfully for ${roomId}.`);
    return NextResponse.json({ success: true, message: 'Room chatbots updated successfully' });

  } catch (error) {
    const typedError = error as Error;
    console.error('[API PUT /room-chatbots-associations] Catch error:', typedError.message);
    if (typedError instanceof SyntaxError) {
        return NextResponse.json({ error: 'Invalid JSON payload in PUT request.' }, { status: 400 });
    }
    return NextResponse.json(
      { error: typedError.message || 'Failed to update room chatbots' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/[chatbotId]/route.ts
import type { NextRequest } from 'next/server';
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { CreateChatbotPayload } from '@/types/database.types';

// For Next.js 15.3.1, we need to use any for dynamic route params
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function GET(request: NextRequest, { params }: any) {
  try {
    const { chatbotId } = params;

    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }

    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a teacher using admin client to bypass RLS
    const { data: profile } = await supabaseAdmin
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Get the chatbot using admin client to bypass RLS
    const { data: chatbot, error: fetchError } = await supabaseAdmin
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (fetchError) {
      if (fetchError.code === 'PGRST116') {
        return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
      }
      throw fetchError;
    }

    return NextResponse.json(chatbot);
  } catch (error) {
    console.error('Error in GET /api/teacher/chatbots/[chatbotId]:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch chatbot' },
      { status: 500 }
    );
  }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function PUT(request: NextRequest, { params }: any) {
  try {
    const { chatbotId } = params;

    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }

    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a teacher using admin client to bypass RLS
    const { data: profile } = await supabaseAdmin
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Verify the chatbot exists and belongs to this teacher using admin client to bypass RLS
    const { data: existingChatbot, error: fetchError } = await supabaseAdmin
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();
    
    if (fetchError) {
      if (fetchError.code === 'PGRST116') {
        return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
      }
      throw fetchError;
    }

    // Get the payload from the request
    const body: CreateChatbotPayload = await request.json();
    console.log("[API PUT /teacher/chatbots/[chatbotId]]", { chatbotId }, "Received payload for update:", body);

    // Validate required fields
    if (!body.name || !body.system_prompt) {
      return NextResponse.json({ error: 'Name and system prompt are required' }, { status: 400 });
    }
    
    if (body.bot_type === 'assessment' && (!body.assessment_criteria_text || body.assessment_criteria_text.trim() === '')) {
      return NextResponse.json({ error: 'Assessment criteria are required for assessment bots.' }, { status: 400 });
    }

    // Prepare the update data
    const updateData = {
      name: body.name,
      description: body.description || undefined,
      system_prompt: body.system_prompt,
      model: body.model || existingChatbot.model,
      max_tokens: body.max_tokens === undefined || body.max_tokens === null 
        ? existingChatbot.max_tokens 
        : Number(body.max_tokens),
      temperature: body.temperature === undefined || body.temperature === null 
        ? existingChatbot.temperature 
        : Number(body.temperature),
      enable_rag: body.bot_type === 'learning' ? (body.enable_rag || false) : false,
      bot_type: body.bot_type || existingChatbot.bot_type,
      assessment_criteria_text: body.bot_type === 'assessment' ? body.assessment_criteria_text : null,
      welcome_message: body.welcome_message || null,
      updated_at: new Date().toISOString(),
    };
    
    if (updateData.description === undefined) {
      delete updateData.description;
    }

    // Update the chatbot using admin client to bypass RLS
    const { data: updatedChatbot, error: updateError } = await supabaseAdmin
      .from('chatbots')
      .update(updateData)
      .eq('chatbot_id', chatbotId)
      .select()
      .single();

    if (updateError) {
      console.error('Error updating chatbot:', updateError);
      if (updateError.code === '23505') {
        return NextResponse.json(
          { error: 'A chatbot with this name might already exist or another unique constraint was violated.' }, 
          { status: 409 }
        );
      }
      throw updateError;
    }

    return NextResponse.json(updatedChatbot);
  } catch (error) {
    console.error('Error in PUT /api/teacher/chatbots/[chatbotId]:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to update chatbot' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/[chatbotId]/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function POST(request: NextRequest) {
  console.log("Document upload request received");
  
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Rest of the function remains the same
    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get file from formData
    const formData = await request.formData();
    console.log("FormData received:", formData);
    
    const file = formData.get('file') as File;
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("File received:", file.name, file.type, file.size);

    // Validate file type
    const fileType = getFileType(file.name);
    if (!fileType) {
      return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });
    }

    // Create storage path
    const filePath = `${user.id}/${chatbotId}/${file.name}`;
    
    // Get file buffer
    const buffer = await file.arrayBuffer();
    
    // Upload file to storage
    const { error: uploadError } = await supabase
      .storage
      .from('documents')
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: true
      });

    if (uploadError) {
      console.error("Storage upload error:", uploadError);
      return NextResponse.json({ error: `Failed to upload file: ${uploadError.message}` }, { status: 500 });
    }

    // Create document record
    const { data: document, error: documentError } = await supabase
      .from('documents')
      .insert({
        chatbot_id: chatbotId,
        file_name: file.name,
        file_path: filePath,
        file_type: fileType,
        file_size: file.size,
        status: 'uploaded'
      })
      .select()
      .single();

    if (documentError) {
      console.error("Document insert error:", documentError);
      
      // Clean up uploaded file if document record creation fails
      await supabase.storage.from('documents').remove([filePath]);
      
      return NextResponse.json({ error: `Failed to create document record: ${documentError.message}` }, { status: 500 });
    }

    return NextResponse.json({
      document: document,
      message: 'Document uploaded successfully. Processing will begin shortly.'
    });
  } catch (error) {
    console.error('Error in document upload:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to upload document' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching documents for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get all documents for this chatbot
    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 });
    }

    return NextResponse.json(documents || []);
  } catch (error) {
    console.error('Error fetching documents:', error);
    return NextResponse.json(
      { error: 'Failed to fetch documents' },
      { status: 500 }
    );
  }
}

// Helper function to determine file type
function getFileType(fileName: string): 'pdf' | 'docx' | 'txt' | null {
  const extension = fileName.split('.').pop()?.toLowerCase();
  
  switch (extension) {
    case 'pdf': return 'pdf';
    case 'docx': case 'doc': return 'docx';
    case 'txt': return 'txt';
    default: return null;
  }
}// src/app/api/teacher/chatbots/[chatbotId]/vectorize/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { processDocument as processDocumentFile } from '@/lib/document-processing/processor';
import type { Document } from '@/types/knowledge-base.types';

export async function POST(request: NextRequest) {
  console.log("[API vectorize POST] Document processing request received");

  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("[API vectorize POST] Processing for chatbot ID:", chatbotId);
    
    // Get both standard and admin clients
    const supabase = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Use admin client to verify chatbot ownership
    console.log(`[API vectorize POST] Verifying chatbot ownership: chatbotId=${chatbotId}, userId=${user.id}`);
    const { data: chatbot, error: chatbotError } = await adminSupabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .single();

    if (chatbotError) {
      console.error(`[API vectorize POST] Error finding chatbot: ${chatbotError.message}`);
      return NextResponse.json({ error: `Chatbot not found: ${chatbotError.message}` }, { status: 404 });
    }
    
    if (!chatbot) {
      console.error(`[API vectorize POST] Chatbot not found with ID: ${chatbotId}`);
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }
    
    // Check if user owns the chatbot
    if (chatbot.teacher_id !== user.id) {
      console.error(`[API vectorize POST] Authorization error: User ${user.id} is not the owner of chatbot ${chatbotId}. Owner: ${chatbot.teacher_id}`);
      return NextResponse.json({ error: 'Not authorized to process documents for this chatbot' }, { status: 403 });
    }
    
    console.log(`[API vectorize POST] Authorization successful for user ${user.id} on chatbot ${chatbotId}`);

    let body;
    try {
      body = await request.json();
    } catch (parseError) {
      console.error("[API vectorize POST] Error parsing request body:", parseError);
      return NextResponse.json({ error: 'Invalid request body format' }, { status: 400 });
    }

    const documentId = body.documentId;

    if (!documentId) {
      console.error("[API vectorize POST] Missing documentId in request body");
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    console.log(`[API vectorize POST] Looking up document: ${documentId} for chatbot: ${chatbotId}`);
    
    // Use admin client to get document
    const { data: document, error: documentError } = await adminSupabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError) {
      console.error(`[API vectorize POST] Error finding document: ${documentError.message}`);
      return NextResponse.json({ error: `Document not found: ${documentError.message}` }, { status: 404 });
    }
    
    if (!document) {
      console.error(`[API vectorize POST] Document not found with ID: ${documentId}`);
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    if (document.status === 'processing') {
      console.log(`[API vectorize POST] Document ${documentId} is already being processed`);
      return NextResponse.json({ error: 'Document is already being processed' }, { status: 400 });
    }

    console.log(`[API vectorize POST] Updating document ${documentId} status to 'processing'`);
    
    // Use admin client to update document status
    const { error: updateError } = await adminSupabase
      .from('documents')
      .update({
        status: 'processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', documentId);

    if (updateError) {
      console.error(`[API vectorize POST] Error updating document status: ${updateError.message}`);
      return NextResponse.json({ error: 'Failed to update document status' }, { status: 500 });
    }
    
    console.log(`[API vectorize POST] Document ${documentId} status updated successfully`);

    // Process in the background using the imported function
    processDocumentFile(document as Document)
      .catch(error => console.error(`Background processing error for doc ${document.document_id}:`, error));

    return NextResponse.json({ message: 'Document processing started' });
  } catch (error) {
    console.error('Error in document processing endpoint (POST):', error);
    return NextResponse.json(
      { error: 'Internal server error during POST' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  console.log("[API vectorize GET] Document processing status request received");
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("[API vectorize GET] Fetching status for chatbot ID:", chatbotId);
    
    // Get both standard and admin clients
    const supabase = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const documentId = searchParams.get('documentId');

    if (!documentId) {
      console.error("[API vectorize GET] Missing documentId parameter");
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    // Use admin client to verify chatbot ownership
    console.log(`[API vectorize GET] Verifying chatbot ownership: chatbotId=${chatbotId}, userId=${user.id}`);
    const { data: chatbot, error: chatbotError } = await adminSupabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .single();

    if (chatbotError) {
      console.error(`[API vectorize GET] Error finding chatbot: ${chatbotError.message}`);
      return NextResponse.json({ error: `Chatbot not found: ${chatbotError.message}` }, { status: 404 });
    }
    
    if (!chatbot) {
      console.error(`[API vectorize GET] Chatbot not found with ID: ${chatbotId}`);
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }
    
    // Check if user owns the chatbot
    if (chatbot.teacher_id !== user.id) {
      console.error(`[API vectorize GET] Authorization error: User ${user.id} is not the owner of chatbot ${chatbotId}. Owner: ${chatbot.teacher_id}`);
      return NextResponse.json({ error: 'Not authorized to access documents for this chatbot' }, { status: 403 });
    }

    console.log(`[API vectorize GET] Looking up document: ${documentId} for chatbot: ${chatbotId}`);
    
    // Use admin client to get document
    const { data: document, error: documentError } = await adminSupabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError) {
      console.error(`[API vectorize GET] Error finding document: ${documentError.message}`);
      return NextResponse.json({ error: `Document not found: ${documentError.message}` }, { status: 404 });
    }
    
    if (!document) {
      console.error(`[API vectorize GET] Document not found with ID: ${documentId}`);
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    console.log(`[API vectorize GET] Fetching document chunks for document: ${documentId}`);
    
    // Use admin client to fetch chunks
    const { data: allChunks, error: chunksError } = await adminSupabase
      .from('document_chunks')
      .select('status')
      .eq('document_id', documentId);

    if (chunksError) {
      console.error(`[API vectorize GET] Error fetching document chunks: ${chunksError.message}`);
      return NextResponse.json({ error: 'Failed to fetch document chunks' }, { status: 500 });
    }

    const totalChunks = allChunks?.length || 0;
    const processedChunks = allChunks?.filter(chunk => chunk.status === 'embedded').length || 0;
    const errorChunks = allChunks?.filter(chunk => chunk.status === 'error').length || 0;
    const percentComplete = totalChunks ? Math.round((processedChunks / totalChunks) * 100) : 0;

    console.log(`Status for doc ${documentId}: Total ${totalChunks}, Processed ${processedChunks}, Errors ${errorChunks}, Complete ${percentComplete}%`);

    return NextResponse.json({
      document,
      processingStats: {
        totalChunks,
        processedChunks,
        errorChunks,
        percentComplete
      }
    });
  } catch (error) {
    console.error('Error fetching processing status (GET):', error);
    return NextResponse.json(
      { error: 'Failed to fetch processing status' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { deleteChatbotVectors } from '@/lib/pinecone/utils';
import type { CreateChatbotPayload, Chatbot as DatabaseChatbot, BotTypeEnum } from '@/types/database.types'; // MODIFIED: Added BotTypeEnum

// GET Handler
export async function GET(request: NextRequest) { // MODIFIED: Added request parameter
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // IMPORTANT: We're using the admin client to bypass RLS issues
    const supabaseAdmin = createAdminClient();
    
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // MODIFIED: Extract query parameters for filtering and sorting
    const { searchParams } = new URL(request.url);
    const searchTerm = searchParams.get('searchTerm');
    const botType = searchParams.get('botType') as BotTypeEnum | null;
    const ragEnabledParam = searchParams.get('ragEnabled'); // Will be 'true' or 'false' as string
    const sortBy = searchParams.get('sortBy') || 'created_at_desc'; // Default sort

    // Use admin client instead of RLS-restricted client
    let query = supabaseAdmin
      .from('chatbots')
      .select('*')
      .eq('teacher_id', user.id);

    // Apply search term filter (searches name and description)
    if (searchTerm) {
      // Using .or() for searching in multiple columns.
      // The syntax `description.ilike.%${searchTerm}%` means description case-insensitive LIKE '%searchTerm%'
      query = query.or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`);
    }

    // Apply botType filter
    if (botType && (botType === 'learning' || botType === 'assessment')) {
      query = query.eq('bot_type', botType);
    }

    // Apply ragEnabled filter
    if (ragEnabledParam === 'true') {
      query = query.eq('enable_rag', true);
    } else if (ragEnabledParam === 'false') {
      query = query.eq('enable_rag', false);
    }

    // Apply sorting
    // Example: sortBy = "name_asc" or "created_at_desc"
    const [sortField, sortOrder] = sortBy.split('_');
    if (sortField && sortOrder && ['name', 'created_at', 'updated_at', 'bot_type'].includes(sortField)) {
      query = query.order(sortField as keyof DatabaseChatbot, { ascending: sortOrder === 'asc' });
    } else {
      // Default sort if sortBy parameter is invalid or not provided fully
      query = query.order('created_at', { ascending: false });
    }
    
    // Execute the query using admin client
    try {
      const { data: chatbots, error: fetchError } = await query;

      if (fetchError) {
        console.error('Error fetching chatbots:', fetchError);
        throw fetchError;
      }

      return NextResponse.json(chatbots || []);
    } catch (queryError) {
      console.error('Error executing chatbot query:', queryError);
      throw queryError;
    }
  } catch (error) {
    console.error('Error in GET /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch chatbots' },
      { status: 500 }
    );
  }
}

// POST Handler
export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Use admin client for all database operations to bypass RLS
    const supabaseAdmin = createAdminClient();

    const { data: profile } = await supabaseAdmin
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body: CreateChatbotPayload = await request.json();
    console.log("[API POST /teacher/chatbots] Received payload for creation:", body);

    if (!body.name || !body.system_prompt) {
        return NextResponse.json({ error: 'Name and system prompt are required' }, { status: 400 });
    }
    if (body.bot_type === 'assessment' && (!body.assessment_criteria_text || body.assessment_criteria_text.trim() === '')) {
        return NextResponse.json({ error: 'Assessment criteria are required for assessment bots.' }, { status: 400 });
    }

    const chatbotDataToInsert: Omit<DatabaseChatbot, 'chatbot_id' | 'created_at' | 'updated_at'> & { teacher_id: string } = {
      name: body.name,
      description: body.description || undefined, 
      system_prompt: body.system_prompt,
      teacher_id: user.id,
      model: body.model || 'openai/gpt-4.1-nano',
      max_tokens: body.max_tokens === undefined || body.max_tokens === null ? 1000 : Number(body.max_tokens),
      temperature: body.temperature === undefined || body.temperature === null ? 0.7 : Number(body.temperature),
      enable_rag: body.bot_type === 'learning' ? (body.enable_rag || false) : false,
      bot_type: body.bot_type || 'learning',
      assessment_criteria_text: body.bot_type === 'assessment' ? body.assessment_criteria_text : null,
      welcome_message: body.welcome_message || null, 
    };
    if (chatbotDataToInsert.description === undefined) {
        delete chatbotDataToInsert.description; 
    }

    // Use admin client for insert to bypass RLS restrictions
    const { data: newChatbot, error: insertError } = await supabaseAdmin
      .from('chatbots')
      .insert(chatbotDataToInsert)
      .select()
      .single();

    if (insertError) {
      console.error('Error creating chatbot:', insertError);
      if (insertError.code === '23505') {
         return NextResponse.json({ error: 'A chatbot with this name might already exist or another unique constraint was violated.' }, { status: 409 });
      }
      throw insertError;
    }

    return NextResponse.json(newChatbot, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create chatbot' },
      { status: 500 }
    );
  }
}


// DELETE Handler
export async function DELETE(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const chatbotId = searchParams.get('chatbotId');

    if (!chatbotId) {
        return NextResponse.json({ error: 'Chatbot ID is required as a query parameter for deletion' }, { status: 400 });
    }
    console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Request received.`);

    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();

    try {
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        // Use admin client for all DB operations to bypass RLS
        const { data: chatbot, error: fetchError } = await supabaseAdmin
            .from('chatbots')
            .select('teacher_id, name')
            .eq('chatbot_id', chatbotId)
            .single();

        if (fetchError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error fetching chatbot: ${fetchError.message}`);
            if (fetchError.code === 'PGRST116') return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
            return NextResponse.json({ error: 'Failed to fetch chatbot details' }, { status: 500 });
        }
        if (!chatbot) {
            return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
        }
        if (chatbot.teacher_id !== user.id) {
            return NextResponse.json({ error: 'Not authorized to delete this chatbot' }, { status: 403 });
        }
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] User ${user.id} authorized to delete chatbot "${chatbot.name}".`);

        const documentsFolderPath = `${user.id}/${chatbotId}/`;
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Listing files in storage path: ${documentsFolderPath}`);
        const { data: filesInStorage, error: listError } = await supabaseAdmin.storage
            .from('documents')
            .list(documentsFolderPath);

        if (listError) {
            console.warn(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error listing files in storage for cleanup: ${listError.message}`);
        } else if (filesInStorage && filesInStorage.length > 0) {
            const filePathsToRemove = filesInStorage.map(file => `${documentsFolderPath}${file.name}`);
            if (filePathsToRemove.length > 0) {
                console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Removing ${filePathsToRemove.length} files from storage.`);
                const { error: removeFilesError } = await supabaseAdmin.storage.from('documents').remove(filePathsToRemove);
                if (removeFilesError) console.warn(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error removing files from storage: ${removeFilesError.message}`);
                else console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Successfully removed files from storage.`);
            }
        }

        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Deleting chatbot record from database.`);
        const { error: deleteChatbotError } = await supabaseAdmin
            .from('chatbots')
            .delete()
            .eq('chatbot_id', chatbotId);

        if (deleteChatbotError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error deleting chatbot from database: ${deleteChatbotError.message}`);
            throw deleteChatbotError;
        }
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Chatbot record deleted from database.`);

        try {
            console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Deleting vectors from Pinecone.`);
            await deleteChatbotVectors(chatbotId);
            console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Pinecone vectors deletion initiated/completed.`);
        } catch (pineconeError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error deleting vectors from Pinecone:`, pineconeError);
        }

        return NextResponse.json({ success: true, message: `Chatbot "${chatbot.name}" and associated data deleted.` });

    } catch (error) {
        console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] General error:`, error);
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to delete chatbot' }, { status: 500 });
    }
}// src/app/api/teacher/dashboard-stats/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET() {
  console.log('\n--- [API GET /dashboard-stats] ---');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API STATS] Not authenticated.', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API STATS] User authenticated:', user.id);

    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError || !profile) {
      console.error('[API STATS] Profile fetch failed or not found:', profileError?.message);
      return NextResponse.json({ error: `Profile fetch issue: ${profileError?.message || 'Not found'}` }, { status: 500 });
    }
    if (profile.role !== 'teacher') {
      console.warn('[API STATS] User is not a teacher. Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (not a teacher)' }, { status: 403 });
    }
    console.log('[API STATS] User is teacher. Proceeding with stats.');
    
    // Create admin client to bypass RLS policies
    const supabaseAdmin = createAdminClient();
    
    // Fetch all stats concurrently using admin client
    const [
        chatbotsResult,
        roomsResult,
        activeRoomsResult,
        pendingConcernsResult
    ] = await Promise.all([
        supabaseAdmin
            .from('chatbots')
            .select('chatbot_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id),
        supabaseAdmin
            .from('rooms')
            .select('room_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id),
        supabaseAdmin
            .from('rooms')
            .select('room_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id)
            .eq('is_active', true),
        supabaseAdmin
            .from('flagged_messages')
            .select('flag_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id)
            .eq('status', 'pending') // Count only PENDING concerns
    ]);

    // Error handling for each query (optional, but good for debugging)
    if (chatbotsResult.error) console.error('[API STATS] Error fetching chatbots count:', chatbotsResult.error.message);
    if (roomsResult.error) console.error('[API STATS] Error fetching total rooms count:', roomsResult.error.message);
    if (activeRoomsResult.error) console.error('[API STATS] Error fetching active rooms count:', activeRoomsResult.error.message);
    if (pendingConcernsResult.error) console.error('[API STATS] Error fetching pending concerns count:', pendingConcernsResult.error.message);

    const stats = {
      totalChatbots: chatbotsResult.count || 0,
      totalRooms: roomsResult.count || 0,
      activeRooms: activeRoomsResult.count || 0,
      pendingConcerns: pendingConcernsResult.count || 0, // <<<< Use the actual count
    };
    
    console.log('[API STATS] Returning stats:', stats);
    return NextResponse.json(stats);

  } catch (error: unknown) {
    const typedError = error as Error;
    console.error('[API STATS] CATCH BLOCK Error:', typedError.message);
    return NextResponse.json({ error: typedError.message || 'Failed to fetch dashboard stats' }, { status: 500 });
  }
}// src/app/api/teacher/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { DocumentType, DocumentStatus } from '@/types/knowledge-base.types'; // MODIFIED: Added DocumentStatus
import { createAdminClient } from '@/lib/supabase/admin';
import { extractContentFromUrl } from '@/lib/scraping/content-extractor'; // MODIFIED: Import new utility

// Helper function to determine file type
function getFileTypeFromFile(file: File): DocumentType | null {
    const fileName = file.name;
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'pdf': return 'pdf';
        case 'doc': case 'docx': return 'docx';
        case 'txt': return 'txt';
        // 'webpage' type is handled differently
        default: return null;
    }
}

// --- GET Handler: Fetch documents for a specific chatbot ---
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const chatbotId = searchParams.get('chatbotId');

  if (!chatbotId) {
    return NextResponse.json({ error: 'Chatbot ID is required as a query parameter' }, { status: 400 });
  }
  console.log(`[API /documents GET] Request for chatbotId: ${chatbotId}`);

  try {
    const supabase = await createServerSupabaseClient(); // User-context client
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.log('[API /documents GET] Not authenticated');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Get admin client to bypass RLS
    const adminSupabase = createAdminClient();
    
    // Verify user is a teacher and owns the chatbot using admin client
    console.log(`[API /documents GET] Verifying chatbot ownership: chatbotId=${chatbotId}, userId=${user.id}`);
    const { data: chatbot, error: chatbotOwnerError } = await adminSupabase
      .from('chatbots')
      .select('chatbot_id, teacher_id') // Select teacher_id for ownership check
      .eq('chatbot_id', chatbotId)
      .single(); // Use single to ensure it exists

    if (chatbotOwnerError) {
      console.error(`[API /documents GET] Error finding chatbot: ${chatbotOwnerError.message}`);
      return NextResponse.json({ error: `Chatbot not found: ${chatbotOwnerError.message}` }, { status: 404 });
    }
    
    if (!chatbot) {
      console.error(`[API /documents GET] Chatbot not found with ID: ${chatbotId}`);
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }
    
    if (chatbot.teacher_id !== user.id) {
        console.error(`[API /documents GET] User ${user.id} does not own chatbot ${chatbotId}. Owner: ${chatbot.teacher_id}`);
        return NextResponse.json({ error: 'Not authorized to access documents for this chatbot' }, { status: 403 });
    }
    
    console.log(`[API /documents GET] Authorization successful for user ${user.id} on chatbot ${chatbotId}`);

    // Get all documents for this chatbot using admin client
    console.log(`[API /documents GET] Fetching documents for chatbot: ${chatbotId}`);
    const { data: documents, error: documentsError } = await adminSupabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      console.error('[API /documents GET] Error fetching documents from DB:', documentsError);
      return NextResponse.json({ error: 'Failed to fetch documents', details: documentsError.message }, { status: 500 });
    }

    return NextResponse.json(documents || []);

  } catch (error) {
    console.error('[API /documents GET] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch documents due to an unexpected error' },
      { status: 500 }
    );
  }
}

// --- POST Handler: Upload a new document (file or URL) for a chatbot ---
export async function POST(request: NextRequest) {
  console.log("[API /documents POST] Document/URL add request received");
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Parse request body - could be form data or JSON
    let file: File | null = null;
    let url: string | null = null;
    let chatbotId: string | null = null;
    
    // Try to parse as form data first
    try {
        const formData = await request.formData();
        file = formData.get('file') as File | null;
        url = formData.get('url') as string | null;
        chatbotId = formData.get('chatbotId') as string | null;
        
        console.log('[API /documents POST] Request parsed as FormData:', { 
            hasFile: !!file, 
            hasUrl: !!url, 
            chatbotId 
        });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (_formDataError) {
        // If not form data, try as JSON
        try {
            const jsonData = await request.json();
            url = jsonData.url || null;
            chatbotId = jsonData.chatbotId || null;
            
            console.log('[API /documents POST] Request parsed as JSON:', { 
                hasUrl: !!url, 
                chatbotId 
            });
        } catch (jsonError) {
            console.error('[API /documents POST] Failed to parse request body as FormData or JSON:', jsonError);
            return NextResponse.json({ error: 'Invalid request format' }, { status: 400 });
        }
    }

    if (!chatbotId) {
        console.error('[API /documents POST] Missing chatbotId in request');
        return NextResponse.json({ error: 'Chatbot ID not provided' }, { status: 400 });
    }
    if (!file && !url) {
        console.error('[API /documents POST] No file or URL provided');
        return NextResponse.json({ error: 'No file or URL provided' }, { status: 400 });
    }
    if (file && url) {
        console.error('[API /documents POST] Both file and URL provided');
        return NextResponse.json({ error: 'Provide either a file or a URL, not both' }, { status: 400 });
    }

    console.log(`[API /documents POST] Processing for chatbot ID: ${chatbotId}`);

    // Verify user owns the chatbot - use admin client to bypass RLS
    console.log(`[API /documents POST] Verifying chatbot ownership: chatbotId=${chatbotId}, userId=${user.id}`);
    const adminSupabase = createAdminClient();

    // First, check if the chatbot exists using admin client
    const { data: chatbot, error: chatbotOwnerError } = await adminSupabase
      .from('chatbots')
      .select('chatbot_id, teacher_id')
      .eq('chatbot_id', chatbotId)
      .single();

    if (chatbotOwnerError) {
      console.error(`[API /documents POST] Error finding chatbot: ${chatbotOwnerError.message}`, chatbotOwnerError);
      return NextResponse.json({ error: `Chatbot not found: ${chatbotOwnerError.message}` }, { status: 404 });
    }
    
    if (!chatbot) {
      console.error(`[API /documents POST] Chatbot not found with ID: ${chatbotId}`);
      return NextResponse.json({ error: 'Chatbot not found for upload/add' }, { status: 404 });
    }
    
    console.log(`[API /documents POST] Chatbot found. Owner is: ${chatbot.teacher_id}, current user: ${user.id}`);
    
    if (chatbot.teacher_id !== user.id) {
      console.error(`[API /documents POST] Authorization error: User ${user.id} is not the owner of chatbot ${chatbotId}`);
      return NextResponse.json({ error: 'Not authorized to add documents to this chatbot' }, { status: 403 });
    }
    
    console.log(`[API /documents POST] Authorization successful for user ${user.id} on chatbot ${chatbotId}`);

    let documentRecordData;

    if (file) {
        // --- File Upload Logic (Existing) ---
        console.log(`[API /documents POST] Processing file: ${file.name}`);
        const fileType = getFileTypeFromFile(file);
        if (!fileType) return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });

        const MAX_FILE_SIZE_MB = 10;
        if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
            return NextResponse.json({ error: `File too large. Maximum size is ${MAX_FILE_SIZE_MB}MB.` }, { status: 413 });
        }

        const filePath = `${user.id}/${chatbotId}/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9_.\-]/g, '_')}`;
        const buffer = await file.arrayBuffer();

        console.log(`[API /documents POST] Uploading to storage path: ${filePath}`);
        // Use admin client for storage operations to bypass RLS
        const { error: uploadError } = await adminSupabase.storage
          .from('documents')
          .upload(filePath, buffer, { contentType: file.type, upsert: false });

        if (uploadError) {
          console.error("[API /documents POST] Storage upload error:", uploadError);
          return NextResponse.json({ error: `Failed to upload file to storage: ${uploadError.message}` }, { status: 500 });
        }
        console.log(`[API /documents POST] File uploaded to storage successfully.`);

        // Use admin client for database operations
        const { data: dbDocument, error: documentInsertError } = await adminSupabase
          .from('documents')
          .insert({
            chatbot_id: chatbotId,
            file_name: file.name,
            file_path: filePath,
            file_type: fileType,
            file_size: file.size,
            status: 'uploaded' as DocumentStatus,
          })
          .select()
          .single();

        if (documentInsertError) {
          console.error("[API /documents POST] Document DB insert error (file):", documentInsertError);
          // Use admin client for storage operations to bypass RLS
          await adminSupabase.storage.from('documents').remove([filePath]);
          return NextResponse.json({ error: `Failed to create document record: ${documentInsertError.message}` }, { status: 500 });
        }
        documentRecordData = dbDocument;
        console.log(`[API /documents POST] File document record created: ${documentRecordData.document_id}`);
    } else if (url) {
        // --- URL Processing Logic (New) ---
        console.log(`[API /documents POST] Processing URL: ${url}`);
        if (!/^https?:\/\//i.test(url)) {
            return NextResponse.json({ error: 'Invalid URL format. Must start with http:// or https://' }, { status: 400 });
        }

        const extractedData = await extractContentFromUrl(url);

        if (extractedData.error || !extractedData.textContent) {
            console.error(`[API /documents POST] Error extracting content from URL ${url}:`, extractedData.error);
            return NextResponse.json({ error: extractedData.error || 'Failed to extract content from URL. The page might be inaccessible or have no readable content.' }, { status: 400 });
        }
        
        // For webpages, file_path will store the original URL with timestamp to avoid duplicate key issues.
        // file_name will store the extracted title (or a truncated URL).
        // file_size will be the length of the extracted text.
        const fileNameForDb = extractedData.title.substring(0, 255); // Max length for file_name
        const fileSizeForDb = extractedData.textContent.length;
        
        // Add timestamp to URL to avoid duplicate key constraint
        // This allows the same URL to be added multiple times
        const timestamp = Date.now();
        const uniqueFilePath = `${url}#timestamp=${timestamp}`;
        
        console.log(`[API /documents POST] Inserting webpage document record with title: "${fileNameForDb}" (${fileSizeForDb} bytes)`);
        console.log(`[API /documents POST] Using unique path: ${uniqueFilePath}`);
        
        // Create the document data with the essential fields
        // Define a proper type for document data
        interface DocumentInsertData {
            chatbot_id: string;
            file_name: string;
            file_path: string;
            file_type: DocumentType;
            file_size: number;
            status: DocumentStatus;
            original_url?: string; // Optional field
        }
        
        const documentData: DocumentInsertData = {
            chatbot_id: chatbotId,
            file_name: fileNameForDb,
            file_path: uniqueFilePath, // Store the URL with timestamp to make it unique
            file_type: 'webpage' as DocumentType,
            file_size: fileSizeForDb,
            status: 'fetched' as DocumentStatus, // New status for successfully fetched URL content
        };
        
        // Check if the original_url column exists in the table schema
        try {
            // First try to get the schema to check if the column exists
            const { data: columns, error: schemaError } = await adminSupabase
                .from('documents')
                .select('*')
                .limit(1);
                
            // If we can successfully query and the response has a shape, we can check for the column
            if (!schemaError && columns && columns.length > 0) {
                const firstRow = columns[0];
                // If original_url is present in the schema or we don't know
                // We'll try to insert it and handle any error gracefully
                if ('original_url' in firstRow || Object.keys(firstRow).length === 0) {
                    documentData.original_url = url;
                    console.log('[API /documents POST] Including original_url in document data');
                } else {
                    console.log('[API /documents POST] original_url column not found in schema, skipping');
                }
            }
        } catch (schemaCheckError) {
            console.warn('[API /documents POST] Error checking schema for original_url column:', schemaCheckError);
            // Continue without the original_url column
        }
        
        // Use admin client for database operations to bypass RLS policies
        const { data: dbDocument, error: documentInsertError } = await adminSupabase
          .from('documents')
          .insert(documentData)
          .select()
          .single();

        if (documentInsertError) {
          console.error("[API /documents POST] Document DB insert error (URL):", documentInsertError);
          return NextResponse.json({ error: `Failed to create document record for URL: ${documentInsertError.message}` }, { status: 500 });
        }
        documentRecordData = dbDocument;
        console.log(`[API /documents POST] Webpage document record created: ${documentRecordData.document_id}`);
    } else {
        // This case should not be reached due to earlier checks, but as a safeguard:
        return NextResponse.json({ error: 'No file or URL provided (safeguard).' }, { status: 400 });
    }

    // Return a consistent response format
    return NextResponse.json({
      document: documentRecordData,
      documentId: documentRecordData.document_id, // Add this explicitly for client compatibility
      message: file ? 'File uploaded successfully. Processing can now be initiated.' : 'Webpage added successfully. Processing can now be initiated.'
    }, { status: 201 });

  } catch (error) {
    console.error('[API /documents POST] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to process request due to an unexpected error' },
      { status: 500 }
    );
  }
}


// --- DELETE Handler: Delete a specific document ---
export async function DELETE(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const documentId = searchParams.get('documentId');

  if (!documentId) {
    return NextResponse.json({ error: 'Document ID is required as a query parameter' }, { status: 400 });
  }
  console.log(`[API /documents DELETE] Request for documentId: ${documentId}`);

  try {
    const supabase = await createServerSupabaseClient(); 
    const adminSupabase = createAdminClient(); 
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Use admin client consistently to bypass RLS
    const { data: document, error: docFetchError } = await adminSupabase
        .from('documents')
        .select('document_id, chatbot_id, file_path, file_type') // MODIFIED: Added file_type
        .eq('document_id', documentId)
        .single();

    if (docFetchError) {
        console.error(`[API /documents DELETE] Error finding document: ${docFetchError.message}`);
        return NextResponse.json({ error: `Document not found: ${docFetchError.message}` }, { status: 404 });
    }
    
    if (!document) {
        console.error(`[API /documents DELETE] Document not found with ID: ${documentId}`);
        return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    // Use admin client to check chatbot ownership
    const { data: chatbot, error: chatbotFetchError } = await adminSupabase
        .from('chatbots')
        .select('teacher_id')
        .eq('chatbot_id', document.chatbot_id)
        .single();
    
    if (chatbotFetchError) {
        console.error(`[API /documents DELETE] Error finding chatbot: ${chatbotFetchError.message}`);
        return NextResponse.json({ error: `Chatbot not found: ${chatbotFetchError.message}` }, { status: 404 });
    }
    
    if (!chatbot) {
        console.error(`[API /documents DELETE] Chatbot not found for document ${documentId}`);
        return NextResponse.json({ error: 'Parent chatbot not found' }, { status: 404 });
    }
    
    if (chatbot.teacher_id !== user.id) {
        console.error(`[API /documents DELETE] User ${user.id} not authorized to delete document ${documentId}. Owner: ${chatbot.teacher_id}`);
        return NextResponse.json({ error: 'Not authorized to delete this document' }, { status: 403 });
    }
    
    console.log(`[API /documents DELETE] Authorization successful for user ${user.id} to delete document ${documentId}`);

    console.log(`[API /documents DELETE] Deleting document record ${documentId} from database.`);
    const { error: dbDeleteError } = await adminSupabase
      .from('documents')
      .delete()
      .eq('document_id', documentId);

    if (dbDeleteError) {
      console.error(`[API /documents DELETE] Error deleting document record ${documentId} from DB:`, dbDeleteError);
      return NextResponse.json({ error: 'Failed to delete document record from database', details: dbDeleteError.message }, { status: 500 });
    }
    console.log(`[API /documents DELETE] Document record ${documentId} deleted from database.`);

    // Only delete from storage if it's not a 'webpage' type (where file_path contains a URL)
    if (document.file_type !== 'webpage' && document.file_path) {
        console.log(`[API /documents DELETE] Deleting file from storage: ${document.file_path}`);
        const { error: storageError } = await adminSupabase.storage.from('documents').remove([document.file_path]);
        if (storageError) {
            console.error(`[API /documents DELETE] Error deleting file ${document.file_path} from storage:`, storageError);
        } else {
            console.log(`[API /documents DELETE] File ${document.file_path} deleted from storage.`);
        }
    } else if (document.file_type === 'webpage') {
        // Extract the original URL from file_path by removing the timestamp part
        // Handle both new schema (with original_url) and old schema gracefully
        let originalUrl = 'unknown';
        
        // TypeScript type check to avoid runtime errors with optional fields
        if (document && typeof document === 'object') {
            // Check if original_url exists as a property (for new schema)
            if ('original_url' in document && document.original_url) {
                originalUrl = document.original_url as string;
            } 
            // Fallback to extracting from file_path
            else if (document.file_path) {
                const parts = document.file_path.split('#timestamp=');
                if (parts.length > 0) {
                    originalUrl = parts[0]; 
                }
            }
        }
        
        console.log(`[API /documents DELETE] Document type is 'webpage', skipping storage deletion for URL: ${originalUrl}`);
    }
    
    // TODO: Implement Pinecone vector deletion for document
    console.log(`[API /documents DELETE] TODO: Implement Pinecone vector deletion for document ${documentId}.`);


    return NextResponse.json({ success: true, message: 'Document deleted successfully' });

  } catch (error) {
    console.error('[API /documents DELETE] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to delete document due to an unexpected error' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/magic-link/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function POST(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // Verify user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Generate a signup link with embedded room code
    // For production, ensure we're using skolr.app domain
    let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
    
    // If we're in production, but the URL isn't skolr.app, force it to be
    if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
      console.log('[Room Magic Link API] Enforcing production domain for magic link');
      baseUrl = 'https://skolr.app';
    }
    
    const magicLink = `${baseUrl}/join-room?code=${room.room_code}`;

    return NextResponse.json({ 
      magicLink: magicLink,
      roomCode: room.room_code 
    });
  } catch (error) {
    console.error('Error generating magic link:', error);
    return NextResponse.json(
      { error: 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/students/import/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { parse } from 'csv-parse/sync';
import { v4 as uuidv4 } from 'uuid'; // Used for generating unique IDs in magic links
import crypto from 'crypto';

const MAX_FILE_SIZE = 1024 * 1024 * 2; // 2MB limit

// For Next.js 15.3.1, we need to use any for dynamic route params
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function POST(request: NextRequest, { params }: any) {
  try {
    console.log('[CSV Import API] Starting import process');
    
    // Need to await params in Next.js 15.3+
    const awaitedParams = await params;
    const roomId = awaitedParams.roomId;
    console.log('[CSV Import API] Room ID from params:', roomId);
    
    // Authentication
    const supabase = await createServerSupabaseClient();
    const supabaseAdmin = createAdminClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      console.log('[CSV Import API] User not authenticated');
      return new NextResponse(
        JSON.stringify({ error: 'Not authenticated' }), 
        { status: 401, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    // Verify user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('*')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.log('[CSV Import API] Room access denied:', roomError?.message);
      return new NextResponse(
        JSON.stringify({ error: 'Room not found or you do not have permission to access it' }), 
        { status: 404, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    // Parse form data
    let formData;
    try {
      formData = await request.formData();
      console.log('[CSV Import API] Form data keys:', [...formData.keys()]);
    } catch (formError) {
      console.error('[CSV Import API] Error parsing form data:', formError);
      return new NextResponse(
        JSON.stringify({ error: 'Failed to parse form data' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    // Get file from form data
    const file = formData.get('file') as File;
    if (!file) {
      console.log('[CSV Import API] No file provided');
      return new NextResponse(
        JSON.stringify({ error: 'No file provided' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    console.log('[CSV Import API] File received:', file.name, file.size, file.type);
    
    // File validations
    if (file.size > MAX_FILE_SIZE) {
      return new NextResponse(
        JSON.stringify({ error: 'File size exceeds the 2MB limit' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }

    if (file.type !== 'text/csv' && !file.name.endsWith('.csv')) {
      return new NextResponse(
        JSON.stringify({ error: 'File must be a CSV' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }

    // Process CSV
    let content = '';
    try {
      const fileBuffer = await file.arrayBuffer();
      content = new TextDecoder().decode(fileBuffer);
      console.log('[CSV Import API] File content length:', content.length);
    } catch (readError) {
      console.error('[CSV Import API] Error reading file:', readError);
      return new NextResponse(
        JSON.stringify({ error: 'Failed to read CSV file' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    // Parse CSV
    let records;
    try {
      records = parse(content, {
        columns: true,
        skip_empty_lines: true,
        trim: true,
        relax_column_count: true,
      });
      console.log('[CSV Import API] Parsed records count:', records.length);
    } catch (parseError) {
      console.error('[CSV Import API] Error parsing CSV:', parseError);
      return new NextResponse(
        JSON.stringify({ error: 'Failed to parse CSV' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    if (records.length === 0) {
      return new NextResponse(
        JSON.stringify({ error: 'CSV file is empty' }), 
        { status: 400, headers: { 'Content-Type': 'application/json' }}
      );
    }
    
    // Process students with real database operations
    const successfulImports = [];
    const failedImports = [];
    const schoolId = room.school_id;
    
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      
      // Extract student data using flexible header matching
      const fullNameKeys = Object.keys(record).filter(
        k => k.toLowerCase().includes('full name') || 
             k.toLowerCase().includes('fullname') || 
             k.toLowerCase().includes('student name') ||
             k.toLowerCase() === 'name'
      );
      
      const emailKeys = Object.keys(record).filter(
        k => k.toLowerCase().includes('email') ||
             k.toLowerCase().includes('e-mail')
      );
      
      const fullName = fullNameKeys.length > 0 ? record[fullNameKeys[0]]?.trim() || '' : '';
      const email = emailKeys.length > 0 ? record[emailKeys[0]]?.trim() || null : null;
      
      if (!fullName.trim()) {
        console.log(`[CSV Import API] Skipping row ${i+1}: Missing name`);
        failedImports.push({
          index: i,
          student: { fullName: '', email },
          error: 'Missing required full name'
        });
        continue;
      }
      
      try {
        console.log(`[CSV Import API] Processing student: ${fullName}`);
        
        // Define a student object to keep track of data
        let userId: string | undefined;
        const username = generateUsername(fullName);
        const pinCode = Math.floor(1000 + Math.random() * 9000).toString();
        
        // Step 1: Check if student with this email already exists
        if (email) {
          const { data: existingProfile } = await supabaseAdmin
            .from('profiles')
            .select('user_id')
            .eq('email', email)
            .maybeSingle();
            
          if (existingProfile) {
            userId = existingProfile.user_id;
            console.log(`[CSV Import API] Found existing user with email ${email}, user_id: ${userId}`);
          }
        }
        
        // Step 2: If no user found, create a new user
        if (!userId) {
          // Generate temp email if none provided
          const userEmail = email || `temp-${crypto.randomBytes(8).toString('hex')}@example.com`;
          
          try {
            console.log(`[CSV Import API] Creating new user for ${fullName}`);
            const { data: newUser, error: createError } = await supabaseAdmin.auth.admin.createUser({
              email: userEmail,
              email_confirm: true,
              user_metadata: { full_name: fullName, role: 'student' },
              password: crypto.randomBytes(16).toString('hex') // Random password
            });
            
            if (createError) {
              throw new Error(`Failed to create user: ${createError.message}`);
            }
            
            userId = newUser.user.id;
            console.log(`[CSV Import API] Created user with ID: ${userId}`);
            
            // Wait for triggers to process
            await new Promise(resolve => setTimeout(resolve, 500));
          } catch (createError) {
            console.error(`[CSV Import API] Error creating user:`, createError);
            throw createError;
          }
        }
        
        // Step 3: Ensure profile exists with PIN and username
        try {
          console.log(`[CSV Import API] Updating profile for ${fullName}`);
          await supabaseAdmin.from('profiles').upsert({
            user_id: userId,
            full_name: fullName,
            email: email || '',
            role: 'student',
            school_id: schoolId,
            username: username,
            pin_code: pinCode,
            last_pin_change: new Date().toISOString(),
            pin_change_by: user.id,
            updated_at: new Date().toISOString()
          }, {
            onConflict: 'user_id'
          });
        } catch (profileError) {
          console.error(`[CSV Import API] Error updating profile:`, profileError);
          // Continue anyway - this is not critical
        }
        
        // Step 4: Add student to room (if not already a member)
        try {
          // Check if already in room
          const { data: existingMembership } = await supabaseAdmin
            .from('room_memberships')
            .select('*')
            .eq('room_id', roomId)
            .eq('student_id', userId)
            .maybeSingle();
            
          if (!existingMembership) {
            console.log(`[CSV Import API] Adding ${fullName} to room ${roomId}`);
            await supabaseAdmin.from('room_memberships').insert({
              room_id: roomId,
              student_id: userId,
              joined_at: new Date().toISOString()
            });
          } else {
            console.log(`[CSV Import API] ${fullName} already in room ${roomId}`);
          }
        } catch (membershipError) {
          console.error(`[CSV Import API] Error adding to room:`, membershipError);
          throw membershipError;
        }
        
        // Step 5: Generate magic link
        // Add uuidv4 to ensure uniqueness even if same student is added multiple times
        const uniqueToken = uuidv4();
        const simpleLinkCode = `${room.room_code}_${userId}_${encodeURIComponent(fullName)}_${uniqueToken.substring(0, 8)}`;
        
        // For production, ensure we're using skolr.app domain
        let baseUrl = process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3000';
        
        // If we're in production, but the URL isn't skolr.app, force it to be
        if (process.env.NODE_ENV === 'production' && !baseUrl.includes('skolr.app')) {
          console.log('[CSV Import API] Enforcing production domain for magic link');
          baseUrl = 'https://skolr.app';
        }
        
        const magicLink = `${baseUrl}/m/${simpleLinkCode}`;
        
        // Add to successful imports
        successfulImports.push({
          fullName,
          email,
          username,
          pin_code: pinCode,
          magicLink
        });
        
      } catch (studentError) {
        console.error(`[CSV Import API] Failed to process student ${fullName}:`, studentError);
        failedImports.push({
          index: i,
          student: { fullName, email },
          error: studentError instanceof Error ? studentError.message : 'Unknown error'
        });
      }
    }
    
    // Return response with both successful and failed imports
    return new NextResponse(
      JSON.stringify({
        success: true,
        students: successfulImports,
        count: successfulImports.length,
        totalAttempted: records.length,
        failedImports: failedImports
      }), 
      { 
        status: 200, 
        headers: { 
          'Content-Type': 'application/json',
          'Cache-Control': 'no-cache, no-store, must-revalidate'
        }
      }
    );
    
  } catch (error) {
    console.error('[CSV Import API] Error:', error);
    
    return new NextResponse(
      JSON.stringify({ 
        error: error instanceof Error ? error.message : 'Failed to import students',
        errorType: error instanceof Error ? error.name : 'Unknown'
      }), 
      { 
        status: 500, 
        headers: { 'Content-Type': 'application/json' }
      }
    );
  }
}

function generateUsername(fullName: string): string {
  // Remove special characters and convert to lowercase
  const cleanName = fullName.toLowerCase().replace(/[^a-z0-9]/g, '');
  
  // Add a random suffix to ensure uniqueness (3 digits)
  const randomSuffix = Math.floor(100 + Math.random() * 900).toString();
  
  return cleanName + randomSuffix;
}// src/app/api/teacher/rooms/[roomId]/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function PATCH(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { is_active } = await request.json();
    const params = await context.params;
    const roomId = params.roomId;

    // Update room status
    const { data: room, error } = await supabase
      .from('rooms')
      .update({ is_active })
      .eq('room_id', roomId)
      .eq('teacher_id', user.id) // Ensure only the room owner can update
      .select()
      .single();

    if (error) {
      throw error;
    }

    if (!room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    return NextResponse.json(room);
  } catch (error) {
    console.error('Error updating room:', error);
    return NextResponse.json(
      { error: 'Failed to update room' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // First, check if the user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Delete the room (this will cascade to related tables via foreign key constraints)
    const { error: deleteError } = await supabase
      .from('rooms')
      .delete()
      .eq('room_id', roomId)
      .eq('teacher_id', user.id);

    if (deleteError) {
      throw deleteError;
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting room:', error);
    return NextResponse.json(
      { error: 'Failed to delete room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/archive/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function POST(request: Request) {
  try {
    // Authentication check
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Get request body
    const { roomId, archive = true } = await request.json();

    if (!roomId) {
      return NextResponse.json(
        { error: 'Missing required field: roomId is required' },
        { status: 400 }
      );
    }
    
    // Verify the teacher owns the room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();
    
    if (roomError || !room) {
      console.error('Room access error:', roomError);
      return NextResponse.json(
        { error: 'No permission to access this room or room not found' },
        { status: 403 }
      );
    }

    // Use admin client for the update to bypass RLS
    const adminClient = createAdminClient();
    
    // Archive or restore the room
    const { error: archiveError } = await adminClient
      .from('rooms')
      .update({ 
        is_archived: archive,
        updated_at: new Date().toISOString()
      })
      .eq('room_id', roomId);
      
    if (archiveError) {
      console.error(`Error ${archive ? 'archiving' : 'restoring'} room:`, archiveError);
      return NextResponse.json(
        { error: `Failed to ${archive ? 'archive' : 'restore'} room: ` + archiveError.message },
        { status: 500 }
      );
    }
    
    return NextResponse.json({
      success: true,
      message: `Room successfully ${archive ? 'archived' : 'restored'}`
    });
    
  } catch (error) {
    console.error('Error in room archive/restore endpoint:', error);
    return NextResponse.json(
      { error: 'Server error while processing request' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { generateRoomCode } from '@/lib/utils/room-codes';
import type { CreateRoomPayload, TeacherRoom } from '@/types/database.types';
import type { PostgrestError } from '@supabase/supabase-js'; // Import for better error typing

// GET all rooms for the teacher
export async function GET(request: NextRequest) {
  console.log('[API GET /rooms] Received request.');
  try {
    const { searchParams } = new URL(request.url);
    const includeArchived = searchParams.get('includeArchived') === 'true';
    const archivedOnly = searchParams.get('archivedOnly') === 'true';
    
    console.log(`[API GET /rooms] Query params: includeArchived=${includeArchived}, archivedOnly=${archivedOnly}`);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API GET /rooms] User authenticated by getUser:', {
        id: user.id,
        email: user.email,
        aud: user.aud,
        role: user.role
    });

    console.log('[API GET /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileError) {
      console.error('[API GET /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileError, null, 2));
      console.warn('[API GET /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileError.message);
      return NextResponse.json({ error: `User profile not found or error fetching it. Details: ${profileError.message}` }, { status: 403 });
    }

    if (!profile) {
      console.warn('[API GET /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
      return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }

    console.log('[API GET /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API GET /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }

    console.log('[API GET /rooms] User is confirmed teacher. Fetching rooms.');
    
    // Use the admin client to bypass RLS policy issues completely
    const supabaseAdmin = createAdminClient();
    
    // Get basic room data first, bypassing RLS completely
    let query = supabaseAdmin
      .from('rooms')
      .select('*')
      .eq('teacher_id', user.id);
      
    // Apply archive filtering based on query parameters
    if (archivedOnly) {
      query = query.eq('is_archived', true);
    } else if (!includeArchived) {
      query = query.eq('is_archived', false);
    }
    
    // Always order by creation date
    query = query.order('created_at', { ascending: false });
    
    const { data: rooms, error: fetchError } = await query;

    if (fetchError) {
      console.error('[API GET /rooms] Error fetching rooms from DB:', fetchError);
      throw fetchError;
    }
    
    // Now fetch associated chatbots separately, also bypassing RLS
    if (rooms && rooms.length > 0) {
      const roomIds = rooms.map(room => room.room_id);
      
      // Get chatbot associations, also using admin client
      const { data: roomChatbots, error: chatbotError } = await supabaseAdmin
        .from('room_chatbots')
        .select(`
          room_id,
          chatbot_id,
          chatbots (chatbot_id, name)
        `)
        .in('room_id', roomIds);
        
      if (chatbotError) {
        console.error('[API GET /rooms] Error fetching room chatbots:', chatbotError);
        // Continue despite error - we'll return rooms without chatbot data
      } else if (roomChatbots) {
        // Manually structure the data to match the previous nested query result
        rooms.forEach(room => {
          const chatbotsForRoom = roomChatbots.filter(rc => rc.room_id === room.room_id);
          room.room_chatbots = chatbotsForRoom;
        });
      }
    }
    
    console.log(`[API GET /rooms] Successfully fetched ${rooms?.length || 0} rooms.`);
    return NextResponse.json(rooms || []);

  } catch (error) {
    // Attempt to type error as PostgrestError or a generic Error
    const typedError = error as PostgrestError | Error;
    let code: string | undefined;
    let details: string | undefined;
    let hint: string | undefined;

    if ('code' in typedError && typeof typedError.code === 'string') {
        code = typedError.code;
    }
    if ('details' in typedError && typeof typedError.details === 'string') {
        details = typedError.details;
    }
     if ('hint' in typedError && typeof typedError.hint === 'string') {
        hint = typedError.hint;
    }

    console.error('[API GET /rooms] CATCH BLOCK Error:',
        typedError.message,
        'Code:', code,
        'Details:', details,
        'Hint:', hint
    );
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}

// POST a new room - V-ROBUST Version
export async function POST(request: Request) {
  console.log('[API POST /rooms] V-ROBUST Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API POST /rooms] V-ROBUST - Not authenticated');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API POST /rooms] V-ROBUST - User authenticated:', user.id);

    const { data: profile, error: profileFetchError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileFetchError || !profile) {
        console.error('[API POST /rooms] V-ROBUST - Profile fetch error or no profile:', profileFetchError);
        return NextResponse.json({ error: 'Profile error or profile not found while creating room.' }, { status: 500 });
    }
    if (profile.role !== 'teacher') {
        console.warn('[API POST /rooms] V-ROBUST - User not a teacher');
        return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    console.log('[API POST /rooms] V-ROBUST - Profile fetched:', profile);

    const body: CreateRoomPayload = await request.json();
    console.log('[API POST /rooms] V-ROBUST - Request body:', body);

    if (!body.room_name || !body.chatbot_ids || !Array.isArray(body.chatbot_ids) || body.chatbot_ids.length === 0) {
      console.warn('[API POST /rooms] V-ROBUST - Invalid request body: Missing room_name or chatbot_ids.');
      return NextResponse.json({ error: 'Room name and at least one chatbot ID are required' }, { status: 400 });
    }

    let roomCode = '';
    let attempts = 0;
    const MAX_ATTEMPTS = 10;
    let newRoomData = null;

    console.log('[API POST /rooms] V-ROBUST - Attempting to generate unique room code and insert...');
    while (attempts < MAX_ATTEMPTS && !newRoomData) {
      roomCode = generateRoomCode();
      attempts++;
      console.log(`[API POST /rooms] V-ROBUST - Attempt #${attempts} with roomCode: ${roomCode}`);

      const { data, error: insertError } = await supabase
        .from('rooms')
        .insert({
          room_name: body.room_name,
          room_code: roomCode,
          teacher_id: user.id,
          school_id: profile.school_id,
          is_active: true,
        })
        .select()
        .single();

      if (insertError) {
        // insertError should be PostgrestError if it's a Supabase/PostgREST error
        if (insertError.code === '23505' && insertError.message.includes('rooms_room_code_key')) {
          console.warn(`[API POST /rooms] V-ROBUST - Room code ${roomCode} collision on attempt #${attempts}. Retrying...`);
          if (attempts >= MAX_ATTEMPTS) {
            console.error('[API POST /rooms] V-ROBUST - Failed to generate unique room code after multiple insert attempts.');
            throw new Error('Failed to generate a unique room code due to repeated collisions.');
          }
          // Continue to the next iteration of the loop to generate a new code
        } else {
          console.error('[API POST /rooms] V-ROBUST - Error inserting into "rooms" table (non-collision):', JSON.stringify(insertError, null, 2));
          throw insertError; // Throw this error to be caught by the outer catch block
        }
      } else {
        newRoomData = data;
        // Use non-null assertion because if data is not null, room_id should exist
        console.log(`[API POST /rooms] V-ROBUST - Room inserted successfully on attempt #${attempts}. Room ID: ${newRoomData!.room_id}`);
      }
    }

    if (!newRoomData) {
        console.error('[API POST /rooms] V-ROBUST - Could not create room after max attempts for room code generation.');
        throw new Error('Failed to create room after multiple attempts to find a unique room code.');
    }

    console.log('[API POST /rooms] V-ROBUST - Preparing to insert into "room_chatbots" table for room ID:', newRoomData.room_id);
    const roomChatbotEntries = body.chatbot_ids.map(chatbotId => ({
      room_id: newRoomData!.room_id,
      chatbot_id: chatbotId,
    }));

    const { error: rcInsertError } = await supabase
      .from('room_chatbots')
      .insert(roomChatbotEntries);

    if (rcInsertError) {
      console.error('[API POST /rooms] V-ROBUST - Error inserting into "room_chatbots":', rcInsertError);
      console.log(`[API POST /rooms] V-ROBUST - Attempting to rollback room creation for room ID: ${newRoomData!.room_id} due to room_chatbots insert failure.`);
      const { error: deleteError } = await supabase.from('rooms').delete().eq('room_id', newRoomData!.room_id);
      if (deleteError) {
          console.error(`[API POST /rooms] V-ROBUST - CRITICAL: Failed to rollback room ${newRoomData!.room_id} after room_chatbots insert error:`, deleteError);
      } else {
          console.log(`[API POST /rooms] V-ROBUST - Successfully rolled back room ${newRoomData!.room_id}.`);
      }
      throw rcInsertError;
    }
    console.log(`[API POST /rooms] V-ROBUST - Successfully inserted ${roomChatbotEntries.length} entries into "room_chatbots".`);

    console.log('[API POST /rooms] V-ROBUST - Fetching complete room data for response.');
    const { data: completeRoomData, error: fetchCompleteError } = await supabase
        .from('rooms')
        .select(`
            *,
            room_chatbots (
              chatbots ( chatbot_id, name )
            )
        `)
        .eq('room_id', newRoomData!.room_id)
        .single();

    if (fetchCompleteError) {
        console.error('[API POST /rooms] V-ROBUST - Error fetching complete room data after creation:', fetchCompleteError);
        throw fetchCompleteError;
    }
    if (!completeRoomData) {
        console.error('[API POST /rooms] V-ROBUST - Failed to fetch complete room data after creation, though room should exist.');
        throw new Error('Failed to retrieve newly created room details.');
    }

    console.log('[API POST /rooms] V-ROBUST - Room creation successful. Returning complete room data.');
    return NextResponse.json(completeRoomData as TeacherRoom, { status: 201 });

  } catch (error) {
    // Type guard to check if error is a PostgrestError or at least has common error properties
    let code: string | undefined;
    let details: string | undefined;
    let hint: string | undefined;
    let constraint: string | undefined;
    let message = 'An unknown error occurred';

    if (error && typeof error === 'object') {
        if ('message' in error && typeof error.message === 'string') {
            message = error.message;
        }
        if ('code' in error && typeof error.code === 'string') {
            code = error.code;
        }
        if ('details' in error && typeof error.details === 'string') {
            details = error.details;
        }
        if ('hint' in error && typeof error.hint === 'string') {
            hint = error.hint;
        }
        if ('constraint' in error && typeof error.constraint === 'string') {
            constraint = error.constraint;
        }
    } else if (error instanceof Error) {
        message = error.message;
    }


    console.error('[API POST /rooms] V-ROBUST - CATCH BLOCK Error:',
        message,
        'Code:', code,
        'Details:', details,
        'Hint:', hint,
        'Constraint:', constraint
    );

    let statusCode = 500;
    if (code === '23505' && constraint === 'rooms_room_code_key') {
        statusCode = 409;
    } else if (code === '42501') {
        statusCode = 403;
    }

    return NextResponse.json(
      {
        error: message || 'Failed to create room',
        code: code,
        details: details,
        hint: hint
      },
      { status: statusCode }
    );
  }
}// src/app/api/teacher/concerns/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin'; // << IMPORT ADMIN CLIENT
import type { FlaggedMessage, ConcernStatus, Profile, Room, ChatMessage as DatabaseChatMessage } from '@/types/database.types';
import { PostgrestError, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

// Intermediate type - Simpler, as we'll fetch student profiles separately
type RawFlaggedMessage = FlaggedMessage & {
    // No 'student' field here initially
    room: Pick<Room, 'room_name'> | null;
    message: Pick<DatabaseChatMessage, 'content' | 'created_at' | 'metadata'> | null;
};

interface FlaggedConcernListDetails extends FlaggedMessage {
    student_name: string | null;
    student_email: string | null;
    room_name: string | null;
    message_content: string | null;
}
// ... (FlagDetailsResponse and getSingleConcernDetails can remain mostly as is, but getSingleConcernDetails will also use admin client for student profile)
interface FlagDetailsResponse extends FlaggedMessage {
    student: null;
    student_name: string | null;
    student_email: string | null;
    room_name: string;
    message_content: string;
    message: DatabaseChatMessage | null;
    surroundingMessages: DatabaseChatMessage[];
}


export async function GET(request: NextRequest) {
    console.log('[API GET /concerns] Received request.');
    try {
        const supabase = await createServerSupabaseClient(); // Standard client for user context
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) { /* ... auth checks ... */ 
            console.warn('[API GET /concerns] Not authenticated.');
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }
        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
        if (profileError || !profile || profile.role !== 'teacher') {
            console.warn('[API GET /concerns] User profile/role issue.');
            return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
        }
        console.log(`[API GET /concerns] Authenticated teacher: ${user.id}`);

        const { searchParams } = new URL(request.url);
        const flagId = searchParams.get('flagId');
        
        if (flagId) {
            console.log(`[API GET /concerns] Fetching single concern details for flagId: ${flagId}`);
            // Modify getSingleConcernDetails to use admin client for student profile
            return await getSingleConcernDetails_V2(supabase, flagId, user.id); 
        }
        
        const statusFilter = searchParams.get('status');
        const limit = parseInt(searchParams.get('limit') || '10', 10);
        const page = parseInt(searchParams.get('page') || '0', 10);
        const offset = page * limit;

        console.log(`[API GET /concerns] Fetching concerns list. Status: ${statusFilter || 'all'}, Page: ${page}, Limit: ${limit}`);

        let countQuery = supabase
            .from('flagged_messages')
            .select('*', { count: 'exact', head: true })
            .eq('teacher_id', user.id);

        // Fetch flagged_messages with joins to rooms and chat_messages, but NOT profiles yet
        let dataQuery = supabase
            .from('flagged_messages')
            .select(`
                *, 
                room:rooms!fk_room(room_name),
                message:chat_messages!fk_message(content, created_at, metadata)
            `)
            .eq('teacher_id', user.id) // RLS on flagged_messages will handle this
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);

        if (statusFilter && ['pending', 'reviewing', 'resolved', 'false_positive'].includes(statusFilter)) {
            countQuery = countQuery.eq('status', statusFilter);
            dataQuery = dataQuery.eq('status', statusFilter);
        }

        const [countResult, dataResult] = await Promise.all([countQuery, dataQuery]);

        const { count, error: countError } = countResult;
        const { data: rawFlagsData, error: fetchError } = dataResult as { data: RawFlaggedMessage[] | null, error: PostgrestError | null };

        if (countError) console.warn('[API GET /concerns] Error fetching concerns count:', countError.message);
        if (fetchError) {
            console.error('[API GET /concerns] Error fetching base flagged messages data:', fetchError);
            throw new Error(`Failed to fetch flagged messages: ${fetchError.message}`);
        }

        if (!rawFlagsData || rawFlagsData.length === 0) {
            console.log('[API GET /concerns] No raw flags found.');
            return NextResponse.json({ concerns: [], pagination: { currentPage: page, pageSize: limit, totalCount: 0, totalPages: 0, hasMore: false } });
        }

        // Get unique student IDs from the fetched flags
        const studentIds = [...new Set(rawFlagsData.map(flag => flag.student_id).filter(id => id != null))] as string[];
        const studentProfilesMap: Map<string, Pick<Profile, 'full_name' | 'email'>> = new Map();

        if (studentIds.length > 0) {
            console.log('[API GET /concerns] Fetching profiles for student IDs:', studentIds);
            const adminSupabase = createAdminClient();
            const { data: profilesData, error: profilesError } = await adminSupabase
                .from('profiles')
                .select('user_id, full_name, email')
                .in('user_id', studentIds);

            if (profilesError) {
                console.error('[API GET /concerns] Admin client error fetching student profiles:', profilesError.message);
                // Proceed without student names if this fails, or handle error more gracefully
            } else if (profilesData) {
                profilesData.forEach(p => studentProfilesMap.set(p.user_id, { full_name: p.full_name, email: p.email }));
            }
        }

        // Map raw flags to the detailed response, adding student info
        const concerns: FlaggedConcernListDetails[] = rawFlagsData.map((flag: RawFlaggedMessage) => {
            const studentProfile = flag.student_id ? studentProfilesMap.get(flag.student_id) : null;
            return {
                ...flag,
                student_name: studentProfile?.full_name || 'Unknown Student',
                student_email: studentProfile?.email || null,
                room_name: flag.room?.room_name || 'Unknown Room',
                message_content: flag.message?.content || '[Message Content Unavailable]',
            };
        });

        const totalCount = count || 0;
        const hasMore = (offset + concerns.length) < totalCount;
        const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;

        console.log(`[API GET /concerns] Processed ${concerns.length} concerns for page ${page}, total: ${totalCount}`);
        return NextResponse.json({
            concerns,
            pagination: { currentPage: page, pageSize: limit, totalCount, totalPages, hasMore }
        });

    } catch (error) { /* ... error handling ... */ 
        console.error('[API GET /concerns] CATCH BLOCK Error:', error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'An internal error occurred while fetching concerns.' },
            { status: 500 }
        );
    }
}


// Modified getSingleConcernDetails to use Admin Client for student profile
async function getSingleConcernDetails_V2(
    supabaseUserClient: SupabaseClient<Database>, // User-context client for initial flag fetch
    flagId: string,
    teacherId: string
): Promise<NextResponse> {
    try {
        console.log(`[API getSingleConcernDetails_V2] Fetching details for concern flag ID: ${flagId}`);
        
        // Fetch the main flag data (without student profile yet)
        const { data: flag, error: flagError } = await supabaseUserClient
            .from('flagged_messages')
            .select(`
                *, 
                room:rooms!fk_room(room_name),
                message:chat_messages!fk_message(*)
            `)
            .eq('flag_id', flagId)
            .eq('teacher_id', teacherId) // Ensures teacher owns the flag
            .single();
            
        if (flagError) { /* ... error handling for flag fetch ... */ 
            console.error(`[API getSingleConcernDetails_V2] Error fetching flag ${flagId}:`, flagError);
            if (flagError.code === 'PGRST116') {
                 return NextResponse.json({ error: 'Concern not found or not authorized' }, { status: 404 });
            }
            throw flagError;
        }
        if (!flag) { return NextResponse.json({ error: 'Concern not found' }, { status: 404 }); }
        
        // Cast to a working type, student profile will be added
        const typedFlag = flag as unknown as (FlaggedMessage & { 
            room: Pick<Room, 'room_name'> | null; 
            message: DatabaseChatMessage | null;
        });

        let studentName: string | null = 'Unknown Student';
        let studentEmail: string | null = null;

        if (typedFlag.student_id) {
            const adminSupabase = createAdminClient();
            const { data: studentProfileData, error: studentProfileError } = await adminSupabase
                .from('profiles')
                .select('full_name, email')
                .eq('user_id', typedFlag.student_id)
                .single();
            if (studentProfileError) {
                console.warn(`[API getSingleConcernDetails_V2] Admin client error fetching student profile ${typedFlag.student_id}:`, studentProfileError.message);
            } else if (studentProfileData) {
                studentName = studentProfileData.full_name || studentName;
                studentEmail = studentProfileData.email || studentEmail;
            }
        }

        // Make sure we have a good analysis_explanation if it's missing or contains an API error
        let analysis = typedFlag.analysis_explanation || "";
        
        // Check if the analysis contains an API error
        if (!analysis || analysis.includes("OpenRouter API error") || analysis.includes("Failed to fetch")) {
            // Set a more user-friendly explanation based on concern type
            const readableConcernType = typedFlag.concern_type ? 
                typedFlag.concern_type.replace(/_/g, ' ') : 
                'potential safety';
                
            analysis = `This message was flagged due to ${readableConcernType} concerns. Please review the conversation context and take appropriate action if needed.`;
        }
        
        const response: FlagDetailsResponse = {
            ...typedFlag,
            student: null, // Not fetching the full student object in this structure anymore, using flattened names
            student_name: studentName,
            student_email: studentEmail,
            room_name: typedFlag.room?.room_name || 'Unknown Room',
            message_content: typedFlag.message?.content || '[Message Content Unavailable]',
            message: typedFlag.message,
            // Always provide a valid analysis_explanation 
            analysis_explanation: analysis,
            surroundingMessages: [] // Populate this as before
        };
        
        // Fetch surrounding messages (logic remains similar, ensure chatMessageRoomId is correct)
        if (typedFlag.message && typedFlag.message.room_id && typedFlag.student_id) {
            const messageCreatedAt = typedFlag.message.created_at;
            const studentId = typedFlag.student_id;
            const chatMessageRoomId = typedFlag.message.room_id; // TEXT room_id from chat_messages
            const messageChatbotId = typedFlag.message.metadata?.chatbotId || null;

            const { data: messagesData, error: messagesError } = await supabaseUserClient // Use user client for chat history
                .from('chat_messages')
                .select<string, DatabaseChatMessage>("*") 
                .eq('room_id', chatMessageRoomId) 
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', messageChatbotId ? 'eq' : 'is', messageChatbotId || null)
                .lt('created_at', messageCreatedAt) 
                .order('created_at', { ascending: false })
                .limit(5); 
            
            const { data: messagesDataAfter, error: messagesErrorAfter } = await supabaseUserClient
                .from('chat_messages')
                .select<string, DatabaseChatMessage>("*")
                .eq('room_id', chatMessageRoomId) 
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', messageChatbotId ? 'eq' : 'is', messageChatbotId || null)
                .gt('created_at', messageCreatedAt) 
                .order('created_at', { ascending: true })
                .limit(5); 

            if (messagesError || messagesErrorAfter) {
                console.warn(`[API getSingleConcernDetails_V2] Error fetching conversation context for flag ${flagId}:`, messagesError || messagesErrorAfter);
            } else {
                const beforeMessages = (messagesData || []).reverse(); 
                const afterMessages = messagesDataAfter || [];
                const mainFlaggedMessageTyped = typedFlag.message as DatabaseChatMessage;
                response.surroundingMessages = [...beforeMessages, mainFlaggedMessageTyped, ...afterMessages].filter(Boolean);
            }
        }
        
        console.log(`[API getSingleConcernDetails_V2] Successfully fetched details for flag ${flagId}`);
        return NextResponse.json(response);
        
    } catch (error) { /* ... error handling ... */ 
        console.error(`[API getSingleConcernDetails_V2] CATCH for flag ${flagId}:`, error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Failed to fetch concern details' },
            { status: 500 }
        );
    }
}

// PATCH handler remains the same, as it operates on flagged_messages directly
// and RLS for UPDATE on flagged_messages already checks teacher_id.
export async function PATCH(request: NextRequest) {
    console.log('[API PATCH /concerns] Received request.');
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            console.warn('[API PATCH /concerns] Not authenticated.');
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
        if (!profile || profile.role !== 'teacher') {
            console.warn('[API PATCH /concerns] User not a teacher or profile error.');
            return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
        }

        const body = await request.json();
        const { flagId, status, notes } = body;

        if (!flagId) {
            return NextResponse.json({ error: 'Flag ID is required' }, { status: 400 });
        }

        const validStatuses: ConcernStatus[] = ['pending', 'reviewing', 'resolved', 'false_positive'];
        if (!status || !validStatuses.includes(status as ConcernStatus)) {
            return NextResponse.json({ error: `Invalid status provided: ${status}` }, { status: 400 });
        }
        
        if (notes !== undefined && notes !== null && typeof notes !== 'string') {
            return NextResponse.json({ error: 'Invalid notes format, must be a string or null.' }, { status: 400 });
        }

        console.log(`[API PATCH /concerns] Updating flag ${flagId} by teacher ${user.id} to status: ${status}`);

        const updateData: Partial<FlaggedMessage> = {
            status: status as ConcernStatus,
            updated_at: new Date().toISOString(),
            reviewer_id: user.id,
            reviewed_at: new Date().toISOString(),
        };
        if (notes !== undefined) {
            updateData.notes = notes === '' ? null : notes;
        }

        const { data: updatedFlag, error: updateError } = await supabase
            .from('flagged_messages')
            .update(updateData)
            .eq('flag_id', flagId)
            .eq('teacher_id', user.id)
            .select()
            .single();

        if (updateError) {
            console.error(`[API PATCH /concerns] Error updating flag ${flagId}:`, updateError);
            if (updateError.code === 'PGRST116') {
                return NextResponse.json({ error: 'Update failed: Flag not found or permission denied' }, { status: 404 });
            }
            throw updateError;
        }

        if (!updatedFlag) {
            return NextResponse.json({ error: 'Flag not found or update failed post-operation' }, { status: 404 });
        }

        console.log(`[API PATCH /concerns] Flag ${flagId} updated successfully.`);
        return NextResponse.json(updatedFlag);

    } catch (error) { 
        console.error(`[API PATCH /concerns] CATCH BLOCK Error:`, error); 
        return NextResponse.json({ 
            error: error instanceof Error ? error.message : 'Failed to update concern status' 
        }, { status: 500 }); 
    }
}// src/app/api/teacher/room-details/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin'; // For fetching student profiles

export async function GET(request: NextRequest) {
  console.log('[API GET /teacher/room-details] Received request.');
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');

    if (!roomId) {
      console.warn('[API GET /teacher/room-details] roomId query parameter is missing.');
      return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
    }
    console.log(`[API GET /teacher/room-details] Processing for roomId: ${roomId}`);

    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /teacher/room-details] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: teacherProfile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError || !teacherProfile) {
      console.warn(`[API GET /teacher/room-details] Profile not found or error for user ${user.id}:`, profileError?.message);
      return NextResponse.json({ error: 'User profile not found or error fetching it.' }, { status: 403 });
    }
    if (teacherProfile.role !== 'teacher') {
      console.warn(`[API GET /teacher/room-details] User ${user.id} is not a teacher. Role: ${teacherProfile.role}`);
      return NextResponse.json({ error: 'Not authorized (user is not a teacher)' }, { status: 403 });
    }
    console.log(`[API GET /teacher/room-details] User ${user.id} authenticated as teacher.`);

    // Fetch room details and verify ownership
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select('*') // Select all room fields
      .eq('room_id', roomId)
      .eq('teacher_id', user.id) // RLS also enforces this, but explicit check is good
      .single();

    if (roomError || !roomData) {
      console.warn(`[API GET /teacher/room-details] Room ${roomId} not found or teacher ${user.id} not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }
    console.log(`[API GET /teacher/room-details] Room ${roomId} details fetched.`);

    // Fetch assigned chatbots
    const { data: roomChatbotsData, error: roomChatbotsError } = await supabase
      .from('room_chatbots')
      .select('chatbots (chatbot_id, name, description, bot_type)') // Include description and bot_type
      .eq('room_id', roomId);

    if (roomChatbotsError) {
      console.error(`[API GET /teacher/room-details] Error fetching chatbots for room ${roomId}:`, roomChatbotsError.message);
      // Don't fail the whole request, proceed with empty chatbots array
    }
    const assignedChatbots = roomChatbotsData?.map(rc => rc.chatbots).filter(Boolean) || [];
    console.log(`[API GET /teacher/room-details] Fetched ${assignedChatbots.length} assigned chatbots for room ${roomId}.`);


    // Get query parameter to include archived students
    const includeArchived = searchParams.get('includeArchived') === 'true';
    const archivedOnly = searchParams.get('archivedOnly') === 'true';
    
    console.log(`[API GET /teacher/room-details] Query params: includeArchived=${includeArchived}, archivedOnly=${archivedOnly}`);
    
    // Fetch student memberships with archive filtering
    let membershipQuery = supabase
      .from('room_memberships')
      .select('student_id, joined_at, is_archived')
      .eq('room_id', roomId);
      
    // Apply archive filtering based on query parameters  
    if (archivedOnly) {
      membershipQuery = membershipQuery.eq('is_archived', true);
    } else if (!includeArchived) {
      membershipQuery = membershipQuery.eq('is_archived', false);
    }
    
    const { data: memberships, error: membershipError } = await membershipQuery;

    if (membershipError) {
      console.error(`[API GET /teacher/room-details] Error fetching student memberships for room ${roomId}:`, membershipError.message);
      return NextResponse.json({ error: 'Failed to fetch student memberships' }, { status: 500 });
    }

    interface StudentInRoom {
        user_id: string;
        full_name: string;
        email: string;
        joined_at: string;
        is_archived?: boolean;
    }

    let studentsInRoom: StudentInRoom[] = [];
    if (memberships && memberships.length > 0) {
      const studentIds = memberships.map(m => m.student_id);
      console.log(`[API GET /teacher/room-details] Found ${studentIds.length} student IDs in room ${roomId}.`);

      const adminSupabase = createAdminClient();
      const { data: profilesData, error: profilesError } = await adminSupabase
        .from('profiles')
        .select('user_id, full_name, email')
        .in('user_id', studentIds);

      if (profilesError) {
        console.error(`[API GET /teacher/room-details] Admin client error fetching student profiles:`, profilesError.message);
        // Proceed, but student names/emails might be missing
      }

      studentsInRoom = memberships.map(membership => {
        const profile = profilesData?.find(p => p.user_id === membership.student_id);
        return {
          user_id: membership.student_id,
          full_name: profile?.full_name || 'Student', // Fallback name
          email: profile?.email || 'No email',       // Fallback email
          joined_at: membership.joined_at,
          is_archived: membership.is_archived || false
        };
      });
      console.log(`[API GET /teacher/room-details] Processed student profile data for room ${roomId}.`);
    } else {
      console.log(`[API GET /teacher/room-details] No student memberships found for room ${roomId}.`);
    }

    const responsePayload = {
      room: roomData,
      chatbots: assignedChatbots,
      students: studentsInRoom,
    };

    console.log(`[API GET /teacher/room-details] Successfully prepared data for room ${roomId}. Returning response.`);
    return NextResponse.json(responsePayload);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string };
    console.error('[API GET /teacher/room-details] CATCH BLOCK Error:', typedError.message, 'Code:', typedError.code, 'Details:', typedError.details);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch room details' },
      { status: 500 }
    );
  }
}// src/app/api/debug-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    
    if (!roomId) {
      return NextResponse.json({ error: 'roomId parameter required' }, { status: 400 });
    }
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Use admin client to fetch room details
    const adminClient = createAdminClient();
    const { data: room, error: roomError } = await adminClient
      .from('rooms')
      .select('*')
      .eq('room_id', roomId)
      .single();
      
    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found', details: roomError }, { status: 404 });
    }
    
    // Get teacher profile using the room's teacher_id
    const { data: teacherProfile, error: profileError } = await adminClient
      .from('profiles')
      .select('*')
      .eq('user_id', room.teacher_id)
      .single();
      
    return NextResponse.json({
      room,
      teacherProfile,
      profileError,
      teacherIdInRoom: room.teacher_id,
      yourUserId: user.id,
      isMatch: room.teacher_id === user.id,
    });
  } catch {
    return NextResponse.json({ error: 'Failed to get room debug info' }, { status: 500 });
  }
}'use client';

import { useState, useEffect } from 'react';
import { useParams } from 'next/navigation';
import styled from 'styled-components';
import { Card, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import { createClient } from '@/lib/supabase/client';

const PageContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 90vh;
  background: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.lg};
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 500px;
  text-align: center;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
`;

const Title = styled.h1`
  font-size: 2rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.primary};
`;

const RoomCode = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.md} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.textLight};
  line-height: 1.5;
`;

export default function SimpleMagicLinkPage() {
  const [status, setStatus] = useState<'joining' | 'success' | 'error'>('joining');
  const [error, setError] = useState('');
  const [roomCode, setRoomCode] = useState('');
  const [studentName, setStudentName] = useState('');
  // We track userId but don't directly use it outside of the state update function
  const [, setUserId] = useState('');
  // router is used for redirection in future updates
  // const router = useRouter();
  
  // We create the client but use it via API calls instead of directly
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const supabase = createClient();
  const params = useParams();
  
  useEffect(() => {
    // Get the code from params in a Next.js 14-compatible way
    // params is now a ReadonlyURLSearchParams object in Next.js 14
    const codeParam = params?.code;
    const code = Array.isArray(codeParam) ? codeParam[0] : (codeParam?.toString() || '');
    
    if (!code) {
      setError('Invalid magic link');
      setStatus('error');
      return;
    }
    
    // Extract information from the code
    const parts = code.split('_');
    
    if (parts.length < 2) {
      setError('Invalid magic link format');
      setStatus('error');
      return;
    }
    
    let extractedRoomCode: string;
    let extractedUserId: string | null = null;
    let extractedStudentName: string[];
    
    if (parts.length >= 3) {
      // New format: roomCode_userId_studentName
      [extractedRoomCode, extractedUserId, ...extractedStudentName] = parts;
    } else {
      // Old format: roomCode_studentName
      [extractedRoomCode, ...extractedStudentName] = parts;
    }
    
    const normalizedRoomCode = extractedRoomCode.toUpperCase();
    setRoomCode(normalizedRoomCode);
    
    const decodedName = decodeURIComponent(extractedStudentName.join('_'));
    setStudentName(decodedName);
    
    if (extractedUserId) {
      setUserId(extractedUserId);
      // If we have a user ID, we can try to sign in as that user directly
      tryExistingUser(extractedUserId, normalizedRoomCode, decodedName);
    } else {
      // Otherwise fall back to creating a new user
      joinRoom(normalizedRoomCode, decodedName);
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [params]);
  
  const tryExistingUser = async (userId: string, roomCode: string, name: string) => {
    try {
      console.log(`[Magic Link] Attempting to join with existing user: ${userId}, room: ${roomCode}, name: ${name}`);
      
      // Try to directly join an existing student to the room
      // Instead of redirecting via router.push, we'll POST a form to trigger a full page reload
      // This ensures our session cookies are properly processed
      const requestBody = { 
        room_code: roomCode,
        student_name: name,
        user_id: userId,
        skip_auth: true
      };
      
      console.log(`[Magic Link] Existing user request payload:`, requestBody);
      
      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        // Ensures cookies are handled
        credentials: 'include'
      });
      
      console.log(`[Magic Link] Existing user response status:`, response.status);
      
      // Clone the response so we can read it multiple times
      const responseClone = response.clone();
      
      // Try to get the response text for debugging
      try {
        const textPromise = responseClone.text();
        textPromise.then(text => {
          console.log(`[Magic Link] Existing user raw response:`, text.substring(0, 200) + (text.length > 200 ? '...' : ''));
        }).catch(err => {
          console.error(`[Magic Link] Error reading existing user response text:`, err);
        });
        // Make sure the promise completes but don't wait for it
        Promise.resolve(textPromise).catch(() => {/* ignore errors */});
      } catch (err) {
        console.error(`[Magic Link] Exception trying to read response text:`, err);
      }
      
      if (!response.ok) {
        console.warn(`[Magic Link] Failed to join with existing user (status ${response.status}), falling back to creating new user`);
        joinRoom(roomCode, name);
        return;
      }
      
      const data = await response.json();
      console.log(`[Magic Link] Existing user successful response:`, data);
      
      // Show success message briefly
      setStatus('success');
      
      // Two-step redirect:
      // 1. First show success message
      // 2. Then redirect to room page which will show available chatbots
      setTimeout(async () => {
        console.log('Preparing redirect to room with cookies (existing user)...');
        
        if (data.roomId) {
          try {
            // Instead of directly going to the chat page, we need to:
            // 1. Find a chatbot for this room
            // 2. Then redirect to the proper URL
            console.log('Finding available chatbots for room:', data.roomId);
            
            const response = await fetch(`/api/student/room-chatbots?roomId=${data.roomId}`, {
              method: 'GET',
              credentials: 'include'
            });
            
            if (response.ok) {
              const chatbotData = await response.json();
              console.log('Available chatbots:', chatbotData);
              
              if (chatbotData.chatbots && chatbotData.chatbots.length > 0) {
                // Always redirect to room page first, regardless of chatbot count
                console.log(`Found ${chatbotData.chatbots.length} chatbots, redirecting to room selection page...`);
                window.location.href = `/room/${data.roomId}?uid=${data.userId || userId}&ts=${Date.now()}`;
              } else {
                // No chatbots - redirect to room page anyway
                console.log('No chatbots found for this room, redirecting to room page...');
                window.location.href = `/room/${data.roomId}?uid=${data.userId || userId}&ts=${Date.now()}`;
              }
            } else {
              // API error - go to room directly
              console.error('Failed to fetch chatbots, redirecting to room directly');
              window.location.href = `/room/${data.roomId}?uid=${data.userId || userId}&ts=${Date.now()}`;
            }
          } catch (error) {
            console.error('Error during chatbot lookup:', error);
            // Fallback to room page
            window.location.href = `/room/${data.roomId}?uid=${data.userId || userId}&ts=${Date.now()}`;
          }
        } else {
          // No room ID - go to student dashboard
          console.log('No room ID available, redirecting to student dashboard');
          window.location.href = '/student/dashboard';
        }
      }, 1500);
    } catch (err) {
      console.error('Error joining with existing user:', err);
      // Fall back to creating a new user
      joinRoom(roomCode, name);
    }
  };
  
  const joinRoom = async (roomCode: string, name: string) => {
    try {
      console.log(`[Magic Link] Attempting to join room: ${roomCode} with name: ${name}`);
      
      // Try the emergency fallback approach first - it's more reliable
      // This will bypass potential auth issues by using a more direct approach
      const bypassResult = await directBypass();
      if (bypassResult) {
        console.log(`[Magic Link] Emergency bypass initiated, waiting for redirect`);
        // The directBypass function handles the redirect, so we don't need to continue
        return;
      }
      
      // If directBypass fails, continue with the API approach
      console.log(`[Magic Link] Emergency bypass failed, using API fallback`);
      
      // Simple direct join with minimal complexity
      const requestBody = { 
        room_code: roomCode,
        student_name: name,
        skip_auth: true
      };
      
      console.log(`[Magic Link] Request payload:`, requestBody);
      
      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestBody),
        // Ensures cookies are handled
        credentials: 'include'
      });
      
      console.log(`[Magic Link] Response status:`, response.status);
      
      // Clone the response so we can read it multiple times
      const responseClone = response.clone();
      
      // Try to get the response text for debugging
      try {
        const textPromise = responseClone.text();
        textPromise.then(text => {
          console.log(`[Magic Link] Raw response:`, text.substring(0, 200) + (text.length > 200 ? '...' : ''));
        }).catch(err => {
          console.error(`[Magic Link] Error reading response text:`, err);
        });
        // Make sure the promise completes but don't wait for it
        Promise.resolve(textPromise).catch(() => {/* ignore errors */});
      } catch (err) {
        console.error(`[Magic Link] Exception trying to read response text:`, err);
      }
      
      if (!response.ok) {
        // Try to get JSON error if available
        try {
          const errorData = await response.json();
          console.error(`[Magic Link] Error response:`, errorData);
          
          // If the API fails, try the emergency bypass as a last resort
          console.log(`[Magic Link] API failed, trying emergency bypass as last resort`);
          const bypassResult = await directBypass();
          if (bypassResult) {
            return; // Bypass initiated
          }
          
          throw new Error(errorData.error || `Error: Failed to join room`);
        } catch (parseError) {
          // If JSON parsing fails, use the response status
          console.error(`[Magic Link] Error parsing error response:`, parseError);
          
          // Try emergency bypass again
          console.log(`[Magic Link] API and JSON parsing failed, trying emergency bypass one more time`);
          const bypassResult = await directBypass();
          if (bypassResult) {
            return; // Bypass initiated
          }
          
          throw new Error(`Error: Failed to join room (${response.status})`);
        }
      }
      
      const data = await response.json();
      console.log(`[Magic Link] Successful response:`, data);
      
      // Show success message briefly
      setStatus('success');
      
      // Two-step redirect:
      // 1. First show success message
      // 2. Then redirect to room page which will show available chatbots
      setTimeout(async () => {
        console.log('Preparing redirect to room with cookies...');
        
        if (data.roomId) {
          try {
            // Instead of directly going to the chat page, we need to:
            // 1. Find a chatbot for this room
            // 2. Then redirect to the proper URL
            console.log('Finding available chatbots for room:', data.roomId);
            
            const response = await fetch(`/api/student/room-chatbots?roomId=${data.roomId}`, {
              method: 'GET',
              credentials: 'include'
            });
            
            if (response.ok) {
              const chatbotData = await response.json();
              console.log('Available chatbots:', chatbotData);
              
              if (chatbotData.chatbots && chatbotData.chatbots.length > 0) {
                // Always redirect to room page first, regardless of chatbot count
                console.log(`Found ${chatbotData.chatbots.length} chatbots, redirecting to room selection page...`);
                window.location.href = `/room/${data.roomId}?uid=${data.userId || ''}&ts=${Date.now()}`;
              } else {
                // No chatbots - redirect to student dashboard
                console.log('No chatbots found for this room, redirecting to student dashboard...');
                window.location.href = `/room/${data.roomId}?uid=${data.userId || ''}&ts=${Date.now()}`;
              }
            } else {
              // API error - go to room directly
              console.error('Failed to fetch chatbots, redirecting to room directly');
              window.location.href = `/room/${data.roomId}?uid=${data.userId || ''}&ts=${Date.now()}`;
            }
          } catch (error) {
            console.error('Error during chatbot lookup:', error);
            // Fallback to room page
            window.location.href = `/room/${data.roomId}?uid=${data.userId || ''}&ts=${Date.now()}`;
          }
        } else {
          // No room ID - go to student dashboard
          console.log('No room ID available, redirecting to student dashboard');
          window.location.href = '/student/dashboard';
        }
      }, 1500);
    } catch (err) {
      console.error('Error joining room:', err);
      setError(err instanceof Error ? err.message : 'Failed to join room');
      setStatus('error');
    }
  };
  
  // Loading state
  if (status === 'joining') {
    return (
      <PageContainer>
        <JoinCard>
          <Title>Joining Classroom</Title>
          {roomCode && <RoomCode>{roomCode}</RoomCode>}
          <Text>Welcome, {studentName || 'Student'}! Setting up your access...</Text>
          <LoadingSpinner />
        </JoinCard>
      </PageContainer>
    );
  }
  
  // Success state
  if (status === 'success') {
    return (
      <PageContainer>
        <JoinCard>
          <Title>Successfully Joined!</Title>
          {roomCode && <RoomCode>{roomCode}</RoomCode>}
          <Alert variant="success">Welcome, {studentName}! You&apos;ve joined the classroom.</Alert>
          <Text>Taking you to the classroom chat...</Text>
          <LoadingSpinner />
        </JoinCard>
      </PageContainer>
    );
  }
  
  // Define a direct bypass function for emergency room access
  const directBypass = async (code = roomCode, name = studentName): Promise<boolean> => {
    try {
      console.log(`[Magic Link] Attempting direct bypass for room ${code} with name ${name}`);
      
      // Method 1: Try the JSON API endpoint first
      const response = await fetch('/api/emergency-room-access', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          roomCode: code || '',
          studentName: name || '',
          timestamp: Date.now()
        }),
        credentials: 'include' // Include cookies
      });
      
      // If this worked, process the response
      if (response.ok) {
        const data = await response.json();
        console.log('[Magic Link] Emergency access successful:', data);
        
        // Show success message briefly
        setStatus('success');
        
        // Redirect to the room after a short delay
        setTimeout(() => {
          if (data.roomId) {
            window.location.href = `/room/${data.roomId}?emergency=true&uid=${data.userId || ''}&ts=${Date.now()}`;
          } else {
            window.location.href = '/join-room?code=' + code;
          }
        }, 1500);
        
        return true;
      }
      
      console.log('[Magic Link] JSON emergency access failed, trying form submission');
      
      // Method 2: Fall back to form submission as a last resort
      const form = document.createElement('form');
      form.method = 'POST';
      form.action = '/api/emergency-room-access';
      
      // Add all the data we have
      const codeField = document.createElement('input');
      codeField.type = 'hidden';
      codeField.name = 'room_code';
      codeField.value = code || '';
      form.appendChild(codeField);
      
      const nameField = document.createElement('input');
      nameField.type = 'hidden';
      nameField.name = 'student_name';
      nameField.value = name || '';
      form.appendChild(nameField);
      
      const tsField = document.createElement('input');
      tsField.type = 'hidden';
      tsField.name = 'timestamp';
      tsField.value = Date.now().toString();
      form.appendChild(tsField);
      
      // Add to document and submit
      document.body.appendChild(form);
      form.submit();
      
      return true;
    } catch (error) {
      console.error('[Magic Link] Emergency access error:', error);
      return false;
    }
  };
  
  // Error state
  return (
    <PageContainer>
      <JoinCard>
        <Title>Error Joining Classroom</Title>
        {roomCode && <RoomCode>{roomCode}</RoomCode>}
        <Alert variant="error">{error}</Alert>
        <Text>
          <a href={`/join-room?code=${roomCode}`} style={{ color: 'inherit', textDecoration: 'underline' }}>
            Try joining manually instead
          </a>
        </Text>
        <div style={{ marginTop: '20px' }}>
          <button 
            onClick={async () => {
              try {
                await directBypass(); // Use default parameters
              } catch (error) {
                console.error('Error in emergency access button handler:', error);
              }
            }}
            style={{ 
              background: '#555', 
              color: 'white',
              border: 'none',
              padding: '8px 16px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
          >
            Try Emergency Access
          </button>
        </div>
      </JoinCard>
    </PageContainer>
  );
}// src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import styled, { useTheme } from 'styled-components'; // Added useTheme
import { useRouter } from 'next/navigation';
import { Container, Card, Button } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';
import { APP_NAME, APP_DESCRIPTION } from '@/lib/utils/constants';

// Helper to lighten colors for gradients if needed (can be moved to a utils file)
// This is a very basic implementation. For production, consider a more robust color manipulation library or pre-calculated shades.
const lightenColor = (hex: string, percent: number): string => {
  hex = hex.replace(/^\s*#|\s*$/g, '');
  if (hex.length === 3) {
    hex = hex.replace(/(.)/g, '$1$1');
  }
  const num = parseInt(hex, 16);
  const amt = Math.round(2.55 * percent);
  const R = Math.min(255, (num >> 16) + amt);
  const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
  const B = Math.min(255, (num & 0x0000FF) + amt);
  return `#${(0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)}`;
};


const HomePage = styled.div`
  /* Keep overall background white for now, or set to a very light theme color if desired */
  background: ${({ theme }) => theme.colors.background};
  min-height: 100vh;
`;

const Hero = styled.section`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl} ${({ theme }) => theme.spacing.lg}; // Added horizontal padding
  // Using a subtle gradient from a very light version of primary to a very light version of blue (cyan)
  // Adjust percentages for desired subtlety. 
  // Ensure the text colors (Title, Subtitle) have good contrast.
  background: linear-gradient(135deg, 
    ${({ theme }) => lightenColor(theme.colors.primary, 45)}, // Very light purple
    ${({ theme }) => lightenColor(theme.colors.blue, 48)}    // Very light cyan
  );
  border-bottom: 1px solid ${({ theme }) => theme.colors.border}; // Optional: for a soft separation

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl} ${({ theme }) => theme.spacing.md};
  }
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.primaryDark}; // Darker primary for better contrast on light gradient
  font-size: 3rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-weight: 700; // Make it bolder

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    font-size: 2.5rem;
  }
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.text}; // Slightly darker for better contrast on light gradient
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  max-width: 700px; // Constrain width for readability
  margin-left: auto;
  margin-right: auto;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    font-size: 1.2rem;
  }
`;

const CTAButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const ContentWrapper = styled(Container)` // Use Container for consistent padding
  padding-top: ${({ theme }) => theme.spacing.xxl};
  padding-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const Features = styled.section`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  /* Removed margin-top, ContentWrapper handles overall spacing */
`;

// Added $accentColor prop for dynamic styling
const FeatureCard = styled(Card)<{ $accentColor?: string }>`
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  border-top: 5px solid ${({ theme, $accentColor }) => $accentColor || theme.colors.primary};
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;

  &:hover {
    transform: translateY(-5px);
    box-shadow: ${({ theme }) => theme.shadows.lg};
  }
  
  h3 {
    // Use the accent color for the heading
    color: ${({ theme, $accentColor }) => $accentColor || theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    font-size: 1.3rem; // Slightly larger
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1rem; // Slightly larger
  }
`;

// Optional: For displaying the Skolr logo image if you have it


export default function Home() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [isRedirecting, setIsRedirecting] = useState(false); 
  const router = useRouter();
  const supabase = createClient();
  const theme = useTheme(); // Access the theme object for colors

  useEffect(() => {
    const checkUserAndRedirect = async () => {
      setLoading(true); 
      setIsRedirecting(false); 

      try {
        const { data: { user: currentUser } } = await supabase.auth.getUser(); 
        setUser(currentUser);
        
        if (currentUser) {
          setIsRedirecting(true); 
          
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', currentUser.id)
            .single();

          if (profileError) {
            console.error('Error fetching profile on homepage:', profileError.message);
            setIsRedirecting(false); 
            setLoading(false);
            return;
          }
          
          if (profile?.role === 'teacher') {
            router.push('/teacher-dashboard');
          } else if (profile?.role === 'student') {
            router.push('/student/dashboard'); 
          } else {
            setIsRedirecting(false);
          }
        }
      } catch (error) {
        console.error('Error in checkUserAndRedirect on homepage:', error);
        setIsRedirecting(false);
      } finally {
        setLoading(false);
      }
    };

    checkUserAndRedirect();
  }, [router, supabase]);

  if (loading || isRedirecting) {
    return (
      <HomePage>
        <ContentWrapper> {/* Use ContentWrapper for consistent padding */}
          <Hero> {/* Hero still used for structure, but gradient is lighter */}
            <Title>{loading ? "Loading..." : APP_NAME}</Title>
          </Hero>
        </ContentWrapper>
      </HomePage>
    );
  }

  // Define accent colors for feature cards from your theme
  const featureCardAccents = [
    theme.colors.magenta, // #C848AF
    theme.colors.blue,    // #4CBEF3 (which is your theme.colors.blue, originally skolrCyan)
    theme.colors.green    // #7BBC44
  ];

  return (
    <HomePage>
      <Hero>
        {/* Optional: If you have the Skolr logo image */}
        {/* <LogoImageContainer>
          <Image 
            src="/logos/skolr-banner.png" // Replace with your actual logo path
            alt="Skolr"
            width={500} // Adjust
            height={150} // Adjust
            priority
          />
        </LogoImageContainer> */}
        <Title>{APP_NAME}</Title>
        <Subtitle>{APP_DESCRIPTION}</Subtitle>
        
        {!user && (
          <CTAButtons>
            <Button size="large" onClick={() => router.push('/auth?type=teacher_signup')}>
              Teacher Sign Up
            </Button>
            <Button size="large" variant="secondary" onClick={() => router.push('/student-access')}>
              Student Login
            </Button>
          </CTAButtons>
        )}
      </Hero>

      <ContentWrapper> {/* Wrap Features in ContentWrapper for padding */}
        <Features>
          <FeatureCard $accentColor={featureCardAccents[0]}>
            <h3>For Teachers</h3>
            <p>Create custom AI learning companions tailored to your classroom needs and curriculum.</p>
          </FeatureCard>
          <FeatureCard $accentColor={featureCardAccents[1]}>
            <h3>For Students</h3>
            <p>Engage interactively with AI assistants for support, practice, and deeper understanding.</p>
          </FeatureCard>
          <FeatureCard $accentColor={featureCardAccents[2]}>
            <h3>Smart & Safe</h3>
            <p>Benefit from RAG-powered knowledge, AI assessments, and integrated safety monitoring.</p>
          </FeatureCard>
        </Features>
      </ContentWrapper>
    </HomePage>
  );
}/* src/app/globals.css */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}// src/app/providers.tsx
'use client';

import StyledComponentsRegistry from '@/lib/StyledComponentsRegistry';
import ThemeProvider from '@/components/ThemeProvider';

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <StyledComponentsRegistry>
      <ThemeProvider>
        {children}
      </ThemeProvider>
    </StyledComponentsRegistry>
  );
}// src/styles/GlobalStyles.ts
'use client';

import { createGlobalStyle } from 'styled-components';

export const GlobalStyles = createGlobalStyle`
  /* Use web-safe fonts for now - add Google Fonts to your layout.tsx instead */
  
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  
  html, body {
    max-width: 100vw;
    overflow-x: hidden;
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: ${({ theme }) => theme.fonts.heading};
    line-height: 1.2;
    color: ${({ theme }) => theme.colors.text};
    font-weight: 600;
  }
  
  h1 { font-size: 2.5rem; }
  h2 { font-size: 2rem; }
  h3 { font-size: 1.75rem; }
  h4 { font-size: 1.5rem; }
  h5 { font-size: 1.25rem; }
  h6 { font-size: 1rem; }
  
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }
  
  a {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: none;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primaryLight};
    }
  }
  
  button {
    font-family: ${({ theme }) => theme.fonts.body};
    cursor: pointer;
    border: none;
    background: none;
    transition: all ${({ theme }) => theme.transitions.fast};
    
    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  }
  
  input, textarea, select {
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.5;
  }
  
  /* Custom scrollbar styles */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  
  ::-webkit-scrollbar-track {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  ::-webkit-scrollbar-thumb {
    background: ${({ theme }) => theme.colors.border};
    border-radius: ${({ theme }) => theme.borderRadius.small};
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: ${({ theme }) => theme.colors.borderDark};
  }
  
  /* Focus styles */
  button:focus-visible,
  input:focus-visible,
  textarea:focus-visible,
  select:focus-visible {
    outline: 2px solid ${({ theme }) => theme.colors.focus};
    outline-offset: 2px;
  }
`;// src/styles/StyledComponents.ts
import styled, { css } from 'styled-components'; // Added css import
import Link from 'next/link'; // Import Link for the new StyledLink

export const Container = styled.div`
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0 ${({ theme }) => theme.spacing.md};
  }
`;

export const Card = styled.div<{ $accentColor?: string; $accentSide?: 'top' | 'left' }>` // Added optional accent props
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.xl};
  padding: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};
  position: relative; // Needed for pseudo-elements if we go that route, or direct border

  // Subtle accent border using the $accentColor prop or defaulting to a light primary
  // You can choose 'top' or 'left' (or add more)
  ${({ theme, $accentColor, $accentSide = 'top' }) => {
    const color = $accentColor || theme.colors.primary + '70'; // Default to semi-transparent primary
    if ($accentSide === 'top') {
      return css`
        border-top: 4px solid ${color};
      `;
    }
    if ($accentSide === 'left') {
      return css`
        border-left: 4px solid ${color};
      `;
    }
    return ''; // No accent border if side is not specified or matched
  }}


  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.lg};
  }
`;

export const Button = styled.button<{
    variant?: 'primary' | 'secondary' | 'outline' | 'danger' | 'magenta' | 'cyan' | 'text'; // Added magenta, cyan, text
    size?: 'small' | 'medium' | 'large';
  }>`
    background: ${({ theme, variant = 'primary' }) => {
      if (variant === 'primary') return theme.colors.primary;
      if (variant === 'secondary') return theme.colors.secondary;
      if (variant === 'danger') return theme.colors.red;
      if (variant === 'magenta') return theme.colors.magenta;
      if (variant === 'cyan') return theme.colors.blue; // Assuming theme.colors.blue is your skolrCyan
      return 'transparent'; // For 'outline', 'text', or default
    }};
    color: ${({ theme, variant = 'primary' }) => {
      if (variant === 'outline') return theme.colors.primary;
      if (variant === 'text') return theme.colors.primary; // Text buttons often use primary color
      // For solid backgrounds (primary, secondary, danger, magenta, cyan), text is usually white
      return 'white'; 
    }};
    border: ${({ theme, variant = 'primary' }) => { // Added default to 'primary' for variant
      if (variant === 'outline') return `2px solid ${theme.colors.primary}`;
      if (variant === 'danger') return `2px solid ${theme.colors.red}`;
      if (variant === 'magenta') return `2px solid ${theme.colors.magenta}`;
      if (variant === 'cyan') return `2px solid ${theme.colors.blue}`;
      // For 'primary', 'secondary', 'text' -> no border by default
      return 'none'; 
    }};
    padding: ${({ theme, size = 'medium', variant }) => {
      if (variant === 'text') return `${theme.spacing.xs} ${theme.spacing.sm}`; // Smaller padding for text buttons
      return size === 'small' ? `${theme.spacing.xs} ${theme.spacing.md}` :
             size === 'large' ? `${theme.spacing.md} ${theme.spacing.xl}` :
             `${theme.spacing.sm} ${theme.spacing.lg}`;
    }};
    border-radius: ${({ theme }) => theme.borderRadius.large};
    font-weight: 600; // Slightly bolder
    transition: all ${({ theme }) => theme.transitions.fast};
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1.2;
    text-decoration: none;

    &:hover:not(:disabled) {
      background: ${({ theme, variant = 'primary' }) => {
        if (variant === 'primary') return theme.colors.primaryDark;
        if (variant === 'secondary') return theme.colors.secondaryDark;
        if (variant === 'danger') return darken(theme.colors.red, 10); // Use darken helper
        if (variant === 'magenta') return darken(theme.colors.magenta, 10);
        if (variant === 'cyan') return darken(theme.colors.blue, 10);
        if (variant === 'outline') return theme.colors.primary; 
        if (variant === 'text') return theme.colors.backgroundDark; // Subtle background on hover for text
        return undefined;
      }};
      border-color: ${({ theme, variant = 'primary' }) => {
        if (variant === 'danger') return darken(theme.colors.red, 10);
        if (variant === 'magenta') return darken(theme.colors.magenta, 10);
        if (variant === 'cyan') return darken(theme.colors.blue, 10);
        if (variant === 'outline') return theme.colors.primary;
        return undefined;
      }};
      color: ${({ theme, variant = 'primary' }) => { // Added theme to access colors
        if (variant === 'outline') return 'white';
        if (variant === 'text') return theme.colors.primaryDark; // Darker text on hover for text button
        return 'white'; 
      }};
      transform: translateY(-1px);
      box-shadow: ${({ theme, variant }) => (variant !== 'text' ? theme.shadows.md : 'none')}; // No shadow for text buttons
    }

    &:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    &:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  `;

// Inherit from Button for consistency
export const SecondaryButton = styled(Button).attrs({ variant: 'secondary' })``;
export const OutlineButton = styled(Button).attrs({ variant: 'outline' })``;
export const DangerButton = styled(Button).attrs({ variant: 'danger' })``;
export const MagentaButton = styled(Button).attrs({ variant: 'magenta' })``; // New MagentaButton
export const CyanButton = styled(Button).attrs({ variant: 'cyan' })``;     // New CyanButton
export const TextButton = styled(Button).attrs({ variant: 'text' })``;       // New TextButton


export const FormGroup = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

export const Label = styled.label`
  display: block;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.9rem;
`;

export const Input = styled.input`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border}; // Thinner border for inputs
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  min-height: 44px;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colors.primary + '30'}; // Adjusted focus shadow
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const TextArea = styled.textarea`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border}; // Thinner border
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.6;
  transition: border-color ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  min-height: 100px;
  resize: vertical;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colors.primary + '30'}; // Adjusted focus shadow
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

   &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const Select = styled.select`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border}; // Thinner border
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  min-height: 44px;
  cursor: pointer;
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${({ theme }) => theme.colors.textMuted.replace('#', '')}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right ${({ theme }) => theme.spacing.md} center;
  background-size: 0.65em auto;
  padding-right: ${({ theme }) => `calc(${theme.spacing.md} * 2.5 + 1em)`};

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colors.primary + '30'}; // Adjusted focus shadow
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
    background-image: none;
  }

  option {
    color: ${({ theme }) => theme.colors.text};
    background: ${({ theme }) => theme.colors.background};
  }
`;

export const Alert = styled.div<{ variant?: 'info' | 'success' | 'warning' | 'error' }>`
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  border-left: 4px solid;
  font-size: 0.9rem;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `
          background: ${theme.colors.green + '15'};
          border-color: ${theme.colors.green};
          color: ${darken(theme.colors.green, 25)}; // Darker text for better contrast
        `;
      case 'warning':
        return `
          background: ${theme.colors.secondary + '15'};
          border-color: ${theme.colors.secondary};
          color: ${darken(theme.colors.secondaryDark, 10)}; // Darker text
        `;
      case 'error':
        return `
          background: ${theme.colors.red + '15'};
          border-color: ${theme.colors.red};
          color: ${darken(theme.colors.red, 20)}; // Darker text
        `;
      default: // info (uses theme.colors.blue which is our skolrCyan)
        return `
          background: ${theme.colors.blue + '15'};
          border-color: ${theme.colors.blue};
          color: ${darken(theme.colors.blue, 25)}; // Darker text
        `;
    }
  }}
`;

export const Badge = styled.span<{ variant?: 'default' | 'success' | 'warning' | 'error' | 'magenta' | 'cyan' }>`
  display: inline-flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.round};
  font-size: 0.75rem;
  font-weight: 600;
  line-height: 1;
  text-transform: uppercase;
  letter-spacing: 0.05em;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `background: ${theme.colors.green + '20'}; color: ${theme.colors.green};`;
      case 'warning':
        return `background: ${theme.colors.secondary + '20'}; color: ${theme.colors.secondaryDark};`;
      case 'error':
        return `background: ${theme.colors.red + '20'}; color: ${theme.colors.red};`;
      case 'magenta': // New magenta badge
        return `background: ${theme.colors.magenta + '20'}; color: ${theme.colors.magenta};`;
      case 'cyan':    // New cyan badge (uses theme.colors.blue)
        return `background: ${theme.colors.blue + '20'}; color: ${theme.colors.blue};`;
      default: // default uses primary
        return `background: ${theme.colors.primary + '20'}; color: ${theme.colors.primary};`;
    }
  }}
`;

// New StyledLink component
export const StyledLink = styled(Link)<{ $variant?: 'primary' | 'secondary' | 'magenta' | 'cyan' | 'default' }>`
  color: ${({ theme, $variant = 'primary' }) => {
    if ($variant === 'secondary') return theme.colors.secondaryDark;
    if ($variant === 'magenta') return theme.colors.magenta;
    if ($variant === 'cyan') return theme.colors.blue; // theme.colors.blue is skolrCyan
    if ($variant === 'default') return theme.colors.text;
    return theme.colors.primary;
  }};
  text-decoration: none;
  font-weight: 500;
  transition: color ${({ theme }) => theme.transitions.fast};

  &:hover {
    text-decoration: underline;
    color: ${({ theme, $variant = 'primary' }) => {
      if ($variant === 'secondary') return darken(theme.colors.secondaryDark, 10);
      if ($variant === 'magenta') return darken(theme.colors.magenta, 10);
      if ($variant === 'cyan') return darken(theme.colors.blue, 10);
      if ($variant === 'default') return theme.colors.primary; // Default text link hovers to primary
      return theme.colors.primaryDark;
    }};
  }
`;

// Helper function (can be moved to a utils file if used elsewhere)
const darken = (color: string, percent: number): string => {
  const num = parseInt(color.replace("#",""), 16),
    amt = Math.round(2.55 * percent),
    R = Math.max(0, (num >> 16) - amt),
    G = Math.max(0, (num >> 8 & 0x00FF) - amt),
    B = Math.max(0, (num & 0x0000FF) - amt);
  return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
};// src/styles/theme.ts
import { DefaultTheme } from 'styled-components';

// New Skolr Brand Colors (defined for clarity and easy reference)
const skolrPurple = '#985DD7';
const skolrCyan = '#4CBEF3';
const skolrMagenta = '#C848AF';
const skolrGreen = '#7BBC44';
const skolrCoral = '#FE4372';
const skolrOrange = '#FFB612';

// Helper function to generate lighter/darker shades (basic example, you might use a tool)
// This is a very simplistic way to generate shades. For best results, pick them manually or use a color tool.
const lighten = (color: string, percent: number): string => {
  const num = parseInt(color.replace("#",""), 16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) + amt,
    G = (num >> 8 & 0x00FF) + amt,
    B = (num & 0x0000FF) + amt;
  return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
};

const darken = (color: string, percent: number): string => {
  const num = parseInt(color.replace("#",""), 16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) - amt,
    G = (num >> 8 & 0x00FF) - amt,
    B = (num & 0x0000FF) - amt;
  return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
};


const theme: DefaultTheme = {
  colors: {
    // Primary colors
    primary: skolrPurple, 
    primaryLight: lighten(skolrPurple, 15), // Lighter purple (e.g., #b589e0)
    primaryDark: darken(skolrPurple, 15),  // Darker purple (e.g., #7a4bb5)
    
    // Secondary colors
    secondary: skolrOrange, 
    secondaryLight: lighten(skolrOrange, 10), // Lighter orange (e.g., #ffc74e)
    secondaryDark: darken(skolrOrange, 10),  // Darker orange (e.g., #e5a000)
    
    // Neutral colors (keeping these as the base for a light theme)
    background: '#FFFFFF', 
    backgroundDark: '#F5F5F5', 
    backgroundCard: '#F9FAFB', 
    text: '#1A1E2E', 
    textLight: '#5E6C7A', 
    textMuted: '#9CA3AF', 
    
    // Accent/Status colors
    green: skolrGreen, 
    red: skolrCoral, 
    blue: skolrCyan, // Using Cyan for info/blue context
    
    // Additional brand accent color
    magenta: skolrMagenta,
    
    // UI colors
    border: '#E5E7EB', 
    borderDark: '#D1D5DB', 
    focus: skolrPurple, // Focus ring color now matches new primary
    shadow: '0, 0, 0', 
  },
  
  fonts: {
    heading: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    body: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    mono: "'SF Mono', 'Fira Code', Consolas, monospace",
  },
  
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px',
  },
  
  borderRadius: {
    small: '6px',
    medium: '8px',
    large: '12px',
    xl: '16px',
    round: '50%',
  },
  
  shadows: {
    sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
    md: '0 4px 6px rgba(0, 0, 0, 0.1)',
    lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
    xl: '0 20px 25px rgba(0, 0, 0, 0.1)',
  },
  
  gradients: {
    primary: `linear-gradient(135deg, ${skolrPurple}, ${lighten(skolrPurple, 20)})`, // Updated
    secondary: `linear-gradient(135deg, ${skolrOrange}, ${lighten(skolrOrange, 15)})`, // Updated
  },
  
  breakpoints: {
    mobile: '480px',
    tablet: '768px',
    desktop: '1024px',
    wide: '1280px',
  },
  
  transitions: {
    fast: '0.15s ease',
    normal: '0.25s ease',
    slow: '0.35s ease',
  },
};

export default theme;// src/components/auth/teacherProfileCheck.tsx
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';
import { Alert, Card, Button } from '@/styles/StyledComponents';
import { useRouter } from 'next/navigation';
import styled from 'styled-components';

const FixProfileCard = styled(Card)`
  max-width: 500px;
  margin: 2rem auto;
  padding: 2rem;
  text-align: center;
`;

const StatusMessage = styled.p`
  margin: 1rem 0;
  font-weight: bold;
`;

const LoadingSpinner = styled.div`
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 3px solid rgba(0, 0, 0, 0.1);
  border-radius: 50%;
  border-top-color: ${({ theme }) => theme.colors.primary};
  animation: spin 1s ease-in-out infinite;
  margin-right: 0.5rem;
  
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
`;

export default function TeacherProfileCheck() {
  const [checking, setChecking] = useState(true);
  const [needsRepair, setNeedsRepair] = useState(false);
  const [repairing, setRepairing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState(false);
  const router = useRouter();
  const supabase = createClient();
  
  // Check if the current user has a valid profile
  useEffect(() => {
    const checkProfile = async () => {
      try {
        setChecking(true);
        
        // Get the current authenticated user
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        
        if (userError || !user) {
          console.error('Error getting user:', userError);
          setError('Could not verify your authentication status. Please log out and try again.');
          setChecking(false);
          return;
        }
        
        console.log('Current user:', user.id, 'with metadata:', user.user_metadata);
        
        // Check if the user's metadata indicates they are a teacher
        const isTeacherInMetadata = user.user_metadata?.role === 'teacher';
        
        if (!isTeacherInMetadata) {
          console.log('User is not marked as a teacher in metadata, no repair needed');
          setChecking(false);
          return;
        }
        
        // Check if the user has a profile in the profiles table
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('user_id, role, email')
          .eq('user_id', user.id)
          .maybeSingle();
          
        if (profileError) {
          console.error('Error checking profile:', profileError);
          setError('Could not verify your profile status. Please try again later.');
          setChecking(false);
          return;
        }
        
        // If there's no profile or the role isn't set to teacher, we need to repair it
        if (!profile || profile.role !== 'teacher') {
          console.log('User needs profile repair:', profile ? 'Role mismatch' : 'No profile');
          setNeedsRepair(true);
        } else {
          console.log('User has a valid teacher profile, no repair needed');
        }
        
        setChecking(false);
      } catch (e) {
        console.error('Error in profile check:', e);
        setError('An unexpected error occurred while checking your profile.');
        setChecking(false);
      }
    };
    
    checkProfile();
  }, [supabase]);
  
  // Handler for repairing the profile
  const handleRepairProfile = async () => {
    try {
      setRepairing(true);
      setError(null);
      
      // Get the current user
      const { data: { user }, error: userError } = await supabase.auth.getUser();
      
      if (userError || !user) {
        throw new Error('Could not retrieve user information');
      }
      
      // Create or update the profile with the teacher role
      const { error: upsertError } = await supabase
        .from('profiles')
        .upsert({
          user_id: user.id,
          email: user.email || `${user.id}@example.com`,
          role: 'teacher',
          full_name: user.user_metadata?.full_name || 'Teacher',
          updated_at: new Date().toISOString()
        }, {
          onConflict: 'user_id'
        });
        
      if (upsertError) {
        throw new Error(`Profile update failed: ${upsertError.message}`);
      }
      
      console.log('Profile repaired successfully');
      setSuccess(true);
      
      // Redirect to the teacher dashboard after a short delay
      setTimeout(() => {
        router.push('/teacher-dashboard');
      }, 2000);
      
    } catch (e) {
      console.error('Error repairing profile:', e);
      setError(e instanceof Error ? e.message : 'Failed to repair profile');
    } finally {
      setRepairing(false);
    }
  };
  
  // If still checking, show loading state
  if (checking) {
    return (
      <FixProfileCard>
        <h2>Checking Profile Status</h2>
        <div className="status-container">
          <LoadingSpinner /> <span>Verifying your account...</span>
        </div>
      </FixProfileCard>
    );
  }
  
  // If repair needed, show repair UI
  if (needsRepair) {
    return (
      <FixProfileCard>
        <h2>Profile Setup Required</h2>
        
        {error && <Alert variant="error">{error}</Alert>}
        {success && <Alert variant="success">Profile fixed successfully! Redirecting to dashboard...</Alert>}
        
        <p>Your teacher account needs additional setup to access the teacher dashboard.</p>
        
        <Button 
          onClick={handleRepairProfile} 
          disabled={repairing || success}
          style={{ marginTop: '1rem' }}
        >
          {repairing ? <><LoadingSpinner /><span> Setting Up Profile...</span></> : 'Complete Setup'}
        </Button>
      </FixProfileCard>
    );
  }
  
  // If no repair needed, show nothing (component will unmount)
  return null;
}// src/components/auth/PinLogin.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, FormGroup, Label, Input, Button, Alert } from '@/styles/StyledComponents';

const StyledCard = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.xl};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2`
  color: ${({ theme }) => theme.colors.primary};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  text-align: center;
`;

const FormContainer = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const PinInputContainer = styled.div`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const PinInput = styled(Input)`
  width: 100%;
  text-align: center;
  font-size: 1.5rem;
  letter-spacing: 1rem;
  padding: ${({ theme }) => theme.spacing.md};
  font-weight: bold;
`;

const Divider = styled.div`
  display: flex;
  align-items: center;
  margin: ${({ theme }) => theme.spacing.lg} 0;
  
  &:before, &:after {
    content: '';
    flex: 1;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  }
  
  span {
    padding: 0 ${({ theme }) => theme.spacing.md};
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.9rem;
  }
`;

const InfoText = styled.p`
  text-align: center;
  color: ${({ theme }) => theme.colors.textLight};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const PinExample = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.sm};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  font-size: 0.85rem;
  color: ${({ theme }) => theme.colors.textMuted};
  text-align: center;
`;

const Note = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  font-size: 0.85rem;
  color: ${({ theme }) => theme.colors.textMuted};
  text-align: center;
`;

const DebugInfo = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.sm};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  font-size: 0.75rem;
  color: ${({ theme }) => theme.colors.textMuted};
  font-family: ${({ theme }) => theme.fonts.mono};
  max-height: 200px;
  overflow-y: auto;
  white-space: pre-wrap;
`;

const ResultBox = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin: ${({ theme }) => theme.spacing.md} 0;
  
  .name {
    font-weight: bold;
    color: ${({ theme }) => theme.colors.text};
    font-size: 1.1rem;
  }
  
  .username {
    color: ${({ theme }) => theme.colors.primary};
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 500;
  }
  
  p {
    margin: ${({ theme }) => theme.spacing.xs} 0;
  }
`;

interface PinLoginProps {
  onLoginSuccess?: () => void;
  redirectTo?: string;
}

export default function PinLogin({ onLoginSuccess, redirectTo = '/student/dashboard' }: PinLoginProps) {
  // Ensure we're redirecting to the student dashboard after login
  // '/student/dashboard' is the correct path for authenticated students
  const [identifier, setIdentifier] = useState('');
  const [pin, setPin] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [matchFound, setMatchFound] = useState<{ full_name: string; user_id: string } | null>(null);
  const [isChecking, setIsChecking] = useState(false);
  const [debugInfo, setDebugInfo] = useState<(string | Record<string, unknown>)[]>([]);
  const [showDebug, setShowDebug] = useState(false);
  const router = useRouter();

  // Toggle debug info with "d" key
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'd' && e.ctrlKey && e.shiftKey) {
        setShowDebug(prev => !prev);
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, []);

  const addDebugInfo = (info: string | Record<string, unknown>) => {
    console.log('Debug:', info);
    setDebugInfo(prev => [...prev, info]);
  };
  
  // Check if a student matches this identifier without verifying PIN
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const checkForStudentMatch = async (): Promise<void> => {
    if (!identifier.trim()) return;
    
    setIsChecking(true);
    setError(null);
    
    try {
      addDebugInfo(`Looking up student without PIN: ${identifier.trim()}`);
      
      const response = await fetch('/api/auth/student-username-lookup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          identifier: identifier.trim()
        })
      });
      
      const data = await response.json();
      addDebugInfo(`API response (lookup only): ${JSON.stringify(data)}`);
      
      if (!response.ok) {
        setMatchFound(null);
        return;
      }
      
      if (data.success && data.best_match) {
        setMatchFound(data.best_match);
      } else {
        setMatchFound(null);
      }
    } catch (err) {
      console.error('Student lookup error:', err);
      setMatchFound(null);
    } finally {
      setIsChecking(false);
    }
  };
  
  // When identifier changes, check for matching student after a delay
  useEffect(() => {
    const timer = setTimeout(() => {
      if (identifier.trim().length >= 3) {
        checkForStudentMatch();
      } else {
        setMatchFound(null);
      }
    }, 500);
    
    return () => clearTimeout(timer);
  }, [identifier, checkForStudentMatch]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setDebugInfo([]);

    // Validate inputs
    if (!identifier.trim()) {
      setError('Please enter your name or username');
      setIsLoading(false);
      return;
    }

    if (!pin.trim() || pin.length !== 4 || !/^\d{4}$/.test(pin)) {
      setError('Please enter a valid 4-digit PIN');
      setIsLoading(false);
      return;
    }

    try {
      addDebugInfo(`Looking up student: ${identifier.trim()}`);
      
      // Use the server API to look up the student and verify PIN
      const response = await fetch('/api/auth/student-username-lookup', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          identifier: identifier.trim(),
          pin: pin
        })
      });
      
      const data = await response.json();
      addDebugInfo(`API response: ${JSON.stringify(data)}`);
      
      if (!response.ok) {
        if (response.status === 404) {
          throw new Error(`Student not found. Please check your name or ask your teacher for help.`);
        } else if (response.status === 401) {
          throw new Error('Incorrect PIN code. Please try again or ask your teacher for help.');
        } else {
          throw new Error(data.error || 'Failed to log in');
        }
      }
      
      // We should have a user_id if PIN was verified
      if (data.success && data.pin_verified && data.user_id) {
        // Log in using that user_id
        addDebugInfo(`Logging in with user_id: ${data.user_id}`);
        
        // Try the standard login first
        try {
          const loginResponse = await fetch('/api/auth/student-pin-login', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              user_id: data.user_id,
              pin_code: pin
            })
          });
          
          if (!loginResponse.ok) {
            const loginData = await loginResponse.json().catch(() => ({}));
            console.error('Standard PIN login failed:', loginResponse.status, loginData);
            addDebugInfo('Standard login failed, trying direct login...');
            
            // If standard login fails, try the direct login approach
            const directLoginResponse = await fetch('/api/auth/direct-student-login', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify({
                user_id: data.user_id,
                pin_code: pin
              })
            });
            
            if (!directLoginResponse.ok) {
              const directLoginData = await directLoginResponse.json().catch(() => ({}));
              console.error('Direct PIN login also failed:', directLoginResponse.status, directLoginData);
              throw new Error(directLoginData.error || `Login failed (Status: ${directLoginResponse.status})`);
            }
            
            const directLoginData = await directLoginResponse.json();
            addDebugInfo('Direct login successful: ' + JSON.stringify(directLoginData));
            
            // Add a special flag to indicate this is a direct PIN login in localStorage
            // This will help us detect and handle redirect loops if they occur
            try {
              // Save important information in localStorage
              localStorage.setItem('direct_pin_login', 'true');
              localStorage.setItem('direct_pin_login_time', Date.now().toString());
              localStorage.setItem('direct_pin_login_user', directLoginData.user?.id || 'unknown');
              
              // Cookie validation for browsers that support it
              document.cookie = `direct_pin_login_check=true; path=/; max-age=3600`;
              document.cookie = `direct_pin_login_user=${directLoginData.user?.id || 'unknown'}; path=/; max-age=3600`;
            } catch (e) {
              console.warn('Could not set localStorage for direct login:', e);
            }
            
            // Direct login successful - check if we have a specific redirect_to in the response
            // If not, build our own with the user ID
            const redirectUrl = directLoginData.redirect_to || 
              `/student/dashboard?_t=${Date.now()}&direct=1&user_id=${directLoginData.user?.id || data.user_id}`;
              
            addDebugInfo(`Using redirect URL: ${redirectUrl}`);
            
            completeLogin(redirectUrl);
          } else {
            // Standard login worked
            const loginData = await loginResponse.json();
            addDebugInfo('Standard login successful: ' + JSON.stringify(loginData));
            
            // Successfully logged in - check if response has custom redirect path
            completeLogin(loginData.redirect_to);
          }
        } catch (loginError) {
          console.error('Login processing error:', loginError);
          throw loginError;
        }
        
        // Helper function to complete the login process
        function completeLogin(customRedirect?: string) {
          addDebugInfo('Login successful, applying cookies...');
          
          // Give the cookies a moment to be set
          setTimeout(() => {
            // Login successful - either call callback or redirect
            if (onLoginSuccess) {
              onLoginSuccess();
            } else {
              // Determine where to redirect - use custom redirect path from response if available
              const finalRedirect = customRedirect || redirectTo;
              addDebugInfo(`Redirecting to ${finalRedirect}...`);
              
              // This ensures we do a full browser navigation, not just a client-side route change
              // Add a timestamp to prevent caching and force a full reload
              const redirectWithTimestamp = finalRedirect.includes('?') 
                ? `${finalRedirect}&_t=${Date.now()}` 
                : `${finalRedirect}?_t=${Date.now()}`;
                
              // Log clear confirmation of redirect path
              console.log(`PIN login successful - redirecting to: ${redirectWithTimestamp}`);
              
              window.location.href = redirectWithTimestamp;
            }
          }, 1000); // Increase timeout to ensure cookies are set
        }
      } else {
        // Should never get here if response was ok
        throw new Error('Unexpected error during login - PIN verification success but no user_id');
      }
    } catch (err) {
      console.error('Login error:', err);
      setError(err instanceof Error ? err.message : 'Login failed');
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <StyledCard>
      <Title>Student Login</Title>
      
      <InfoText>
        Log in with your name and 4-digit PIN to access your classrooms.
      </InfoText>
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <PinExample>
        If you haven&apos;t set up a PIN yet, join a classroom first or ask your teacher for help.
      </PinExample>
      
      <FormContainer onSubmit={handleSubmit}>
        <FormGroup>
          <Label htmlFor="identifier">Your Name</Label>
          <Input
            id="identifier"
            type="text"
            value={identifier}
            onChange={(e) => setIdentifier(e.target.value)}
            placeholder="Enter your name"
            disabled={isLoading}
            required
          />
          
          {isChecking && (
            <div style={{ textAlign: 'center', margin: '8px 0' }}>
              Checking...
            </div>
          )}
          
          {matchFound && (
            <ResultBox>
              <p>We found your account:</p>
              <p className="name">{matchFound.full_name}</p>
              <p>Please enter your PIN to continue.</p>
            </ResultBox>
          )}
        </FormGroup>
        
        <FormGroup>
          <Label htmlFor="pin">PIN Code</Label>
          <PinInputContainer>
            <PinInput
              id="pin"
              type="text"
              inputMode="numeric"
              maxLength={4}
              pattern="\d{4}"
              value={pin}
              onChange={(e) => {
                const value = e.target.value.replace(/\D/g, '').substring(0, 4);
                setPin(value);
              }}
              placeholder="****"
              disabled={isLoading}
              required
            />
          </PinInputContainer>
        </FormGroup>
        
        <Button 
          type="submit" 
          disabled={isLoading} 
          style={{ width: '100%' }}
        >
          {isLoading ? 'Logging in...' : 'Login'}
        </Button>
      </FormContainer>
      
      <Divider>
        <span>OR</span>
      </Divider>
      
      <Button 
        variant="outline" 
        style={{ width: '100%' }} 
        onClick={() => router.push('/join')}
      >
        Join New Classroom
      </Button>
      
      <Note>
        Your teacher can help you set up your PIN access if needed.
        {/* Hidden note about debug mode */}
        <br /><small>Press Ctrl+Shift+D to toggle debug info</small>
      </Note>
      
      {/* Debug info panel - hidden by default */}
      {showDebug && debugInfo.length > 0 && (
        <DebugInfo>
          <h4>Debug Information:</h4>
          {debugInfo.map((info, i) => (
            <div key={i} style={{ marginBottom: '4px' }}>
              {typeof info === 'string' ? info : JSON.stringify(info, null, 2)}
            </div>
          ))}
        </DebugInfo>
      )}
    </StyledCard>
  );
}// src/components/auth/MagicLink.tsx
'use client';

import { useState, useEffect, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const MagicCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const SubText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
`;

const RoomCode = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

function MagicLinkContent() {
  const [status, setStatus] = useState<'loading' | 'processing' | 'success' | 'error'>('loading');
  const [error, setError] = useState<string>('');
  const [roomCode, setRoomCode] = useState<string>('');
  // roomId is used in the success handler
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [roomId, setRoomId] = useState<string>('');
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    // Function to handle the magic link process
    const handleMagicLink = async () => {
      // Check if we're in the browser
      if (typeof window === 'undefined') return;

      try {
        // Get parameters from URL
        const params = new URLSearchParams(window.location.search);
        const token = params.get('token');
        const roomCodeParam = params.get('room');
        
        if (!token || !roomCodeParam) {
          console.error('Missing token or room code parameters');
          setError('Invalid magic link: missing parameters');
          setStatus('error');
          return;
        }
        
        setRoomCode(roomCodeParam);
        setStatus('processing');
        
        // Skip the room check - go directly to the API
        // This avoids potential permission issues with checking the room table
        
        // Process the magic link to join the room
        const response = await fetch('/api/auth/magic-link', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            token,
            room_code: roomCodeParam,
          }),
        });

        // Handle any response errors
        if (!response.ok) {
          const errorData = await response.json().catch(() => null);
          const errorMessage = errorData?.error || `Error ${response.status}: Failed to join room`;
          throw new Error(errorMessage);
        }

        // Process the successful response
        const data = await response.json();
        setRoomId(data.room_id);
        setStatus('success');
        
        // Redirect to chat
        setTimeout(() => {
          router.push(`/chat/${data.room_id}`);
        }, 1500);
      } catch (err) {
        console.error('Magic link error:', err);
        const errorMessage = err instanceof Error ? err.message : 'Failed to process magic link';
        setError(errorMessage);
        setStatus('error');
      }
    };

    // Execute the function
    handleMagicLink();
  }, [router, supabase]);

  // Loading or processing state
  if (status === 'loading' || status === 'processing') {
    return (
      <MagicCard>
        <Title>Joining Classroom</Title>
        {roomCode && <RoomCode>{roomCode}</RoomCode>}
        <SubText>
          {status === 'loading' 
            ? 'Processing your magic link...' 
            : 'Setting up your account...'}
        </SubText>
        <LoadingSpinner />
      </MagicCard>
    );
  }

  // Success state
  if (status === 'success') {
    return (
      <MagicCard>
        <Title>Joined Classroom</Title>
        {roomCode && <RoomCode>{roomCode}</RoomCode>}
        <Alert variant="success">Successfully joined classroom!</Alert>
        <SubText>Redirecting to the classroom chat...</SubText>
        <LoadingSpinner />
      </MagicCard>
    );
  }

  // Error state
  return (
    <MagicCard>
      <Title>Error Joining Classroom</Title>
      {roomCode && <RoomCode>{roomCode}</RoomCode>}
      <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>
      
      <Button onClick={() => router.push(`/join-room?code=${roomCode}`)} style={{ marginTop: '16px' }}>
        Try Joining with Room Code
      </Button>
    </MagicCard>
  );
}

export default function MagicLink() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MagicLinkContent />
    </Suspense>
  );
}// src/components/auth/AuthForm.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, FormGroup, Label, Input, Button as StyledButton, Alert, Select as StyledSelect } from '@/styles/StyledComponents';

const AuthCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
`;

const HelpText = styled.div`
  font-size: 0.95em;
  color: ${({ theme }) => theme.colors.textLight};
  margin-top: ${({ theme }) => theme.spacing.xs};
`;

const Title = styled.h1`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const InfoBox = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  
  p {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
  
  strong {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

interface AuthFormProps {
  type: 'login' | 'signup';
}

export default function AuthForm({ type }: AuthFormProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [fullName, setFullName] = useState('');
  const [countryCode, setCountryCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const redirectTo = searchParams?.get('redirect') || '/';

  const checkUser = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      router.push(redirectTo);
    }
  }, [supabase, router, redirectTo]);

  useEffect(() => {
    checkUser();
  }, [checkUser]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (type === 'signup' && !fullName.trim()) {
      setError('Full name is required');
      return;
    }
    
    setLoading(true);
    setError('');

    try {
      if (type === 'signup') {
        const role = 'teacher'; // Only teachers use email signup
        
        const signupData: { role: string; full_name: string; country_code?: string | null } = {
            role: role,
            full_name: fullName,
        };

        signupData.country_code = countryCode.trim() || null;
        
        // Always redirect to teacher dashboard for teacher signups
        const teacherRedirect = '/teacher-dashboard';
        
        const { error: signUpError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/auth/callback?redirect=${encodeURIComponent(teacherRedirect)}`,
            data: signupData
          },
        });
        
        if (signUpError) {
          console.error('Signup error details:', signUpError);
          throw signUpError;
        }
        
        alert('Check your email for the confirmation link! Please also check your spam folder.');
      } else { 
        // For login, first determine user information to ensure correct redirect
        const { error: signInError, data } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        
        if (signInError) {
          throw signInError;
        }
        
        const userId = data.user?.id;
        
        if (userId) {
          // Check user's role to force specific redirect
          const { data: profileData } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', userId)
            .single();
            
          const role = profileData?.role || data.user?.user_metadata?.role;
          console.log(`[AuthForm] User logged in with role: ${role}`);
          
          if (role === 'teacher') {
            // Force teacher dashboard redirect
            router.push('/teacher-dashboard');
          } else if (role === 'student') {
            // Force student dashboard redirect
            router.push('/student/dashboard');
          } else {
            // Use default redirect
            router.push(redirectTo);
          }
        } else {
          // Fall back to default redirect if we can't determine role
          router.push(redirectTo);
        }
        
        router.refresh();
      }
    } catch (error) {
      console.error('Auth error:', error);
      setError(error instanceof Error ? error.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  return (
    <AuthCard>
      <Title>{type === 'login' ? 'Login' : 'Teacher Sign Up'}</Title>
      
      {type === 'signup' && ( 
        <InfoBox>
          <p><strong>For Teachers:</strong> Sign up here to create your teacher account.</p>
          <p><strong>For Students:</strong> Use the &quot;Join Classroom&quot; button on the homepage to join with a room code.</p>
        </InfoBox>
      )}
      
      {type === 'login' && (
        <InfoBox>
          <p><strong>For Teachers:</strong> Log in with your email and password.</p>
          <p><strong>For Students:</strong> If you&apos;ve set up an account via the Account Setup page, you can log in here.</p>
        </InfoBox>
      )}
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        {type === 'signup' && ( 
          <>
            <FormGroup>
              <Label htmlFor="fullName">Full Name</Label>
              <Input
                id="fullName"
                type="text"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                placeholder="Enter your full name"
                required
              />
            </FormGroup>
            <FormGroup>
               <Label htmlFor="countryCode">Your Country (Optional)</Label>
               <StyledSelect
                   id="countryCode"
                   name="countryCode"
                   value={countryCode}
                   onChange={(e) => setCountryCode(e.target.value)}
               >
                   <option value="">Select Country</option>
                   <option value="US">United States</option>
                   <option value="GB">United Kingdom</option>
                   <option value="CA">Canada</option>
                   <option value="AU">Australia</option>
                   <option value="MY">Malaysia</option>
                   <option value="NZ">New Zealand</option>
                   <option value="AE">United Arab Emirates</option>
                   <option value="EU">EU (Other)</option>
               </StyledSelect>
               <HelpText>Selecting your country helps us provide localized safety resources for your students if a concern is flagged.</HelpText>
            </FormGroup>
          </>
        )}
        <FormGroup>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Enter your email"
            required
          />
        </FormGroup>
        <FormGroup>
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter your password"
            required
          />
        </FormGroup>
        <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
          {loading ? 'Loading...' : type === 'login' ? 'Login' : 'Sign Up as Teacher'}
        </StyledButton>
      </form>
    </AuthCard>
  );
}// src/components/auth/SignInDropdown.tsx
'use client';

import { useState, useRef, useEffect } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { Button } from '@/styles/StyledComponents';

const DropdownContainer = styled.div`
  position: relative;
  display: inline-block;
`;

const DropdownMenu = styled.div<{ $isOpen: boolean }>`
  position: absolute;
  top: 100%;
  right: 0;
  margin-top: 0.5rem;
  background: ${({ theme }) => theme.colors.background};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  display: ${({ $isOpen }) => ($isOpen ? 'block' : 'none')};
  min-width: 200px;
  z-index: 1000;
  overflow: hidden;
`;

const DropdownItem = styled(Link)`
  display: block;
  padding: 0.75rem 1rem;
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-size: 0.9rem;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  &:not(:last-child) {
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  }
`;

const StyledButton = styled(Button)`
  display: flex;
  align-items: center;
  gap: 0.25rem;
  
  &:after {
    content: '▼';
    font-size: 0.7rem;
    margin-top: 2px;
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    font-size: 0.9rem;
  }
`;

export default function SignInDropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  const toggleDropdown = () => {
    setIsOpen(!isOpen);
  };

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  return (
    <DropdownContainer ref={dropdownRef}>
      <StyledButton onClick={toggleDropdown}>
        Sign In
      </StyledButton>
      
      <DropdownMenu $isOpen={isOpen}>
        <DropdownItem href="/auth?login=teacher" onClick={() => setIsOpen(false)}>
          Teacher Sign In
        </DropdownItem>
        <DropdownItem href="/student-access" onClick={() => setIsOpen(false)}>
          Student Sign In
        </DropdownItem>
      </DropdownMenu>
    </DropdownContainer>
  );
}// src/components/layout/Footer.tsx
'use client';

import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';

const FooterWrapper = styled.footer`
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.xl} 0;
  margin-top: auto;
`;

const FooterContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    text-align: center;
  }
`;

const Copyright = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

const Links = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  
  a {
    color: ${({ theme }) => theme.colors.textMuted};
    text-decoration: none;
    font-size: 0.875rem;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primary};
    }
  }
`;

export default function Footer() {
  const currentYear = new Date().getFullYear();
  
  return (
    <FooterWrapper>
      <Container>
        <FooterContent>
          <Copyright>
            © {currentYear} {APP_NAME}. All rights reserved.
          </Copyright>
          <Links>
            <a href="/privacy">Privacy Policy</a>
            <a href="/terms">Terms of Service</a>
            <a href="/help">Help Center</a>
          </Links>
        </FooterContent>
      </Container>
    </FooterWrapper>
  );
}// src/components/layout/Header.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client'; // Your client import
import { Container, Button } from '@/styles/StyledComponents';
import SignInDropdown from '@/components/auth/SignInDropdown';
import { APP_NAME } from '@/lib/utils/constants';
import type { User } from '@supabase/supabase-js';
import { usePathname } from 'next/navigation'; // Import usePathname for active link styling

const HeaderWrapper = styled.header`
  background: ${({ theme }) => theme.colors.background};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md} 0;
  position: sticky;
  top: 0;
  z-index: 100;
`;

const HeaderContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-wrap: wrap;
    gap: ${({ theme }) => theme.spacing.sm};
  }
`;

const Logo = styled(Link)`
  font-size: 1.5rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.primary};
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  
  &:hover {
    color: ${({ theme }) => theme.colors.primaryDark};
  }
`;

const Nav = styled.nav`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    order: 3;
    width: 100%;
    justify-content: center;
    margin-top: ${({ theme }) => theme.spacing.sm};
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const NavLink = styled(Link)<{ $isActive?: boolean }>`
  color: ${({ theme, $isActive }) => $isActive ? theme.colors.primary : theme.colors.text};
  text-decoration: none;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  transition: all ${({ theme }) => theme.transitions.fast};
  font-weight: ${({ $isActive }) => $isActive ? '600' : '500'};
  background: ${({ theme, $isActive }) => $isActive ? (theme.colors.primary + '20') : 'transparent'};
  
  &:hover {
    background: ${({ theme, $isActive }) => $isActive ? (theme.colors.primary + '30') : theme.colors.backgroundDark};
    color: ${({ theme }) => theme.colors.primary};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.sm};
    flex: 1;
    text-align: center;
  }
`;

const UserSection = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    min-width: 100px; /* Ensure consistent space */
    justify-content: flex-end;
  }
`;

const HeaderButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    font-size: 0.9rem;
  }
`;

export default function Header() {
  const [user, setUser] = useState<User | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  const supabase = createClient(); // Supabase client initialized here
  const pathname = usePathname();

  // --- START OF CODE TO ADD/VERIFY ---
  useEffect(() => {
    // Expose supabase client to the window object FOR TESTING PURPOSES ONLY
    if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
      // @ts-expect-error // TypeScript might complain, ignore for testing
      window.supabaseClientInstance = supabase;
      console.log("Supabase client instance EXPOSED to window.supabaseClientInstance for testing.");
    }
  }, [supabase]); // Dependency array includes supabase
  // --- END OF CODE TO ADD/VERIFY ---

  useEffect(() => {
    const getUserInfo = async () => {
      const { data: { user: currentUser } } = await supabase.auth.getUser();
      setUser(currentUser);
      
      if (currentUser) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', currentUser.id)
          .single();
        
        if (profile) {
          setUserRole(profile.role);
        } else {
          setUserRole(null);
        }
      } else {
        setUserRole(null);
      }
    };
    
    getUserInfo();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      const sessionUser = session?.user || null;
      setUser(sessionUser);
      
      if (sessionUser) {
        supabase
          .from('profiles')
          .select('role')
          .eq('user_id', sessionUser.id)
          .single()
          .then(({ data: profileData, error: profileError }) => {
            if (profileError) {
              console.warn("Error fetching profile on auth state change:", profileError.message);
              setUserRole(null);
              return;
            }
            if (profileData) {
              setUserRole(profileData.role);
            } else {
              setUserRole(null);
            }
          });
      } else {
        setUserRole(null);
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [supabase]); // supabase is already a dependency here

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    window.location.href = '/'; 
  };

  const isLinkActive = (href: string) => {
    if (href === '/teacher-dashboard' || href === '/student/dashboard') {
        return pathname.startsWith(href);
    }
    return pathname === href;
  };

  return (
    <HeaderWrapper>
      <Container>
        <HeaderContent>
          <Logo href="/">
            {APP_NAME}
          </Logo>
          
          {user && userRole && (
            <Nav>
              {userRole === 'teacher' && (
                <NavLink href="/teacher-dashboard" $isActive={isLinkActive('/teacher-dashboard')}>
                  Dashboard
                </NavLink>
              )}
              {userRole === 'student' && (
                <NavLink href="/student/dashboard" $isActive={isLinkActive('/student/dashboard')}>
                  Dashboard 
                </NavLink>
              )}
            </Nav>
          )}
          
          <UserSection>
            {user ? (
              <HeaderButton variant="outline" onClick={handleSignOut}>
                Sign Out
              </HeaderButton>
            ) : (
              pathname !== '/auth' && pathname !== '/student-login' && pathname !== '/student-access' && (
                <SignInDropdown />
              )
            )}
          </UserSection>
        </HeaderContent>
      </Container>
    </HeaderWrapper>
  );
}// src/components/student/RoomList.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button } from '@/styles/StyledComponents';
import type { StudentRoom } from '@/types/student.types';

const RoomGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCard = styled(Card)`
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    transform: translateY(-2px);
  }
`;

const RoomHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const RoomName = styled.h3`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 1.25rem;
`;

const RoomDetails = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const ChatbotsList = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ChatbotInfo = styled.div`
  font-weight: 600;
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.div`
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 0.875rem;
  
  &:last-child {
    margin-bottom: 0;
  }
  
  strong {
    color: ${({ theme }) => theme.colors.text};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-top: ${({ theme }) => theme.spacing.xs};
  }
`;

const EmptyState = styled.div`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
`;

const RoomFooter = styled.div`
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const JoinedDate = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface RoomListProps {
  rooms: StudentRoom[];
}

export default function RoomList({ rooms }: RoomListProps) {
  return (
    <RoomGrid>
      {rooms.map((room) => (
        <RoomCard key={room.room_id}>
          <RoomHeader>
            <RoomName>{room.room_name}</RoomName>
            <RoomDetails>
              Room Code: <strong>{room.room_code}</strong>
            </RoomDetails>
          </RoomHeader>
          
          <ChatbotsList>
            {room.chatbots.length > 0 ? (
              <>
                <ChatbotInfo>
                  {room.chatbots.length} chatbot{room.chatbots.length > 1 ? 's' : ''}:
                </ChatbotInfo>
                {room.chatbots.map((chatbot) => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <strong>{chatbot.name}</strong>
                    {chatbot.description && (
                      <p>{chatbot.description}</p>
                    )}
                  </ChatbotItem>
                ))}
              </>
            ) : (
              <EmptyState>No chatbots assigned</EmptyState>
            )}
          </ChatbotsList>
          
          <RoomFooter>
            <JoinedDate>
              Joined: {new Date(room.joined_at || room.created_at).toLocaleDateString()}
            </JoinedDate>
            <Button 
              as={Link} 
              href={`/room/${room.room_id}`}
              size="medium"
              style={{ 
                minWidth: '120px',
                textAlign: 'center'
              }}
            >
              Enter Room
            </Button>
          </RoomFooter>
        </RoomCard>
      ))}
    </RoomGrid>
  );
}// src/components/student/JoinRoom.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';
import { isValidRoomCode } from '@/lib/utils/room-codes';
import { createClient } from '@/lib/supabase/client';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0 0 ${({ theme }) => theme.spacing.sm} 0;
  color: ${({ theme }) => theme.colors.text};
`;

const Description = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface JoinRoomProps {
  onClose: () => void;
  onSuccess: () => void;
}

export default function JoinRoom({ onClose, onSuccess }: JoinRoomProps) {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formattedCode = roomCode.toUpperCase();

    if (!isValidRoomCode(formattedCode)) {
      setError('Invalid room code format');
      setIsLoading(false);
      return;
    }

    try {
      // First check if the room exists
      const supabase = createClient();
      const { data: room, error: roomError } = await supabase
        .from('rooms')
        .select('room_id, is_active')
        .eq('room_code', formattedCode)
        .single();

      if (roomError) {
        if (roomError.code === 'PGRST116') { // No rows returned
          setError('Room not found. Please check the code and try again.');
        } else {
          setError('Error checking room. Please try again.');
        }
        setIsLoading(false);
        return;
      }

      if (!room.is_active) {
        setError('This room is currently inactive. Please contact your teacher.');
        setIsLoading(false);
        return;
      }

      // Room exists and is active - redirect to the join room page
      router.push(`/join-room?code=${formattedCode}`);
      
      // Close the modal
      onClose();
      
      // Call the success callback
      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to join room');
      setIsLoading(false);
    }
  };

  return (
    <Overlay>
      <JoinCard>
        <Header>
          <Title>Join Classroom</Title>
          <Description>
            Enter the room code provided by your teacher
          </Description>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <Form onSubmit={handleSubmit}>
          <RoomCodeInput
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
            placeholder="ROOM CODE"
            maxLength={6}
            autoFocus
            required
          />
          
          <ButtonGroup>
            <Button 
              type="button" 
              variant="outline" 
              onClick={onClose}
              style={{ flex: 1 }}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isLoading}
              style={{ flex: 1 }}
            >
              {isLoading ? 'Joining...' : 'Continue'}
            </Button>
          </ButtonGroup>
        </Form>
      </JoinCard>
    </Overlay>
  );
}// src/components/student/ProfileCompletion.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';

const ProfileCard = styled(Card)`
  max-width: 500px;
  margin: 0 auto;
  padding: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
  text-align: center;
`;

const Description = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function ProfileCompletion({ onComplete }: { onComplete: () => void }) {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClient();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!firstName.trim() || !lastName.trim()) {
      setError('Please enter both first and last name');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      // Update profile with name information
      const { error: updateError } = await supabase
        .from('profiles')
        .update({
          name: `${firstName} ${lastName}`.trim(),
          // We could also add these fields if the database schema supports them
          // first_name: firstName,
          // last_name: lastName,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', user.id);
      
      if (updateError) {
        throw updateError;
      }
      
      // Call the completion callback
      onComplete();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <ProfileCard>
      <Title>Complete Your Profile</Title>
      <Description>
        Please provide your name to complete your profile setup
      </Description>
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        <FormGroup>
          <Label htmlFor="firstName">First Name</Label>
          <Input
            id="firstName"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Enter your first name"
            required
          />
        </FormGroup>
        
        <FormGroup>
          <Label htmlFor="lastName">Last Name</Label>
          <Input
            id="lastName"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            placeholder="Enter your last name"
            required
          />
        </FormGroup>
        
        <Button 
          type="submit" 
          disabled={isSubmitting}
          style={{ width: '100%' }}
        >
          {isSubmitting ? 'Saving...' : 'Complete Profile'}
        </Button>
      </form>
    </ProfileCard>
  );
}// src/components/student/StudentProfileCheck.tsx
'use client';

import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';

/**
 * StudentProfileCheck
 * 
 * A hidden component that automatically detects missing student profiles
 * and attempts to repair them. This is a safety net for when the normal
 * auth triggers don't create the profile correctly.
 * 
 * Usage: Include this component in student layouts or on student dashboard
 */
export default function StudentProfileCheck() {
  const [isLoading, setIsLoading] = useState(true);
  const [needsRepair, setNeedsRepair] = useState(false);
  const supabase = createClient();

  useEffect(() => {
    const checkStudentProfile = async () => {
      try {
        // First check if we're signed in
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
          // Not signed in, nothing to do
          setIsLoading(false);
          return;
        }

        // Check if we already have a profile
        const { data: profile, error: profileError } = await supabase
          .from('profiles')
          .select('user_id, role')
          .eq('user_id', user.id)
          .maybeSingle();

        // Determine if we need repair
        let profileRepairNeeded = false;
        
        if (profileError || !profile) {
          console.log('[StudentProfileCheck] No profile found, needs repair');
          profileRepairNeeded = true;
        } else if (profile.role !== 'student') {
          // This shouldn't happen but let's check anyway
          const isStudent = user.user_metadata?.role === 'student' ||
                          user.app_metadata?.role === 'student';
          
          if (isStudent && profile.role !== 'student') {
            console.log('[StudentProfileCheck] User is student but profile role is:', profile.role);
            profileRepairNeeded = true;
          }
        }

        if (profileRepairNeeded) {
          setNeedsRepair(true);
          await repairProfile(user);
        }
      } catch (error) {
        console.error('[StudentProfileCheck] Error checking profile:', error);
      } finally {
        setIsLoading(false);
      }
    };

    const repairProfile = async (user: any) => {
      try {
        console.log('[StudentProfileCheck] Attempting to repair profile');
        
        // Call the profile repair API
        const response = await fetch('/api/student/repair-profile', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userId: user.id,
            fullName: user.user_metadata?.full_name,
            email: user.email,
            isAnonymous: user.user_metadata?.is_anonymous === true
          }),
          credentials: 'include'
        });

        if (!response.ok) {
          throw new Error(`Profile repair failed: ${response.status}`);
        }

        const result = await response.json();
        console.log('[StudentProfileCheck] Profile repair result:', result);
        
        // Repair complete
        setNeedsRepair(false);
      } catch (error) {
        console.error('[StudentProfileCheck] Failed to repair profile:', error);
      }
    };

    checkStudentProfile();
  }, [supabase]);

  // This is a hidden component, it doesn't render anything visible
  return null;
}// src/components/shared/LoadingSpinner.tsx
'use client';

import styled, { keyframes } from 'styled-components';

const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const SpinnerWrapper = styled.div`
  display: inline-flex;
  align-items: center;
  justify-content: center;
`;

const Spinner = styled.div<{ size?: 'small' | 'medium' | 'large' }>`
  width: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  height: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  border: 3px solid ${({ theme }) => theme.colors.border};
  border-top-color: ${({ theme }) => theme.colors.primary};
  border-radius: 50%;
  animation: ${spin} 1s linear infinite;
`;

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
}

export default function LoadingSpinner({ size = 'medium' }: LoadingSpinnerProps) {
  return (
    <SpinnerWrapper>
      <Spinner size={size} />
    </SpinnerWrapper>
  );
}// src/components/shared/Chat.tsx (SUPER SIMPLIFIED DIAGNOSTIC VERSION)
'use client';
import React from 'react';
import { useState, useEffect, useRef, useCallback } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import ChatInput from '@/components/shared/ChatInput';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { ChatMessage, Chatbot } from '@/types/database.types';

const ASSESSMENT_TRIGGER_COMMAND = "/assess";

// Basic front-end safety check to prepare for potential safety responses
// This is just a preliminary check to show a UI placeholder while the server processes
// the safety check - the server has more comprehensive checks
const initialSafetyCheck = (message: string): boolean => {
  // Keywords for a basic check on the client side - these will trigger a UI placeholder
  // The actual safety response will be determined by the server
  const BASIC_KEYWORDS = [
    // Self harm category
    'suicide', 'kill myself', 'die', 'hurt myself', 'end my life', 'take my own life',
    'self harm', 'harming myself', 'cutting myself', 'cut myself',
    'don\'t want to live', 'want to die', 'wanna die', 'better off dead',
    'no reason to live', 'not worth living', 'end it all',
    
    // Bullying category
    'bullied', 'bullying', 'being bullied', 'getting bullied', 
    'laughed at', 'picking on me', 'make fun of me', 'making fun of me',
    'everyone hates me', 'nobody likes me', 'no friends', 'don\'t have friends',
    
    // Depression category
    'depressed', 'depression', 'hate myself', 'hate my life',
    'feeling worthless', 'feel worthless', 'empty', 'no one cares',
    'nobody cares', 'given up', 'lost hope', 'no hope',
    
    // Abuse category
    'abused', 'hitting me', 'hits me', 'beat me', 'beating me',
    'hurt', 'hurting me', 'scared', 'afraid', 'in danger',
    'threatening me', 'threatened', 'unsafe', 'not safe',
    
    // Family issues
    'parents fighting', 'parents argue', 'scared at home', 'afraid at home',
    'kicked out', 'homeless', 'nowhere to go', 'no food',
    'don\'t feel safe', 'not safe at home'
  ];
  
  const lowerMessage = message.toLowerCase();
  
  for (const keyword of BASIC_KEYWORDS) {
    // Check for word boundaries to avoid false positives
    const regex = new RegExp(`\\b${keyword.replace(/'/g, "['']")}\\b`);
    if (regex.test(lowerMessage)) {
      console.log(`[Chat Safety] Potential safety keyword detected: "${keyword}"`);
      return true;
    }
  }
  
  // Additional patterns that need more context
  const contextPatterns = [
    // Self-harm phrases with multiple words
    /hate myself.*(live|going on|anymore)/i,
    /(tired|exhausted).*(living|existing|everything)/i,
    /no point.*(living|going on)/i,
    /can't take (it|this) anymore/i,
    
    // Bullying phrases
    /they (all )?(hate|ignore) me/i,
    /(no one|nobody) (talks|speaks|listens) to me/i,
    /afraid (of|at) school/i,
    
    // Abuse phrases
    /\w+ (hit|hurt|abuse|kick) me/i,  // Someone hit me
    /afraid of \w+/i  // Afraid of someone
  ];
  
  for (const pattern of contextPatterns) {
    if (pattern.test(lowerMessage)) {
      console.log(`[Chat Safety] Potential safety pattern detected: "${pattern}"`);
      return true;
    }
  }
  
  return false;
};

// Styled Components (Keep as is)
const ChatContainer = styled(Card)` /* ... */ `;
const MessagesList = styled.div` /* ... */ `;
const StyledChatInputContainer = styled.div` /* ... */ `;
const EmptyState = styled.div` /* ... */ `;
const ErrorContainer = styled(Alert)` /* ... */ `;
const LoadingIndicator = styled.div` /* ... */ `;
const SubmitAssessmentButton = styled(Button)`
  margin-top: 1rem;
  width: 100%;
`;

const ThinkingIndicator = styled.div`
  display: flex;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.textMuted};
  font-style: italic;
  
  svg {
    margin-right: ${({ theme }) => theme.spacing.sm};
    animation: pulse 1.5s infinite ease-in-out;
  }
  
  @keyframes pulse {
    0% { opacity: 0.4; }
    50% { opacity: 1; }
    100% { opacity: 0.4; }
  }
`;

interface ChatProps {
  roomId: string;
  chatbot: Chatbot;
  // These were intended for direct access but are now handled via the URL
  // Kept for backwards compatibility
  studentId?: string;
  directMode?: boolean;
  // New field for student-specific chatbot instances
  instanceId?: string;
}

export default function Chat({ roomId, chatbot, instanceId }: ChatProps) {
  // studentId and directMode params removed as they're not used
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false); // Keep for ChatInput
  const [isFetchingMessages, setIsFetchingMessages] = useState(true);
  const [error, setError] = useState<string | null>(null); // Keep for ChatInput
  const [fetchError, setFetchError] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [isSubmittingAssessment, setIsSubmittingAssessment] = useState(false);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const supabase = createClient();

  // Check for direct auth via URL
  const [searchParams, setSearchParams] = useState<URLSearchParams | null>(null);

  useEffect(() => {
    // Get search params from URL in a client-safe way
    if (typeof window !== 'undefined') {
      setSearchParams(new URLSearchParams(window.location.search));
    }
  }, []);

  // Get user ID with fallbacks
  useEffect(() => {
    const getUserId = async () => {
      try {
        // Priority 1: Try normal auth session
        const { data: { user } } = await supabase.auth.getUser();
        
        if (user) {
          console.log('[Chat] Found authenticated user:', user.id);
          setUserId(user.id);
          return;
        }
        
        // Priority 2: Check for emergency cookies
        const getEmergencyCookieValue = (name: string): string | null => {
          if (typeof document === 'undefined') return null;
          const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
          return match ? decodeURIComponent(match[2]) : null;
        };
        
        const emergencyUserId = getEmergencyCookieValue('emergency_user_id');
        const emergencyAccess = getEmergencyCookieValue('emergency_access');
        
        if (emergencyUserId && emergencyAccess === 'true') {
          console.log('[Chat] Using emergency user ID from cookies:', emergencyUserId);
          setUserId(emergencyUserId);
          return;
        }
        
        // Priority 3: Check for uid in URL
        const uidFromUrl = searchParams?.get('uid');
        if (uidFromUrl) {
          console.log('[Chat] Using user ID from URL:', uidFromUrl);
          
          // Verify this is a valid user with API
          try {
            const response = await fetch(`/api/student/verify-user?userId=${uidFromUrl}`);
            if (response.ok) {
              const data = await response.json();
              if (data.valid) {
                setUserId(uidFromUrl);
                return;
              }
            }
          } catch (verifyError) {
            console.error('[Chat] Error verifying user from URL:', verifyError);
          }
        }
        
        // No valid user found
        setFetchError("Auth error: No user. Try refreshing the page.");
      } catch (err) { 
        console.error('[Chat] Auth error:', err);
        setFetchError("Auth error. Try refreshing the page."); 
      }
    };
    
    if (searchParams !== null) {
      getUserId();
    }
  }, [supabase, searchParams]);

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, []);

  // Fetch messages with support for direct URL access and homepage fallback
  const fetchMessages = useCallback(async () => {
    if (!chatbot?.chatbot_id || !userId || !roomId) {
      setIsFetchingMessages(false); return;
    }
    setIsFetchingMessages(true); setFetchError(null);
    try {
      // Check if using emergency access or direct URL
      const isEmergencyAccess = document.cookie.includes('emergency_access=true');
      const uidFromUrl = searchParams?.get('uid');
      const emergency = searchParams?.get('emergency');
      
      // Enhanced debugging for instance ID
      console.log(`[Chat] Starting fetchMessages with:
      - instanceId: ${instanceId || 'undefined'}
      - roomId: ${roomId}
      - chatbotId: ${chatbot?.chatbot_id}
      - userId: ${userId}
      `);
      
      // Additional validation
      if (!instanceId) {
        console.warn(`[Chat] No instanceId provided but we are on path ${window.location.pathname} - this might cause shared chat issues`);
      }
      
      // First try to determine the API endpoint
      let url;
      if (isEmergencyAccess || (emergency === 'true') || (uidFromUrl && uidFromUrl === userId)) {
        // Direct access mode - Emergency access takes priority
        url = `/api/chat/direct-access?roomId=${roomId}&userId=${userId}&chatbotId=${chatbot.chatbot_id}`;
        if (instanceId) {
          url += `&instanceId=${instanceId}`;
          console.log('[Chat] Added instanceId to direct access URL:', instanceId);
        } else {
          console.log('[Chat] No instanceId available for direct access URL');
        }
        console.log('[Chat] Using direct access endpoint (emergency or URL parameter)');
      } else if (window.location.pathname === '/' || window.location.pathname.includes('/page')) {
        // Homepage fallback endpoint with less complex queries
        url = `/api/homepage-chat?roomId=${roomId}&chatbotId=${chatbot.chatbot_id}`;
        if (instanceId) {
          url += `&instanceId=${instanceId}`;
          console.log('[Chat] Added instanceId to homepage URL:', instanceId);
        } else {
          console.log('[Chat] No instanceId available for homepage URL');
        }
      } else {
        // Regular API endpoint
        url = `/api/chat/${roomId}?chatbotId=${chatbot.chatbot_id}`;
        if (instanceId) {
          url += `&instanceId=${instanceId}`;
          console.log('[Chat] Added instanceId to regular URL:', instanceId);
        } else {
          console.log('[Chat] No instanceId available for regular URL');
        }
      }
      
      console.log(`[Chat.tsx] Fetching messages from: ${url}`);
      const response = await fetch(url, { credentials: 'include' });
      
      if (!response.ok) {
        // If first attempt fails, try the fallback endpoint
        if (url.includes('/api/chat/') && !url.includes('/api/homepage-chat')) {
          console.log('[Chat.tsx] Primary endpoint failed, trying fallback...');
          // CRITICAL FIX: Always include instanceId in all API calls, including fallbacks
          const fallbackUrl = `/api/homepage-chat?roomId=${roomId}&chatbotId=${chatbot.chatbot_id}${instanceId ? `&instanceId=${instanceId}` : ''}`;
          console.log(`[Chat.tsx] Using fallback URL with instanceId=${instanceId || 'none'}: ${fallbackUrl}`);
          const fallbackResponse = await fetch(fallbackUrl, { credentials: 'include' });
          
          if (!fallbackResponse.ok) {
            throw new Error(`Fallback failed (status: ${fallbackResponse.status})`);
          }
          
          const fallbackData = await fallbackResponse.json();
          
          if (!Array.isArray(fallbackData)) {
            console.warn(`[Chat.tsx] Fallback fetch returned non-array data:`, fallbackData);
            return;
          }
          
          // De-duplicate messages by message_id
          const uniqueMessages = new Map<string, ChatMessage>();
          
          // First add all existing optimistic messages (that haven't been replaced yet)
          const existingOptimisticMessages = messages.filter(msg => 
            msg.metadata?.isOptimistic === true && 
            !fallbackData.some(m => m.metadata?.optimisticContent === msg.metadata?.optimisticContent)
          );
          
          // Also preserve safety placeholders if no real safety messages are present
          const safetyPlaceholders = messages.filter(msg => 
            msg.metadata?.isSafetyPlaceholder === true &&
            !fallbackData.some(m => m.metadata?.isSystemSafetyResponse === true && !m.metadata?.isSafetyPlaceholder)
          );
          
          // Add existing optimistic messages to the map
          existingOptimisticMessages.forEach(msg => {
            uniqueMessages.set(msg.message_id, msg);
          });
          
          // Add safety placeholders to the map
          safetyPlaceholders.forEach(msg => {
            uniqueMessages.set(msg.message_id, msg);
          });
          
          // Process incoming messages
          fallbackData.forEach(msg => {
            // Filter out duplicates - for user messages, also check content
            if (msg.role === 'user') {
              // Look for any optimistic messages with the same content
              const existingOptimisticIndex = Array.from(uniqueMessages.values()).findIndex(existingMsg => 
                existingMsg.metadata?.isOptimistic && 
                existingMsg.metadata?.optimisticContent === msg.content &&
                existingMsg.user_id === msg.user_id
              );
              
              if (existingOptimisticIndex !== -1) {
                // Replace optimistic message
                const existingKeys = Array.from(uniqueMessages.keys());
                if (existingOptimisticIndex < existingKeys.length) {
                  uniqueMessages.delete(existingKeys[existingOptimisticIndex]);
                }
              }
            }
            
            // Add this message
            uniqueMessages.set(msg.message_id, msg);
          });
          
          // Convert map back to array and sort
          const sortedUniqueMessages = Array.from(uniqueMessages.values())
            .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
          
          console.log(`[Chat.tsx] Fallback fetch complete - ${fallbackData.length} raw messages, ${sortedUniqueMessages.length} unique messages`);
          setMessages(sortedUniqueMessages);
          setTimeout(scrollToBottom, 150);
          return;
        } else {
          throw new Error(`Failed to fetch (status: ${response.status})`);
        }
      }
      
      const data = (await response.json()) as ChatMessage[];
      if (!Array.isArray(data)) {
        console.warn(`[Chat.tsx] Fetch messages returned non-array data:`, data);
        return;
      }
      
      // De-duplicate messages by message_id
      const uniqueMessages = new Map<string, ChatMessage>();
      
      // First add all existing optimistic messages (that haven't been replaced yet)
      const existingOptimisticMessages = messages.filter(msg => 
        msg.metadata?.isOptimistic === true && 
        !data.some(m => m.metadata?.optimisticContent === msg.metadata?.optimisticContent)
      );
      
      // Also preserve safety placeholders if no real safety messages are present
      const safetyPlaceholders = messages.filter(msg => 
        msg.metadata?.isSafetyPlaceholder === true &&
        !data.some(m => m.metadata?.isSystemSafetyResponse === true && !m.metadata?.isSafetyPlaceholder)
      );
      
      // Add existing optimistic messages to the map
      existingOptimisticMessages.forEach(msg => {
        uniqueMessages.set(msg.message_id, msg);
      });
      
      // Add safety placeholders to the map
      safetyPlaceholders.forEach(msg => {
        uniqueMessages.set(msg.message_id, msg);
      });
      
      // Process incoming messages
      data.forEach(msg => {
        // Filter out duplicates - for user messages, also check content
        if (msg.role === 'user') {
          // Look for any optimistic messages with the same content
          const existingOptimisticIndex = Array.from(uniqueMessages.values()).findIndex(existingMsg => 
            existingMsg.metadata?.isOptimistic && 
            existingMsg.metadata?.optimisticContent === msg.content &&
            existingMsg.user_id === msg.user_id
          );
          
          if (existingOptimisticIndex !== -1) {
            // Replace optimistic message
            const existingKeys = Array.from(uniqueMessages.keys());
            if (existingOptimisticIndex < existingKeys.length) {
              uniqueMessages.delete(existingKeys[existingOptimisticIndex]);
            }
          }
        }
        
        // Add this message
        uniqueMessages.set(msg.message_id, msg);
      });
      
      // Convert map back to array and sort
      const sortedUniqueMessages = Array.from(uniqueMessages.values())
        .sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
      
      console.log(`[Chat.tsx] Fetch complete - ${data.length} raw messages, ${sortedUniqueMessages.length} unique messages`);
      setMessages(sortedUniqueMessages);
      setTimeout(scrollToBottom, 150);
    } catch (err) {
      console.error('[Chat.tsx] Error fetching messages:', err);
      setFetchError(err instanceof Error ? err.message : 'Failed to load messages');
    } finally {
      setIsFetchingMessages(false);
    }
  }, [roomId, chatbot?.chatbot_id, userId, searchParams, scrollToBottom]);

  // Add welcome message to empty chat
  useEffect(() => {
    console.log('[Chat] Checking welcome message conditions:', {
      isFetchingMessages,
      messagesLength: messages.length,
      hasWelcomeMessage: !!chatbot?.welcome_message,
      welcomeMessageContent: chatbot?.welcome_message?.substring(0, 20),
      hasUserId: !!userId
    });
    
    if (
      !isFetchingMessages && 
      messages.length === 0 && 
      chatbot?.welcome_message && 
      chatbot.welcome_message.trim() !== '' &&
      userId
    ) {
      console.log('[Chat] Adding welcome message for chatbot:', chatbot.chatbot_id);
      
      // Create a synthetic welcome message
      // Create a properly typed welcome message
      const welcomeMessageObj: ChatMessage = {
        message_id: `welcome-${chatbot.chatbot_id}-${Date.now()}`,
        room_id: roomId,
        user_id: userId,
        role: 'assistant' as 'assistant', // Explicitly typed as literal
        content: chatbot.welcome_message.trim(),
        created_at: new Date().toISOString(),
        metadata: {
          chatbotId: chatbot.chatbot_id,
          isWelcomeMessage: true
        }
      };
      
      // Add welcome message to state
      setMessages([welcomeMessageObj]);
      setTimeout(scrollToBottom, 150);
    }
  }, [isFetchingMessages, messages.length, chatbot?.welcome_message, chatbot?.chatbot_id, roomId, userId, scrollToBottom]);
  
  // Backup for welcome message if the above logic didn't trigger
  useEffect(() => {
    // This runs a bit after the first fetch completes and if we still have no messages
    const addDelayedWelcomeMessage = () => {
      if (
        !isFetchingMessages && 
        messages.length === 0 && 
        chatbot?.welcome_message && 
        chatbot.welcome_message.trim() !== '' &&
        userId
      ) {
        console.log('[Chat] Adding delayed welcome message for chatbot:', chatbot.chatbot_id);
        
        // Create a synthetic welcome message
        const welcomeMessageObj: ChatMessage = {
          message_id: `welcome-delayed-${chatbot.chatbot_id}-${Date.now()}`,
          room_id: roomId,
          user_id: userId,
          role: 'assistant' as 'assistant', // Explicitly typed as literal
          content: chatbot.welcome_message.trim(),
          created_at: new Date().toISOString(),
          metadata: {
            chatbotId: chatbot.chatbot_id,
            isWelcomeMessage: true,
            isDelayed: true
          }
        };
        
        // Add welcome message to state
        setMessages([welcomeMessageObj]);
        setTimeout(scrollToBottom, 150);
      }
    };
    
    // Wait a bit after fetching completes to add welcome message if needed
    if (!isFetchingMessages) {
      const timer = setTimeout(addDelayedWelcomeMessage, 500);
      return () => clearTimeout(timer);
    }
  }, [isFetchingMessages, messages.length, chatbot?.welcome_message, chatbot?.chatbot_id, roomId, userId, scrollToBottom]);

  useEffect(() => {
    if (userId && chatbot?.chatbot_id && roomId) {
      fetchMessages();
    }
  }, [userId, chatbot?.chatbot_id, roomId, fetchMessages]);

  // Helper function to handle realtime message inserts
  const handleRealtimeMessage = useCallback((newMessage: ChatMessage) => {
    setMessages((prevMessages) => {
      // Check if message already exists by ID
      if (prevMessages.find(msg => msg.message_id === newMessage.message_id)) {
        console.log(`[Chat.tsx RT] Message ${newMessage.message_id} already in state by ID.`);
        return prevMessages;
      }
      
      // For user messages, check if we have an optimistic version with the same content
      if (newMessage.role === 'user') {
        const optimisticIndex = prevMessages.findIndex(msg => 
          msg.role === 'user' && 
          msg.metadata?.isOptimistic === true && 
          msg.metadata?.optimisticContent === newMessage.content &&
          msg.user_id === newMessage.user_id
        );
        
        if (optimisticIndex !== -1) {
          console.log(`[Chat.tsx RT] Optimistic version of message found at index ${optimisticIndex}, replacing it.`);
          // Replace the optimistic message with the real one
          const updated = [...prevMessages];
          updated[optimisticIndex] = newMessage;
          return updated;
        }
      }
      
      // For safety messages (system role with isSystemSafetyResponse), look for a safety placeholder
      if (newMessage.role === 'system' && newMessage.metadata?.isSystemSafetyResponse) {
        // Find and remove any safety placeholder
        const safetyPlaceholderIndex = prevMessages.findIndex(msg => 
          msg.metadata?.isSafetyPlaceholder === true
        );
        
        if (safetyPlaceholderIndex !== -1) {
          console.log(`[Chat.tsx RT] Replacing safety placeholder with real safety message ${newMessage.message_id}`);
          const updated = [...prevMessages];
          // Replace the placeholder with the real safety message
          updated[safetyPlaceholderIndex] = newMessage;
          return updated;
        }
        
        console.log(`[Chat.tsx RT] Adding safety message ${newMessage.message_id} (no placeholder found)`);
        // No safety placeholder found, but still add the safety message
      }
      
      // No duplicate or placeholder found, add the new message
      console.log(`[Chat.tsx RT] Adding new message ${newMessage.message_id} (Role: ${newMessage.role}).`);
      const updated = [...prevMessages, newMessage];
      updated.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
      return updated;
    });
    setTimeout(scrollToBottom, 100);
  }, [scrollToBottom]);
  
  // Helper function to handle realtime message updates
  const handleRealtimeUpdate = useCallback((updatedMessage: ChatMessage) => {
    setMessages((prevMessages) => {
      // Find the message to update by ID
      const messageIndex = prevMessages.findIndex(msg => msg.message_id === updatedMessage.message_id);
      
      if (messageIndex === -1) {
        console.log(`[Chat.tsx RT] Can't find message ${updatedMessage.message_id} to update. Adding instead.`);
        const updated = [...prevMessages, updatedMessage];
        updated.sort((a, b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime());
        return updated;
      }
      
      console.log(`[Chat.tsx RT] Updating existing message ${updatedMessage.message_id}`);
      const updated = [...prevMessages];
      updated[messageIndex] = updatedMessage;
      return updated;
    });
    setTimeout(scrollToBottom, 100);
  }, [scrollToBottom]);

  // --- REALTIME LISTENER ---
  useEffect(() => {
    const effectChatbotId = chatbot?.chatbot_id; // Use optional chaining for safety
    const effectUserId = userId;

    if (!roomId || !effectChatbotId || !effectUserId || !supabase) {
        console.log('[Chat.tsx RT] Aborting subscription - missing params.', 
            { roomId, effectChatbotId, effectUserId });
        return;
    }

    // Create a safety-specific channel to handle safety messages
    const safetyChannelId = `safety-alert-${effectUserId}`;
    console.log(`[Chat.tsx RT] Subscribing to safety channel: ${safetyChannelId}`);
    
    try {
      // Array to track all channels we create so we can clean them up properly
      const channels: any[] = [];
      
      // Safety alert channel - subscribes to direct safety broadcasts for this user
      // Add broadcast and presence config for more reliability
      const safetyChannel = supabase
        .channel(safetyChannelId, {
          config: {
            broadcast: { self: true },
            presence: { key: effectUserId }
          }
        })
        .on('broadcast', { event: 'safety-message' }, async (payload) => {
          console.log('[Chat.tsx RT] <<< SAFETY MESSAGE BROADCAST RECEIVED >>>:', payload);
          
          // Verify this safety message is for this room and user
          console.log(`[Chat.tsx RT] Verifying safety message payload:`, {
            payloadRoomId: payload.payload.room_id,
            roomId,
            payloadUserId: payload.payload.user_id,
            effectUserId,
            payloadChatbotId: payload.payload.chatbot_id,
            effectChatbotId,
            countryCode: payload.payload.country_code,
            effectiveCountryCode: payload.payload.effectiveCountryCode
          });
          
          if (payload.payload.room_id === roomId && 
              payload.payload.user_id === effectUserId &&
              (!effectChatbotId || payload.payload.chatbot_id === effectChatbotId)) {
            
            try {
              // Fetch the safety message using the API to bypass RLS issues
              console.log(`[Chat.tsx RT] Fetching safety message ID: ${payload.payload.message_id}`);
              const response = await fetch(`/api/student/safety-message?messageId=${payload.payload.message_id}&userId=${effectUserId}`, {
                method: 'GET',
                credentials: 'include',
                cache: 'no-store' // Ensure we don't get cached responses
              });
              
              if (!response.ok) {
                console.error(`[Chat.tsx RT] Error fetching safety message: HTTP ${response.status}`);
                // If we can't get the specific message, try to refresh all messages
                console.log(`[Chat.tsx RT] Attempting to reload all messages to get safety message`);
                await fetchMessages();
                return;
              }
              
              const safetyMessageData = await response.json();
              const safetyMessage = safetyMessageData.message;
              
              // Directly update state instead of using handleRealtimeMessage to avoid duplication
              setMessages((prevMessages) => {
                // Step 1: Remove any safety placeholders
                const withoutPlaceholders = prevMessages.filter(msg => 
                  !msg.metadata?.isSafetyPlaceholder
                );
                
                // Step 2: Update user messages with pendingSafetyResponse=false
                const updatedMessages = withoutPlaceholders.map(msg => {
                  if (msg.role === 'user' && msg.metadata?.pendingSafetyResponse) {
                    return {
                      ...msg,
                      metadata: {
                        ...msg.metadata,
                        pendingSafetyResponse: false
                      }
                    };
                  }
                  return msg;
                });
                
                // Step 3: Check if safety message already exists (prevent duplication)
                const safetyMessageExists = updatedMessages.some(msg => 
                  msg.message_id === safetyMessage.message_id
                );
                
                // Step 4: Add the safety message only if it doesn't exist
                const newMessages = safetyMessageExists 
                  ? updatedMessages 
                  : [...updatedMessages, safetyMessage];
                
                // Step 5: Sort by timestamp
                return newMessages.sort((a, b) => 
                  new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
                );
              });
              
              // Scroll to bottom after updating
              setTimeout(scrollToBottom, 100);
            } catch (err) {
              console.error('[Chat.tsx RT] Error processing safety message:', err);
              // If there's an error, try to refresh all messages as a fallback
              try {
                console.log('[Chat.tsx RT] Attempting to refresh all messages after error');
                await fetchMessages();
              } catch (refreshError) {
                console.error('[Chat.tsx RT] Error refreshing messages:', refreshError);
              }
            }
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') {
            console.log(`[Chat.tsx RT] Successfully SUBSCRIBED to safety channel ${safetyChannelId}`);
            
            // For testing: expose the channel globally so we can debug in the console
            if (typeof window !== 'undefined') {
              (window as any).safetyChannel = safetyChannel;
              console.log('[Chat.tsx RT] Safety channel exposed as window.safetyChannel for debugging');
            }
          } else if (status === 'CHANNEL_ERROR') {
            console.error(`[Chat.tsx RT] Safety channel ERROR: ${safetyChannelId}`, err);
            // Try to reconnect after a short delay
            setTimeout(() => {
              console.log('[Chat.tsx RT] Attempting to reconnect to safety channel after error');
              safetyChannel.subscribe();
            }, 2000);
          } else if (status === 'TIMED_OUT') {
            console.warn(`[Chat.tsx RT] Safety channel TIMED_OUT: ${safetyChannelId}`, err);
            // Try to reconnect after a short delay
            setTimeout(() => {
              console.log('[Chat.tsx RT] Attempting to reconnect to safety channel after timeout');
              safetyChannel.subscribe();
            }, 2000);
          } else if (status === 'CLOSED') {
            console.warn(`[Chat.tsx RT] Safety channel CLOSED: ${safetyChannelId}`);
            // Try to reconnect after a short delay for CLOSED status too
            setTimeout(() => {
              console.log('[Chat.tsx RT] Attempting to reconnect to safety channel after close');
              safetyChannel.subscribe();
            }, 2000);
          }
        });
      
      channels.push(safetyChannel);

      // Regular message subscriptions remain disabled to fix duplication
      console.log('[Chat.tsx RT] Regular message subscriptions remain disabled to fix duplication');

      return () => {
        // Clean up all channels
        for (const channel of channels) {
          try {
            console.log(`[Chat.tsx RT] CLEANUP for channel: ${channel.topic}`);
            supabase.removeChannel(channel);
          } catch (error) {
            console.warn(`[Chat.tsx RT] Error removing channel ${channel?.topic || 'unknown'}:`, error);
          }
        }
      };
    } catch (subscriptionError) {
      console.warn('[Chat.tsx RT] Error setting up subscriptions:', subscriptionError);
      return () => {}; // Return empty cleanup function
    }

    /*
    const channelIdentifier = `chat-room-${roomId}-user-${effectUserId}-bot-${effectChatbotId}`;
    console.log(`[Chat.tsx RT] Subscribing to: ${channelIdentifier}`);
    
    // Array to track all channels we create so we can clean them up properly
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const channels: any[] = [];
    
    try {
      // Main channel for database changes
      const mainChannel = supabase
        .channel(channelIdentifier)
        .on(
          'postgres_changes',
          { event: 'INSERT', schema: 'public', table: 'chat_messages', filter: `room_id=eq.${roomId}`},
          (payload) => {
            const newMessage = payload.new as ChatMessage;
            console.log('[Chat.tsx RT] <<< INSERT REALTIME PAYLOAD RECEIVED >>>:', JSON.stringify(newMessage, null, 2));
            
            // Handle INSERT events
            if (newMessage.room_id === roomId) {
              handleRealtimeMessage(newMessage);
            } else {
              console.log(`[Chat.tsx RT] Received message for different room: ${newMessage.room_id}`);
            }
          }
        )
        .on(
          'postgres_changes',
          { event: 'UPDATE', schema: 'public', table: 'chat_messages', filter: `room_id=eq.${roomId}`},
          (payload) => {
            const updatedMessage = payload.new as ChatMessage;
            console.log('[Chat.tsx RT] <<< UPDATE REALTIME PAYLOAD RECEIVED >>>:', JSON.stringify(updatedMessage, null, 2));
            
            // Handle UPDATE events
            if (updatedMessage.room_id === roomId) {
              handleRealtimeUpdate(updatedMessage);
            } else {
              console.log(`[Chat.tsx RT] Received update for different room: ${updatedMessage.room_id}`);
            }
          }
        )
        .subscribe((status, err) => { 
          if (status === 'SUBSCRIBED') {
              console.log(`[Chat.tsx RT] Successfully SUBSCRIBED to ${channelIdentifier}`);
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
            console.warn(`[Chat.tsx RT] Subscription status: ${status} for channel ${channelIdentifier}`, err);
            // Don't treat as an error since it might be a normal part of unmounting
          }
        });
      
      channels.push(mainChannel);
      */
      
      /*
      // Safety alert channel - subscribes to direct safety broadcasts for this user
      const safetyChannelId = `safety-alert-${effectUserId}`;
      console.log(`[Chat.tsx RT] Subscribing to safety channel: ${safetyChannelId}`);
      
      const safetyChannel = supabase
        .channel(safetyChannelId)
        .on('broadcast', { event: 'safety-message' }, async (payload) => {
          console.log('[Chat.tsx RT] <<< SAFETY MESSAGE BROADCAST RECEIVED >>>:', payload);
          
          // Verify this safety message is for this room and user
          console.log(`[Chat.tsx RT] Verifying safety message payload:`, {
            payloadRoomId: payload.payload.room_id,
            roomId,
            payloadUserId: payload.payload.user_id,
            effectUserId,
            payloadChatbotId: payload.payload.chatbot_id,
            effectChatbotId,
            countryCode: payload.payload.country_code,
            effectiveCountryCode: payload.payload.effectiveCountryCode
          });
          
          if (payload.payload.room_id === roomId && 
              payload.payload.user_id === effectUserId &&
              (!effectChatbotId || payload.payload.chatbot_id === effectChatbotId)) {
            
            try {
              // Fetch the safety message using the admin API to bypass RLS issues
              console.log(`[Chat.tsx RT] Fetching safety message ID: ${payload.payload.message_id}`);
              const response = await fetch(`/api/student/safety-message?messageId=${payload.payload.message_id}&userId=${effectUserId}`, {
                method: 'GET',
                credentials: 'include'
              });
              
              if (!response.ok) {
                console.error(`[Chat.tsx RT] Error fetching safety message: HTTP ${response.status}`);
                return;
              }
              
              const safetyMessageData = await response.json();
              const safetyMessage = safetyMessageData.message;
              
              // Log what we're adding
              console.log(`[Chat.tsx RT] Successfully fetched safety message:`, {
                messageId: safetyMessage.message_id,
                countryCode: safetyMessage.metadata?.countryCode,
                effectiveCountryCode: safetyMessage.metadata?.effectiveCountryCode,
                displayCountryCode: safetyMessage.metadata?.displayCountryCode,
                helplines: safetyMessage.metadata?.helplines
              });
              
              // Directly update state instead of using handleRealtimeMessage to avoid duplication
              setMessages((prevMessages) => {
                // Step 1: Remove any safety placeholders
                const withoutPlaceholders = prevMessages.filter(msg => 
                  !msg.metadata?.isSafetyPlaceholder
                );
                
                // Step 2: Update user messages with pendingSafetyResponse=false
                const updatedMessages = withoutPlaceholders.map(msg => {
                  if (msg.role === 'user' && msg.metadata?.pendingSafetyResponse) {
                    return {
                      ...msg,
                      metadata: {
                        ...msg.metadata,
                        pendingSafetyResponse: false
                      }
                    };
                  }
                  return msg;
                });
                
                // Step 3: Check if safety message already exists (prevent duplication)
                const safetyMessageExists = updatedMessages.some(msg => 
                  msg.message_id === safetyMessage.message_id
                );
                
                // Step 4: Add the safety message only if it doesn't exist
                const newMessages = safetyMessageExists 
                  ? updatedMessages 
                  : [...updatedMessages, safetyMessage];
                
                // Step 5: Sort by timestamp
                return newMessages.sort((a, b) => 
                  new Date(a.created_at).getTime() - new Date(b.created_at).getTime()
                );
              });
              
              // Scroll to bottom after updating
              setTimeout(scrollToBottom, 100);
            } catch (err) {
              console.error('[Chat.tsx RT] Error processing safety message:', err);
              // If there's an error, try to refresh all messages as a fallback
              try {
                console.log('[Chat.tsx RT] Attempting to refresh all messages after error');
                await fetchMessages();
              } catch (refreshError) {
                console.error('[Chat.tsx RT] Error refreshing messages:', refreshError);
              }
            }
          }
        })
        .subscribe((status, err) => {
          if (status === 'SUBSCRIBED') {
            console.log(`[Chat.tsx RT] Successfully SUBSCRIBED to safety channel ${safetyChannelId}`);
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
            console.warn(`[Chat.tsx RT] Safety channel subscription status: ${status}`, err);
            // Don't treat as an error since it might be a normal part of unmounting
          }
        });
      
      channels.push(safetyChannel);
    } catch (subscriptionError) {
      console.warn('[Chat.tsx RT] Error setting up subscriptions:', subscriptionError);
    }
      
    return () => {
      // Clean up all channels
      for (const channel of channels) {
        try {
          console.log(`[Chat.tsx RT] CLEANUP for channel: ${channel.topic}`);
          supabase.removeChannel(channel);
        } catch (error) {
          console.warn(`[Chat.tsx RT] Error removing channel ${channel?.topic || 'unknown'}:`, error);
          // Continue cleanup despite errors
        }
      }
    };
    */
  }, [roomId, chatbot?.chatbot_id, userId, supabase, handleRealtimeMessage, handleRealtimeUpdate]);

  // Simplified function to fetch all messages, including safety messages
  const fetchSafetyMessages = async () => {
    if (!userId || !roomId) return;
    
    try {
      console.log(`[Chat.tsx] Fetching all messages to get safety responses for user ${userId} in room ${roomId}`);
      
      // Simply use the regular fetchMessages function to get all messages
      await fetchMessages();
      
      // Log that we've tried to fetch safety messages
      console.log(`[Chat.tsx] Completed message fetch, any safety messages should now be visible`);
    } catch (error) {
      console.error(`[Chat.tsx] Error fetching messages:`, error);
    }
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim() || isLoading || !userId || !chatbot?.chatbot_id || !roomId) return;
    setIsLoading(true); setError(null);

    // Check for potential safety trigger keywords before sending
    const potentialSafetyTrigger = initialSafetyCheck(content.trim());
    
    // --- OPTIMISTIC UPDATE WITH TRACKING FLAG ---
    const tempOptimisticLocalId = `local-user-${Date.now()}`;
    const optimisticUserMessage: ChatMessage = {
      message_id: tempOptimisticLocalId,
      room_id: roomId, user_id: userId, role: 'user', content: content.trim(),
      created_at: new Date().toISOString(),
      metadata: { 
        chatbotId: chatbot.chatbot_id, 
        isOptimistic: true,
        optimisticContent: content.trim(), // Track the content for deduplication
        potentialSafetyTrigger: potentialSafetyTrigger // Flag for potential safety concerns
      }
    };
    setMessages(prev => [...prev, optimisticUserMessage].sort((a,b) => new Date(a.created_at).getTime() - new Date(b.created_at).getTime()));
    setTimeout(scrollToBottom, 50);
    // --- END OPTIMISTIC UPDATE ---

    try {
        // Check if using direct access via URL
        const uidFromUrl = searchParams?.get('uid');
        let url = uidFromUrl && uidFromUrl === userId
          ? `/api/chat/direct-access?roomId=${roomId}&userId=${userId}`
          : `/api/chat/${roomId}`;
          
        // Add instanceId to URL parameter if available (for GET requests)
        if (instanceId) {
          url += `${url.includes('?') ? '&' : '?'}instanceId=${instanceId}`;
          console.log(`[Chat.tsx] Added instanceId parameter to URL: ${instanceId}`);
        } else {
          console.log(`[Chat.tsx] No instanceId available for URL parameters`);
        }

        console.log(`[Chat.tsx] Sending message to: ${url}`);
        
        // Critical check to ensure we have an instance ID for students
        // Log explicit warning if it's missing and should be present
        if (!instanceId && window.location.pathname.startsWith('/chat/')) {
          console.warn(`[Chat.tsx] WARNING: No instanceId when sending message. This may cause shared chat issues!`);
        }
        
        // Add direct access headers if using URL parameters
        const headers: Record<string, string> = {
          'Content-Type': 'application/json'
        };
        
        // Add direct access headers if using URL parameters
        if (uidFromUrl && uidFromUrl === userId) {
          console.log(`[Chat.tsx] Adding direct access headers with user ID: ${userId}`);
          headers['x-direct-access-user-id'] = userId;
        }
        
        // Create a reader to process the streamed response
        const response = await fetch(url, {
          method: 'POST',
          headers,
          body: JSON.stringify({ 
            content: content.trim(), 
            chatbot_id: chatbot.chatbot_id, 
            model: chatbot.model,
            instance_id: instanceId
          }),
          credentials: 'include'
        });

        if (!response.ok) {
            // Try to extract error details from response
            try {
              const errorText = await response.text();
              console.error(`[Chat.tsx] API error response (${response.status}):`, errorText);
              
              let errorMessage = `API error: ${response.status}`;
              try {
                const errorData = JSON.parse(errorText);
                errorMessage = errorData.error || errorData.message || errorMessage;
                
                // Special handling for safety interventions
                if (errorData.type === "safety_intervention_triggered") {
                  console.log("[Chat.tsx] Safety intervention detected from server response");
                  
                  // Mark the message as sent but pending safety response
                  setMessages(prev => {
                    const updated = [...prev];
                    const index = updated.findIndex(m => m.message_id === tempOptimisticLocalId);
                    if (index !== -1) {
                      updated[index] = {
                        ...updated[index],
                        metadata: {
                          ...updated[index].metadata,
                          isOptimistic: false,
                          pendingSafetyResponse: true
                        }
                      };
                    }
                    return updated;
                  });
                  
                  // Show a thinking indicator for safety response
                  setMessages(prev => {
                    // Create a placeholder for the safety response
                    const safetyPlaceholder: ChatMessage = {
                      message_id: `safety-placeholder-${Date.now()}`,
                      room_id: roomId,
                      user_id: userId,
                      role: 'system',
                      content: 'Processing safety check...',
                      created_at: new Date().toISOString(),
                      metadata: {
                        isSafetyPlaceholder: true,
                        isSystemSafetyResponse: true, // Important flag for display
                        chatbotId: chatbot.chatbot_id
                      }
                    };
                    return [...prev, safetyPlaceholder];
                  });
                  
                  setIsLoading(false);
                  
                  // Simple approach - fetch messages once after a short delay
                  console.log('[Chat.tsx] Safety intervention triggered, will fetch messages once after delay');
                  
                  // Single fetch after a delay to allow the safety message to be created
                  setTimeout(async () => {
                    try {
                      console.log('[Chat.tsx] Fetching messages to get safety response');
                      await fetchSafetyMessages();
                      
                      // Remove placeholder if it still exists
                      setMessages(prevMessages => {
                        return prevMessages.filter(msg => !msg.metadata?.isSafetyPlaceholder);
                      });
                    } catch (error) {
                      console.error('[Chat.tsx] Error fetching safety message:', error);
                      
                      // Remove placeholder on error
                      setMessages(prevMessages => {
                        return prevMessages.filter(msg => !msg.metadata?.isSafetyPlaceholder);
                      });
                    }
                  }, 2000);
                  
                  setTimeout(scrollToBottom, 50);
                  return; // Exit early without error
                }
              } catch (parseError) {
                console.warn('[Chat.tsx] Error parsing error response:', parseError);
              }
              
              throw new Error(errorMessage);
            } catch (readError) {
              throw new Error(`API error: ${response.status} - Could not read error details`);
            }
        }

        // Create a temporary placeholder for the assistant's response
        const tempAssistantId = `local-assistant-${Date.now()}`;
        const placeholderMessage: ChatMessage = {
          message_id: tempAssistantId,
          room_id: roomId,
          user_id: userId,
          role: 'assistant',
          content: '',
          created_at: new Date().toISOString(),
          metadata: {
            chatbotId: chatbot.chatbot_id,
            isStreaming: true
          }
        };
        
        // Add placeholder message to show the assistant's response is coming
        setMessages(prev => [...prev, placeholderMessage]);
        setTimeout(scrollToBottom, 50);
        
        // Start processing the stream
        if (response.body) {
          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let assistantResponse = '';
          
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              
              // Process the chunk
              const chunk = decoder.decode(value, { stream: true });
              const lines = chunk.split('\n').filter(line => line.trim().startsWith('data:'));
              
              for (const line of lines) {
                try {
                  const dataContent = line.substring(5).trim();
                  if (dataContent === '[DONE]') continue;
                  
                  const parsed = JSON.parse(dataContent);
                  const piece = parsed.content;
                  
                  if (typeof piece === 'string') {
                    assistantResponse += piece;
                    
                    // Update the placeholder message with the current content
                    setMessages(prev => {
                      const updated = [...prev];
                      const index = updated.findIndex(m => m.message_id === tempAssistantId);
                      if (index !== -1) {
                        updated[index] = {
                          ...updated[index],
                          content: assistantResponse
                        };
                      }
                      return updated;
                    });
                    setTimeout(scrollToBottom, 10);
                  }
                } catch (e) {
                  console.warn('[Chat.tsx] Stream parse error:', e);
                }
              }
            }
          } catch (streamError) {
            console.error('[Chat.tsx] Stream processing error:', streamError);
            // Remove the placeholder if we had an error with the stream
            setMessages(prev => prev.filter(m => m.message_id !== tempAssistantId));
          } finally {
            // Remove the placeholder flag, but keep the message
            setMessages(prev => {
              const updated = [...prev];
              const index = updated.findIndex(m => m.message_id === tempAssistantId);
              if (index !== -1) {
                updated[index] = {
                  ...updated[index],
                  metadata: { ...updated[index].metadata, isStreaming: false }
                };
              }
              return updated;
            });
          }
        }
    } catch (err) {
        console.error('[Chat.tsx] Chat send/receive error:', err);
        const errorMsg = err instanceof Error ? err.message : 'Failed to send message';
        setError(errorMsg);
        setMessages(prev => prev.map(m => 
            m.message_id === tempOptimisticLocalId ? 
            {...m, metadata: {...m.metadata, error: errorMsg, isOptimistic: false }} : m 
        ));
    } finally {
      setIsLoading(false);
      setTimeout(scrollToBottom, 50);
    }
  };

  const handleSubmitAssessment = async () => {
    if (isLoading || isSubmittingAssessment || !userId || !chatbot?.chatbot_id || !roomId) return;
    setIsSubmittingAssessment(true);
    
    try {
      await handleSendMessage(ASSESSMENT_TRIGGER_COMMAND);
    } catch (err) {
      console.error('[Chat.tsx] Assessment submission error:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to submit assessment';
      setError(errorMsg);
    } finally {
      setIsSubmittingAssessment(false);
    }
  };
  
  return (
    <ChatContainer>
      {fetchError && ( <ErrorContainer variant="error"> {`Error loading: ${fetchError}`} <Button onClick={() => fetchMessages()} size="small">Retry</Button> </ErrorContainer> )}
      <MessagesList>
        {isFetchingMessages && messages.length === 0 ? ( 
          <LoadingIndicator><LoadingSpinner /> Loading...</LoadingIndicator> 
        ) : !isFetchingMessages && messages.length === 0 && !fetchError ? (
          <EmptyState>
            <h3>Start with {chatbot.name}</h3>
            <p>History will appear here.</p>
            {chatbot.bot_type === 'assessment' && <p>Click the Submit Assessment button when you&apos;re ready to be assessed.</p>}
          </EmptyState>
        ) : (
          messages
            .filter(message => {
              // Show all user and assistant messages
              if (message.role === 'user' || message.role === 'assistant') {
                return true;
              }
              
              // For system messages, only show safety responses and placeholders
              if (message.role === 'system') {
                return message.metadata?.isSystemSafetyResponse === true || 
                       message.metadata?.isSafetyPlaceholder === true;
              }
              
              return false;
            })
            .map((message) => (
              <ChatMessageComponent key={message.message_id} message={message} chatbotName={chatbot.name} />
            ))
        )}
        {isLoading && (
          <ThinkingIndicator>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              <path d="M12 16V17" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
              <path d="M12 7C11.4696 7 10.9609 7.21071 10.5858 7.58579C10.2107 7.96086 10 8.46957 10 9V12C10 12.5304 10.2107 13.0391 10.5858 13.4142C10.9609 13.7893 11.4696 14 12 14C12.5304 14 13.0391 13.7893 13.4142 13.4142C13.7893 13.0391 14 12.5304 14 12V9C14 8.46957 13.7893 7.96086 13.4142 7.58579C13.0391 7.21071 12.5304 7 12 7Z" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
            </svg>
            {chatbot.name} is thinking...
          </ThinkingIndicator>
        )}
        <div ref={messagesEndRef} />
      </MessagesList>
      <StyledChatInputContainer>
        <ChatInput onSend={handleSendMessage} isLoading={isLoading} error={error} onClearError={() => setError(null)} />
        {chatbot.bot_type === 'assessment' && (
          <SubmitAssessmentButton 
            onClick={handleSubmitAssessment} 
            disabled={isLoading || isSubmittingAssessment}
            variant="primary"
          >
            {isSubmittingAssessment ? 'Submitting Assessment...' : 'Submit Assessment'}
          </SubmitAssessmentButton>
        )}
      </StyledChatInputContainer>
    </ChatContainer>
  );
}// src/components/shared/ChatMessage.tsx
'use client';

import styled, { css } from 'styled-components'; // Added css import
import ReactMarkdown, { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { ChatMessage as DbChatMessage } from '@/types/database.types'; // Renamed to avoid conflict

// --- Type Definitions ---\
interface ChatMessageProps {
  message: DbChatMessage; // Use the aliased type
  chatbotName: string;
}

type MessageMetadataWithFlags = {
    error?: unknown;
    isAssessmentFeedback?: boolean;
    isAssessmentPlaceholder?: boolean;
    isOptimistic?: boolean;
    optimisticContent?: string;
    isStreaming?: boolean;
    isSystemSafetyResponse?: boolean;
    isSafetyPlaceholder?: boolean;
    potentialSafetyTrigger?: boolean;
    pendingSafetyResponse?: boolean;
    [key: string]: unknown;
} | null | undefined;

// --- Styled Components ---
interface MessageWrapperProps {
  $isUser: boolean;
  $hasError: boolean;
}
const MessageWrapper = styled.div<MessageWrapperProps>`
  display: flex;
  justify-content: ${({ $isUser }) => $isUser ? 'flex-end' : 'flex-start'};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  opacity: ${({ $hasError }) => $hasError ? 0.7 : 1};
`;

interface MessageBubbleProps {
  $isUser: boolean;
  $hasError: boolean;
  $isAssessmentFeedback?: boolean;
  $isAssessmentPlaceholder?: boolean;
  $isOptimistic?: boolean;
  $isStreaming?: boolean;
  $isSystemSafetyResponse?: boolean;
  $isSafetyPlaceholder?: boolean;
  $pendingSafetyResponse?: boolean;
}
const MessageBubble = styled.div<MessageBubbleProps>`
  max-width: 80%;
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme, $isUser }) =>
    $isUser
      ? `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small} ${theme.borderRadius.xl}`
      : `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small}`
  };
  background: ${({ theme, $isUser, $isAssessmentFeedback, $isAssessmentPlaceholder, $isSystemSafetyResponse, $isSafetyPlaceholder }) => {
    if ($isAssessmentFeedback) return theme.colors.blue + '20'; // Light blue for feedback
    if ($isAssessmentPlaceholder) return theme.colors.backgroundDark;
    if ($isSystemSafetyResponse) return theme.colors.red + '10'; // Very light red for safety messages
    if ($isSafetyPlaceholder) return theme.colors.backgroundDark;
    return $isUser ? theme.colors.primary : theme.colors.backgroundCard;
  }};
  color: ${({ theme, $isUser, $isAssessmentFeedback, $isAssessmentPlaceholder, $isSystemSafetyResponse, $isSafetyPlaceholder }) => {
    if ($isAssessmentFeedback) return theme.colors.blue; // Darker blue text
    if ($isAssessmentPlaceholder) return theme.colors.textMuted;
    if ($isSystemSafetyResponse) return theme.colors.text; // Normal text color for safety message
    if ($isSafetyPlaceholder) return theme.colors.textMuted;
    return $isUser ? 'white' : theme.colors.text;
  }};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  position: relative;
  border: 1px solid transparent; // Default border

  ${({ $hasError, theme }) => $hasError && `
      border-color: ${theme.colors.red};
   `}

  ${({ $isAssessmentFeedback, theme }) => $isAssessmentFeedback && css`
    border-color: ${theme.colors.blue};
    /* You could add an icon or other distinct styling here */
  `}
  ${({ $isAssessmentPlaceholder }) => $isAssessmentPlaceholder && css`
    font-style: italic;
  `}
  ${({ $isOptimistic }) => $isOptimistic && css`
    opacity: 0.7;
  `}
  ${({ $isStreaming, theme }) => $isStreaming && css`
    border-left: 3px solid ${theme.colors.primary};
  `}
  ${({ $isSystemSafetyResponse, theme }) => $isSystemSafetyResponse && css`
    border-left: 3px solid ${theme.colors.red};
  `}
  ${({ $isSafetyPlaceholder }) => $isSafetyPlaceholder && css`
    font-style: italic;
  `}
  ${({ $pendingSafetyResponse }) => $pendingSafetyResponse && css`
    opacity: 0.7;
  `}
`;

const MessageHeader = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const SenderName = styled.span`
  font-weight: 600;
  font-size: 0.875rem;
  opacity: 0.8;
`;

const Timestamp = styled.span`
  font-size: 0.75rem;
  opacity: 0.7;
`;

const MessageContent = styled.div<{ $isUser: boolean }>`
  line-height: 1.5;
  word-wrap: break-word;
  // ... (Markdown styling remains the same as previous version)
  h1, h2, h3, h4, h5, h6 { margin-top: ${({ theme }) => theme.spacing.md}; margin-bottom: ${({ theme }) => theme.spacing.sm}; font-weight: 600; line-height: 1.3; color: inherit; }
  h1 { font-size: 1.5em; } h2 { font-size: 1.3em; } h3 { font-size: 1.2em; }
  h4 { font-size: 1.1em; } h5 { font-size: 1em; } h6 { font-size: 0.9em; }
  p { margin-bottom: ${({ theme }) => theme.spacing.sm}; &:last-child { margin-bottom: 0; } }
  ul, ol { margin-bottom: ${({ theme }) => theme.spacing.sm}; padding-left: ${({ theme }) => theme.spacing.lg}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }
  blockquote { border-left: 4px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.5)' : theme.colors.border}; padding-left: ${({ theme }) => theme.spacing.md}; margin: ${({ theme }) => theme.spacing.sm} 0; font-style: italic; color: ${({ $isUser }) => $isUser ? 'rgba(255,255,255,0.9)' : 'inherit'}; opacity: 0.9; }
  pre.code-block-wrapper { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)'}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin: ${({ theme }) => theme.spacing.sm} 0; overflow-x: auto; code { background: none !important; padding: 0 !important; font-family: ${({ theme }) => theme.fonts.mono}; white-space: pre; font-size: 0.9em; color: inherit; } }
  code.inline-code { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.1)'}; padding: 2px 5px; border-radius: ${({ theme }) => theme.borderRadius.small}; font-family: ${({ theme }) => theme.fonts.mono}; font-size: 0.9em; }
  hr { border: none; height: 1px; background: ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; margin: ${({ theme }) => theme.spacing.md} 0; }
  table { border-collapse: collapse; margin: ${({ theme }) => theme.spacing.sm} 0; width: auto; border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; th, td { border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm}; } th { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)'}; font-weight: 600; } }
  a { color: ${({ $isUser, theme }) => $isUser ? '#c1d9ff' : theme.colors.primaryDark}; text-decoration: underline; &:hover { text-decoration: none; } }
  ul.contains-task-list { list-style-type: none; padding-left: ${({ theme }) => theme.spacing.sm}; }
  li.task-list-item { display: flex; align-items: center; input[type="checkbox"] { margin-right: ${({ theme }) => theme.spacing.sm}; cursor: default; } }
`;

const ErrorIndicator = styled.div`
    font-size: 0.75rem;
    color: ${({ theme }) => theme.colors.red};
    margin-top: ${({ theme }) => theme.spacing.xs};
    font-style: italic;
`;
// --- End Styled Components ---

// --- Helper Functions ---
function formatTimestamp(timestamp: string | undefined): string {
  // ... (formatTimestamp remains the same)
  if (!timestamp) return '';
  const date = new Date(timestamp);
  if (isNaN(date.getTime())) return '';
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  if (diffInSeconds < 5) return 'just now';
  if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
  if (now.getFullYear() === date.getFullYear()) {
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  } else {
    return date.toLocaleDateString();
  }
}

// Get human-readable country name from ISO country code
function getCountryNameFromCode(code: string): string {
  // This is a lookup function to convert country codes to readable names
  // We do this client-side to avoid hardcoding names in the database
  const COUNTRY_NAMES: Record<string, string> = {
    // Standard ISO codes
    'US': 'United States',
    'GB': 'UK',  // Special case - GB is the ISO code, but UK is more commonly used
    'CA': 'Canada',
    'AU': 'Australia',
    'IE': 'Ireland',
    'FR': 'France',
    'DE': 'Germany',
    'IT': 'Italy',
    'ES': 'Spain',
    'PT': 'Portugal',
    'GR': 'Greece',
    'AE': 'UAE',
    'MY': 'Malaysia',
    // Handle common non-standard codes
    'UK': 'UK',   // Handle non-standard "UK" as well
    // Add other country names as needed
  };
  
  // Return the name if found, otherwise just use the code
  return COUNTRY_NAMES[code] || code;
}
// -----------------------

// --- React Markdown Custom Components (remain the same) ---
const markdownComponents: Components = {
    a: (props) => (<a {...props} target="_blank" rel="noopener noreferrer" />),
    input: (props) => { const { checked, ...rest } = props; return (<input type="checkbox" checked={!!checked} disabled={true} readOnly {...rest} /> ); },
    code({ className, children, inline, ...props }: React.HTMLAttributes<HTMLElement> & { className?: string; children?: React.ReactNode; inline?: boolean; }) {
        const match = /language-(\w+)/.exec(className || '');
        const codeString = String(children).replace(/\n$/, '');
        const { style: _unused, ...restProps } = props;
        void _unused;
        return !inline ? (
            <pre className="code-block-wrapper" {...restProps}>
                <code className={match ? `language-${match[1]}` : undefined}>{codeString}</code>
            </pre>
        ) : (
            <code className={`inline-code ${className || ''}`} {...restProps}>{codeString}</code>
        );
    }
};
// --- End React Markdown Components ---

// --- Main Component ---
function ChatMessageDisplay({ message, chatbotName }: ChatMessageProps) {
    const isUser = message.role === 'user';
    
    const metadata = message.metadata as MessageMetadataWithFlags; // Use new type
    const hasError = !!metadata?.error;
    const errorMessage = hasError ? String(metadata.error) : null;
    const isAssessmentFeedback = !!metadata?.isAssessmentFeedback;
    const isAssessmentPlaceholder = !!metadata?.isAssessmentPlaceholder;
    const isOptimistic = !!metadata?.isOptimistic;
    const isStreaming = !!metadata?.isStreaming;
    const isSystemSafetyResponse = !!metadata?.isSystemSafetyResponse;
    const isSafetyPlaceholder = !!metadata?.isSafetyPlaceholder;
    const pendingSafetyResponse = !!metadata?.pendingSafetyResponse;
    
    let senderNameToDisplay = chatbotName;
    if (isUser) {
        senderNameToDisplay = 'You';
    } else if (isSystemSafetyResponse || isSafetyPlaceholder) {
        // Use a specific name for safety messages - prioritize displayCountryCode (set by API),
        // then fallback to effectiveCountryCode, then countryCode
        const displayCode = metadata?.displayCountryCode || metadata?.effectiveCountryCode || metadata?.countryCode;
        
        // Get country display name using a lookup function
        let countryName = '';
        if (displayCode) {
            // Don't show anything for DEFAULT
            if (displayCode !== 'DEFAULT') {
                // Use a lookup function to get readable country names for ISO codes
                countryName = getCountryNameFromCode(String(displayCode));
            }
        }
        
        const countryDisplay = countryName ? ` - ${countryName}` : '';
        senderNameToDisplay = isSafetyPlaceholder ? 'Safety Check' : `Support Resources${countryDisplay}`;
        
        // Log safety message details for debugging
        if (isSystemSafetyResponse) {
            console.log(`[SafetyDiagnostics] ===== UI SAFETY MESSAGE TRACKING =====`);
            console.log(`[SafetyDiagnostics] Safety Message UI Rendering Details:`);
            console.log(`[SafetyDiagnostics] message.message_id: ${message.message_id}`);
            console.log(`[SafetyDiagnostics] metadata.countryCode: "${metadata?.countryCode}"`);
            console.log(`[SafetyDiagnostics] metadata.effectiveCountryCode: "${metadata?.effectiveCountryCode}"`);
            console.log(`[SafetyDiagnostics] metadata.displayCountryCode: "${metadata?.displayCountryCode}"`);
            console.log(`[SafetyDiagnostics] metadata.helplines: "${metadata?.helplines || 'not provided'}"`);
            console.log(`[SafetyDiagnostics] finalDisplayCode: "${displayCode}"`);
            console.log(`[SafetyDiagnostics] countryName: "${countryName}"`);
            console.log(`[SafetyDiagnostics] senderNameToDisplay: "${senderNameToDisplay}"`);
            console.log(`[SafetyDiagnostics] Content Length: ${message.content?.length || 0} characters`);
            console.log(`[SafetyDiagnostics] First 100 chars: "${message.content?.substring(0, 100)}..."`);
            console.log(`[SafetyDiagnostics] Has MANDATORY HELPLINES marker: ${message.content?.includes('===== MANDATORY HELPLINES')}`);
            console.log(`[SafetyDiagnostics] ===== END TRACKING =====`);
            
            // Original logger
            console.log('[ChatMessage] Displaying safety message with details:', { 
                countryCode: metadata?.countryCode,
                effectiveCountryCode: metadata?.effectiveCountryCode,
                displayCountryCode: metadata?.displayCountryCode,
                finalDisplayCode: displayCode,
                countryName,
                content: message.content,
                messageId: message.message_id
            });
            
            // Check if the message content contains the expected helplines based on the country
            let helplineCheckResult: {
                containsPhoneNumber?: boolean;
                containsWebsite?: boolean;
                containsSpecificHelplines?: boolean;
                overallSuccess?: boolean;
                messageLength?: number;
                formattedHelplines?: boolean;
                bulletPointCount?: number;
                hasFormattedHelplineSection?: boolean;
                hasHelplineHeader?: boolean;
                hasHelplineFooter?: boolean;
                hasBulletPoints?: boolean;
                helplines?: string;
            } = {};
            
            // Check for bullet points which indicate helplines are present
            const hasBulletPoints = message.content.includes('* ');
            const hasPhoneNumbers = message.content.includes('Phone:');
            const hasWebsites = message.content.includes('Website:');
            
            // We don't use markers anymore, but define these variables to maintain compatibility
            const hasHelplineHeader = false;
            const hasHelplineFooter = false;
            
            // Log metadata helplines for debugging
            if (metadata?.helplines) {
                console.log(`[ChatMessage] Safety message has metadata helplines: ${metadata.helplines}`);
            }
            
            // Display exact message content for verification
            console.log(`[SafetyDiagnostics] CRITICAL SAFETY VERIFICATION - Full message content for inspection:`);
            console.log(`${message.content}`);
            
            // Parse and count the helplines that are in the message (now without markers)
            const messageLines = message.content.split('\n');
            
            // Find all lines that start with a bullet point
            const actualHelplines = messageLines.filter(line => line.trim().startsWith('*'));
            
            if (actualHelplines.length > 0) {
                console.log(`[SafetyDiagnostics] Found ${actualHelplines.length} helplines in the message content:`);
                actualHelplines.forEach(line => {
                    console.log(`[SafetyDiagnostics] HELPLINE: ${line.trim()}`);
                });
                
                // Verify these match the metadata if provided
                if (metadata?.helplines && typeof metadata.helplines === 'string') {
                    const metadataHelplineNames = metadata.helplines.split(',');
                    console.log(`[SafetyDiagnostics] Checking if displayed helplines match metadata helplines:`);
                    console.log(`[SafetyDiagnostics] - Metadata has ${metadataHelplineNames.length} helplines: ${metadataHelplineNames.join(', ')}`);
                    
                    let matchCount = 0;
                    for (const name of metadataHelplineNames) {
                        const found = actualHelplines.some(line => line.includes(name));
                        console.log(`[SafetyDiagnostics] - Helpline "${name}" in message: ${found ? 'YES' : 'NO'}`);
                        if (found) matchCount++;
                    }
                    
                    console.log(`[SafetyDiagnostics] Match result: ${matchCount}/${metadataHelplineNames.length} helplines found in message`);
                }
            } else {
                console.error(`[SafetyDiagnostics] FAILED TO FIND HELPLINES in message content!`);
            }
            
            // If we have bullet points and phone numbers or websites, consider it successful
            if (hasBulletPoints && (hasPhoneNumbers || hasWebsites)) {
                helplineCheckResult = {
                    hasFormattedHelplineSection: true,
                    hasHelplineHeader: false, // We don't use these markers anymore
                    hasHelplineFooter: false, // We don't use these markers anymore
                    hasBulletPoints,
                    helplines: typeof metadata?.helplines === 'string' ? metadata.helplines : 'unknown',
                    overallSuccess: true,
                    messageLength: message.content.length
                };
            }
            // Use a generic check for all countries instead of hardcoding specific helplines
            else {
                // Generic check for any helpline-like content
                // Look for typical helpline indicators: phone numbers and websites
                const containsPhone = /\b\d{3}[- .]?\d{3}[- .]?\d{4}\b|\b\d{5}\b|\b\d{4}\s?\d{4}\b|\b\d{3}\b/.test(message.content);
                const containsWebsite = /\b\w+\.\w+(\.\w+)?\b/.test(message.content);
                
                // Check if metadata has helpline names we can verify
                let containsSpecificHelplines = false;
                if (metadata?.helplines && typeof metadata.helplines === 'string') {
                    const metadataHelplineNames = metadata.helplines.split(',');
                    // Check if at least one of the expected helplines is in the message
                    containsSpecificHelplines = metadataHelplineNames.some(name => 
                        message.content.includes(name));
                }
                
                helplineCheckResult = {
                    containsPhoneNumber: containsPhone,
                    containsWebsite: containsWebsite,
                    containsSpecificHelplines,
                    overallSuccess: containsPhone || containsWebsite || containsSpecificHelplines || (hasHelplineHeader && hasHelplineFooter), 
                    messageLength: message.content.length
                };
            }
            
            console.log(`[ChatMessage] Helpline check for ${countryName}:`, helplineCheckResult);
            
            if (!helplineCheckResult.overallSuccess) {
                console.warn(`[ChatMessage] CRITICAL WARNING: Safety message may not contain proper helplines!`);
                // Log the entire message content to see exactly what's coming through
                console.log(`[ChatMessage] FULL SAFETY MESSAGE CONTENT (for debugging):\n${message.content}`);
                console.log(`[ChatMessage] Safety message metadata:`, message.metadata);
            }
        }
    } else if (isAssessmentFeedback || isAssessmentPlaceholder || message.role === 'system') {
        // For system messages or assessment feedback, use a generic name or the bot's name
        // If it's a placeholder or feedback, you might want a specific title like "Assessment System"
        senderNameToDisplay = isAssessmentFeedback ? `${chatbotName} (Assessment)` : (isAssessmentPlaceholder ? 'System' : chatbotName);
        if (message.user_id === 'system-assessment' || message.user_id === 'system-feedback') {
             // Let's refine this. If the message.role is 'system', it should be styled as such.
        }
    }


    return (
        <MessageWrapper $isUser={isUser} $hasError={hasError}>
            <MessageBubble
              $isUser={isUser}
              $hasError={hasError}
              $isAssessmentFeedback={isAssessmentFeedback}
              $isAssessmentPlaceholder={isAssessmentPlaceholder}
              $isOptimistic={isOptimistic}
              $isStreaming={isStreaming}
              $isSystemSafetyResponse={isSystemSafetyResponse}
              $isSafetyPlaceholder={isSafetyPlaceholder}
              $pendingSafetyResponse={pendingSafetyResponse}
            >
                <MessageHeader>
                    <SenderName>{senderNameToDisplay}</SenderName>
                    <Timestamp>
                        {isOptimistic ? 'Sending...' : formatTimestamp(message.created_at)}
                    </Timestamp>
                </MessageHeader>
                <MessageContent $isUser={isUser}>
                    <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={markdownComponents}
                    >
                        {message.content || ''}
                    </ReactMarkdown>
                    {isStreaming && (
                      <span style={{ display: 'inline-block', width: '8px', height: '16px', background: '#3498db', marginLeft: '2px', animation: 'blink 1s infinite' }} />
                    )}
                </MessageContent>
                {hasError && (
                    <ErrorIndicator title={errorMessage || 'Failed to send message'}>
                       ⚠️ Failed to send
                    </ErrorIndicator>
                 )}
            </MessageBubble>
        </MessageWrapper>
    );
}
// --- End Main Component ---

export { ChatMessageDisplay as ChatMessage };// src/components/shared/ChatInput.tsx
'use client';

import { useState, KeyboardEvent } from 'react';
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';

// ... (InputContainer, InputForm, TextInput, SendButton, ErrorAlert styled components remain the same)

const InputForm = styled.form`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
  }
`;

const TextInput = styled.input`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
  }
  
  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  
  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const SendButton = styled(Button)`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.xl};
  min-width: 100px;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const ErrorAlert = styled(Alert)`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;


const InputHint = styled.p`
  font-size: 0.8rem; /* Slightly larger for better readability */
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.sm};
  text-align: left; /* Align to left, often better for hints near input */
  padding-left: ${({ theme }) => theme.spacing.xs};

  /* Default hint shown on mobile for Ctrl/Cmd+Enter */
  @media (min-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none; 
  }
`;

// We're removing this since we now use a button instead of a command
// Keeping the styled component in case we need it for other hints later
const AssessmentHint = styled(InputHint)`
    display: block; /* Ensure it's always visible if provided */
    text-align: center; /* Center this specific hint */
    margin-bottom: -${({ theme }) => theme.spacing.xs}; /* Adjust spacing slightly */
`;


interface ChatInputProps {
  onSend: (content: string) => Promise<void>;
  isLoading: boolean;
  error: string | null;
  onClearError: () => void;
  hint?: string; // New optional hint prop
}

export default function ChatInput({ onSend, isLoading, error, onClearError, hint }: ChatInputProps) {
  const [message, setMessage] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() || isLoading) return;

    const content = message.trim();
    setMessage(''); // Clear input immediately
    await onSend(content);
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      // Prevent default Enter behavior (like newline in some setups) if Ctrl/Meta is pressed
      e.preventDefault(); 
      handleSubmit(e as unknown as React.FormEvent); // Cast because original event is KeyboardEvent
    } else if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
      // If just Enter is pressed (and not Shift+Enter for newline)
      e.preventDefault(); 
      handleSubmit(e as unknown as React.FormEvent);
    }
  };

  return (
    // InputContainer styling has been removed from Chat.tsx and should be part of ChatInput itself if needed.
    // For now, assuming StyledChatInputContainer in Chat.tsx provides the main padding.
    <> 
      {error && (
        <ErrorAlert variant="error" onClick={onClearError} style={{marginBottom: '8px'}}>
          {error}
        </ErrorAlert>
      )}
      
      <InputForm onSubmit={handleSubmit}>
        <TextInput
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder="Type your message..."
          disabled={isLoading}
        />
        <SendButton
          type="submit"
          disabled={isLoading || !message.trim()}
        >
          {isLoading ? 'Sending...' : 'Send'}
        </SendButton>
      </InputForm>

      {hint && <AssessmentHint>{hint}</AssessmentHint>}
      
      {/* General hint for mobile, could be combined or made more context-aware */}
      {!hint && (
         <InputHint>
            Press Enter to send. Use Shift+Enter for a new line.
         </InputHint>
      )}
    </>
  );
}// src/components/ThemeProvider.tsx
'use client';

import { ThemeProvider as StyledThemeProvider } from 'styled-components';
import theme from '@/styles/theme';
import { GlobalStyles } from '@/styles/GlobalStyles';

export default function ThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <StyledThemeProvider theme={theme}>
      <GlobalStyles />
      {children}
    </StyledThemeProvider>
  );
}// src/components/teacher/StudentChatHistory.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

const HistoryContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.xl};
`;

const FilterCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const FilterTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterForm = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    align-items: stretch;
  }
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

const StudentNameDisplay = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.primary};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }
`;

const Select = styled.select`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  min-width: 200px;
`;

const ConversationCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ConversationHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const ConversationInfo = styled.div`
  h4 {
    margin: 0;
    color: ${({ theme }) => theme.colors.text};
  }

  .timestamp {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
`;

const MessagesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.md};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadMoreButton = styled(Button)`
  margin: ${({ theme }) => theme.spacing.md} auto;
  display: block;
`;

interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface StudentChatHistoryProps {
  roomId: string;
  studentId: string;
  studentName: string;
  chatbots: ChatbotOption[];
}

export default function StudentChatHistory({
  roomId,
  studentId,
  studentName,
  chatbots
}: StudentChatHistoryProps) {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedChatbotFilter, setSelectedChatbotFilter] = useState<string>('');
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(false);

  const fetchConversations = useCallback(async (resetPage = true) => {
    const currentPageToFetch = resetPage ? 0 : page;

    if (resetPage) {
      setPage(0);
      setConversations([]);
    }

    setLoading(true);
    setError(null);

    try {
      // Use the new flattened API endpoint
      const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';
      const url = new URL(`/api/teacher/student-chats`, baseUrl);
      
      // Add parameters as query parameters
      url.searchParams.append('roomId', roomId);
      url.searchParams.append('studentId', studentId);
      
      if (selectedChatbotFilter) {
        url.searchParams.append('chatbotId', selectedChatbotFilter);
      }

      // Add pagination params if your API supports them
      if (!resetPage && currentPageToFetch > 0) {
        url.searchParams.append('page', currentPageToFetch.toString());
        url.searchParams.append('limit', '10'); // Example limit
      }

      const response = await fetch(url.toString());

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({error: 'Failed to parse error response'}));
        throw new Error(errorData.error || 'Failed to fetch chat history');
      }

      const data = await response.json();

      if (resetPage) {
        setConversations(data.conversations || []);
      } else {
        setConversations(prev => [...prev, ...(data.conversations || [])]);
      }

      // Set has more if API returns pagination info
      setHasMore(data.pagination?.hasMore || false);

      if (!resetPage && data.conversations && data.conversations.length > 0) {
        setPage(currentPageToFetch + 1);
      } else if (resetPage) {
        setPage(0);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load chat history');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, selectedChatbotFilter, page]);

  useEffect(() => {
    // Initial fetch or fetch when filter changes
    fetchConversations(true);
  }, [roomId, studentId, selectedChatbotFilter, fetchConversations]);

  const handleLoadMore = () => {
    fetchConversations(false);
  };

  const handleChatbotChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedChatbotFilter(e.target.value);
  };

  const formatDate = (dateString: string) => {
    if (!dateString) return 'Unknown date';
    return new Date(dateString).toLocaleString();
  };

  return (
    <HistoryContainer>
      <FilterCard>
        <FilterTitle>Chat History</FilterTitle>
        <FilterForm>
          <StudentNameDisplay>
            Showing conversations for: {studentName}
          </StudentNameDisplay>
          <FilterControls>
            <Select
              value={selectedChatbotFilter}
              onChange={handleChatbotChange}
            >
              <option value="">All Chatbots</option>
              {chatbots.map(chatbot => (
                <option key={chatbot.chatbot_id} value={chatbot.chatbot_id}>
                  {chatbot.name}
                </option>
              ))}
            </Select>
          </FilterControls>
        </FilterForm>
      </FilterCard>

      {error && (
        <Alert variant="error">Error: {error}</Alert>
      )}

      {loading && conversations.length === 0 ? (
        <Card>
          <p>Loading conversations...</p>
        </Card>
      ) : conversations.length === 0 ? (
        <EmptyState>
          <h3>No conversations found</h3>
          <p>
            {selectedChatbotFilter
              ? `This student hasn't chatted with the selected chatbot yet.`
              : `This student hasn't chatted with any chatbots yet.`}
          </p>
        </EmptyState>
      ) : (
        <>
          {conversations.map((conversation, index) => {
            const chatbotNameForDisplay = conversation.chatbot_name || 'Unknown Chatbot';

            return (
              <ConversationCard key={`conv-${index}-${conversation.started_at}`}>
                <ConversationHeader>
                  <ConversationInfo>
                    <h4>{chatbotNameForDisplay}</h4>
                    <span className="timestamp">Started {formatDate(conversation.started_at)}</span>
                  </ConversationInfo>
                </ConversationHeader>

                <MessagesList>
                  {conversation.messages.map(message => (
                    <ChatMessageComponent
                      key={message.message_id}
                      message={message}
                      chatbotName={chatbotNameForDisplay}
                    />
                  ))}
                </MessagesList>
              </ConversationCard>
            );
          })}

          {hasMore && (
            <LoadMoreButton
              variant="outline"
              onClick={handleLoadMore}
              disabled={loading}
            >
              {loading ? 'Loading...' : 'Load More'}
            </LoadMoreButton>
          )}
        </>
      )}
    </HistoryContainer>
  );
}'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { Card, Button, Alert, Badge } from '@/styles/StyledComponents'; // Added Alert and Badge
import ChatbotForm from '@/components/teacher/ChatbotForm';
import RoomForm from '@/components/teacher/RoomForm';
import RoomList from '@/components/teacher/RoomList';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import ConcernsList from '@/components/teacher/ConcernsList'; // Import ConcernsList
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import Loader
import { createClient } from '@/lib/supabase/client';
import type { Chatbot, Room as BaseRoom } from '@/types/database.types'; // Use BaseRoom alias

// --- Styled Components (Keep as previously defined) ---
const DashboardContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  flex-wrap: wrap; /* Allow wrapping */
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    button {
      width: 100%;
    }
  }
`;

const SectionTitle = styled.h2`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.5rem;
  margin: 0; /* Remove default margin */
`;

const StatsCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: pointer; // Make stats cards clickable if they link somewhere
  transition: transform 0.2s ease, box-shadow 0.2s ease;

   &:hover {
      transform: translateY(-2px);
      box-shadow: ${({ theme }) => theme.shadows.md};
   }

  h3 {
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }

  .value {
    font-size: 2rem;
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const ChatbotList = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};

  &:hover {
    transform: translateY(-2px);
    box-shadow: ${({ theme }) => theme.shadows.md};
  }

  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
  }

  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1;
    min-height: 2.5rem;

    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }

  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.sm};
    margin-top: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap;
    justify-content: flex-start;

    button, a {
        flex-grow: 1;
        min-width: 100px;
        text-align: center;
    }

     @media (max-width: 550px) {
         button, a {
            width: 100%;
            flex-grow: 0;
         }
     }
  }

  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
`;


const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 450px;
  margin: 20px;
  position: relative;
  text-align: center;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

// --- Define the Room type WITH joined data (Matching API Response) ---
interface RoomWithChatbots extends BaseRoom {
  room_chatbots: {
    chatbots: {
      chatbot_id: string;
      name: string;
    } | null;
  }[] | null;
}
// ---------------------------------------------------------------


interface DeleteModalProps {
  isOpen: boolean;
  itemType: 'Chatbot' | 'Room';
  itemName: string;
  onConfirm: () => Promise<void>; // Make confirm async
  onCancel: () => void;
  isDeleting: boolean;
}

function DeleteModal({ isOpen, itemType, itemName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete {itemType}</ModalTitle>
        <ModalText>
          Are you sure you want to delete the {itemType.toLowerCase()} &quot;
          <strong>{itemName}</strong>
          &quot;? This action cannot be undone and may affect associated data (e.g., student memberships, chat history).
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
             variant="secondary" // Use secondary as base, style for danger
             style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }}
             onClick={onConfirm} // Directly call the passed async handler
             disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : `Yes, Delete ${itemType}`}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

export default function Dashboard() {
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  // --- FIX: Use the correct type for rooms state ---
  const [rooms, setRooms] = useState<RoomWithChatbots[]>([]);
  // --------------------------------------------------
  const [stats, setStats] = useState({
    totalChatbots: 0,
    totalRooms: 0,
    activeRooms: 0,
    pendingConcerns: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    type: 'Chatbot' | 'Room';
    id: string | null;
    name: string;
  }>({ isOpen: false, type: 'Chatbot', id: null, name: '' });
   const [isDeleting, setIsDeleting] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null); // Edit modal likely needs BaseRoom
  const supabase = createClient();
  const router = useRouter();

  const fetchDashboardData = useCallback(async () => {
    setError(null);

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }

      // Fetch all data concurrently
      const [chatbotsRes, roomsRes, concernsRes] = await Promise.all([
        supabase.from('chatbots').select('*').eq('teacher_id', user.id),
        // --- FIX: Fetch rooms using the API route which handles the join ---
        fetch('/api/teacher/rooms').then(res => {
            if (!res.ok) throw new Error('Failed to fetch rooms');
            return res.json();
        }),
        // --------------------------------------------------------------------
        supabase.from('flagged_messages')
          .select('flag_id', { count: 'exact', head: true })
          .eq('teacher_id', user.id)
          .eq('status', 'pending')
      ]);

      // Process Chatbots
      if (chatbotsRes.error) throw new Error(`Failed to fetch chatbots: ${chatbotsRes.error.message}`);
      const chatbotsData = chatbotsRes.data || [];
      setChatbots(chatbotsData);

      // Process Rooms (data is already fetched via API)
      const roomsData: RoomWithChatbots[] = roomsRes || []; // Type assertion based on API response
      setRooms(roomsData);

       // Process Concerns Count
       if (concernsRes.error) throw new Error(`Failed to fetch concerns count: ${concernsRes.error.message}`);
       const pendingConcernsCount = concernsRes.count || 0;

      // Update Stats
      setStats({
        totalChatbots: chatbotsData.length,
        totalRooms: roomsData.length,
        activeRooms: roomsData.filter(room => room.is_active).length,
        pendingConcerns: pendingConcernsCount,
      });

    } catch (error) {
      console.error('Error fetching dashboard data:', error);
      setError(error instanceof Error ? error.message : 'Failed to load dashboard data.');
      // Reset state on error
      setChatbots([]);
      setRooms([]);
      setStats({ totalChatbots: 0, totalRooms: 0, activeRooms: 0, pendingConcerns: 0 });
    } finally {
      setLoading(false);
    }
  }, [supabase, router]); // Dependencies

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchDashboardData();
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    fetchDashboardData();
  };

  // Test Chatbot (unused function removed)

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const openDeleteModal = (type: 'Chatbot' | 'Room', id: string, name: string) => {
    setDeleteModal({ isOpen: true, type, id, name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, type: 'Chatbot', id: null, name: '' });
  };

  // --- Combined Delete Handler ---
  const handleDeleteConfirm = async () => {
    if (!deleteModal.id || !deleteModal.type) return;

    setIsDeleting(true);
    setError(null);

    const { type, id } = deleteModal;
    const endpoint = type === 'Chatbot' ? `/api/teacher/chatbots/${id}` : `/api/teacher/rooms/${id}`;

    try {
        const response = await fetch(endpoint, { method: 'DELETE' });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete ${type.toLowerCase()}`);
        }

        console.log(`${type} ${id} deleted successfully.`);
        closeDeleteModal();
        fetchDashboardData(); // Refresh dashboard
    } catch (error) {
        console.error(`Error deleting ${type}:`, error);
        setError(error instanceof Error ? error.message : `Failed to delete ${type}.`);
        // Keep modal open on error to show feedback if desired, or close:
        // closeDeleteModal();
    } finally {
        setIsDeleting(false);
    }
};


  const handleEditRoom = (room: BaseRoom) => { // Use BaseRoom for editing modal
    setEditingRoom(room);
  };

  const handleCloseEditRoom = () => {
    setEditingRoom(null);
  };

  const handleRoomEditSuccess = () => {
    setEditingRoom(null);
    fetchDashboardData();
  };

  // Get model display name (no changes)
    const getModelDisplayName = (model: string | undefined) => {
      if (!model) return 'Default Model';
      const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B A22B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash'
      };
      return modelNames[model] || model;
    };


  if (loading) {
    return <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading dashboard...</Card>;
  }

  return (
    <div>
        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        {/* Quick Stats Section */}
        <Section>
            <DashboardContainer>
            <StatsCard onClick={() => document.getElementById('chatbots-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Chatbots</h3>
                <div className="value">{stats.totalChatbots}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Rooms</h3>
                <div className="value">{stats.totalRooms}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Active Rooms</h3>
                <div className="value">{stats.activeRooms}</div>
            </StatsCard>
            <StatsCard style={{ cursor: 'pointer' }} onClick={() => document.getElementById('concerns-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Pending Concerns</h3>
                <div className="value" style={{ color: stats.pendingConcerns > 0 ? '#F87F7F' : undefined }}>
                    {stats.pendingConcerns}
                </div>
                 {stats.pendingConcerns > 0 && <Badge variant='error' style={{ marginTop: '8px' }}>Review Needed</Badge>}
            </StatsCard>
            </DashboardContainer>
        </Section>

      {/* Concerns Section */}
      <Section id="concerns-section">
            <SectionHeader>
                 <SectionTitle>Welfare Concerns</SectionTitle>
                 {/* Can add a direct link/button to a dedicated concerns page if needed */}
            </SectionHeader>
            <ConcernsList />
       </Section>


      {/* Chatbots Section */}
      <Section id="chatbots-section">
        <SectionHeader>
          <SectionTitle>Your Chatbots</SectionTitle>
          <Button onClick={() => setShowChatbotForm(true)}>
            + Create Chatbot
          </Button>
        </SectionHeader>

        {showChatbotForm && (
          <ChatbotForm
            onClose={() => setShowChatbotForm(false)}
            onSuccess={handleChatbotCreated}
          />
        )}

        {chatbots.length > 0 ? (
          <ChatbotList>
            {chatbots.map(chatbot => (
              <ChatbotCard key={chatbot.chatbot_id}>
                <h3>{chatbot.name}</h3>
                <p className="description">{chatbot.description || 'No description provided.'}</p>
                <div className="model-info">
                  Model: {getModelDisplayName(chatbot.model)}
                </div>
                <div className="actions">
                  <Button
                    size="small"
                    variant="outline"
                    onClick={() => handleEditChatbot(chatbot.chatbot_id)}
                    title="Edit chatbot configuration"
                  >
                    Configure
                  </Button>
                   <Button
                        as={Link}
                        size="small"
                        variant="outline"
                        href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/knowledge-base`}
                        title="Manage knowledge base documents"
                    >
                        Knowledge Base
                    </Button>
                   <Button
                        size="small"
                        variant="secondary"
                         style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }} // Danger style
                        onClick={() => openDeleteModal('Chatbot', chatbot.chatbot_id, chatbot.name)}
                        title="Delete this chatbot"
                    >
                        Delete
                    </Button>
                </div>
              </ChatbotCard>
            ))}
          </ChatbotList>
        ) : (
          <Card>
            <p>No chatbots created yet. Click &quot;+ Create Chatbot&quot; to get started!</p>
          </Card>
        )}
      </Section>

      {/* Rooms Section */}
      <Section id="rooms-section">
        <SectionHeader>
          <SectionTitle>Classroom Rooms</SectionTitle>
          <Button onClick={() => setShowRoomForm(true)} disabled={chatbots.length === 0}>
            + Create Room
          </Button>
           {chatbots.length === 0 && <Alert variant='info'>Create a chatbot before creating a room.</Alert>}
        </SectionHeader>

        {showRoomForm && (
          <RoomForm
            chatbots={chatbots}
            onClose={() => setShowRoomForm(false)}
            onSuccess={handleRoomCreated}
          />
        )}

        <RoomList
          rooms={rooms} // Pass the correctly typed rooms state
          onUpdate={fetchDashboardData}
          onEditRoom={handleEditRoom}
          onDeleteRoom={(room) => openDeleteModal('Room', room.room_id, room.room_name)} // Pass handler for delete button in list
          onArchiveRoom={(room) => router.push(`/teacher-dashboard/rooms/${room.room_id}`)} // Redirect to room page for archiving
        />
      </Section>

      {/* Delete Confirmation Modal */}
      <DeleteModal
        isOpen={deleteModal.isOpen}
        itemType={deleteModal.type}
        itemName={deleteModal.name}
        onConfirm={handleDeleteConfirm} // Use the combined handler
        onCancel={closeDeleteModal}
        isDeleting={isDeleting}
      />

      {/* Edit Room Modal */}
      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={handleCloseEditRoom}
          onSuccess={handleRoomEditSuccess}
        />
      )}
    </div>
  );
}// src/components/teacher/EmbeddingStatus.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert } from '@/styles/StyledComponents';
import { Document, ProcessingStats } from '@/types/knowledge-base.types';

const StatusContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h3`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const ProgressContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ProgressBar = styled.div`
  height: 8px;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  overflow: hidden;
`;

const ProgressFill = styled.div<{ $progress: number; $hasErrors: boolean }>`
  height: 100%;
  width: ${({ $progress }) => `${$progress}%`};
  background-color: ${({ theme, $hasErrors }) => 
    $hasErrors ? theme.colors.secondary : theme.colors.green};
  transition: width 0.5s ease;
`;

const StatsContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const StatCard = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  text-align: center;
`;

const StatValue = styled.div`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: ${({ theme }) => theme.spacing.xs};
  color: ${({ theme }) => theme.colors.text};
`;

const StatLabel = styled.div`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const StatusText = styled.div<{ $isComplete: boolean; $hasErrors: boolean }>`
  color: ${({ theme, $isComplete, $hasErrors }) => 
    $isComplete 
      ? $hasErrors ? theme.colors.secondary : theme.colors.green 
      : theme.colors.text};
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

interface EmbeddingStatusProps {
  document: Document;
  chatbotId: string;
  onRefresh?: () => void;
}

export default function EmbeddingStatus({ 
  document, 
  chatbotId,
  onRefresh
}: EmbeddingStatusProps) {
  const [stats, setStats] = useState<ProcessingStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(null);

  const fetchStatus = useCallback(async () => {
    try {
      const response = await fetch(
        `/api/teacher/chatbots/${chatbotId}/vectorize?documentId=${document.document_id}`
      );
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch processing status');
      }
      
      const data = await response.json();
      setStats(data.processingStats);
      
      // Update document with latest status
      if (data.document.status !== document.status && onRefresh) {
        onRefresh();
      }
      
      // If processing is complete, stop polling
      if (data.document.status === 'completed' || data.document.status === 'error') {
        if (pollingInterval) {
          clearInterval(pollingInterval);
          setPollingInterval(null);
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch processing status');
    } finally {
      setLoading(false);
    }
  }, [document.document_id, document.status, chatbotId, onRefresh, pollingInterval]);

  useEffect(() => {
    fetchStatus();
    
    // Set up polling for processing status
    if (document.status === 'processing' && !pollingInterval) {
      const interval = setInterval(fetchStatus, 5000); // Poll every 5 seconds
      setPollingInterval(interval);
    }
    
    return () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [document.status, fetchStatus, pollingInterval]);

  if (loading) {
    return (
      <StatusContainer>
        <p>Loading processing status...</p>
      </StatusContainer>
    );
  }

  if (error) {
    return (
      <StatusContainer>
        <Alert variant="error">{error}</Alert>
      </StatusContainer>
    );
  }

  if (!stats) {
    return (
      <StatusContainer>
        <p>No processing statistics available</p>
      </StatusContainer>
    );
  }

  const progressPercent = stats.totalChunks > 0
    ? Math.round((stats.processedChunks / stats.totalChunks) * 100)
    : 0;
  
  const hasErrors = stats.errorChunks > 0;
  const isComplete = document.status === 'completed' || 
                     (document.status === 'processing' && progressPercent === 100);

  return (
    <StatusContainer>
      <Header>
        <Title>Document Processing Status</Title>
      </Header>
      
      <ProgressContainer>
        <ProgressBar>
          <ProgressFill $progress={progressPercent} $hasErrors={hasErrors} />
        </ProgressBar>
        <StatusText 
          $isComplete={isComplete} 
          $hasErrors={hasErrors}
        >
          {document.status === 'error' ? 'Processing failed' :
           isComplete ? 'Processing complete' : 'Processing in progress'}
           {hasErrors && ' (with some errors)'}
           {document.status === 'processing' && ` - ${progressPercent}%`}
        </StatusText>
      </ProgressContainer>
      
      <StatsContainer>
        <StatCard>
          <StatValue>{stats.totalChunks}</StatValue>
          <StatLabel>Total Chunks</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.processedChunks}</StatValue>
          <StatLabel>Processed</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.errorChunks}</StatValue>
          <StatLabel>Errors</StatLabel>
        </StatCard>
      </StatsContainer>
      
      {document.error_message && (
        <Alert variant="error">Error: {document.error_message}</Alert>
      )}
    </StatusContainer>
  );
}// src/components/teacher/RagComponents.tsx
'use client';

import { useState, useRef, ChangeEvent } from 'react';
import styled from 'styled-components';
import { Button, Alert, Input, FormGroup, Label } from '@/styles/StyledComponents';

const UploaderContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
`;

const UploadArea = styled.div`
  border: 2px dashed ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.lg};
  text-align: center;
  transition: all ${({ theme }) => theme.transitions.fast};
  cursor: pointer;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  
  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => `${theme.colors.primary}05`};
  }
`;

const FileInput = styled.input`
  display: none;
`;

const UploadText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SectionTitle = styled.h3`
  font-size: 1.1rem;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.text};
`;

// No unused styles - removed unused styled component

export function SimpleDocumentUploader() {
  const [file, setFile] = useState<File | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      setFile(files[0]);
    }
  };

  return (
    <UploaderContainer>
      <SectionTitle>Upload Documents</SectionTitle>
      <UploadArea onClick={() => fileInputRef.current?.click()}>
        <FileInput
          type="file"
          ref={fileInputRef}
          onChange={handleFileChange}
          accept=".pdf,.doc,.docx,.txt"
        />
        <UploadText>Click or drag file to upload</UploadText>
        <FileTypeInfo>Supported: PDF, DOC, DOCX, TXT (Max 10MB)</FileTypeInfo>
        <Button 
          size="small" 
          variant="outline" 
          type="button" 
          onClick={(e) => { 
            e.stopPropagation(); 
            fileInputRef.current?.click();
          }}
        >
          Browse Files
        </Button>
      </UploadArea>
      
      {file && (
        <Alert variant="info">
          Selected: {file.name} ({Math.round(file.size / 1024)} KB)
          <div style={{ marginTop: '8px' }}>
            Note: You&apos;ll be able to upload this file after creating the chatbot.
          </div>
        </Alert>
      )}
    </UploaderContainer>
  );
}

export function SimpleWebScraper() {
  const [url, setUrl] = useState('');

  return (
    <UploaderContainer>
      <SectionTitle>Web Scraper</SectionTitle>
      <FormGroup>
        <Label htmlFor="webpage-url">Webpage URL</Label>
        <Input
          id="webpage-url"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="https://example.com/article"
          type="url"
        />
        <FileTypeInfo>
          Enter a URL to scrape content from a webpage directly into your knowledge base.
        </FileTypeInfo>
      </FormGroup>
      <Button 
        variant="primary" 
        disabled={!url.trim() || !url.startsWith('http')}
        style={{ marginTop: '8px' }}
      >
        Extract Content
      </Button>
      <Alert variant="info" style={{ marginTop: '16px' }}>
        Note: You&apos;ll be able to scrape web content after creating the chatbot.
      </Alert>
    </UploaderContainer>
  );
}// src/components/teacher/EditRoomModal.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Card, Button, Alert } from '@/styles/StyledComponents';
import type { Room, Chatbot } from '@/types/database.types';

// ... (styled components remain the same)
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const SectionTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;

const DirectAccessContainer = styled.div`
  margin-top: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  border: 1px dashed ${({ theme }) => theme.colors.border};
`;

const DirectAccessUrl = styled.input`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-top: ${({ theme }) => theme.spacing.sm};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 0.8rem;
`;


interface EditRoomModalProps {
  room: Room;
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function EditRoomModal({ room, chatbots, onClose, onSuccess }: EditRoomModalProps) {
  const [selectedChatbots, setSelectedChatbots] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchRoomChatbots = async () => {
      setIsLoading(true); // Ensure loading state is true at the start
      setError(null);
      try {
        // MODIFIED API CALL
        const response = await fetch(`/api/teacher/room-chatbots-associations?roomId=${room.room_id}`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Failed to parse error from fetchRoomChatbots' }));
            throw new Error(errorData.error || 'Failed to fetch room chatbots');
        }
        
        const data = await response.json();
        setSelectedChatbots(data.map((rc: { chatbot_id: string }) => rc.chatbot_id));
      } catch (err) {
        console.error("EditRoomModal fetchRoomChatbots error:", err);
        setError(err instanceof Error ? err.message : 'Failed to load current chatbots for this room.');
      } finally {
        setIsLoading(false);
      }
    };

    if (room?.room_id) { // Ensure room_id is present
        fetchRoomChatbots();
    } else {
        setError("Room information is missing.");
        setIsLoading(false);
    }
  }, [room.room_id]); // Depend only on room.room_id

  const handleToggleChatbot = (chatbotId: string) => {
    setSelectedChatbots(prev => 
      prev.includes(chatbotId)
        ? prev.filter(id => id !== chatbotId)
        : [...prev, chatbotId]
    );
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setError(null);

    try {
      // MODIFIED API CALL
      const response = await fetch(`/api/teacher/room-chatbots-associations?roomId=${room.room_id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ chatbot_ids: selectedChatbots }),
      });

      if (!response.ok) {
        // Attempt to parse error JSON, but handle cases where it might not be JSON
        let errorMsg = 'Failed to update room chatbots';
        try {
            const errorData = await response.json();
            errorMsg = errorData.error || errorMsg;
        } catch {
            // If response is not JSON, use status text or a generic message
            errorMsg = `Failed to update room chatbots (status: ${response.status} ${response.statusText})`;
            console.error("PUT request failed with non-JSON response:", await response.text());
        }
        throw new Error(errorMsg);
      }
      // If you expect JSON on successful PUT, parse it here. Otherwise, just call onSuccess.
      // const successData = await response.json(); 
      // console.log("Room chatbots updated:", successData);
      onSuccess();
    } catch (err) {
      console.error("EditRoomModal handleSubmit error:", err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred while saving changes.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Edit Room: {room.room_name}</Title>
          <CloseButton onClick={onClose}>×</CloseButton>
        </Header>

        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        <Section>
          <SectionTitle>Select Chatbots for this Room</SectionTitle>
          {isLoading ? (
            <div style={{textAlign: 'center', padding: '20px'}}>Loading chatbots...</div>
          ) : chatbots.length === 0 ? (
            <p>No chatbots available to assign. Please create a chatbot first.</p>
          ) : (
            <ChatbotList>
              {chatbots.map(chatbot => (
                <ChatbotItem key={chatbot.chatbot_id}>
                  <Checkbox
                    type="checkbox"
                    id={`cb-edit-${chatbot.chatbot_id}`}
                    checked={selectedChatbots.includes(chatbot.chatbot_id)}
                    onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                  />
                  <label htmlFor={`cb-edit-${chatbot.chatbot_id}`} style={{cursor: 'pointer', flexGrow: 1}}>
                    {chatbot.name}
                    {chatbot.description && (
                      <span style={{ marginLeft: '8px', color: '#777', fontSize: '0.9em' }}>
                        - {chatbot.description.length > 50 ? chatbot.description.substring(0, 50) + '...' : chatbot.description}
                      </span>
                    )}
                  </label>
                </ChatbotItem>
              ))}
            </ChatbotList>
          )}
        </Section>

        <Section>
          <SectionTitle>Direct Student Access</SectionTitle>
          <DirectAccessContainer>
            <p>Students can directly access this room using the following URL:</p>
            <DirectAccessUrl 
              type="text" 
              value={`${window.location.origin}/chat/${room.room_id}`} 
              readOnly
              onClick={(e) => e.currentTarget.select()}
            />
            <Button 
              variant="outline" 
              size="small" 
              onClick={() => {
                navigator.clipboard.writeText(`${window.location.origin}/chat/${room.room_id}`);
                alert('Link copied to clipboard!');
              }}
            >
              Copy Link
            </Button>
          </DirectAccessContainer>
        </Section>

        <Footer>
          <Button type="button" variant="outline" onClick={onClose} disabled={isSubmitting}>
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleSubmit} 
            disabled={isSubmitting || isLoading || (chatbots.length > 0 && selectedChatbots.length === 0 && !isLoading) }
            // Disable save if loading, submitting, or if chatbots are available but none are selected (unless still loading initial selection)
            title={chatbots.length > 0 && selectedChatbots.length === 0 && !isLoading ? "Select at least one chatbot" : undefined}
          >
            {isSubmitting ? 'Saving...' : 'Save Changes'}
          </Button>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/RoomList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import type { Room as BaseRoom } from '@/types/database.types';
import StudentCsvUpload from './StudentCsvUpload';

// --- Styled Components ---
const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; 
  }
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  min-width: 1000px;
`;

const Th = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.875rem;
  letter-spacing: 0.05em;
  white-space: nowrap;
`;

const Td = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  vertical-align: top;
`;

const ActionButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: nowrap;
  width: 100%;
`;

const RoomCode = styled.span`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  display: inline-block;

  &:hover {
    text-decoration: underline;
    background-color: ${({ theme }) => theme.colors.border};
  }
`;

const RoomNameLink = styled(Link)`
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-weight: 500;
  transition: color ${({ theme }) => theme.transitions.fast};

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: underline;
  }
`;

const EmptyState = styled(Card)` // EmptyState is a Card
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textLight};
  /* The $accentColor prop will be passed here from the main return */

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.md};
    color: ${({ theme }) => theme.colors.text};
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 500px;
  margin: 20px;
  position: relative;
  text-align: center;
  border-top: none !important; // Ensure modal doesn't get section accent
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

const MobileCardList = styled.div`
  display: none; 

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: flex; 
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    /* Add padding if Card wrapper is removed from return */
    padding: ${({ theme }) => theme.spacing.lg}; 
  }
`;

const MobileRoomCard = styled(Card)` 
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border} !important; // Override section accent for individual mobile cards
`;

const RoomCardHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start; 
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const RoomCardTitle = styled(Link)` 
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-weight: 600;
  font-size: 1.2rem;
  margin-right: ${({ theme }) => theme.spacing.sm}; 

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const RoomCardDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr; 
  gap: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.9rem;
`;

const DetailItem = styled.div`
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    font-weight: 500;
  }
  .value {
    color: ${({ theme }) => theme.colors.text};
    word-break: break-word; 
  }
`;

const MobileActions = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); 
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.md};
`;

interface RoomWithChatbots extends BaseRoom {
  room_chatbots: { 
    chatbots: { 
      chatbot_id: string;
      name: string;
    } | null; 
  }[] | null; 
}

// MODIFIED Props Interface
interface RoomListProps {
  rooms: RoomWithChatbots[]; 
  onUpdate: () => void;
  onEditRoom: (room: BaseRoom) => void; 
  onDeleteRoom: (room: BaseRoom) => void;
  onArchiveRoom: (room: BaseRoom) => void;
  accentColor?: string; // Added optional accentColor prop
}

interface DeleteModalProps {
  isOpen: boolean;
  roomName: string;
  onConfirm: () => void;
  onCancel: () => void;
  isDeleting: boolean; 
}

function DeleteModal({ isOpen, roomName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;
  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete Room</ModalTitle>
        <ModalText>
          Are you sure you want to delete the room &quot;<strong>{roomName}</strong>&quot;? This action cannot be undone and will remove all student memberships and associated data.
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
            variant="magenta" 
            onClick={onConfirm}
            disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : 'Yes, Delete Room'}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

// MODIFIED Component Signature
export default function RoomList({ rooms, onUpdate, onEditRoom, onDeleteRoom, onArchiveRoom, accentColor }: RoomListProps) {
  const [loadingState, setLoadingState] = useState<{ [key: string]: boolean }>({});
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    roomId: string | null;
    roomName: string;
  }>({ isOpen: false, roomId: null, roomName: '' });
  const [isDeleting, setIsDeleting] = useState(false);
  const [csvUploadRoom, setCsvUploadRoom] = useState<BaseRoom | null>(null); 

  const toggleRoomStatus = async (roomId: string, currentStatus: boolean) => {
    setLoadingState(prev => ({ ...prev, [roomId]: true }));
    try {
      const response = await fetch(`/api/teacher/rooms/${roomId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_active: !currentStatus }),
      });
      if (!response.ok) throw new Error('Failed to update room status');
      onUpdate();
    } catch (error) {
      console.error('Error updating room status:', error);
      alert(`Error: ${error instanceof Error ? error.message : 'Could not update room status.'}`);
    } finally {
      setLoadingState(prev => ({ ...prev, [roomId]: false }));
    }
  };

  const copyRoomCode = async (code: string) => {
    try {
      await navigator.clipboard.writeText(code);
      alert(`Room code "${code}" copied to clipboard!`);
    } catch (error) {
      console.error('Failed to copy room code:', error);
      alert('Failed to copy room code.');
    }
  };

  const generateJoinUrl = async (roomId: string, roomCode: string) => {
    try {
      // Simply generate a direct link to the join page with the room code
      // This doesn't use Supabase's auth magic link system - it's just a room join URL
      const joinLink = `${window.location.origin}/join-room?code=${roomCode}`;
      await navigator.clipboard.writeText(joinLink);
      alert(`Student join URL copied to clipboard:\n${joinLink}\n\nShare this URL with students to let them join your room. This is a direct room link, not a Supabase magic link.`);
    } catch (error) {
      console.error('Error generating join link:', error);
      alert('Failed to generate join link.');
    }
  };

  const openDeleteModal = (room: BaseRoom) => {
    setDeleteModal({ isOpen: true, roomId: room.room_id, roomName: room.room_name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, roomId: null, roomName: '' });
  };

  const handleDeleteRoomConfirm = async () => {
    if (!deleteModal.roomId) return;
    setIsDeleting(true); 
    try {
      await onDeleteRoom({ room_id: deleteModal.roomId, room_name: deleteModal.roomName } as BaseRoom);
      closeDeleteModal(); 
    } catch (error) {
      console.error('Error during delete confirmation:', error);
      alert(`Failed to delete room: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsDeleting(false); 
    }
  };

  const getChatbotCount = (room: RoomWithChatbots): number => {
    if (room.room_chatbots && Array.isArray(room.room_chatbots)) {
      return room.room_chatbots.filter(rc => rc && rc.chatbots).length;
    }
    return 0;
  };

  if (rooms.length === 0) {
    // Pass $accentColor to EmptyState Card
    return (
      <EmptyState $accentColor={accentColor} $accentSide="top"> 
        <h3>No Rooms Created</h3>
        <p>Create your first classroom room to get started!</p>
      </EmptyState>
    );
  }

  return (
    <>
      {/* The outermost element IS a Card, pass $accentColor and $accentSide to it */}
      <Card $accentColor={accentColor} $accentSide="top"> 
        <TableContainer>
          <Table>
            <thead>
              <tr>
                <Th>Room Name</Th>
                <Th>Room Code</Th>
                <Th>Chatbots</Th>
                <Th>Status</Th>
                <Th>Created</Th>
                <Th>Actions</Th>
              </tr>
            </thead>
            <tbody>
              {rooms.map((room) => {
                const chatbotCount = getChatbotCount(room);
                const isLoading = loadingState[room.room_id] || false; 

                return (
                  <tr key={room.room_id}>
                    <Td>
                      <RoomNameLink href={`/teacher-dashboard/rooms/${room.room_id}`} title={`View details for room: ${room.room_name}`}>
                        {room.room_name}
                      </RoomNameLink>
                    </Td>
                    <Td>
                      <RoomCode onClick={() => copyRoomCode(room.room_code)} title="Click to copy room code">
                        {room.room_code}
                      </RoomCode>
                    </Td>
                    <Td>
                      {chatbotCount > 0 ? `${chatbotCount} Attached` : 'None'}
                    </Td>
                    <Td>
                      <Badge variant={room.is_active ? 'success' : 'default'}>
                        {room.is_active ? 'Active' : 'Inactive'}
                      </Badge>
                    </Td>
                    <Td>
                      {new Date(room.created_at).toLocaleDateString()}
                    </Td>
                    <Td>
                      <ActionButtons>
                        <Button size="small" onClick={() => onEditRoom(room)} disabled={isLoading} title="Edit Chatbots for this Room">Edit</Button>
                        <Button size="small" variant="outline" onClick={() => generateJoinUrl(room.room_id, room.room_code)} disabled={isLoading} title="Copy Student Join Link">Join URL</Button>
                        <Button 
                          size="small" 
                          variant="primary" 
                          onClick={() => setCsvUploadRoom(room)} 
                          disabled={isLoading} 
                          title="Import students via CSV"
                          style={{ fontWeight: 'bold' }}
                        >
                          Import Students
                        </Button>
                        <Button size="small" variant={room.is_active ? 'secondary' : 'primary'} onClick={() => toggleRoomStatus(room.room_id, room.is_active)} disabled={isLoading} title={room.is_active ? 'Deactivate Room' : 'Activate Room'}>{isLoading ? '...' : room.is_active ? 'Deactivate' : 'Activate'}</Button>
                        <Button size="small" variant="secondary" onClick={() => onArchiveRoom(room)} disabled={isLoading} title="Archive Room">Archive</Button>
                        <Button size="small" variant="magenta" onClick={() => openDeleteModal(room)} disabled={isLoading} title="Delete Room">Delete</Button>
                      </ActionButtons>
                    </Td>
                  </tr>
                );
              })}
            </tbody>
          </Table>
        </TableContainer>

        <MobileCardList>
          {rooms.map((room) => {
             const chatbotCount = getChatbotCount(room);
             const isLoading = loadingState[room.room_id] || false;
             return (
                <MobileRoomCard key={`mobile-${room.room_id}`}> 
                  <RoomCardHeader>
                    <RoomCardTitle href={`/teacher-dashboard/rooms/${room.room_id}`} title={`View details for room: ${room.room_name}`}>
                      {room.room_name}
                    </RoomCardTitle>
                    <Badge variant={room.is_active ? 'success' : 'default'}>
                      {room.is_active ? 'Active' : 'Inactive'}
                    </Badge>
                  </RoomCardHeader>
                  <RoomCardDetails>
                    <DetailItem>
                      <span className="label">Code:</span>
                      <RoomCode className="value" onClick={() => copyRoomCode(room.room_code)} title="Click to copy room code">
                        {room.room_code}
                      </RoomCode>
                    </DetailItem>
                    <DetailItem>
                      <span className="label">Chatbots:</span>
                      <span className="value">{chatbotCount > 0 ? `${chatbotCount} Attached` : 'None'}</span>
                    </DetailItem>
                    <DetailItem>
                      <span className="label">Created:</span>
                      <span className="value">{new Date(room.created_at).toLocaleDateString()}</span>
                    </DetailItem>
                  </RoomCardDetails>
                  <MobileActions>
                    <Button size="small" onClick={() => onEditRoom(room)} disabled={isLoading}>Edit</Button>
                    <Button size="small" variant="outline" onClick={() => generateJoinUrl(room.room_id, room.room_code)} disabled={isLoading}>Join URL</Button>
                    <Button 
                      size="small" 
                      variant="primary" 
                      onClick={() => setCsvUploadRoom(room)} 
                      disabled={isLoading}
                      style={{ fontWeight: 'bold' }}
                    >
                      Import Students
                    </Button>
                    <Button size="small" variant={room.is_active ? 'secondary' : 'primary'} onClick={() => toggleRoomStatus(room.room_id, room.is_active)} disabled={isLoading}>{isLoading ? '...' : room.is_active ? 'Deactivate' : 'Activate'}</Button>
                    <Button size="small" variant="secondary" onClick={() => onArchiveRoom(room)} disabled={isLoading}>Archive</Button>
                    <Button size="small" variant="magenta" onClick={() => openDeleteModal(room)} disabled={isLoading}>Delete</Button>
                  </MobileActions>
                </MobileRoomCard>
             );
          })}
        </MobileCardList>
      </Card>

      <DeleteModal
        isOpen={deleteModal.isOpen}
        roomName={deleteModal.roomName}
        onConfirm={handleDeleteRoomConfirm}
        onCancel={closeDeleteModal}
        isDeleting={isDeleting} 
      />

      {csvUploadRoom && (
        <StudentCsvUpload
          roomId={csvUploadRoom.room_id}
          roomName={csvUploadRoom.room_name}
          onClose={() => setCsvUploadRoom(null)}
        />
      )}
    </>
  );
}// src/components/teacher/TeacherNav.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { usePathname } from 'next/navigation';

const NavWrapper = styled.nav`
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};

  ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    gap: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap; // Allow wrapping on smaller screens
  }

  li a {
    text-decoration: none;
    color: ${({ theme }) => theme.colors.textLight};
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    font-weight: 500;
    transition: all ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.backgroundDark};
    }

    &.active {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.primary + '20'}; // Light primary background
    }
  }
`;

const navItems = [
  { href: '/teacher-dashboard', label: 'Overview' },
  { href: '/teacher-dashboard/chatbots', label: 'Chatbots' },
  { href: '/teacher-dashboard/rooms', label: 'Rooms' },
  { href: '/teacher-dashboard/concerns', label: 'Concerns' },
  // { href: '/teacher-dashboard/students', label: 'Students' }, // Future
  // { href: '/teacher-dashboard/settings', label: 'Settings' }, // Future
];

export default function TeacherNav() {
  const pathname = usePathname();

  return (
    <NavWrapper>
      <ul>
        {navItems.map((item) => (
          <li key={item.href}>
            <Link href={item.href} className={pathname === item.href ? 'active' : ''}>
              {item.label}
            </Link>
          </li>
        ))}
      </ul>
    </NavWrapper>
  );
}// src/components/teacher/DocumentUploader.tsx
'use client';

import { useState, useRef, ChangeEvent, DragEvent } from 'react'; // Added specific event types
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';
import type { DocumentType } from '@/types/knowledge-base.types'; // Ensure this path is correct

const UploaderContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const UploadArea = styled.div<{ $isDragging: boolean }>`
  border: 2px dashed ${({ theme, $isDragging }) => 
    $isDragging ? theme.colors.primary : theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  transition: all ${({ theme }) => theme.transitions.fast};
  background-color: ${({ theme, $isDragging }) => 
    $isDragging ? `${theme.colors.primary}10` : theme.colors.backgroundCard};
  
  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => `${theme.colors.primary}05`};
  }
  cursor: pointer;
`;

const FileInput = styled.input`
  display: none;
`;

const UploadIcon = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 2rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const UploadText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SelectedFileContainer = styled.div` // Renamed from SelectedFile to avoid conflict
  margin-top: ${({ theme }) => theme.spacing.md};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const FileName = styled.span`
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const FileSize = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface DocumentUploaderProps {
  chatbotId: string;
  onUploadSuccess: () => void; // Callback after successful upload
}

export default function DocumentUploader({ chatbotId, onUploadSuccess }: DocumentUploaderProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(false);
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const validateAndSetFile = (file: File) => {
    setError(null);
    setSuccessMessage(null);
    const validTypes: DocumentType[] = ['pdf', 'docx', 'txt'];
    const extension = file.name.split('.').pop()?.toLowerCase();

    if (!extension || (!validTypes.includes(extension as DocumentType) && extension !== 'doc')) {
      setError('Invalid file type. Please upload PDF, Word (.doc, .docx), or TXT.');
      setSelectedFile(null);
      return;
    }
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      setError('File too large. Maximum size is 10MB.');
      setSelectedFile(null);
      return;
    }
    setSelectedFile(file);
  };

  const handleUpload = async () => {
    if (!selectedFile) return;

    setIsUploading(true);
    setError(null);
    setSuccessMessage(null);

    const formData = new FormData();
    formData.append('file', selectedFile);
    formData.append('chatbotId', chatbotId); // << MODIFICATION: Add chatbotId to FormData

    try {
      // << MODIFICATION: Change API endpoint >>
      const response = await fetch('/api/teacher/documents', {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Failed to upload document');
      }
      
      setSuccessMessage(data.message || 'Document uploaded successfully!');
      setSelectedFile(null); 
      if (fileInputRef.current) {
        fileInputRef.current.value = ""; // Reset file input
      }
      onUploadSuccess(); // Call parent callback
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred during upload.');
    } finally {
      setIsUploading(false);
    }
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  return (
    <UploaderContainer>
      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      {successMessage && <Alert variant="success" style={{ marginBottom: '16px' }}>{successMessage}</Alert>}
      
      <UploadArea
        $isDragging={isDragging}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={() => fileInputRef.current?.click()}
      >
        <FileInput
          type="file"
          ref={fileInputRef}
          onChange={handleFileChange}
          accept=".pdf,.doc,.docx,.txt"
        />
        <UploadIcon>📄</UploadIcon> {/* Replace with actual icon if you have one */}
        <UploadText>{isDragging ? 'Drop your file here' : 'Click or drag file to upload'}</UploadText>
        <FileTypeInfo>Supported: PDF, DOC, DOCX, TXT (Max 10MB)</FileTypeInfo>
        {!selectedFile && (
            <Button size="small" variant="outline" type="button" onClick={(e) => { e.stopPropagation(); fileInputRef.current?.click();}}>
                Browse Files
            </Button>
        )}
      </UploadArea>

      {selectedFile && (
        <>
          <SelectedFileContainer>
            <FileName title={selectedFile.name}>{selectedFile.name}</FileName>
            <FileSize>{formatFileSize(selectedFile.size)}</FileSize>
            <Button
              size="small"
              variant="outline"
              onClick={(e) => { e.stopPropagation(); setSelectedFile(null); if(fileInputRef.current) fileInputRef.current.value = ""; setError(null);}}
              type="button"
            >
              Remove
            </Button>
          </SelectedFileContainer>
          
          <Button
            onClick={handleUpload}
            disabled={isUploading}
            style={{ marginTop: '16px', width: '100%' }}
            type="button"
          >
            {isUploading ? 'Uploading...' : `Upload ${selectedFile.name}`}
          </Button>
        </>
      )}
    </UploaderContainer>
  );
}// src/components/teacher/ArchivePanel.tsx
'use client';

import React, { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Button, Card, Alert } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { Room } from '@/types/database.types';

// Styled components
const ArchiveContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding: ${({ theme }) => theme.spacing.lg};
`;

const ArchiveHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  
  h3 {
    margin: 0;
    font-size: 1.2rem;
  }
`;

const ArchiveList = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
`;

const ArchiveItem = styled.div`
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: ${({ theme }) => theme.colors.backgroundDark};
`;

const ItemInfo = styled.div`
  h4 {
    margin: 0 0 ${({ theme }) => theme.spacing.xs} 0;
    font-size: 1.1rem;
  }
  
  p {
    margin: 0;
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
  }
`;

const ActionButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

// Component interfaces
interface ArchivedRoom extends Room {
  // Add any additional properties needed for rooms
}

interface ArchivedStudent {
  user_id: string;
  full_name: string;
  email: string;
  joined_at: string;
  room_id: string;
  is_archived: boolean;
}

interface ArchivePanelProps {
  type: 'rooms' | 'students';
  roomId?: string; // Only needed for students
  onItemRestored: () => void;
}

export default function ArchivePanel({ type, roomId, onItemRestored }: ArchivePanelProps) {
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [archivedRooms, setArchivedRooms] = useState<ArchivedRoom[]>([]);
  const [archivedStudents, setArchivedStudents] = useState<ArchivedStudent[]>([]);
  const [restoringIds, setRestoringIds] = useState<Record<string, boolean>>({});

  useEffect(() => {
    fetchArchivedItems();
  }, []);

  const fetchArchivedItems = async () => {
    setLoading(true);
    setError(null);
    
    try {
      if (type === 'rooms') {
        // Fetch archived rooms
        const response = await fetch(`/api/teacher/rooms?archivedOnly=true`);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to fetch archived rooms (status ${response.status})`);
        }
        
        const data = await response.json();
        setArchivedRooms(data);
      } else if (type === 'students' && roomId) {
        // Fetch archived students for a specific room
        const response = await fetch(`/api/teacher/room-details?roomId=${roomId}&archivedOnly=true`);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to fetch archived students (status ${response.status})`);
        }
        
        const data = await response.json();
        const studentsWithRoomId = data.students.map((student: any) => ({
          ...student,
          room_id: roomId
        }));
        setArchivedStudents(studentsWithRoomId);
      }
    } catch (err) {
      console.error(`Error fetching archived ${type}:`, err);
      setError(err instanceof Error ? err.message : `Failed to fetch archived ${type}`);
    } finally {
      setLoading(false);
    }
  };

  const handleRestoreRoom = async (roomId: string) => {
    setRestoringIds(prev => ({ ...prev, [roomId]: true }));
    
    try {
      const response = await fetch(`/api/teacher/rooms/archive`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          roomId,
          archive: false // Set to false to restore
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to restore room (status ${response.status})`);
      }
      
      // Update local state
      setArchivedRooms(prev => prev.filter(room => room.room_id !== roomId));
      onItemRestored();
    } catch (err) {
      console.error('Error restoring room:', err);
      setError(err instanceof Error ? err.message : 'Failed to restore room');
    } finally {
      setRestoringIds(prev => {
        const newState = { ...prev };
        delete newState[roomId];
        return newState;
      });
    }
  };

  const handleRestoreStudent = async (studentId: string, roomId: string) => {
    setRestoringIds(prev => ({ ...prev, [studentId]: true }));
    
    try {
      const response = await fetch(`/api/teacher/students/restore`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          studentId,
          roomId
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to restore student (status ${response.status})`);
      }
      
      // Update local state
      setArchivedStudents(prev => prev.filter(student => student.user_id !== studentId));
      onItemRestored();
    } catch (err) {
      console.error('Error restoring student:', err);
      setError(err instanceof Error ? err.message : 'Failed to restore student');
    } finally {
      setRestoringIds(prev => {
        const newState = { ...prev };
        delete newState[studentId];
        return newState;
      });
    }
  };

  const formatDate = (dateString: string) => {
    try {
      return new Date(dateString).toLocaleDateString();
    } catch {
      return 'Unknown date';
    }
  };

  const renderArchiveList = () => {
    if (loading) {
      return (
        <div style={{ textAlign: 'center', padding: '20px' }}>
          <LoadingSpinner />
          <p>Loading archived {type}...</p>
        </div>
      );
    }

    if (error) {
      return <Alert variant="error">{error}</Alert>;
    }

    if (type === 'rooms' && archivedRooms.length === 0) {
      return <Alert variant="info">No archived rooms found.</Alert>;
    }

    if (type === 'students' && archivedStudents.length === 0) {
      return <Alert variant="info">No archived students found for this room.</Alert>;
    }

    if (type === 'rooms') {
      return (
        <ArchiveList>
          {archivedRooms.map(room => (
            <ArchiveItem key={room.room_id}>
              <ItemInfo>
                <h4>{room.room_name}</h4>
                <p>Code: {room.room_code} | Archived on: {formatDate(room.updated_at || room.created_at)}</p>
              </ItemInfo>
              <ActionButtons>
                {restoringIds[room.room_id] ? (
                  <Button disabled size="small" variant="outline">
                    <LoadingSpinner size="small" /> Restoring...
                  </Button>
                ) : (
                  <Button 
                    size="small" 
                    variant="outline"
                    onClick={() => handleRestoreRoom(room.room_id)}
                  >
                    Restore Room
                  </Button>
                )}
              </ActionButtons>
            </ArchiveItem>
          ))}
        </ArchiveList>
      );
    } else {
      return (
        <ArchiveList>
          {archivedStudents.map(student => (
            <ArchiveItem key={student.user_id}>
              <ItemInfo>
                <h4>{student.full_name}</h4>
                <p>{student.email} | Archived on: {formatDate(student.joined_at)}</p>
              </ItemInfo>
              <ActionButtons>
                {restoringIds[student.user_id] ? (
                  <Button disabled size="small" variant="outline">
                    <LoadingSpinner size="small" /> Restoring...
                  </Button>
                ) : (
                  <Button 
                    size="small" 
                    variant="outline"
                    onClick={() => handleRestoreStudent(student.user_id, student.room_id)}
                  >
                    Restore Student
                  </Button>
                )}
              </ActionButtons>
            </ArchiveItem>
          ))}
        </ArchiveList>
      );
    }
  };

  return (
    <ArchiveContainer>
      <ArchiveHeader>
        <h3>Archived {type === 'rooms' ? 'Rooms' : 'Students'}</h3>
        <Button 
          size="small" 
          variant="outline"
          onClick={fetchArchivedItems}
          disabled={loading}
        >
          {loading ? <LoadingSpinner size="small" /> : 'Refresh'}
        </Button>
      </ArchiveHeader>
      {renderArchiveList()}
    </ArchiveContainer>
  );
}// src/components/teacher/StatsCard.tsx
'use client';

import styled, { DefaultTheme } from 'styled-components'; // Ensure DefaultTheme is imported
import { Card } from '@/styles/StyledComponents';

// Make sure this interface matches what DashboardOverview expects and provides
export interface StatsCardProps { 
  title: string;
  value: string | number;
  onClick?: () => void;
  icon?: React.ReactNode;
  variant?: 'default' | 'warning' | 'danger' | 'magenta' | 'cyan' | 'green' | 'orange_secondary'; 
}

// Helper function to get the actual color from the variant
const getVariantColor = (theme: DefaultTheme, variant: StatsCardProps['variant']): string => {
  switch (variant) {
    case 'danger': 
      return theme.colors.red;      // skolrCoral (#FE4372)
    case 'warning': 
      return theme.colors.secondary;// skolrOrange (#FFB612) 
    case 'magenta': 
      return theme.colors.magenta;  // skolrMagenta (#C848AF)
    case 'cyan': 
      return theme.colors.blue;     // skolrCyan (#4CBEF3) - as theme.colors.blue is mapped to this
    case 'green': 
      return theme.colors.green;    // skolrGreen (#7BBC44)
    case 'orange_secondary': // This explicitly uses the secondary color (skolrOrange)
      return theme.colors.secondary; 
    case 'default': // Explicitly handle default
    default: // Fallback
      return theme.colors.primary;  // skolrPurple (#985DD7)
  }
};

// Make sure the $variant prop passed from the component is correctly typed here
const StyledStatsCard = styled(Card)<{ $clickable: boolean; $variant: StatsCardProps['variant'] }>`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: ${({ $clickable }) => ($clickable ? 'pointer' : 'default')};
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
  
  /* Ensure this line is using the $variant prop passed to StyledStatsCard */
  border-top: 5px solid ${({ theme, $variant }) => getVariantColor(theme, $variant)};

  &:hover {
    transform: ${({ $clickable }) => ($clickable ? 'translateY(-3px)' : 'none')};
    box-shadow: ${({ $clickable, theme }) => ($clickable ? theme.shadows.md : theme.shadows.sm)};
  }

  .icon {
    font-size: 1.8rem;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme, $variant }) => getVariantColor(theme, $variant)};
  }
  
  h3 { // Title
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-weight: 500;
  }

  .value {
    font-size: 2.2rem;
    font-weight: 600;
    color: ${({ theme, $variant }) => getVariantColor(theme, $variant)};
    line-height: 1.2;
  }
`;

export default function StatsCard({ title, value, onClick, icon, variant = 'default' }: StatsCardProps) {
  // The 'variant' prop received here is passed as '$variant' to StyledStatsCard
  return (
    <StyledStatsCard onClick={onClick} $clickable={!!onClick} $variant={variant}>
      {icon && <div className="icon">{icon}</div>}
      <h3>{title}</h3>
      <div className="value">{value}</div>
    </StyledStatsCard>
  );
}// src/components/teacher/ChatbotForm.tsx
'use client';

import { useState } from 'react';
// useEffect import removed as it's not used
import styled from 'styled-components';
import { BotTypeEnum } from '@/types/database.types';
import {
    Card,
    Button,
    FormGroup,
    Label,
    Input,
    TextArea,
    Alert,
    Select as StyledSelect
} from '@/styles/StyledComponents';
// Instead of SimpleDocumentUploader and SimpleWebScraper, use enhanced versions
import EnhancedRagUploader from './EnhancedRagUploader';
import EnhancedRagScraper from './EnhancedRagScraper';
// No direct import of CreateChatbotPayload here as it's for the API route, not this component directly

// Use the BotTypeEnum from database.types
type BotType = BotTypeEnum;

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 650px;
  margin: 20px;
  position: relative;
  display: flex;
  flex-direction: column;
  max-height: 90vh;
  overflow-y: hidden; /* Hide overflow to let FormContent handle scrolling */

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    width: 100%;
    min-height: 100vh;
    max-height: 100vh;
    border-radius: 0;
    box-shadow: none;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.lg};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  flex-shrink: 0;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const Title = styled.h2`
  margin: 0;
  font-size: 1.4rem;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.75rem;
  padding: 0;
  line-height: 1;

  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const FormContent = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  overflow-y: auto;
  flex-grow: 1;
  max-height: calc(90vh - 140px); /* Adjust this value based on header/footer height */
  overscroll-behavior: contain; /* Prevent scroll chaining */

  &::-webkit-scrollbar {
    width: 8px;
  }
  &::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => theme.colors.borderDark};
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }
  scrollbar-width: thin; /* Firefox */
  scrollbar-color: ${({ theme }) => theme.colors.borderDark} transparent; /* Firefox */

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
    max-height: calc(100vh - 140px); /* Adjust for mobile */
  }
`;


const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  flex-shrink: 0;
  background-color: ${({ theme }) => theme.colors.background}; /* Ensure footer is opaque */
  position: sticky;
  bottom: 0;
  z-index: 5;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const AssessmentCriteriaSection = styled(FormGroup)`
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
`;

const RubricInfoText = styled(HelpText)`
  font-style: italic;
  margin-top: ${({ theme }) => theme.spacing.md};
`;

const ExampleTemplateContainer = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const TemplateButton = styled(Button)`
  align-self: flex-start;
  font-size: 0.85rem;
  padding: ${({ theme }) => `${theme.spacing.xs} ${theme.spacing.sm}`};
  margin-right: ${({ theme }) => theme.spacing.sm};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const TemplateButtonGroup = styled.div`
  display: flex;
  flex-wrap: wrap;
  margin-top: ${({ theme }) => theme.spacing.xs};
`;


interface ChatbotFormData {
  name: string;
  description: string;
  system_prompt: string;
  model: string;
  max_tokens?: number;
  temperature?: number;
  enable_rag: boolean;
  bot_type: BotType;
  assessment_criteria_text: string;
  welcome_message: string;
  chatbot_id?: string; // For edit mode
}

interface ChatbotFormProps {
  onClose: () => void;
  onSuccess: (chatbotId: string) => void;
  initialData?: Partial<ChatbotFormData>;
  editMode?: boolean;
}

export default function ChatbotForm({ onClose, onSuccess, initialData, editMode = false }: ChatbotFormProps) {
  const [formData, setFormData] = useState<ChatbotFormData>({
    name: initialData?.name || '',
    description: initialData?.description || '',
    system_prompt: initialData?.system_prompt || '',
    model: initialData?.model || 'openai/gpt-4.1-nano',
    max_tokens: initialData?.max_tokens !== undefined ? initialData.max_tokens : 1000,
    temperature: initialData?.temperature !== undefined ? initialData.temperature : 0.7,
    enable_rag: initialData?.enable_rag !== undefined ? initialData.enable_rag : false,
    bot_type: initialData?.bot_type || 'learning',
    assessment_criteria_text: initialData?.assessment_criteria_text || '',
    welcome_message: initialData?.welcome_message || '',
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<Partial<Record<keyof ChatbotFormData, string>>>({});

  const validateForm = (): boolean => {
    const errors: Partial<Record<keyof ChatbotFormData, string>> = {};
    
    // Basic validation rules
    if (!formData.name.trim()) {
      errors.name = 'Name is required';
    } else if (formData.name.length > 100) {
      errors.name = 'Name must be less than 100 characters';
    }

    if (!formData.system_prompt.trim()) {
      errors.system_prompt = 'System prompt is required';
    } else if (formData.system_prompt.length < 10) {
      errors.system_prompt = 'System prompt is too short (min 10 characters)';
    } else if (formData.system_prompt.length > 4000) {
      errors.system_prompt = 'System prompt is too long (max 4000 characters)';
    }

    if (formData.bot_type === 'assessment' && !formData.assessment_criteria_text.trim()) {
      errors.assessment_criteria_text = 'Assessment criteria is required for assessment bots';
    }

    if (formData.welcome_message && formData.welcome_message.length > 1000) {
      errors.welcome_message = 'Welcome message must be less than 1000 characters';
    }

    if (formData.description && formData.description.length > 500) {
      errors.description = 'Description must be less than 500 characters';
    }

    // Validate numerical fields
    if (formData.max_tokens !== undefined && formData.max_tokens !== null) {
      const maxTokens = Number(formData.max_tokens);
      if (isNaN(maxTokens) || maxTokens < 1 || maxTokens > 32000) {
        errors.max_tokens = 'Max tokens must be between 1 and 32000';
      }
    }

    if (formData.temperature !== undefined && formData.temperature !== null) {
      const temp = Number(formData.temperature);
      if (isNaN(temp) || temp < 0 || temp > 2) {
        errors.temperature = 'Temperature must be between 0 and 2';
      }
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate form before submission
    if (!validateForm()) {
      return;
    }
    
    setIsSubmitting(true);
    setError(null);

    // The payload sent to /api/teacher/chatbots should match CreateChatbotPayload
    const payload = {
      name: formData.name,
      description: formData.description || undefined,
      system_prompt: formData.system_prompt,
      model: formData.model,
      max_tokens: (formData.max_tokens === undefined || formData.max_tokens === null || isNaN(formData.max_tokens) || String(formData.max_tokens).trim() === '') ? null : Number(formData.max_tokens),
      temperature: (formData.temperature === undefined || formData.temperature === null || isNaN(formData.temperature) || String(formData.temperature).trim() === '') ? null : Number(formData.temperature),
      enable_rag: formData.bot_type === 'learning' ? formData.enable_rag : false,
      bot_type: formData.bot_type,
      assessment_criteria_text: formData.bot_type === 'assessment' ? (formData.assessment_criteria_text || null) : null,
      welcome_message: formData.welcome_message.trim() || null, // <--- ADDED (send null if empty)
    };


    try {
      // Determine if we're creating a new chatbot or updating an existing one
      const endpoint = editMode && initialData?.chatbot_id 
        ? `/api/teacher/chatbots/${initialData.chatbot_id}` 
        : '/api/teacher/chatbots';
      
      const method = editMode ? 'PUT' : 'POST';
      
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error || `Failed to ${editMode ? 'update' : 'create'} chatbot`);
      }

      onSuccess(responseData.chatbot_id);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create chatbot');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    // Clear validation error for this field when user makes changes
    if (validationErrors[e.target.name as keyof ChatbotFormData]) {
      setValidationErrors(prev => ({
        ...prev,
        [e.target.name]: undefined
      }));
    }
    const { name, value, type } = e.target;

    if (type === 'checkbox') {
        const { checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: checked,
        }));
    } else {
        // For welcome_message, allow empty string in state for controlled input,
        // it will be converted to null in handleSubmit if empty.
        setFormData(prev => ({
            ...prev,
            [name]: (name === 'max_tokens' || name === 'temperature') && value !== '' ? Number(value) : value,
        }));
    }
  };


  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>{editMode ? 'Edit Chatbot' : 'Create New Chatbot'}</Title>
          <CloseButton onClick={onClose} aria-label="Close modal">×</CloseButton>
        </Header>

        <FormContent>
          {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

          <form onSubmit={handleSubmit} id="chatbotCreateForm">
            {/* ... other FormGroups for name, bot_type, assessment_criteria, description, system_prompt ... */}
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input
                id="name"
                name="name"
                value={formData.name}
                onChange={handleChange}
                placeholder="e.g., History Helper, Vocab Quizzer"
                required
                className={!!validationErrors.name ? 'is-invalid' : ''}
              />
              {validationErrors.name && (
                <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                  {validationErrors.name}
                </Alert>
              )}
            </FormGroup>

            <FormGroup>
              <Label htmlFor="bot_type">Bot Type</Label>
              <StyledSelect
                id="bot_type"
                name="bot_type"
                value={formData.bot_type}
                onChange={handleChange}
              >
                <option value="learning">Learning Bot</option>
                <option value="assessment">Assessment Bot</option>
              </StyledSelect>
              <HelpText>
                Choose &apos;Learning&apos; for general interaction or &apos;Assessment&apos; to evaluate student responses against criteria.
              </HelpText>
            </FormGroup>

            {formData.bot_type === 'assessment' && (
              <AssessmentCriteriaSection>
                <Label htmlFor="assessment_criteria_text">Define Assessment Rubric / Criteria</Label>
                <TextArea
                  id="assessment_criteria_text"
                  name="assessment_criteria_text"
                  value={formData.assessment_criteria_text}
                  onChange={handleChange}
                  rows={8}
                  placeholder="Clearly describe what the AI should assess. For example:
1. Accuracy of answers to key concepts.
2. Clarity of student's explanations.
3. Use of specific examples or evidence.
4. Critical thinking demonstrated."
                  required={formData.bot_type === 'assessment'}
                  className={!!validationErrors.assessment_criteria_text ? 'is-invalid' : ''}
                />
                {validationErrors.assessment_criteria_text && (
                  <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                    {validationErrors.assessment_criteria_text}
                  </Alert>
                )}
                <HelpText>
                  This text will guide the AI in evaluating student responses. Be specific.
                </HelpText>
                
                <ExampleTemplateContainer>
                  <Label as="p" style={{ marginBottom: '4px' }}>Example Templates:</Label>
                  <TemplateButtonGroup>
                    <TemplateButton 
                      variant="outline" 
                      size="small"
                      onClick={() => {
                        setFormData(prev => ({
                          ...prev,
                          assessment_criteria_text: `Evaluate the student's understanding of key scientific concepts based on the following criteria:

1. Understanding of the scientific method (20%)
   - Can identify all steps in the scientific method
   - Explains how hypothesis testing works
   - Understands experimental controls and variables

2. Content knowledge accuracy (40%)
   - Facts are correct and relevant
   - Can explain relationships between concepts
   - Uses proper scientific terminology

3. Critical analysis (20%)
   - Identifies strengths/weaknesses in arguments
   - Considers multiple perspectives
   - Draws reasonable conclusions from evidence

4. Communication clarity (20%)
   - Ideas expressed logically and coherently
   - Uses specific examples to support points
   - Grammar and spelling are correct`
                        }))
                      }}
                    >
                      Science Assessment
                    </TemplateButton>
                    
                    <TemplateButton 
                      variant="outline" 
                      size="small"
                      onClick={() => {
                        setFormData(prev => ({
                          ...prev,
                          assessment_criteria_text: `Assess the student's essay using the following criteria:

1. Thesis & Structure (25%)
   - Clear thesis statement that establishes the argument
   - Logical organization with introduction, body paragraphs, and conclusion
   - Smooth transitions between ideas

2. Evidence & Analysis (30%)
   - Relevant and specific evidence to support claims
   - In-depth analysis that connects evidence to thesis
   - Thoughtful engagement with multiple perspectives

3. Critical Thinking (25%)
   - Original insights beyond surface-level observations
   - Considers implications and significance of the argument
   - Addresses potential counterarguments

4. Writing Mechanics (20%)
   - Proper grammar, spelling, and punctuation
   - Varied sentence structure and academic vocabulary
   - Consistent citation format (if applicable)`
                        }))
                      }}
                    >
                      Essay Rubric
                    </TemplateButton>
                    
                    <TemplateButton 
                      variant="outline" 
                      size="small"
                      onClick={() => {
                        setFormData(prev => ({
                          ...prev,
                          assessment_criteria_text: `Evaluate the student's math problem-solving abilities using these criteria:

1. Procedural Fluency (30%)
   - Correctly applies mathematical operations
   - Follows proper order of operations
   - Shows computational accuracy

2. Conceptual Understanding (30%)
   - Demonstrates understanding of underlying concepts
   - Can explain why procedures work
   - Makes connections between related ideas

3. Problem-Solving Strategy (25%)
   - Selects appropriate approach to solve problems
   - Implements strategy efficiently
   - Can apply concepts to novel situations

4. Mathematical Communication (15%)
   - Uses correct mathematical notation
   - Shows work in a clear, organized manner
   - Explains reasoning behind steps`
                        }))
                      }}
                    >
                      Math Problems
                    </TemplateButton>
                  </TemplateButtonGroup>
                </ExampleTemplateContainer>
                
                <RubricInfoText>
                  For more complex rubrics, you will be able to upload a document (e.g., PDF, DOCX) with detailed criteria after creating the bot (on the chatbot&apos;s configuration page). For now, please provide a text-based summary here.
                </RubricInfoText>
              </AssessmentCriteriaSection>
            )}

            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input
                id="description"
                name="description"
                value={formData.description}
                onChange={handleChange}
                placeholder="A brief summary of what this chatbot does"
                className={!!validationErrors.description ? 'is-invalid' : ''}
              />
              {validationErrors.description && (
                <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                  {validationErrors.description}
                </Alert>
              )}
            </FormGroup>

            <FormGroup>
              <Label htmlFor="system_prompt">System Prompt (AI&apos;s Persona & Core Instructions)</Label>
              <TextArea
                id="system_prompt"
                name="system_prompt"
                value={formData.system_prompt}
                onChange={handleChange}
                placeholder={
                  formData.bot_type === 'assessment'
                  ? "e.g., You are an assessment assistant. Engage the student based on the provided topic. Do not provide answers directly but guide them if they struggle. After the interaction, your analysis will be based on teacher criteria."
                  : "e.g., You are a friendly and helpful history tutor for Grade 10 students."
                }
                required
                rows={formData.bot_type === 'assessment' ? 3 : 5}
                className={!!validationErrors.system_prompt ? 'is-invalid' : ''}
              />
              {validationErrors.system_prompt && (
                <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                  {validationErrors.system_prompt}
                </Alert>
              )}
              <HelpText>
                  This defines the AI&apos;s general behavior.
                  {formData.bot_type === 'assessment' && " For Assessment Bots, assessment-specific instructions are primarily driven by the Assessment Criteria you define above."}
              </HelpText>
            </FormGroup>

            {/* ADDED Welcome Message Field */}
            <FormGroup>
              <Label htmlFor="welcome_message">Welcome Message (Optional)</Label>
              <TextArea
                id="welcome_message"
                name="welcome_message"
                value={formData.welcome_message}
                onChange={handleChange}
                rows={3}
                placeholder="e.g., Hello! I'm your [topic] assistant. How can I help you today?"
                className={!!validationErrors.welcome_message ? 'is-invalid' : ''}
              />
              {validationErrors.welcome_message && (
                <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                  {validationErrors.welcome_message}
                </Alert>
              )}
              <HelpText>
                This will be the first message the student sees from the bot.
              </HelpText>
            </FormGroup>
            {/* END ADDED Welcome Message Field */}

            <FormGroup>
              <Label htmlFor="model">AI Model (for Chatting)</Label>
              <StyledSelect
                  id="model"
                  name="model"
                  value={formData.model}
                  onChange={handleChange}
              >
                  <option value="openai/gpt-4.1-nano">OpenAI GPT-4.1 Nano</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta (Paid)</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B (Free)</option>
              </StyledSelect>
              <HelpText>
                  This model is used for the chatbot&apos;s direct replies to students. The assessment evaluation will use a dedicated model (Qwen3 235B by default for now).
              </HelpText>
            </FormGroup>

            {formData.bot_type === 'learning' && (
              <FormGroup>
                  <Label htmlFor="enable_rag">Knowledge Base (RAG)</Label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px'}}>
                      <input
                          id="enable_rag"
                          name="enable_rag"
                          type="checkbox"
                          checked={formData.enable_rag}
                          onChange={handleChange}
                          style={{ width: '1.15em', height: '1.15em', cursor: 'pointer' }}
                      />
                      <span>Enable RAG: Allow chatbot to use uploaded documents to answer questions.</span>
                  </div>
                  <HelpText>
                      If enabled, you can upload documents to this chatbot&apos;s knowledge base after creation (on the chatbot&apos;s configuration page).
                  </HelpText>
                  
                  {formData.enable_rag && (
                    <>
                      {/* Show enhanced RAG components only in edit mode with a valid chatbot ID */}
                      {editMode && initialData?.chatbot_id ? (
                        <>
                          <EnhancedRagUploader
                            chatbotId={initialData.chatbot_id}
                            onUploadSuccess={() => {
                              // Could add a success notification here if desired
                            }}
                          />
                          <EnhancedRagScraper
                            chatbotId={initialData.chatbot_id}
                            onScrapeSuccess={() => {
                              // Could add a success notification here if desired
                            }}
                          />
                        </>
                      ) : (
                        <Alert variant="info" style={{ marginTop: '12px', marginBottom: '12px' }}>
                          After creating your chatbot, you&apos;ll be able to upload documents and scrape webpages for the knowledge base.
                        </Alert>
                      )}
                    </>
                  )}
              </FormGroup>
            )}

            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens (Chat Response Length)</Label>
              <Input 
                id="max_tokens" 
                name="max_tokens" 
                type="number" 
                value={formData.max_tokens || ''} 
                onChange={handleChange} 
                placeholder="Default: 1000" 
                className={!!validationErrors.max_tokens ? 'is-invalid' : ''}
              />
              {validationErrors.max_tokens && (
                <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                  {validationErrors.max_tokens}
                </Alert>
              )}
            </FormGroup>

            <FormGroup>
              <Label htmlFor="temperature">Temperature (Chat Creativity)</Label>
              <Input 
                id="temperature" 
                name="temperature" 
                type="number" 
                value={formData.temperature || ''} 
                onChange={handleChange} 
                min="0" 
                max="2" 
                step="0.1" 
                placeholder="Default: 0.7"
                className={!!validationErrors.temperature ? 'is-invalid' : ''}
              />
              {validationErrors.temperature && (
                <Alert variant="error" style={{ marginTop: '4px', padding: '4px 8px' }}>
                  {validationErrors.temperature}
                </Alert>
              )}
              <HelpText>0.0 = most deterministic, 2.0 = most creative. Default is 0.7 for the chatbot&apos;s replies.</HelpText>
            </FormGroup>
          </form>
        </FormContent>

        <Footer>
          <ActionButton type="button" variant="outline" onClick={onClose}>
            Cancel
          </ActionButton>
          <ActionButton type="submit" form="chatbotCreateForm" disabled={isSubmitting}>
            {isSubmitting ? (editMode ? 'Saving...' : 'Creating...') : (editMode ? 'Save Changes' : 'Create Chatbot')}
          </ActionButton>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/EnhancedRagScraper.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Button, Alert, Input, FormGroup, Label } from '@/styles/StyledComponents';

// Styled components for the web scraper
const ScraperContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
`;

const SectionTitle = styled.h3`
  font-size: 1.1rem;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const ProgressBar = styled.div`
  width: 100%;
  height: 12px;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-top: ${({ theme }) => theme.spacing.md};
  overflow: hidden;
`;

const Progress = styled.div<{ $progress: number }>`
  height: 100%;
  width: ${props => props.$progress}%;
  background-color: ${({ theme }) => theme.colors.primary};
  transition: width 0.3s ease;
`;

const StatusText = styled.div`
  font-size: 0.9rem;
  margin-top: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.textLight};
`;

interface EnhancedRagScraperProps {
  chatbotId: string;
  onScrapeSuccess?: () => void;
}

export default function EnhancedRagScraper({ chatbotId, onScrapeSuccess }: EnhancedRagScraperProps) {
  const [url, setUrl] = useState('');
  const [scraping, setScraping] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  // Store document ID for internal processing only (not displayed to user)
  const [status, setStatus] = useState<string>('');

  const validateUrl = (url: string): boolean => {
    try {
      new URL(url);
      return true;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    } catch (_urlError) {
      return false;
    }
  };

  const handleScrape = async () => {
    if (!url.trim() || !chatbotId) {
      setError(`Missing required data: ${!url.trim() ? 'No URL entered' : 'No chatbot ID provided'}`);
      return;
    }
    
    if (!validateUrl(url)) {
      setError('Please enter a valid URL starting with http:// or https://');
      return;
    }
    
    console.log(`Scraping URL for chatbot ID: ${chatbotId}`);
    
    setScraping(true);
    setError(null);
    setSuccessMessage(null);
    setProgress(0);
    setStatus('Scraping webpage content...');
    
    try {
      // Create form data with URL information
      const formData = new FormData();
      formData.append('url', url.trim());
      formData.append('chatbotId', chatbotId);
      
      // First, scrape the webpage using FormData
      const scrapeResponse = await fetch('/api/teacher/documents', {
        method: 'POST',
        body: formData,
      });
      
      if (!scrapeResponse.ok) {
        const data = await scrapeResponse.json().catch(() => ({}));
        console.error('Scraping error response:', data);
        throw new Error(data.error || `Failed to scrape webpage (Status: ${scrapeResponse.status})`);
      }
      
      const scrapeData = await scrapeResponse.json();
      console.log('Scraping response data:', scrapeData);
      
      // Get document ID from the response - could be in different formats
      const scrapedDocumentId = 
        scrapeData.documentId || 
        (scrapeData.document && scrapeData.document.document_id);
      
      if (!scrapedDocumentId) {
        console.error('Unexpected response format:', scrapeData);
        throw new Error('No document ID returned from scraping');
      }
      
      // Store document ID for processing
      const documentIdForVectorizing = scrapedDocumentId;
      setProgress(50);
      setStatus('Webpage scraped. Starting processing...');
      setSuccessMessage('Webpage scraped successfully! Processing...');
      
      // Process the scraped content
      setProcessing(true);
      console.log(`Processing document ID: ${scrapedDocumentId} for chatbot: ${chatbotId}`);
      const processResponse = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId: documentIdForVectorizing }),
      });
      
      if (!processResponse.ok) {
        const data = await processResponse.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to process webpage content');
      }
      
      setProgress(100);
      setStatus('Webpage content processed successfully!');
      setSuccessMessage('Webpage content extracted and processing started. It will be available for RAG soon.');
      
      // Clear the URL input
      setUrl('');
      
      // Notify parent
      if (onScrapeSuccess) {
        onScrapeSuccess();
      }
    } catch (err) {
      console.error('Error scraping webpage:', err);
      setError(err instanceof Error ? err.message : 'Failed to scrape webpage');
      setStatus('Error occurred');
    } finally {
      setScraping(false);
      setProcessing(false);
    }
  };

  return (
    <ScraperContainer>
      <SectionTitle>Web Scraper for Knowledge Base</SectionTitle>
      
      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      {successMessage && <Alert variant="success" style={{ marginBottom: '16px' }}>{successMessage}</Alert>}
      
      <FormGroup>
        <Label htmlFor="webpage-url">Webpage URL</Label>
        <Input
          id="webpage-url"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="https://example.com/article"
          type="url"
          disabled={scraping || processing}
        />
        <FileTypeInfo>
          Enter a URL to scrape content from a webpage directly into your knowledge base.
        </FileTypeInfo>
      </FormGroup>
      
      <Button 
        variant="primary" 
        disabled={!url.trim() || !url.startsWith('http') || scraping || processing}
        style={{ marginTop: '8px', width: '100%' }}
        onClick={handleScrape}
      >
        {scraping || processing ? 'Processing...' : 'Extract & Process Content'}
      </Button>
      
      {(scraping || processing) && (
        <>
          <ProgressBar>
            <Progress $progress={progress} />
          </ProgressBar>
          <StatusText>{status}</StatusText>
        </>
      )}
    </ScraperContainer>
  );
}// src/components/teacher/EnhancedRagUploader.tsx
'use client';

import { useState, useRef, ChangeEvent } from 'react';
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';

// Styled components for the uploader
const UploaderContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
`;

const UploadArea = styled.div`
  border: 2px dashed ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.lg};
  text-align: center;
  transition: all ${({ theme }) => theme.transitions.fast};
  cursor: pointer;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  
  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => `${theme.colors.primary}05`};
  }
`;

const FileInput = styled.input`
  display: none;
`;

const UploadText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SectionTitle = styled.h3`
  font-size: 1.1rem;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.text};
`;

const SelectedFileContainer = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const FileName = styled.span`
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const FileSize = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

const ProgressBar = styled.div`
  width: 100%;
  height: 12px;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-top: ${({ theme }) => theme.spacing.md};
  overflow: hidden;
`;

const Progress = styled.div<{ $progress: number }>`
  height: 100%;
  width: ${props => props.$progress}%;
  background-color: ${({ theme }) => theme.colors.primary};
  transition: width 0.3s ease;
`;

const StatusText = styled.div`
  font-size: 0.9rem;
  margin-top: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.textLight};
`;

interface EnhancedRagUploaderProps {
  chatbotId: string;
  onUploadSuccess?: () => void;
}

export default function EnhancedRagUploader({ chatbotId, onUploadSuccess }: EnhancedRagUploaderProps) {
  const [file, setFile] = useState<File | null>(null);
  const [uploading, setUploading] = useState(false);
  const [processing, setProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  // Removed unused documentId state
  const [status, setStatus] = useState<string>('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const validateAndSetFile = (file: File) => {
    setError(null);
    setSuccessMessage(null);
    
    // Check file extension
    const extension = file.name.split('.').pop()?.toLowerCase();
    const validExtensions = ['pdf', 'doc', 'docx', 'txt'];
    
    if (!extension || !validExtensions.includes(extension)) {
      setError('Invalid file type. Please upload PDF, Word (.doc, .docx), or TXT files.');
      return;
    }
    
    // Check file size (10MB max)
    const maxSize = 10 * 1024 * 1024;
    if (file.size > maxSize) {
      setError('File too large. Maximum size is 10MB.');
      return;
    }
    
    setFile(file);
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
  };

  const handleUpload = async () => {
    if (!file || !chatbotId) {
      setError(`Missing required data: ${!file ? 'No file selected' : 'No chatbot ID provided'}`);
      return;
    }
    
    console.log(`Uploading file for chatbot ID: ${chatbotId}`);
    
    setUploading(true);
    setError(null);
    setSuccessMessage(null);
    setProgress(0);
    setStatus('Uploading file...');
    
    try {
      // Create form data for the file upload
      const formData = new FormData();
      formData.append('file', file);
      formData.append('chatbotId', chatbotId);
      
      // Upload the file
      const uploadResponse = await fetch('/api/teacher/documents', {
        method: 'POST',
        body: formData,
      });
      
      if (!uploadResponse.ok) {
        const data = await uploadResponse.json().catch(() => ({}));
        console.error('Upload error response:', data);
        throw new Error(data.error || `Failed to upload document (Status: ${uploadResponse.status})`);
      }
      
      const uploadData = await uploadResponse.json();
      console.log('Upload response data:', uploadData);
      
      // Get document ID from the response - could be in different formats based on API
      const uploadedDocumentId = 
        uploadData.documentId || 
        (uploadData.document && uploadData.document.document_id);
      
      if (!uploadedDocumentId) {
        console.error('Unexpected response format:', uploadData);
        throw new Error('No document ID returned from upload');
      }
      
      // Store documentId for vectorization
      const documentIdForProcessing = uploadedDocumentId;
      setProgress(50);
      setStatus('Document uploaded. Starting processing...');
      setSuccessMessage('Document uploaded successfully! Processing...');
      
      // Process the uploaded document
      setProcessing(true);
      console.log(`Processing document ID: ${uploadedDocumentId} for chatbot: ${chatbotId}`);
      const processResponse = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId: documentIdForProcessing }),
      });
      
      if (!processResponse.ok) {
        const data = await processResponse.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to process document');
      }
      
      setProgress(100);
      setStatus('Document processed successfully!');
      setSuccessMessage('Document uploaded and processing started. It will be available for RAG soon.');
      
      // Clear the file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
      setFile(null);
      
      // Notify parent
      if (onUploadSuccess) {
        onUploadSuccess();
      }
    } catch (err) {
      console.error('Error uploading document:', err);
      setError(err instanceof Error ? err.message : 'Failed to upload document');
      setStatus('Error occurred');
    } finally {
      setUploading(false);
      setProcessing(false);
    }
  };

  return (
    <UploaderContainer>
      <SectionTitle>Upload Documents for Knowledge Base</SectionTitle>
      
      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      {successMessage && <Alert variant="success" style={{ marginBottom: '16px' }}>{successMessage}</Alert>}
      
      <UploadArea onClick={() => fileInputRef.current?.click()}>
        <FileInput
          type="file"
          ref={fileInputRef}
          onChange={handleFileChange}
          accept=".pdf,.doc,.docx,.txt"
        />
        <UploadText>Click or drag file to upload</UploadText>
        <FileTypeInfo>Supported: PDF, DOC, DOCX, TXT (Max 10MB)</FileTypeInfo>
        <Button 
          size="small" 
          variant="outline" 
          type="button" 
          onClick={(e) => { 
            e.stopPropagation(); 
            fileInputRef.current?.click();
          }}
        >
          Browse Files
        </Button>
      </UploadArea>
      
      {file && (
        <>
          <SelectedFileContainer>
            <FileName title={file.name}>{file.name}</FileName>
            <FileSize>{formatFileSize(file.size)}</FileSize>
            <Button
              size="small"
              variant="outline"
              onClick={() => setFile(null)}
              disabled={uploading || processing}
            >
              Remove
            </Button>
          </SelectedFileContainer>
          
          <Button
            onClick={handleUpload}
            disabled={uploading || processing}
            style={{ marginTop: '16px', width: '100%' }}
          >
            {uploading || processing ? 'Processing...' : `Upload & Process ${file.name}`}
          </Button>
          
          {(uploading || processing) && (
            <>
              <ProgressBar>
                <Progress $progress={progress} />
              </ProgressBar>
              <StatusText>{status}</StatusText>
            </>
          )}
        </>
      )}
    </UploaderContainer>
  );
}// src/components/teacher/ConcernsList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button, Badge, Select as StyledSelect } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { ConcernStatus, FlaggedMessage } from '@/types/database.types';

// --- Styled Components ---
const ListContainer = styled(Card)` // This is the Card we want to pass the accent to
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  /* The $accentColor prop will be handled by the base Card component */
`;

const Title = styled.h2`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterControls = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  flex-wrap: wrap;
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; 
  border-collapse: collapse;
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md}; 
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  white-space: nowrap;
  vertical-align: bottom;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.875rem;
  vertical-align: top;
`;

const MessagePreview = styled.div`
  max-width: 200px; 
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: ${({ theme }) => theme.colors.textLight};
  font-style: italic;
`;

interface ConcernBadgeProps {
  $level: number; 
}

const ConcernBadge = styled(Badge)<ConcernBadgeProps>`
  background: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red + '20'; 
    if ($level >= 3) return theme.colors.secondary + '20';
    return theme.colors.blue + '20'; 
  }};

  color: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red;
    if ($level >= 3) return theme.colors.secondaryDark; 
    return theme.colors.blue;
  }};
  font-weight: 500;
`;

interface StatusBadgeProps {
  $status: ConcernStatus; 
}

const StatusBadge = styled(Badge)<StatusBadgeProps>`
   background: ${({ theme, $status }) => {
       switch ($status) {
           case 'resolved': return theme.colors.green + '20';
           case 'false_positive': return theme.colors.textMuted + '20';
           case 'reviewing': return theme.colors.secondary + '20';
           case 'pending': return theme.colors.red + '20';
           default: return theme.colors.backgroundDark;
       }
   }};
   color: ${({ theme, $status }) => {
        switch ($status) {
           case 'resolved': return theme.colors.green;
           case 'false_positive': return theme.colors.textMuted;
           case 'reviewing': return theme.colors.secondaryDark;
           case 'pending': return theme.colors.red;
           default: return theme.colors.textLight;
       }
   }};
   font-weight: 500;
`;


const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  min-height: 100px; 
`;

const PaginationControls = styled.div`
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: ${({ theme }) => theme.spacing.lg};
    gap: ${({ theme }) => theme.spacing.md};
`;

interface ConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

function getConcernTypeText(type: string): string {
    if (!type) return 'Unknown';
    return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

function getConcernLevelText(level: number): string {
    if (level >= 5) return 'Critical';
    if (level >= 4) return 'High';
    if (level >= 3) return 'Significant';
    if (level >= 2) return 'Moderate';
    if (level >= 1) return 'Minor';
    return 'Low';
}

function getStatusText(status: ConcernStatus): string {
    switch (status) {
        case 'pending': return 'Pending';
        case 'reviewing': return 'Reviewing';
        case 'resolved': return 'Resolved';
        case 'false_positive': return 'False Positive';
        default: return status || 'Unknown';
    }
}

// --- MODIFIED Props Interface ---
interface ConcernsListProps {
  limit?: number; 
  accentColor?: string; // Added optional accentColor prop
}

// --- MODIFIED Component Signature to accept accentColor ---
export default function ConcernsList({ limit, accentColor }: ConcernsListProps) {
    const [concerns, setConcerns] = useState<ConcernDetails[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [statusFilter, setStatusFilter] = useState<string>('pending'); 
    const [pagination, setPagination] = useState({ currentPage: 0, hasMore: false, totalCount: 0 });
    const router = useRouter();

    const fetchConcerns = useCallback(async (page = 0, filter = statusFilter, isNewFilter = false) => {
        setLoading(true); 
        if (isNewFilter) {
             setConcerns([]); 
             setPagination(prev => ({ ...prev, currentPage: 0, hasMore: false })); 
        }
        setError(null);

        try {
            const itemsPerPage = limit || 10; 
            const url = new URL('/api/teacher/concerns', window.location.origin);
            url.searchParams.append('page', page.toString());
            url.searchParams.append('limit', itemsPerPage.toString());
            if (filter) {
                url.searchParams.append('status', filter);
            }

            const response = await fetch(url.toString());

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to fetch concerns (status: ${response.status})`);
            }

            const data = await response.json();
            setConcerns(prev => (page > 0 && !isNewFilter) ? [...prev, ...(data.concerns || [])] : (data.concerns || []));
            setPagination({
                 currentPage: data.pagination?.currentPage ?? 0,
                 hasMore: data.pagination?.hasMore ?? false,
                 totalCount: data.pagination?.totalCount ?? 0,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error loading concerns');
            setConcerns([]); 
            setPagination({ currentPage: 0, hasMore: false, totalCount: 0 }); 
        } finally {
            setLoading(false);
        }
    }, [limit, statusFilter]); 

    useEffect(() => {
        fetchConcerns(0, statusFilter, true); 
    }, [fetchConcerns, statusFilter]); 


    const handleViewConversation = (concern: ConcernDetails) => {
        router.push(`/teacher-dashboard/concerns/${concern.flag_id}`);
    };

    const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newFilter = e.target.value;
        setStatusFilter(newFilter);
    };

    const handleLoadMore = () => {
        if (!loading && pagination.hasMore) {
            fetchConcerns(pagination.currentPage + 1, statusFilter, false); 
        }
    };

    const renderContent = () => {
        if (loading && concerns.length === 0) { 
            return <LoadingState><LoadingSpinner /> Loading concerns...</LoadingState>;
        }

        if (error) {
            return <Alert variant="error">{error}</Alert>;
        }

        if (concerns.length === 0) {
            return (
            <EmptyState>
                <p>No concerns {statusFilter ? `with status "${getStatusText(statusFilter as ConcernStatus)}"` : ''} found.</p>
            </EmptyState>
            );
        }

        return (
            <>
                <TableContainer>
                    <Table>
                        <thead>
                            <tr>
                                <TableHeader>Student</TableHeader>
                                <TableHeader>Room</TableHeader>
                                <TableHeader>Concern Type</TableHeader>
                                <TableHeader>Level</TableHeader>
                                <TableHeader>Message Preview</TableHeader>
                                <TableHeader>Date Flagged</TableHeader>
                                <TableHeader>Status</TableHeader>
                                <TableHeader>Actions</TableHeader>
                            </tr>
                        </thead>
                        <tbody>
                            {concerns.map((concern) => (
                                <tr key={concern.flag_id}>
                                    <TableCell>{concern.student_name || 'N/A'}</TableCell>
                                    <TableCell>{concern.room_name || 'N/A'}</TableCell>
                                    <TableCell>{getConcernTypeText(concern.concern_type)}</TableCell>
                                    <TableCell>
                                        <ConcernBadge $level={concern.concern_level}>
                                            {getConcernLevelText(concern.concern_level)} ({concern.concern_level})
                                        </ConcernBadge>
                                    </TableCell>
                                    <TableCell>
                                        <MessagePreview title={concern.message_content || ''}>
                                            {concern.message_content || '[N/A]'}
                                        </MessagePreview>
                                    </TableCell>
                                    <TableCell>
                                        {new Date(concern.created_at).toLocaleString()}
                                    </TableCell>
                                    <TableCell>
                                        <StatusBadge $status={concern.status}>
                                            {getStatusText(concern.status)}
                                        </StatusBadge>
                                    </TableCell>
                                    <TableCell>
                                        <Button
                                            size="small"
                                            onClick={() => handleViewConversation(concern)}
                                        >
                                            Review
                                        </Button>
                                    </TableCell>
                                </tr>
                            ))}
                        </tbody>
                    </Table>
                </TableContainer>

                {!limit && pagination.hasMore && ( 
                 <PaginationControls>
                     <Button onClick={handleLoadMore} variant="outline" disabled={loading}>
                         {loading ? 'Loading...' : 'Load More Concerns'}
                     </Button>
                 </PaginationControls>
                )}
            </>
        );
    };

    return (
        <ListContainer $accentColor={accentColor} $accentSide="top"> {/* MODIFIED: Passed props to Card */}
            {!limit && (
                <>
                    <Title>Student Welfare Concerns</Title>
                    <FilterControls>
                        <label htmlFor="status-filter">Filter by status:</label>
                        <StyledSelect 
                            id="status-filter"
                            value={statusFilter}
                            onChange={handleFilterChange}
                            disabled={loading}
                        >
                            <option value="pending">Pending</option>
                            <option value="reviewing">Reviewing</option>
                            <option value="resolved">Resolved</option>
                            <option value="false_positive">False Positive</option>
                            <option value="">All</option>
                        </StyledSelect>
                        {!loading && <span>Total Found: {pagination.totalCount}</span>}
                    </FilterControls>
                 </>
            )}
            {renderContent()}
        </ListContainer>
    );
}// src/components/teacher/DashboardOverview.tsx
'use client';

import { useState, useEffect, useCallback } from 'react'; // MODIFIED: Added useCallback
import styled from 'styled-components';
import StatsCard from './StatsCard'; 
import { Button, Alert, Card } from '@/styles/StyledComponents'; 
import { useRouter } from 'next/navigation';
import Link from 'next/link'; // MODIFIED: Added Link for the "Create one now" message
import LoadingSpinner from '@/components/shared/LoadingSpinner'; 
import RoomForm from '@/components/teacher/RoomForm'; 
import ChatbotList from '@/components/teacher/ChatbotList'; // MODIFIED: Make sure this is imported
import type { Chatbot } from '@/types/database.types'; 

const OverviewWrapper = styled.div`
  /* Add any specific wrapper styles if needed */
`;

const StatsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Section = styled(Card)` 
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  padding: ${({ theme }) => theme.spacing.lg};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

const QuickActionsContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    button {
      width: 100%;
    }
  }
`;

interface DashboardStats {
  totalChatbots: number;
  totalRooms: number;
  activeRooms: number;
  pendingConcerns: number;
}

export default function DashboardOverview() {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loadingStats, setLoadingStats] = useState(true);
  const [statsError, setStatsError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false); 
  const [availableChatbots, setAvailableChatbots] = useState<Chatbot[]>([]); 
  const [loadingChatbots, setLoadingChatbots] = useState(false); 
  // MODIFIED: State for recent chatbots to display in overview
  const [recentChatbots, setRecentChatbots] = useState<Chatbot[]>([]);
  const [loadingRecentChatbots, setLoadingRecentChatbots] = useState(true);
  const [success, setSuccess] = useState<string | null>(null);


  const router = useRouter();

  // MODIFIED: Separated fetching logic slightly
  const fetchDashboardStats = useCallback(async () => {
    setLoadingStats(true);
    // Don't reset statsError here if chatbots are also loading, let chatbot fetch handle its part
    try {
      // Add a cache-busting parameter to avoid browser caching
      const statsResponse = await fetch(`/api/teacher/dashboard-stats?t=${Date.now()}`, {
        method: 'GET',
        headers: {
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'Pragma': 'no-cache',
          'Expires': '0'
        }
      });
      
      console.log('[DashboardOverview] Stats response status:', statsResponse.status);
      
      if (!statsResponse.ok) {
        const errorData = await statsResponse.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch stats (status ${statsResponse.status})`);
      }
      
      const statsData: DashboardStats = await statsResponse.json();
      console.log('[DashboardOverview] Stats data received:', statsData);
      
      // Validate that we have all the stats we need
      if (statsData) {
        // Create default stats object if any properties are missing
        const validatedStats: DashboardStats = {
          totalChatbots: typeof statsData.totalChatbots === 'number' ? statsData.totalChatbots : 0,
          totalRooms: typeof statsData.totalRooms === 'number' ? statsData.totalRooms : 0,
          activeRooms: typeof statsData.activeRooms === 'number' ? statsData.activeRooms : 0,
          pendingConcerns: typeof statsData.pendingConcerns === 'number' ? statsData.pendingConcerns : 0
        };
        
        setStats(validatedStats);
      } else {
        console.warn('[DashboardOverview] Stats data is empty or invalid');
        // Set default stats
        setStats({
          totalChatbots: 0,
          totalRooms: 0,
          activeRooms: 0,
          pendingConcerns: 0
        });
      }
    } catch (err) {
      console.error("[DashboardOverview] Error fetching dashboard stats:", err);
      const errorMessage = err instanceof Error ? err.message : 'Could not load dashboard statistics.';
      setStatsError(prev => prev ? `${prev}\n${errorMessage}` : errorMessage);
      
      // Provide default stats even in error case to avoid UI issues
      setStats({
        totalChatbots: 0,
        totalRooms: 0,
        activeRooms: 0,
        pendingConcerns: 0
      });
    } finally {
      setLoadingStats(false);
    }
  }, []);

  const fetchTeacherChatbots = useCallback(async (isForQuickActions = false) => {
    if (isForQuickActions) {
      setLoadingChatbots(true);
    } else {
      setLoadingRecentChatbots(true);
    }
    // Don't reset statsError here
    try {
      const chatbotsResponse = await fetch('/api/teacher/chatbots'); // Fetches all chatbots
      if (!chatbotsResponse.ok) {
        const errorData = await chatbotsResponse.json().catch(() => ({}));
        const errorMsg = errorData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`;
        console.error(errorMsg);
        setStatsError(prev => prev ? `${prev}\n${errorMsg}` : errorMsg);
        if (isForQuickActions) setAvailableChatbots([]); else setRecentChatbots([]);
        return;
      }
      const chatbotsData: Chatbot[] = await chatbotsResponse.json();
      if (isForQuickActions) {
        setAvailableChatbots(chatbotsData);
      } else {
        // For overview, maybe show most recent 3-4 or filter them differently
        setRecentChatbots(chatbotsData.slice(0, 4)); // Example: show first 4
        if (availableChatbots.length === 0) { // Also populate availableChatbots if not already fetched
            setAvailableChatbots(chatbotsData);
        }
      }
    } catch (err) {
      console.error("Error fetching chatbots:", err);
      const errorMsg = err instanceof Error ? err.message : 'Could not load chatbots.';
      setStatsError(prev => prev ? `${prev}\n${errorMsg}` : errorMsg);
      if (isForQuickActions) setAvailableChatbots([]); else setRecentChatbots([]);
    } finally {
      if (isForQuickActions) setLoadingChatbots(false); else setLoadingRecentChatbots(false);
    }
  }, [availableChatbots.length]); // Rerun if availableChatbots length changes (e.g., from empty)

  useEffect(() => {
    fetchDashboardStats();
    fetchTeacherChatbots(false); // Fetch for recent chatbots list
    // If availableChatbots is needed for quick actions and not populated by recent fetch
    if(availableChatbots.length === 0) {
        fetchTeacherChatbots(true); // Fetch for quick actions if not already populated
    }
  }, [fetchDashboardStats, fetchTeacherChatbots, availableChatbots.length]); // Added availableChatbots.length

  const handleCreateNewChatbot = () => {
    router.push('/teacher-dashboard/chatbots/new/edit'); 
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    setStatsError(null);
    setSuccess("Room created successfully!");
    // Add success state and display it briefly
    setTimeout(() => {
      setSuccess(null);
    }, 3000);
    fetchDashboardStats(); // Refresh stats which includes room counts
  };

  // MODIFIED: Placeholder handlers for ChatbotList in overview
  const handleEditChatbotOverview = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbotOverview = async (chatbotId: string, chatbotName: string) => {
    if (window.confirm(`Are you sure you want to delete "${chatbotName}"? This will navigate you to the main chatbots page to confirm further.`)) {
      // Or, directly call the delete API and refresh data here if preferred
      // For now, just navigate to the main chatbots page where full delete logic exists
      router.push('/teacher-dashboard/chatbots');
      // To make it fully functional here, you'd replicate the delete logic from ManageChatbotsPage
      // and call fetchTeacherChatbots(false) and fetchDashboardStats() on success.
      setSuccess(`Deletion for "${chatbotName}" would be handled on the main chatbots page`);
      setTimeout(() => {
        setSuccess(null);
      }, 3000);
    }
  };


  if (loadingStats || loadingRecentChatbots) { 
    return (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
            <LoadingSpinner size="large" />
            <p style={{marginTop: '16px'}}>Loading dashboard overview...</p>
        </Card>
    );
  }

  if (statsError && !stats && recentChatbots.length === 0) {
    return (
        <Alert variant="error" style={{ marginBottom: '16px' }}>
            {statsError}
            <Button onClick={() => window.location.reload()} size="small" style={{marginLeft: '10px'}}>Retry</Button>
        </Alert>
    );
  }
  
  return (
    <OverviewWrapper>
      {statsError && <Alert variant="error" style={{ marginBottom: '16px' }}>{statsError}</Alert>}
      {success && <Alert variant="success" style={{ marginBottom: '16px' }}>{success}</Alert>}

      <StatsGrid>
        {!stats && statsError ? (
          <>
            <Card style={{ gridColumn: '1 / -1', padding: '20px', textAlign: 'center' }}>
              <Alert variant="error" style={{ marginBottom: '16px' }}>Failed to load dashboard statistics</Alert>
              <Button onClick={fetchDashboardStats} variant="primary">Retry Loading Stats</Button>
            </Card>
          </>
        ) : (
          <>
            <StatsCard
              title="Pending Concerns"
              value={stats?.pendingConcerns ?? 0}
              onClick={() => router.push('/teacher-dashboard/concerns')}
              variant={(stats?.pendingConcerns ?? 0) > 0 ? 'danger' : 'green'}
            />
            <StatsCard
              title="Active Rooms"
              value={stats?.activeRooms ?? 0}
              onClick={() => router.push('/teacher-dashboard/rooms')}
              variant="cyan" 
            />
            <StatsCard
              title="My Chatbots"
              value={stats?.totalChatbots ?? 0}
              onClick={() => router.push('/teacher-dashboard/chatbots')}
              variant="magenta" 
            />
            <StatsCard
              title="Total Rooms"
              value={stats?.totalRooms ?? 0}
              onClick={() => router.push('/teacher-dashboard/rooms')} 
              variant="orange_secondary" 
            />
          </>
        )}
      </StatsGrid>

      <Section $accentSide="top" $accentColor="magenta">
        <SectionHeader>
          <SectionTitle>Quick Actions</SectionTitle>
        </SectionHeader>
        <QuickActionsContainer>
          <Button onClick={handleCreateNewChatbot}>
            + Create New Chatbot
          </Button>
          <Button
            onClick={() => setShowRoomForm(true)}
            disabled={loadingChatbots || availableChatbots.length === 0}
            title={availableChatbots.length === 0 && !loadingChatbots ? "Create a chatbot before creating a room" : "Create New Room"}
          >
            {loadingChatbots ? "Loading Chatbots..." : "+ Create New Room"}
          </Button>
        </QuickActionsContainer>
        {availableChatbots.length === 0 && !loadingChatbots && !statsError?.includes("Failed to load chatbots for Room Creation.") && (
            <Alert variant='info' style={{marginTop: '16px'}}>
                You need to create at least one chatbot before you can create a classroom room using the quick action.
            </Alert>
        )}
      </Section>

      {/* MODIFIED: Section to display recent chatbots */}
      <Section $accentSide="top" $accentColor="blue">
        <SectionHeader>
          <SectionTitle>My Recent Chatbots</SectionTitle>
          {stats && stats.totalChatbots > recentChatbots.length && (
            <Button variant="outline" size="small" onClick={() => router.push('/teacher-dashboard/chatbots')}>
              View All ({stats.totalChatbots})
            </Button>
          )}
        </SectionHeader>
        {loadingRecentChatbots && recentChatbots.length === 0 ? (
            <div style={{textAlign: 'center', padding: '20px'}}><LoadingSpinner /> Loading chatbots...</div>
        ) : recentChatbots.length > 0 ? (
          <ChatbotList
            chatbots={recentChatbots} 
            onEdit={handleEditChatbotOverview}
            onDelete={handleDeleteChatbotOverview}
            viewMode="card" // MODIFIED: Provide the viewMode prop, defaulting to 'card' for overview
          />
        ) : (
          <p>No chatbots created yet. <Link href="/teacher-dashboard/chatbots/new/edit" style={{textDecoration: 'underline', fontWeight: '500'}}>Create one now!</Link></p>
        )}
      </Section>


      {showRoomForm && (
        <RoomForm
          chatbots={availableChatbots} 
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreated}
        />
      )}
    </OverviewWrapper>
  );
}// src/components/teacher/StudentList.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react'; // Added useRef
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button } from '@/styles/StyledComponents';
// Input import is removed as it's not used
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; 
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled(EmptyState)` // Reuse EmptyState style for consistency
    display: flex;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
`;


const MobileList = styled.div`
  display: none;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block;
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const StudentName = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.875rem;
  
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-right: ${({ theme }) => theme.spacing.md};
  }
  
  .value {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const PinInfoContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-top: ${({ theme }) => theme.spacing.sm};
  padding: ${({ theme }) => theme.spacing.sm};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  border: 1px solid ${({ theme }) => theme.colors.border};
`;

const PinInfoRow = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.xs};
  
  .label {
    font-weight: 500;
    min-width: 80px;
  }
  
  .value {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    letter-spacing: 1px;
  }
`;

const PinActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-top: ${({ theme }) => theme.spacing.sm};
`;

// ExpandButton is defined but not used - kept for future use
// const ExpandButton = styled.button`
//   background: none;
//   border: none;
//   color: ${({ theme }) => theme.colors.primary};
//   cursor: pointer;
//   font-size: 0.875rem;
//   padding: 0;
//   display: inline-flex;
//   align-items: center;
//   margin-left: ${({ theme }) => theme.spacing.xs};
  
//   &:hover {
//     text-decoration: underline;
//   }
// `;

interface Student {
  user_id: string;
  name: string;
  email: string;
  joined_at: string | null;
  pin_code?: string;
  username?: string;
  pinLoading?: boolean;
  showPin?: boolean;
  archiving?: boolean;
}

interface StudentListProps {
  roomId: string;
}

// PinResponse is defined but not directly used - kept for clarity
// interface PinResponse {
//   pin_code: string;
//   username: string;
//   studentName: string;
//   regenerated?: boolean;
// }

const ArchiveButton = styled(Button)`
  background-color: ${({ theme }) => theme.colors.secondary};
  color: white;
  
  &:hover {
    background-color: ${({ theme }) => theme.colors.secondaryDark};
  }
`;

const ConfirmationModal = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 400px;
  padding: ${({ theme }) => theme.spacing.lg};
  text-align: center;
`;

const ModalActions = styled.div`
  display: flex;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

export default function StudentList({ roomId }: StudentListProps) {
  const [students, setStudents] = useState<Student[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [archiveModalOpen, setArchiveModalOpen] = useState(false);
  const [studentToArchive, setStudentToArchive] = useState<Student | null>(null);
  const router = useRouter();
  const linkInputRefs = useRef<Record<string, HTMLInputElement | null>>({});

  const fetchStudents = useCallback(async () => {
    console.log(`[StudentList] Fetching students for roomId: ${roomId}`);
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/teacher/students?roomId=${roomId}`);
      
      if (!response.ok) {
        let errorMessage = `Failed to fetch students (status ${response.status})`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.error || errorMessage;
        } catch {
          // Failed to parse error JSON
        }
        console.error(`[StudentList] API error: ${errorMessage}`);
        throw new Error(errorMessage);
      }
      
      const data = await response.json();
      console.log('[StudentList] Students data received:', data);
      setStudents(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error('[StudentList] Catch block error fetching students:', err);
      setError(err instanceof Error ? err.message : 'Could not load student data.');
      setStudents([]); // Clear students on error
    } finally {
      console.log('[StudentList] Setting loading to false.');
      setLoading(false);
    }
  }, [roomId]); // roomId is the dependency

  useEffect(() => {
    if (roomId) { // Only fetch if roomId is available
        fetchStudents();
    } else {
        console.warn("[StudentList] RoomId is missing, not fetching students.");
        setLoading(false); // Don't hang in loading state if no roomId
    }
  }, [roomId, fetchStudents]); // fetchStudents is stable due to useCallback

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString();
    } catch {
        return 'Invalid Date';
    }
  };

  const handleViewChats = (studentId: string) => {
    router.push(`/teacher-dashboard/rooms/${roomId}/students/${studentId}`);
  };
  
  const openArchiveModal = (student: Student) => {
    setStudentToArchive(student);
    setArchiveModalOpen(true);
  };
  
  const closeArchiveModal = () => {
    setArchiveModalOpen(false);
    setStudentToArchive(null);
  };
  
  const archiveStudent = async (studentId: string) => {
    // Mark student as archiving
    setStudents(current => 
      current.map(s => 
        s.user_id === studentId ? { ...s, archiving: true } : s
      )
    );
    
    try {
      const response = await fetch(`/api/teacher/students/archive`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          studentId,
          roomId
        })
      });
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to archive student (${response.status})`);
      }
      
      // Remove the student from the list
      setStudents(current => current.filter(s => s.user_id !== studentId));
      closeArchiveModal();
    } catch (err) {
      console.error('Error archiving student:', err);
      setError(err instanceof Error ? err.message : 'Failed to archive student');
      
      // Reset archiving state
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId ? { ...s, archiving: false } : s
        )
      );
      closeArchiveModal();
    }
  };
  
  const fetchStudentPin = async (studentId: string) => {
    // Find the student and set loading state
    setStudents(current => 
      current.map(s => 
        s.user_id === studentId ? { ...s, pinLoading: true, showPin: true } : s
      )
    );
    
    try {
      const response = await fetch(`/api/teacher/students/pin-code?studentId=${studentId}`);
      
      if (!response.ok) {
        throw new Error(`Failed to get student PIN (${response.status})`);
      }
      
      const data = await response.json();
      
      // Update the student with the PIN code
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId 
            ? { 
                ...s, 
                pin_code: data.pin_code, 
                username: data.username, 
                pinLoading: false, 
                showPin: true 
              } 
            : s
        )
      );
    } catch (err) {
      console.error('Error fetching student PIN:', err);
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId 
            ? { ...s, pin_code: undefined, pinLoading: false, showPin: true } 
            : s
        )
      );
      setError(err instanceof Error ? err.message : 'Failed to get student PIN');
    }
  };
  
  const regeneratePin = async (studentId: string) => {
    // Find the student and set loading state
    setStudents(current => 
      current.map(s => 
        s.user_id === studentId ? { ...s, pinLoading: true } : s
      )
    );
    
    try {
      const response = await fetch('/api/teacher/students/pin-code', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ studentId })
      });
      
      if (!response.ok) {
        throw new Error(`Failed to regenerate PIN (${response.status})`);
      }
      
      const data = await response.json();
      
      // Update the student with the new PIN
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId 
            ? { 
                ...s, 
                pin_code: data.pin_code, 
                username: data.username, 
                pinLoading: false 
              } 
            : s
        )
      );
    } catch (err) {
      console.error('Error regenerating PIN:', err);
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId ? { ...s, pinLoading: false } : s
        )
      );
      setError(err instanceof Error ? err.message : 'Failed to regenerate PIN');
    }
  };
  
  const copyToClipboard = (studentId: string) => {
    const student = students.find(s => s.user_id === studentId);
    if (!student?.pin_code || !student?.username) return;
    
    // Create a formatted text with username and PIN
    const textToCopy = `Username: ${student.username}\nPIN: ${student.pin_code}`;
    
    // Use the clipboard API
    navigator.clipboard.writeText(textToCopy)
      .then(() => {
        alert('Username and PIN copied to clipboard!');
      })
      .catch(err => {
        console.error('Failed to copy to clipboard:', err);
        
        // Fallback to input element select method
        const inputRef = linkInputRefs.current[studentId];
        if (inputRef) {
          inputRef.value = textToCopy;
          inputRef.select();
          document.execCommand('copy');
          alert('Username and PIN copied to clipboard!');
        }
      });
  };
  
  const togglePinDisplay = (studentId: string) => {
    const student = students.find(s => s.user_id === studentId);
    
    if (student?.showPin) {
      // Hide the PIN
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId ? { ...s, showPin: false } : s
        )
      );
    } else if (student?.pin_code) {
      // Show existing PIN
      setStudents(current => 
        current.map(s => 
          s.user_id === studentId ? { ...s, showPin: true } : s
        )
      );
    } else {
      // Fetch PIN
      fetchStudentPin(studentId);
    }
  };

  if (loading) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <LoadingState><LoadingSpinner size="small" /> Loading student data...</LoadingState>
      </ListContainer>
    );
  }

  // Error display takes precedence over empty state if an error occurred
  if (error) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <Alert variant="error">
          Error: {error}
          <Button size="small" onClick={fetchStudents} style={{ marginLeft: '10px' }}>
            Retry
          </Button>
        </Alert>
      </ListContainer>
    );
  }

  if (students.length === 0) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <EmptyState>
          <p>No students have joined this room yet, or data could not be loaded.</p>
          <Button size="small" onClick={fetchStudents} style={{ marginTop: '10px' }}>
            Refresh List
          </Button>
        </EmptyState>
      </ListContainer>
    );
  }

  return (
    <ListContainer>
      <Title>Students ({students.length})</Title>
      
      <Table>
        <thead>
          <tr>
            <TableHeader>Name</TableHeader>
            <TableHeader>Email</TableHeader>
            <TableHeader>Joined</TableHeader>
            <TableHeader>Login Credentials</TableHeader>
            <TableHeader>Actions</TableHeader>
          </tr>
        </thead>
        <tbody>
          {students.map((student) => (
            <tr key={student.user_id}>
              <TableCell>{student.name}</TableCell>
              <TableCell>{student.email}</TableCell>
              <TableCell>{formatDate(student.joined_at)}</TableCell>
              <TableCell>
                {student.pinLoading ? (
                  <LoadingSpinner size="small" />
                ) : student.showPin && student.pin_code ? (
                  <PinInfoContainer>
                    <PinInfoRow>
                      <span className="label">Username:</span>
                      <span className="value">{student.username}</span>
                    </PinInfoRow>
                    <PinInfoRow>
                      <span className="label">PIN:</span>
                      <span className="value">{student.pin_code}</span>
                    </PinInfoRow>
                    <PinActions>
                      <Button 
                        size="small" 
                        variant="secondary"
                        onClick={() => copyToClipboard(student.user_id)}
                      >
                        Copy
                      </Button>
                      <Button 
                        size="small" 
                        variant="secondary"
                        onClick={() => regeneratePin(student.user_id)}
                      >
                        New PIN
                      </Button>
                      <Button 
                        size="small" 
                        variant="secondary"
                        onClick={() => togglePinDisplay(student.user_id)}
                      >
                        Hide
                      </Button>
                    </PinActions>
                  </PinInfoContainer>
                ) : (
                  <Button 
                    size="small" 
                    variant="secondary"
                    onClick={() => togglePinDisplay(student.user_id)}
                  >
                    Show Login Info
                  </Button>
                )}
              </TableCell>
              <TableCell>
                <div style={{ display: 'flex', gap: '0.5rem' }}>
                  <Button
                    size="small"
                    onClick={() => handleViewChats(student.user_id)}
                  >
                    Student Details
                  </Button>
                  {student.archiving ? (
                    <Button size="small" disabled>
                      <LoadingSpinner size="small" /> Archiving...
                    </Button>
                  ) : (
                    <ArchiveButton
                      size="small"
                      onClick={() => openArchiveModal(student)}
                      variant="secondary"
                    >
                      Archive
                    </ArchiveButton>
                  )}
                </div>
              </TableCell>
            </tr>
          ))}
        </tbody>
      </Table>
      
      <MobileList>
        {students.map((student) => (
          <MobileCard key={student.user_id}>
            <MobileHeader>
              <StudentName>{student.name}</StudentName>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Email:</span>
              <span className="value">{student.email}</span>
              <span className="label">Joined:</span>
              <span className="value">{formatDate(student.joined_at)}</span>
              {student.showPin && student.pin_code && (
                <>
                  <span className="label">Username:</span>
                  <span className="value">{student.username}</span>
                  <span className="label">PIN:</span>
                  <span className="value">{student.pin_code}</span>
                </>
              )}
            </MobileDetails>
            <MobileActions>
              {student.pinLoading ? (
                <LoadingSpinner size="small" />
              ) : student.showPin && student.pin_code ? (
                <>
                  <Button 
                    size="small" 
                    variant="secondary"
                    onClick={() => copyToClipboard(student.user_id)}
                  >
                    Copy
                  </Button>
                  <Button 
                    size="small" 
                    variant="secondary"
                    onClick={() => regeneratePin(student.user_id)}
                  >
                    New PIN
                  </Button>
                  <Button 
                    size="small" 
                    variant="secondary"
                    onClick={() => togglePinDisplay(student.user_id)}
                  >
                    Hide
                  </Button>
                </>
              ) : (
                <Button 
                  size="small" 
                  variant="secondary"
                  onClick={() => togglePinDisplay(student.user_id)}
                >
                  Show Login Info
                </Button>
              )}
              <Button
                size="small"
                onClick={() => handleViewChats(student.user_id)}
                style={{ marginRight: '0.5rem' }}
              >
                Student Details
              </Button>
              {student.archiving ? (
                <Button size="small" disabled>
                  <LoadingSpinner size="small" /> Archiving...
                </Button>
              ) : (
                <ArchiveButton
                  size="small"
                  onClick={() => openArchiveModal(student)}
                  variant="secondary"
                >
                  Archive
                </ArchiveButton>
              )}
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
      {archiveModalOpen && studentToArchive && (
        <ConfirmationModal>
          <ModalContent>
            <h3>Archive Student</h3>
            <p>Are you sure you want to remove <strong>{studentToArchive.name}</strong> from this room?</p>
            <p>The student will no longer have access to this room, but their account and data will be preserved.</p>
            <ModalActions>
              <Button variant="outline" onClick={closeArchiveModal}>
                Cancel
              </Button>
              <ArchiveButton 
                onClick={() => archiveStudent(studentToArchive.user_id)}
                variant="secondary"
              >
                Archive Student
              </ArchiveButton>
            </ModalActions>
          </ModalContent>
        </ConfirmationModal>
      )}
    </ListContainer>
  );
}// src/components/teacher/ChatbotList.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

// Card View Styled Components (Existing)
const ListGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const StyledChatbotCard = styled(Card)<{ $cardAccentColor?: string }>`
  position: relative;
  display: flex;
  flex-direction: column;
  ${({ $cardAccentColor }) => 
    $cardAccentColor && `border-top: 4px solid ${$cardAccentColor};`}

  a > h3 { 
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
    text-decoration: none;
    display: block; 
    transition: color ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      text-decoration: underline;
    }
  }
  
  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1; 
    min-height: 40px; 
  }
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.md};
    margin-top: auto; 
    padding-top: ${({ theme }) => theme.spacing.md}; 
    flex-wrap: no-wrap; 
    
    button { 
        flex-grow: 1; 
        flex-basis: calc(50% - ${({ theme }) => `calc(${theme.spacing.md} / 2)`});
        max-width: calc(50% - ${({ theme }) => `calc(${theme.spacing.md} / 2)`});
        text-align: center; 

         @media (max-width: 380px) { 
            flex-basis: 100%; 
            max-width: 100%;
            &:not(:last-child) {
              margin-bottom: ${({ theme }) => theme.spacing.sm};
            }
         }
    }
  }
`;

// Styled Components for Table/List View
const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;
  margin-top: ${({ theme }) => theme.spacing.lg};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; 
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    vertical-align: middle;
  }

  th {
    background-color: ${({ theme }) => theme.colors.backgroundCard};
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    white-space: nowrap;
  }

  td {
    font-size: 0.9rem;
  }

  tr:last-child td {
    border-bottom: none;
  }
  
  .description-cell {
    max-width: 250px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
`;

const ActionButtonsContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  align-items: center;
`;

const ActionButtonsContainerCard = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: auto; 
  padding-top: ${({ theme }) => theme.spacing.md}; 
  flex-wrap: wrap;
`;

const ActionButton = styled(Button)`
  flex: 1;
  min-width: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.xs};
  white-space: nowrap;
  
  svg {
    font-size: 0.85rem;
  }
  
  @media (max-width: 380px) { 
    flex-basis: 100%; 
    
    &:not(:last-child) {
      margin-bottom: ${({ theme }) => theme.spacing.sm};
    }
  }
`;

const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash',
        'openai/gpt-4.1-nano': 'GPT-4.1 Nano', 
    };
    return modelNames[model] || model;
};

// Ensure this interface is EXPORTED
export interface ChatbotListProps {
  chatbots: Chatbot[];
  onEdit: (chatbotId: string) => void;
  onDelete: (chatbotId: string, chatbotName: string) => void; 
  viewMode: 'card' | 'list';
}

export default function ChatbotList({ chatbots, onEdit, onDelete, viewMode }: ChatbotListProps) {

  if (chatbots.length === 0) {
    return <Card><p>No chatbots found.</p></Card>;
  }

  const formatDate = (dateString: string | undefined) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString();
  };

  if (viewMode === 'list') {
    return (
      <TableContainer>
        <Table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Type</th>
              <th>Description</th>
              <th>Model</th>
              <th>RAG</th>
              <th>Last Modified</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {chatbots.map((chatbot) => (
              <tr key={chatbot.chatbot_id}>
                <td>
                  <Link href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/test-chat`} title={`Test chat with ${chatbot.name}`}>
                    {chatbot.name}
                  </Link>
                </td>
                <td>
                  <Badge variant={chatbot.bot_type === 'assessment' ? 'warning' : 'default'}>
                    {chatbot.bot_type ? chatbot.bot_type.charAt(0).toUpperCase() + chatbot.bot_type.slice(1) : 'N/A'}
                  </Badge>
                </td>
                <td className="description-cell" title={chatbot.description || undefined}>
                  {chatbot.description || '-'}
                </td>
                <td>{getModelDisplayName(chatbot.model)}</td>
                <td>
                  <Badge variant={chatbot.enable_rag ? 'success' : 'default'}>
                    {chatbot.enable_rag ? 'Enabled' : 'Disabled'}
                  </Badge>
                </td>
                <td>{formatDate(chatbot.updated_at || chatbot.created_at)}</td>
                <td>
                  <ActionButtonsContainer>
                    <Button
                      size="small"
                      variant="outline"
                      onClick={() => onEdit(chatbot.chatbot_id)}
                    >
                      Edit
                    </Button>
                    <Button
                      size="small"
                      variant="magenta"
                      onClick={() => onDelete(chatbot.chatbot_id, chatbot.name)}
                    >
                      Delete
                    </Button>
                  </ActionButtonsContainer>
                </td>
              </tr>
            ))}
          </tbody>
        </Table>
      </TableContainer>
    );
  }

  return (
    <ListGrid>
      {chatbots.map((chatbot) => {
        return (
          <StyledChatbotCard 
              key={chatbot.chatbot_id}
          >
            <Link href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/test-chat`} title={`Test chat with ${chatbot.name}`}>
              <h3>{chatbot.name}</h3>
            </Link>
            <p className="description">{chatbot.description || 'No description provided.'}</p>
            <div className="model-info">
              Model: {getModelDisplayName(chatbot.model)}
            </div>
            <ActionButtonsContainerCard>
              <ActionButton
                size="small"
                variant="outline" 
                onClick={() => onEdit(chatbot.chatbot_id)}
                title="Edit chatbot settings"
              >
                Edit
              </ActionButton>
              <ActionButton
                size="small"
                variant="magenta"
                onClick={() => onDelete(chatbot.chatbot_id, chatbot.name)}
                title="Delete this chatbot"
              >
                Delete
              </ActionButton>
            </ActionButtonsContainerCard>
          </StyledChatbotCard>
        );
      })}
    </ListGrid>
  );
}// src/components/teacher/StudentCsvUpload.tsx
'use client';

import { useState, useRef } from 'react';
import styled from 'styled-components';
import { Card, Button, Alert } from '@/styles/StyledComponents';

// --- Styled Components ---
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 500px;
  margin: 20px;
  position: relative;
  text-align: center;
  border-top: none !important;
  max-height: 90vh;
  display: flex;
  flex-direction: column;
  overflow-y: hidden; /* Hide overflow at the card level */
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  text-align: left;
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const FileUploadWrapper = styled.div`
  border: 2px dashed ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.lg};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  text-align: center;
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};

  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => theme.colors.background};
  }
`;

const HiddenInput = styled.input`
  display: none;
`;

const TemplateLink = styled.a`
  color: ${({ theme }) => theme.colors.primary};
  font-weight: 500;
  text-decoration: underline;
  cursor: pointer;
`;

const ResultsContainer = styled.div`
  margin-top: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  max-height: 300px;
  overflow-y: auto;
  text-align: left;
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  
  &::-webkit-scrollbar {
    width: 8px;
  }
  &::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => theme.colors.borderDark};
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }
  scrollbar-width: thin; /* Firefox */
  scrollbar-color: ${({ theme }) => theme.colors.borderDark} transparent; /* Firefox */
`;

const MagicLinkItem = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.background};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  border-left: 3px solid ${({ theme }) => theme.colors.primary};
`;

const ExpiryWarning = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.secondary}20;
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  border-left: 3px solid ${({ theme }) => theme.colors.secondary};
  font-size: 0.9rem;
`;

const StudentName = styled.div`
  font-weight: 600;
  margin-bottom: ${({ theme }) => theme.spacing.xs};
`;

const MagicLink = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 0.8rem;
  word-break: break-all;
  padding: ${({ theme }) => theme.spacing.xs};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-top: ${({ theme }) => theme.spacing.xs};
`;

const CopyButton = styled(Button).attrs({ size: 'small' })`
  margin-top: ${({ theme }) => theme.spacing.xs};
  font-size: 0.8rem;
`;

const CopyAllButton = styled(Button)`
  margin-top: ${({ theme }) => theme.spacing.md};
  /* This component inherits all Button props */
`;

interface StudentCsvUploadProps {
  roomId: string;
  roomName: string;
  onClose: () => void;
}

interface StudentLinkResult {
  fullName: string;
  email: string | null;
  magicLink: string;
}

export default function StudentCsvUpload({ roomId, roomName, onClose }: StudentCsvUploadProps) {
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [results, setResults] = useState<StudentLinkResult[]>([]);
  const [success, setSuccess] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    setError(null);
    setSuccess(null);
    setResults([]);
    
    const file = event.target.files?.[0];
    if (!file) return;

    if (file.type !== 'text/csv' && !file.name.endsWith('.csv')) {
      setError('Please upload a valid CSV file.');
      return;
    }

    const formData = new FormData();
    formData.append('file', file);
    formData.append('roomId', roomId);

    setIsUploading(true);

    try {
      const importURL = `/api/teacher/rooms/${roomId}/students/import`;
      console.log('Sending CSV import request to:', importURL);
      
      // Send the request with form data
      const response = await fetch(importURL, {
        method: 'POST',
        body: formData,
      });

      console.log('CSV import response status:', response.status, response.statusText);
      
      let data;
      try {
        // Try to parse the JSON, but handle potential parsing errors
        const textResponse = await response.text();
        console.log('Raw response text:', textResponse.substring(0, 200) + (textResponse.length > 200 ? '...' : ''));
        data = textResponse ? JSON.parse(textResponse) : {};
      } catch (parseErr) {
        console.error('Error parsing response:', parseErr);
        throw new Error('Invalid response from server. Check the console for details.');
      }
      
      if (!response.ok) {
        console.error('Import error response:', data);
        console.error('Response status:', response.status, response.statusText);
        
        // Extract more specific error message if available
        const errorMessage = data?.error || `Failed to import students (Status: ${response.status})`;
        throw new Error(errorMessage);
      }

      // Check if we're in debug mode
      if (data?.debug) {
        console.log('Debug mode detected. Mock data:', data);
        setSuccess(`Debug mode: ${data.message || 'Route handler is working'}`);
        
        // Use the mock data provided by the debug route
        if (data.students && data.students.length > 0) {
          setResults(data.students);
        } else {
          setResults([{
            fullName: "Debug Student",
            email: "debug@example.com",
            magicLink: "https://example.com/debug-link"
          }]);
        }
      }
      // If partial success (some students failed)
      else if (data?.failedImports && data.failedImports.length > 0) {
        const successCount = data.students?.length || 0;
        const failedCount = data.failedImports.length;
        
        setSuccess(`Partially successful: Added ${successCount} out of ${successCount + failedCount} students to room "${roomName}".`);
        setError(`Failed to add ${failedCount} students. Please check console for details.`);
        console.error('Failed student imports:', data.failedImports);
        setResults(data?.students || []);
      } else {
        setSuccess(`Successfully added ${data.students?.length || 0} students to room "${roomName}".`);
        setResults(data?.students || []);
      }
    } catch (err) {
      console.error('Error importing students:', err);
      setError(err instanceof Error ? err.message : 'An unknown error occurred during import.');
    } finally {
      setIsUploading(false);
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    }
  };

  const handleCopyLink = async (link: string) => {
    try {
      await navigator.clipboard.writeText(link);
      // Use a safer approach than alert
      setSuccess('Link copied to clipboard!');
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      console.error('Failed to copy link:', err);
      setError('Failed to copy link.');
      setTimeout(() => setError(null), 3000);
    }
  };

  const handleCopyAllLinks = async () => {
    try {
      const allLinks = results.map(result => `${result.fullName}: ${result.magicLink}`).join('\n\n');
      await navigator.clipboard.writeText(allLinks);
      // Use a safer approach than alert
      setSuccess('All links copied to clipboard!');
      setTimeout(() => setSuccess(null), 3000);
    } catch (err) {
      console.error('Failed to copy links:', err);
      setError('Failed to copy links.');
      setTimeout(() => setError(null), 3000);
    }
  };

  const downloadTemplateCSV = () => {
    // Using separate lines for each student to make it clearer in the CSV file
    // Add more rows to demonstrate multiple students can be imported
    const csvContent = 'Full Name,Email\nJohn Doe,john.doe@example.com\nJane Smith,jane.smith@example.com\nBob Johnson,bob.johnson@example.com';
    const blob = new Blob([csvContent], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'student_template.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

const ModalBody = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: 0 ${({ theme }) => theme.spacing.lg};
  
  &::-webkit-scrollbar {
    width: 8px;
  }
  &::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => theme.colors.borderDark};
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }
  scrollbar-width: thin; /* Firefox */
  scrollbar-color: ${({ theme }) => theme.colors.borderDark} transparent; /* Firefox */
`;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Import Students for {roomName}</ModalTitle>
        
        <ModalBody>
          <ModalText>
            Upload a CSV file with student information to bulk add them to this room. 
            Each student will receive a unique magic link for passwordless access.
          </ModalText>
          
          <ModalText>
            Required CSV format: <TemplateLink onClick={downloadTemplateCSV}>Download Template</TemplateLink>
          </ModalText>
          <ul>
            <li><strong>Full Name</strong> (required)</li>
            <li><strong>Email</strong> (optional - if provided, students can also login with email)</li>
          </ul>

          {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
          {success && <Alert variant="success" style={{ marginBottom: '16px' }}>{success}</Alert>}

          <FileUploadWrapper onClick={() => fileInputRef.current?.click()}>
            <p>Click to select CSV file or drag and drop</p>
            {isUploading ? <p>Uploading...</p> : <p>Select file</p>}
            <HiddenInput 
              type="file"
              accept=".csv"
              ref={fileInputRef}
              onChange={handleFileUpload}
            />
          </FileUploadWrapper>

          {results.length > 0 && (
            <>
              <ModalText>Student Magic Links (distribute these to your students):</ModalText>
              <ExpiryWarning>
                <strong>Important:</strong> These magic links will expire after 24 hours. Please make sure students use their links within this timeframe.
                If a link expires, you will need to generate a new one for the student.
              </ExpiryWarning>
              <ResultsContainer>
                {results.map((student, index) => (
                  <MagicLinkItem key={index}>
                    <StudentName>{student.fullName}</StudentName>
                    {student.email && <div>Email: {student.email}</div>}
                    <MagicLink>{student.magicLink}</MagicLink>
                    <CopyButton 
                      size="small"
                      variant="outline"
                      onClick={() => handleCopyLink(student.magicLink)}
                    >
                      Copy Link
                    </CopyButton>
                  </MagicLinkItem>
                ))}
              </ResultsContainer>
              <CopyAllButton onClick={handleCopyAllLinks}>Copy All Links</CopyAllButton>
            </>
          )}
        </ModalBody>

        <ModalActions>
          <Button variant="outline" onClick={onClose} disabled={isUploading}>
            Close
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
    overflow-y: auto;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    max-height: 100%;
    min-height: 100vh;
    border-radius: 0;
    overflow-y: auto;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    position: sticky;
    top: 0;
    background: ${({ theme }) => theme.colors.backgroundCard};
    padding: ${({ theme }) => theme.spacing.sm} 0;
    z-index: 5;
  }
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
  }
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    max-height: 200px;
  }
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
    min-height: 44px; // Better for touch inputs
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 20px;
    height: 20px;
  }
`;

const ChatbotName = styled.span`
  flex: 1;
`;

const ChatbotDescription = styled.span`
  margin-left: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none;
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px; // Better for touch inputs
  }
`;

interface RoomFormProps {
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function RoomForm({ chatbots, onClose, onSuccess }: RoomFormProps) {
  const [formData, setFormData] = useState({
    room_name: '',
    chatbot_ids: [] as string[],
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/teacher/rooms', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create room');
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create room');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({
      ...prev,
      room_name: e.target.value,
    }));
  };

  const handleToggleChatbot = (chatbotId: string) => {
    setFormData(prev => ({
      ...prev,
      chatbot_ids: prev.chatbot_ids.includes(chatbotId)
        ? prev.chatbot_ids.filter(id => id !== chatbotId)
        : [...prev.chatbot_ids, chatbotId]
    }));
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create Classroom Room</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="room_name">Room Name</Label>
            <Input
              id="room_name"
              name="room_name"
              value={formData.room_name}
              onChange={handleNameChange}
              placeholder="Enter room name"
              required
            />
          </FormGroup>

          <FormGroup>
            <Label>Select Chatbots</Label>
            {chatbots.length === 0 ? (
              <Alert variant="warning">
                You need to create a chatbot before you can create a room.
              </Alert>
            ) : (
              <ChatbotList>
                {chatbots.map(chatbot => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <Checkbox
                      type="checkbox"
                      checked={formData.chatbot_ids.includes(chatbot.chatbot_id)}
                      onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                    />
                    <ChatbotName>{chatbot.name}</ChatbotName>
                    {chatbot.description && (
                      <ChatbotDescription>
                        - {chatbot.description}
                      </ChatbotDescription>
                    )}
                  </ChatbotItem>
                ))}
              </ChatbotList>
            )}
          </FormGroup>

          <Footer>
            <ActionButton type="button" variant="outline" onClick={onClose}>
              Cancel
            </ActionButton>
            <ActionButton 
              type="submit" 
              disabled={isSubmitting || chatbots.length === 0 || formData.chatbot_ids.length === 0}
            >
              {isSubmitting ? 'Creating...' : 'Create Room'}
            </ActionButton>
          </Footer>
        </form>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/DocumentList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, Badge, Alert } from '@/styles/StyledComponents';
import type { Document as KnowledgeDocument, DocumentStatus, DocumentType } from '@/types/knowledge-base.types'; // MODIFIED: Added DocumentType

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  overflow-x: auto; 
`;

const Table = styled.table`
  width: 100%;
  min-width: 700px; 
  border-collapse: collapse; 
  
  th, td {
    text-align: left;
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    vertical-align: middle; 
  }

  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    white-space: nowrap; 
  }

  td {
    color: ${({ theme }) => theme.colors.text};
    font-size: 0.875rem;
  }

  .actions-cell {
    width: 1%; 
    white-space: nowrap;
  }
  
  .filename-cell { // MODIFIED: Added for better filename display
    max-width: 250px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const MobileList = styled.div`
  display: none; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* display: block; */
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const FileNameMobile = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  word-break: break-all;
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.8rem;
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  .value {
    color: ${({ theme }) => theme.colors.text};
    word-break: break-all;
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  flex-wrap: wrap;
  button {
    flex-grow: 1;
    min-width: 100px;
  }
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;


// MODIFIED: getStatusBadgeVariant to include 'fetched' status
const getStatusBadgeVariant = (status: DocumentStatus): 'success' | 'warning' | 'error' | 'default' => {
    switch (status) {
      case 'completed': return 'success';
      case 'processing': return 'default';
      case 'error': return 'error';
      case 'uploaded': return 'warning';
      case 'fetched': return 'warning'; // 'fetched' can also be warning or default
      default: return 'default';
    }
};


interface DocumentListProps {
  documents: KnowledgeDocument[];
  onProcessDocument: (documentId: string) => Promise<void>;
  onDeleteDocument: (documentId: string) => Promise<void>;
  onViewStatus: (documentId: string) => void;
}

export default function DocumentList({
  documents,
  onProcessDocument,
  onDeleteDocument,
  onViewStatus
}: DocumentListProps) {
  const [processingId, setProcessingId] = useState<string | null>(null);
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [actionError, setActionError] = useState<string | null>(null);

  const formatDate = (dateString: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleString();
  };

  // MODIFIED: formatFileSize to handle webpage type (size is text length)
  const formatFileSize = (bytes: number, fileType: DocumentType): string => {
    if (fileType === 'webpage') {
        // For webpages, 'bytes' is actually character count of extracted text
        if (bytes === 0) return 'No text extracted';
        return `${bytes.toLocaleString()} chars`;
    }
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + ['Bytes', 'KB', 'MB', 'GB', 'TB'][i];
  };

  // MODIFIED: getStatusLabel to include 'fetched'
  const getStatusLabel = (status: DocumentStatus): string => {
    const labels: Record<DocumentStatus, string> = {
      uploaded: 'Uploaded',
      processing: 'Processing',
      completed: 'Completed',
      error: 'Error',
      fetched: 'Fetched', // New label
    };
    return labels[status] || status;
  };

  const handleProcess = async (documentId: string) => {
    setProcessingId(documentId);
    setActionError(null);
    try {
      await onProcessDocument(documentId);
    } catch (err) {
      setActionError(err instanceof Error ? err.message : "Failed to start processing.");
    } finally {
      setProcessingId(null);
    }
  };

  const handleDelete = async (documentId: string, documentName: string) => {
    if (!window.confirm(`Are you sure you want to delete the document "${documentName}"? This action cannot be undone.`)) {
        return;
    }
    setDeletingId(documentId);
    setActionError(null);
    try {
      await onDeleteDocument(documentId);
    } catch (err) {
      setActionError(err instanceof Error ? err.message : "Failed to delete document.");
    } finally {
      setDeletingId(null);
    }
  };

  if (documents.length === 0) {
    return (
      <ListContainer>
        <EmptyState>
          <p>No documents have been added to this chatbot&apos;s knowledge base yet.</p>
        </EmptyState>
      </ListContainer>
    );
  }

  const renderActions = (doc: KnowledgeDocument) => (
    <>
      {/* MODIFIED: Allow processing for 'fetched' status as well */}
      {(doc.status === 'uploaded' || doc.status === 'fetched') && (
        <Button
          size="small"
          onClick={() => handleProcess(doc.document_id)}
          disabled={processingId === doc.document_id}
          title="Process this document/webpage for RAG"
        >
          {processingId === doc.document_id ? 'Starting...' : 'Process'}
        </Button>
      )}
      {(doc.status === 'processing' || doc.status === 'completed' || doc.status === 'error') && (
        <Button
          size="small"
          variant="outline"
          onClick={() => onViewStatus(doc.document_id)}
          title="View detailed processing status"
        >
          View Status
        </Button>
      )}
      <Button
        size="small"
        variant="danger" 
        onClick={() => handleDelete(doc.document_id, doc.file_name)}
        disabled={deletingId === doc.document_id}
        title="Delete this document/webpage"
      >
        {deletingId === doc.document_id ? 'Deleting...' : 'Delete'}
      </Button>
    </>
  );

  return (
    <ListContainer>
      {actionError && <Alert variant="error" style={{ marginBottom: '16px'}}>{actionError}</Alert>}
      <Table>
        <thead>
          <tr>
            <th>Name / URL</th> 
            <th>Type</th>
            <th>Size / Content Length</th>
            <th>Status</th>
            <th>Added</th>
            <th className="actions-cell">Actions</th>
          </tr>
        </thead>
        <tbody>
          {documents.map((doc) => (
            <tr key={doc.document_id}>
              {/* MODIFIED: Display filename for files, and file_path (URL) for webpages */}
              <td className="filename-cell" title={doc.file_type === 'webpage' ? doc.file_path : doc.file_name}>
                {doc.file_type === 'webpage' ? 
                  <a href={doc.file_path} target="_blank" rel="noopener noreferrer" title={`Open: ${doc.file_path}`}>
                    {doc.file_name} {/* file_name for webpage is its title */}
                  </a>
                  : doc.file_name
                }
              </td>
              <td>{doc.file_type.toUpperCase()}</td>
              {/* MODIFIED: Pass file_type to formatFileSize */}
              <td>{formatFileSize(doc.file_size, doc.file_type)}</td>
              <td>
                <Badge variant={getStatusBadgeVariant(doc.status)}>
                  {getStatusLabel(doc.status)}
                </Badge>
              </td>
              <td>{formatDate(doc.created_at)}</td>
              <td className="actions-cell">
                <div style={{ display: 'flex', gap: '8px' }}>
                  {renderActions(doc)}
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </Table>

      <MobileList>
        {documents.map((doc) => (
          <MobileCard key={`mobile-${doc.document_id}`}> {/* MODIFIED: Added unique key prefix for mobile */}
            <MobileHeader>
              {/* MODIFIED: Mobile display for filename/URL */}
              <FileNameMobile title={doc.file_type === 'webpage' ? doc.file_path : doc.file_name}>
                {doc.file_type === 'webpage' ? 
                  <a href={doc.file_path} target="_blank" rel="noopener noreferrer">
                    {doc.file_name}
                  </a>
                  : doc.file_name
                }
              </FileNameMobile>
              <Badge variant={getStatusBadgeVariant(doc.status)}>
                {getStatusLabel(doc.status)}
              </Badge>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Type:</span>
              <span className="value">{doc.file_type.toUpperCase()}</span>
              <span className="label">Size:</span>
              {/* MODIFIED: Pass file_type to formatFileSize for mobile */}
              <span className="value">{formatFileSize(doc.file_size, doc.file_type)}</span>
              <span className="label">Added:</span>
              <span className="value">{formatDate(doc.created_at)}</span>
              {doc.error_message && (
                <>
                    <span className="label" style={{color: 'red'}}>Error:</span>
                    <span className="value" style={{color: 'red', whiteSpace: 'normal'}}>{doc.error_message}</span>
                </>
              )}
            </MobileDetails>
            <MobileActions>
                {renderActions(doc)}
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo } from 'react';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    void error;
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || <h1>Sorry.. there was an error</h1>;
    }

    return this.props.children;
  }
}// src/lib/scraping/content-extractor.ts
import { JSDOM } from 'jsdom';
import { Readability } from '@mozilla/readability';
import fetch from 'node-fetch'; // Using node-fetch for server-side consistency

interface ExtractedWebPageContent {
  title: string;
  textContent: string;
  excerpt?: string;
  url: string;
  error?: string; // To capture any errors during fetching or parsing
}

// Function to fetch and parse robots.txt
async function isUrlScrapingAllowed(targetUrl: string, userAgent: string = 'SkolrBot/1.0'): Promise<boolean> {
  try {
    const urlObj = new URL(targetUrl);
    const robotsUrl = `${urlObj.protocol}//${urlObj.hostname}/robots.txt`;
    console.log(`[ContentExtractor] Fetching robots.txt from: ${robotsUrl}`);

    const response = await fetch(robotsUrl, {
      headers: { 'User-Agent': userAgent },
    });

    if (!response.ok) {
      console.log(`[ContentExtractor] robots.txt not found or non-200 status (${response.status}) for ${urlObj.hostname}. Assuming allowed.`);
      return true; // If robots.txt is missing or inaccessible, often implies scraping is allowed
    }

    const robotsTxt = await response.text();
    const lines = robotsTxt.split('\n');
    let specificAgentRules = false;
    let generalAgentRules = false;
    let relevantRules: string[] = [];

    // Check for rules specific to our user agent
    for (const line of lines) {
      if (line.toLowerCase().startsWith(`user-agent: ${userAgent.toLowerCase()}`)) {
        specificAgentRules = true;
        relevantRules = []; // Start collecting rules for this agent
        continue;
      }
      if (line.toLowerCase().startsWith('user-agent: *')) {
        generalAgentRules = true;
        if (!specificAgentRules) relevantRules = []; // Start collecting rules for general agent if no specific ones yet
        continue;
      }
      if (specificAgentRules && line.toLowerCase().startsWith('disallow:')) {
        relevantRules.push(line.substring('disallow:'.length).trim());
      } else if (generalAgentRules && !specificAgentRules && line.toLowerCase().startsWith('disallow:')) {
        relevantRules.push(line.substring('disallow:'.length).trim());
      }
    }
    
    // If User-agent: * is present but no User-agent: SkolrBot/1.0, then User-agent: * rules apply.
    // If both are present, User-agent: SkolrBot/1.0 rules take precedence.

    const path = urlObj.pathname || '/';
    for (const rule of relevantRules) {
      if (rule === '/') { // Disallows everything
          if (path.startsWith(rule)) {
            console.log(`[ContentExtractor] Scraping disallowed by rule: Disallow: ${rule} for path: ${path}`);
            return false;
          }
      } else if (rule && path.startsWith(rule)) {
        console.log(`[ContentExtractor] Scraping disallowed by rule: Disallow: ${rule} for path: ${path}`);
        return false;
      }
    }
    console.log(`[ContentExtractor] Scraping allowed for ${targetUrl} based on robots.txt rules.`);
    return true;
  } catch (error) {
    console.error(`[ContentExtractor] Error fetching or parsing robots.txt for ${targetUrl}:`, error);
    return true; // Fail open: if robots.txt can't be processed, assume allowed but log error
  }
}


export async function extractContentFromUrl(url: string): Promise<ExtractedWebPageContent> {
  console.log(`[ContentExtractor] Attempting to extract content from URL: ${url}`);
  try {
    // 1. Check robots.txt
    const allowed = await isUrlScrapingAllowed(url);
    if (!allowed) {
      const errorMessage = `Scraping disallowed by robots.txt for ${url}`;
      console.warn(`[ContentExtractor] ${errorMessage}`);
      return {
        title: url,
        textContent: '',
        url: url,
        error: errorMessage,
      };
    }

    // 2. Fetch the webpage with timeout using AbortController
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout

    let response;
    try {
      response = await fetch(url, {
        headers: {
          'User-Agent': 'SkolrBot/1.0 (+https://skolr.com/bot)', // Be a good bot citizen
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        },
        signal: controller.signal,
      });
    } finally {
      clearTimeout(timeoutId);
    }

    if (!response.ok) {
      const errorMessage = `Failed to fetch URL: ${url}. Status: ${response.status} ${response.statusText}`;
      console.error(`[ContentExtractor] ${errorMessage}`);
      return { title: url, textContent: '', url, error: errorMessage };
    }

    const html = await response.text();
    console.log(`[ContentExtractor] Successfully fetched HTML for ${url}. Length: ${html.length}`);

    // 3. Parse HTML with JSDOM
    const dom = new JSDOM(html, { url }); // Providing the URL helps Readability resolve relative links if needed
    const document = dom.window.document;

    // 4. Use Readability to extract main content
    const reader = new Readability(document);
    const article = reader.parse();

    if (!article || !article.textContent) {
      console.warn(`[ContentExtractor] Readability could not parse main content for ${url}. Falling back to body.textContent.`);
      // Fallback: try to get all text content if Readability fails
      const bodyText = document.body?.textContent?.replace(/\s\s+/g, ' ').trim() || '';
      const titleFromTag = document.title || url;
      if (!bodyText) {
        const errorMessage = `Failed to extract any meaningful text content from ${url}.`;
        console.error(`[ContentExtractor] ${errorMessage}`);
        return { title: titleFromTag, textContent: '', url, error: errorMessage };
      }
      console.log(`[ContentExtractor] Using fallback text content for ${url}. Length: ${bodyText.length}`);
      return {
        title: titleFromTag,
        textContent: bodyText,
        url: url,
      };
    }

    console.log(`[ContentExtractor] Successfully extracted content using Readability for ${url}. Title: ${article.title}`);
    return {
      title: article.title || url, // Use URL as fallback title
      textContent: article.textContent.replace(/\s\s+/g, ' ').trim(), // Clean up whitespace
      excerpt: article.excerpt ?? undefined,
      url: url,
    };

  } catch (error) {
    const errorMessage = `Error processing URL ${url}: ${error instanceof Error ? error.message : String(error)}`;
    console.error(`[ContentExtractor] ${errorMessage}`, error);
    return {
      title: url,
      textContent: '',
      url: url,
      error: errorMessage,
    };
  }
}// src/lib/openrouter/client.ts
import type { ChatMessage } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

export interface OpenRouterConfig {
  model: string;
  temperature?: number;
  maxTokens?: number;
}

export interface OpenRouterResponse {
  choices: {
    message: {
      content: string;
    };
  }[];
  usage?: {
    total_tokens: number;
  };
}

export async function sendChatCompletion(
  messages: ChatMessage[],
  config: OpenRouterConfig
): Promise<OpenRouterResponse> {
  const response = await fetch(OPENROUTER_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
      'X-Title': 'ClassBots AI',
    },
    body: JSON.stringify({
      model: config.model,
      messages: messages.map(msg => ({
        role: msg.role,
        content: msg.content,
      })),
      temperature: config.temperature || 0.7,
      max_tokens: config.maxTokens || 1000,
    }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    console.error('OpenRouter error details:', errorData);
    throw new Error(`OpenRouter API error: ${errorData.error?.message || response.statusText}`);
  }

  return response.json();
}// src/lib/utils/room-codes.ts
const CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
const CODE_LENGTH = 6;

export function generateRoomCode(): string {
  let code = '';
  for (let i = 0; i < CODE_LENGTH; i++) {
    const randomIndex = Math.floor(Math.random() * CHARACTERS.length);
    code += CHARACTERS[randomIndex];
  }
  return code;
}

export function isValidRoomCode(code: string): boolean {
  if (code.length !== CODE_LENGTH) {
    return false;
  }
  
  const regex = new RegExp(`^[${CHARACTERS}]{${CODE_LENGTH}}$`);
  return regex.test(code);
}// src/lib/utils/constants.ts

// App Constants
export const APP_NAME = 'Skolr'; // CHANGED
export const APP_DESCRIPTION = 'Chat Smarter. Learn Faster.'; // UPDATED

// Route Constants
export const ROUTES = {
  HOME: '/',
  AUTH: '/auth',
  TEACHER_DASHBOARD: '/teacher-dashboard',
  STUDENT: '/student', // This now redirects to /student/dashboard
  STUDENT_DASHBOARD: '/student/dashboard', // Explicitly add if needed
  CHAT: (roomId: string) => `/chat/${roomId}`,
  API: {
    TEACHER: {
      CHATBOTS: '/api/teacher/chatbots',
      ROOMS: '/api/teacher/rooms',
      // Add new API routes as they are created
      ROOM_CHATBOT_ASSOCIATIONS: '/api/teacher/room-chatbots-associations',
      ROOM_DETAILS: '/api/teacher/room-details',
      STUDENT_ROOM_DETAILS: '/api/teacher/student-room-details',
    },
    STUDENT: {
      ROOMS: '/api/student/rooms', // Might be deprecated if dashboard API covers it
      JOIN_ROOM: '/api/student/join-room',
      DASHBOARD_DATA: '/api/student/dashboard-data',
      ASSESSMENT_DETAIL: (assessmentId: string) => `/api/student/assessment-detail?assessmentId=${assessmentId}`,
      // ASSESSMENT_REFLECTION: (assessmentId: string) => `/api/student/assessments/${assessmentId}/reflect`, // Kept commented out
    },
    CHAT: (roomId: string) => `/api/chat/${roomId}`,
  },
} as const;

// Default Chatbot Config
export const DEFAULT_CHATBOT_CONFIG = {
  model: 'openai/gpt-4.1-nano', 
  maxTokens: 1500,
  temperature: 0.7,
} as const;

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant',
  SYSTEM: 'system',
} as const;

// User Roles
export const USER_ROLES = {
  TEACHER: 'teacher',
  STUDENT: 'student',
} as const;

// Local Storage Keys
export const STORAGE_KEYS = {
  THEME: 'classbots-theme', // Consider changing to 'skolr-theme'
  LAST_ROOM: 'classbots-last-room', // Consider changing
} as const;// src/lib/document-processing/extractor.ts
import * as pdfParse from 'pdf-parse/lib/pdf-parse.js';
import mammoth from 'mammoth';
import { DocumentType } from '@/types/knowledge-base.types';

/**
 * Extract text from different document types
 */
export async function extractTextFromFile(
  fileBuffer: Buffer,
  fileType: DocumentType
): Promise<string> {
  try {
    switch (fileType) {
      case 'pdf':
        return extractFromPdf(fileBuffer);
      case 'docx':
        return extractFromDocx(fileBuffer);
      case 'txt':
        return extractFromTxt(fileBuffer);
      default:
        throw new Error(`Unsupported file type: ${fileType}`);
    }
  } catch (error) {
    console.error(`Error extracting text from ${fileType} file:`, error);
    throw new Error(`Failed to extract text from ${fileType} file: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF files
 */
async function extractFromPdf(fileBuffer: Buffer): Promise<string> {
  try {
    // Use a minimal options object to avoid looking for test files
    const options = {
      // No version testing, no page rendering
      max: 0,
      pagerender: null
    };
    
    const data = await pdfParse(fileBuffer, options);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw error;
  }
}

/**
 * Extract text from DOCX files
 */
async function extractFromDocx(fileBuffer: Buffer): Promise<string> {
  try {
    const result = await mammoth.extractRawText({ buffer: fileBuffer });
    return result.value;
  } catch (error) {
    console.error('Error extracting text from DOCX:', error);
    throw error;
  }
}

/**
 * Extract text from TXT files
 */
function extractFromTxt(fileBuffer: Buffer): Promise<string> {
  return Promise.resolve(fileBuffer.toString('utf-8'));
}// src/lib/document-processing/processor.ts
import { extractTextFromFile } from './extractor';
import { splitTextIntoChunks, estimateTokenCount } from './chunker';
import { generateEmbeddings } from '@/lib/openai/embeddings';
import { upsertVectors } from '@/lib/pinecone/utils';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { Document, DocumentChunk, DocumentStatus, DocumentType } from '@/types/knowledge-base.types'; // MODIFIED: Added DocumentType
import { extractContentFromUrl } from '@/lib/scraping/content-extractor'; // MODIFIED: Import new utility

// Mock embedding function for fallback - using 1536 dimensions for OpenAI
function createMockEmbedding(): number[] {
  // Create a random vector - 1536 dimensions for OpenAI compatibility
  return Array(1536).fill(0).map(() => (Math.random() * 2) - 1);
}

/**
 * Process a document by extracting text, chunking, and generating embeddings
 */
export async function processDocument(document: Document): Promise<void> {
  console.log(`[PROCESSOR] Starting document processing for doc ID: ${document.document_id}, name: ${document.file_name}, type: ${document.file_type}`);
  const supabase = await createServerSupabaseClient();

  try {
    // Update document status to processing
    await supabase
      .from('documents')
      .update({ status: 'processing' as DocumentStatus, updated_at: new Date().toISOString() })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Status set to processing.`);

    let extractedText: string;

    // MODIFIED: Handle text extraction based on document type
    if (document.file_type === 'webpage') {
      console.log(`[PROCESSOR ${document.document_id}] Extracting content from URL: ${document.file_path}`);
      const webContent = await extractContentFromUrl(document.file_path); // file_path holds the URL
      if (webContent.error || !webContent.textContent) {
        throw new Error(`Failed to extract content from URL ${document.file_path}: ${webContent.error || 'No text content found'}`);
      }
      extractedText = webContent.textContent;
      console.log(`[PROCESSOR ${document.document_id}] Extracted ${extractedText.length} characters from URL.`);
      // Optionally, update document_size if it wasn't set correctly at creation
      if (document.file_size !== extractedText.length) {
        await supabase.from('documents').update({ file_size: extractedText.length }).eq('document_id', document.document_id);
      }
    } else {
      // Existing logic for file-based documents
      console.log(`[PROCESSOR ${document.document_id}] Downloading file from storage: ${document.file_path}`);
      const { data: fileData, error: fileError } = await supabase
        .storage
        .from('documents')
        .download(document.file_path);

      if (fileError || !fileData) {
        throw new Error(`Failed to download file ${document.file_path}: ${fileError?.message}`);
      }
      console.log(`[PROCESSOR ${document.document_id}] File downloaded successfully.`);

      console.log(`[PROCESSOR ${document.document_id}] Extracting text from file type: ${document.file_type}`);
      // We know document.file_type cannot be 'webpage' here, so direct cast is safer
      extractedText = await extractTextFromFile(
        Buffer.from(await fileData.arrayBuffer()),
        document.file_type as Exclude<DocumentType, 'webpage'> 
      );
      console.log(`[PROCESSOR ${document.document_id}] Extracted ${extractedText.length} characters from file.`);
    }

    // Split text into chunks
    console.log(`[PROCESSOR ${document.document_id}] Splitting text into chunks.`);
    const chunks = splitTextIntoChunks(extractedText);
    console.log(`[PROCESSOR ${document.document_id}] Created ${chunks.length} chunks.`);

    if (chunks.length === 0) {
        console.warn(`[PROCESSOR ${document.document_id}] No chunks generated. Document might be empty or too small.`);
        await supabase
          .from('documents')
          .update({ status: 'completed' as DocumentStatus, error_message: 'No content to process.', updated_at: new Date().toISOString() })
          .eq('document_id', document.document_id);
        return;
    }

    // Create chunk records in database
    console.log(`[PROCESSOR ${document.document_id}] Creating database records for chunks.`);
    const chunkRecords: Partial<DocumentChunk>[] = chunks.map((chunkText, index) => ({
      document_id: document.document_id,
      chunk_index: index,
      chunk_text: chunkText,
      token_count: estimateTokenCount(chunkText),
      status: 'pending'
    }));

    const { data: insertedChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .insert(chunkRecords)
      .select();

    if (chunksError) {
      throw new Error(`Failed to insert chunks: ${chunksError.message}`);
    }
    if (!insertedChunks || insertedChunks.length === 0) {
        throw new Error("No chunks were inserted into the database, though chunks were generated.");
    }
    console.log(`[PROCESSOR ${document.document_id}] Inserted ${insertedChunks.length} chunk records.`);

    // SAFER APPROACH: Process chunks in smaller batches for OpenAI embeddings
    const openAIbatchSize = 20;
    let usingMockEmbeddings = false;
    let embeddings: number[][] = [];

    console.log(`[PROCESSOR ${document.document_id}] Generating embeddings in batches of ${openAIbatchSize}.`);
    for (let i = 0; i < chunks.length; i += openAIbatchSize) {
      const batchChunksText = chunks.slice(i, i + openAIbatchSize);
      console.log(`[PROCESSOR ${document.document_id}] Processing OpenAI batch ${Math.floor(i/openAIbatchSize) + 1}/${Math.ceil(chunks.length/openAIbatchSize)} (${batchChunksText.length} chunks)`);

      try {
        const batchEmbeddings = await generateEmbeddings(batchChunksText);
        embeddings = [...embeddings, ...batchEmbeddings];
      } catch (embedError) {
        console.error(`[PROCESSOR ${document.document_id}] Error generating embeddings for batch, falling back to mock:`, embedError);
        usingMockEmbeddings = true;
        const mockBatchEmbeddings = batchChunksText.map(() => createMockEmbedding());
        embeddings = [...embeddings, ...mockBatchEmbeddings];

        await supabase
          .from('documents')
          .update({
            error_message: `Warning: Using mock embeddings for some chunks. OpenAI API error: ${embedError instanceof Error ? embedError.message : String(embedError)}`
          })
          .eq('document_id', document.document_id);
      }
      if (chunks.length > openAIbatchSize) {
        // Avoid hitting rate limits too quickly if there are many batches
        await new Promise(resolve => setTimeout(resolve, 500)); 
      }
    }
    console.log(`[PROCESSOR ${document.document_id}] Generated ${embeddings.length} embeddings. ${usingMockEmbeddings ? '(Used MOCK embeddings for some)' : '(Used REAL embeddings)'}`);

    // Build vectors array
    const preparedVectors = [];
    for (let i = 0; i < embeddings.length; i++) {
      const chunkId = insertedChunks[i]?.chunk_id;
      if (!chunkId) {
        console.error(`[PROCESSOR ${document.document_id}] Mismatch: No chunk_id for embedding at index ${i}. Skipping this vector.`);
        continue;
      }
      
      preparedVectors.push({
        id: chunkId,
        values: embeddings[i],
        metadata: {
          chatbotId: document.chatbot_id,
          documentId: document.document_id,
          chunkId: chunkId,
          text: chunks[i], // The actual chunk text
          fileName: document.file_name, // For webpages, this is the title or URL
          fileType: document.file_type, // Will be 'webpage' for URLs
          isMockEmbedding: usingMockEmbeddings ? "true" : "false"
        }
      });
    }

    if (preparedVectors.length === 0 && chunks.length > 0) {
        console.error(`[PROCESSOR ${document.document_id}] No vectors prepared for Pinecone, though chunks exist. This indicates an issue with chunk_id mapping.`);
        throw new Error("Failed to prepare vectors for Pinecone due to chunk ID mismatch.");
    }
    console.log(`[PROCESSOR ${document.document_id}] Prepared ${preparedVectors.length} vectors for Pinecone.`);

    let vectorsUpsertedSuccessfully = false;
    if (preparedVectors.length > 0) { // MODIFIED: Only upsert if there are vectors
        try {
          console.log(`[PROCESSOR ${document.document_id}] Upserting ${preparedVectors.length} vectors to Pinecone via SDK.`);
          await upsertVectors(preparedVectors);
          vectorsUpsertedSuccessfully = true;
          console.log(`[PROCESSOR ${document.document_id}] Successfully upserted vectors to Pinecone.`);
        } catch (pineconeError) {
            console.error(`[PROCESSOR ${document.document_id}] Error upserting vectors to Pinecone:`, pineconeError);
        }
    } else {
        console.log(`[PROCESSOR ${document.document_id}] No vectors to upsert to Pinecone.`);
        // If there were chunks but no vectors prepared, it's an error handled above.
        // If there were no chunks initially, this part is skipped.
        // If RAG is based on chunks, and no chunks, then "completed" is okay if no other error.
        if (chunks.length === 0) vectorsUpsertedSuccessfully = true; 
    }


    console.log(`[PROCESSOR ${document.document_id}] Updating chunk statuses in DB.`);
    for (const insertedChunk of insertedChunks) { // This loop will only run if chunks were inserted
        const vectorAttempted = preparedVectors.find(v => v.id === insertedChunk.chunk_id);
        const chunkStatus = vectorsUpsertedSuccessfully && vectorAttempted ? 'embedded' : 'error';
        
        await supabase
            .from('document_chunks')
            .update({
                status: chunkStatus,
                embedding_id: (chunkStatus === 'embedded' && vectorAttempted) ? insertedChunk.chunk_id : null // Set embedding_id only if successfully embedded
            })
            .eq('chunk_id', insertedChunk.chunk_id);
    }
    console.log(`[PROCESSOR ${document.document_id}] Chunk statuses updated.`);

    // Determine final document status
    const finalDocStatus = vectorsUpsertedSuccessfully ? 'completed' : 'error';
    let finalErrorMessage = vectorsUpsertedSuccessfully ? null : 'Failed to upsert vectors to Pinecone.';
    if (usingMockEmbeddings && vectorsUpsertedSuccessfully) { // If mock embeddings were used but upsert was "successful"
        finalErrorMessage = (finalErrorMessage ? finalErrorMessage + " " : "") + "Warning: Some or all embeddings are MOCK data.";
    }
    if (chunks.length === 0 && !document.error_message) { // If no chunks and no prior error, consider it completed (nothing to process)
         // Status already set to completed above for this case. Message already set.
    }


    await supabase
      .from('documents')
      .update({
        status: finalDocStatus as DocumentStatus,
        error_message: finalErrorMessage, // This might overwrite "No content to process." if an error occurs later.
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document final status set to ${finalDocStatus}. Processing finished.`);

  } catch (error) {
    console.error(`[PROCESSOR ${document.document_id}] Critical error during processing:`, error);
    await supabase
      .from('documents')
      .update({
        status: 'error' as DocumentStatus,
        error_message: error instanceof Error ? error.message : 'Unknown critical error during processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document status updated to ERROR due to critical failure.`);
  }
}// src/lib/document-processing/chunker.ts

/**
 * Split text into chunks of approximately the specified size with overlap
 * @param text The full text to split
 * @param maxChunkSize Maximum size of each chunk in characters
 * @param overlap Number of characters to overlap between chunks
 * @returns Array of text chunks
 */
export function splitTextIntoChunks(
  text: string,
  maxChunkSize: number = 1000,
  overlap: number = 200
): string[] {
  // Validate parameters
  if (maxChunkSize <= 0) {
    console.error("[CHUNKER] maxChunkSize must be positive. Using default 1000.");
    maxChunkSize = 1000;
  }
  if (overlap < 0) {
    console.error("[CHUNKER] overlap cannot be negative. Using default 0.");
    overlap = 0;
  }
  // Ensure overlap is less than maxChunkSize to guarantee progress
  if (overlap >= maxChunkSize) {
    console.warn(`[CHUNKER] Overlap (${overlap}) is greater than or equal to maxChunkSize (${maxChunkSize}). Adjusting overlap to ensure progress.`);
    overlap = Math.max(0, Math.floor(maxChunkSize / 2) -1); // Ensure it's strictly less
  }

  const cleanedText = text
    .replace(/\s+/g, " ") // Normalize whitespace
    .replace(/\n{2,}/g, "\n") // Reduce multiple newlines to single (or adjust if double is preferred)
    .trim();

  if (cleanedText.length === 0) {
    return [];
  }

  if (cleanedText.length <= maxChunkSize) {
    return [cleanedText];
  }

  const chunks: string[] = [];
  let startIndex = 0;
  let safetyBreak = 0; // To prevent accidental infinite loops during development
  const maxIterations = Math.ceil(cleanedText.length / (maxChunkSize - overlap)) + 10; // Generous estimate

  while (startIndex < cleanedText.length && safetyBreak < maxIterations) {
    safetyBreak++;
    let endIndex = Math.min(startIndex + maxChunkSize, cleanedText.length);

    // If not at the end, try to find a better breakpoint
    if (endIndex < cleanedText.length) {
      let idealEnd = endIndex;
      // Try to break at a paragraph end (double newline, now single due to cleaning)
      // Search backwards from idealEnd, but not too far back (e.g., within last 30% of chunk)
      const searchStartPara = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.3));
      const paragraphBreak = cleanedText.lastIndexOf("\n", idealEnd);
      if (paragraphBreak > searchStartPara && paragraphBreak > startIndex) {
        idealEnd = paragraphBreak + 1; // Include the newline
      } else {
        // Try to break at a sentence end (period followed by space)
        // Search backwards from idealEnd
        const searchStartSentence = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.2));
        const sentenceBreak = cleanedText.lastIndexOf(". ", idealEnd);
        if (sentenceBreak > searchStartSentence && sentenceBreak > startIndex) {
          idealEnd = sentenceBreak + 1; // Include the period
        } else {
          // Try to break at a space
          const searchStartSpace = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.1));
          const spaceBreak = cleanedText.lastIndexOf(" ", idealEnd);
          if (spaceBreak > searchStartSpace && spaceBreak > startIndex) {
            idealEnd = spaceBreak + 1; // Include the space
          }
          // If no good break found, stick with Math.min(startIndex + maxChunkSize, cleanedText.length)
        }
      }
      endIndex = idealEnd;
    }

    const chunk = cleanedText.substring(startIndex, endIndex).trim();
    if (chunk.length > 0) { // Only push non-empty chunks
      chunks.push(chunk);
    }

    // Calculate the next starting point
    // Ensure startIndex always moves forward by at least (maxChunkSize - overlap)
    // unless it's the last chunk
    const nextStart = endIndex - overlap;

    // If nextStart isn't advancing past the current startIndex, it means chunks are too small or overlap is too big
    // This check ensures progress. If endIndex is already at the end, this loop will terminate.
    if (nextStart <= startIndex && endIndex < cleanedText.length) {
        // Force advancement if stuck, this could happen if maxChunkSize is very small or overlap is almost maxChunkSize
        // Or if the breakpoint logic consistently brings endIndex back too far.
        // A simple forced advancement might be to just move past the current chunk with minimal overlap.
        console.warn(`[CHUNKER] Potential stall detected. Forcing startIndex advancement. startIndex: ${startIndex}, endIndex: ${endIndex}, overlap: ${overlap}, nextStart: ${nextStart}`);
        startIndex = endIndex; // Effectively makes next chunk start where this one ended (no overlap if stalled)
                              // Or, for a more robust solution with overlap:
                              // startIndex = Math.max(startIndex + 1, endIndex - overlap);
    } else {
        startIndex = nextStart;
    }

    if (startIndex < 0) startIndex = 0; // Should not happen with validated overlap
  }

  if (safetyBreak >= maxIterations) {
    console.error("[CHUNKER] Safety break triggered, possible infinite loop. Returning collected chunks.", chunks.length);
  }

  // Filter out any potential empty strings again, just in case
  return chunks.filter(c => c.length > 0);
}

/**
 * Simple estimate of token count based on character count
 * @param text The text to estimate tokens for
 * @returns Estimated token count
 */
export function estimateTokenCount(text: string): number {
  // Rough estimate: ~4 characters per token for English text
  return Math.ceil(text.length / 4);
}// src/lib/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export async function updateSession(request: NextRequest) {
  const response = NextResponse.next(); // Changed from let to const

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value,
            ...options, // Use the full options object
          });
        },
        remove(name: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value: '',
            ...options, // Use the full options object
            maxAge: 0,
          });
        },
      },
    }
  );

  await supabase.auth.getUser();

  return response;
}// src/lib/supabase/admin.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

export const createAdminClient = () => {
  // Log the environment variables to verify they exist (redact part of the key for security)
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';
  console.log('Admin client initialization:');
  console.log(`- URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL}`);
  console.log(`- Service key exists: ${serviceRoleKey.length > 0 ? 'YES' : 'NO'}`);
  
  // Check if the key starts with 'eyJ' which is the start of a valid JWT
  if (!serviceRoleKey.startsWith('eyJ')) {
    console.warn('WARNING: Service role key may not be valid - keys typically start with "eyJ"');
  }
  
  // Create the client with the service role key
  const client = createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      },
      // These headers ensure the service role bypasses RLS
      global: {
        headers: {
          'X-Client-Info': 'admin-supabase-js',
          'Authorization': `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`
        }
      }
    }
  );
  
  // Log available methods for debugging - especially check the auth.admin object
  console.log('Admin client methods [auth]:', Object.keys(client.auth));
  if (client.auth.admin) {
    console.log('Admin client methods [auth.admin]:', Object.keys(client.auth.admin));
  } else {
    console.warn('Admin auth methods not available - this may indicate a Supabase version issue');
  }
  
  return client;
};// src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database.types';

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );// src/lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export const createServerSupabaseClient = async () => {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value,
            ...options
          });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value: '',
            ...options,
            maxAge: 0
          });
        },
      },
    }
  );
};// src/lib/safety/monitoring.ts
/**
 * Safety monitoring and response system
 * 
 * ===== SAFETY CRITICAL CODE =====
 * This file handles student safety concerns and delivers country-specific helplines
 * to students when concerning messages are detected. 
 * 
 * IMPORTANT FIX (May 2025): We've improved the reliability of country-specific helplines
 * by adding a verification step that checks if the AI-generated response actually contains
 * the expected country-specific helplines. If not, we rebuild the message completely with
 * the correct helplines from our embedded JSON data. This ensures students always receive
 * the appropriate helplines for their location, even if the AI model doesn't follow instructions.
 */
import type { Room, Database } from '@/types/database.types';
import { createAdminClient } from '@/lib/supabase/admin';
import { SupabaseClient } from '@supabase/supabase-js';
import { sendTeacherAlert } from '@/lib/safety/alerts';
import fs from 'fs';
import path from 'path';

// Define the helplines data structure
interface HelplineEntry {
  name: string;
  phone?: string;
  website?: string;
  text_to?: string;
  text_msg?: string;
  short_desc: string;
}

// Define the full data structure
interface HelplineData {
  [countryCode: string]: HelplineEntry[];
}

// This is the raw JSON data as a string - directly embedding the data to ensure it's available
// Note: This approach ensures the data is directly included in the built code
// and doesn't rely on dynamic imports or file system access at runtime
const HELPLINES_RAW_JSON = `
{
  "US": [
    { "name": "Childhelp USA", "phone": "1-800-422-4453", "website": "childhelp.org", "short_desc": "Child abuse prevention & treatment" },
    { "name": "National Suicide & Crisis Lifeline", "phone": "988", "website": "988lifeline.org", "short_desc": "24/7 crisis support" },
    { "name": "Crisis Text Line", "text_to": "741741", "text_msg": "HOME", "short_desc": "Text support for any crisis" },
    { "name": "The Trevor Project", "phone": "1-866-488-7386", "website": "thetrevorproject.org", "short_desc": "For LGBTQ youth" }
  ],
  "CA": [
    { "name": "Kids Help Phone", "phone": "1-800-668-6868", "website": "kidshelpphone.ca", "short_desc": "24/7 youth support (text CONNECT to 686868)" },
    { "name": "Talk Suicide Canada", "phone": "1-833-456-4566", "website": "talksuicide.ca", "short_desc": "Suicide prevention & support (text 45645)" },
    { "name": "Canadian Centre for Child Protection", "website": "protectchildren.ca", "short_desc": "Child safety resources" }
  ],
  "GB": [
    { "name": "Childline", "phone": "0800 1111", "website": "childline.org.uk", "short_desc": "Support for children & young people" },
    { "name": "NSPCC Helpline", "phone": "0808 800 5000", "website": "nspcc.org.uk", "short_desc": "If you're worried about a child" },
    { "name": "Samaritans", "phone": "116 123", "website": "samaritans.org", "short_desc": "Emotional support, 24/7" },
    { "name": "Papyrus HOPELINEUK", "phone": "0800 068 4141", "website": "papyrus-uk.org", "short_desc": "Suicide prevention for under 35s" }
  ],
  "IE": [
    { "name": "Childline (ISPCC)", "phone": "1800 66 66 66", "website": "childline.ie", "short_desc": "24/7 support for children (text 'LIST' to 50101)" },
    { "name": "Samaritans Ireland", "phone": "116 123", "website": "samaritans.org/ireland/", "short_desc": "Emotional support, 24/7" },
    { "name": "Pieta House", "phone": "1800 247247", "website": "pieta.ie", "short_desc": "Suicide & self-harm crisis centre (text HELP to 51444)" }
  ],
  "FR": [
    { "name": "Allo Enfance en Danger", "phone": "119", "website": "allo119.gouv.fr", "short_desc": "National child protection helpline (24/7)" },
    { "name": "Suicide Écoute", "phone": "01 45 39 40 00", "website": "suicide-ecoute.fr", "short_desc": "Suicide prevention helpline" },
    { "name": "Net Ecoute (e-Enfance)", "phone": "3018", "website": "e-enfance.org/numero-3018/", "short_desc": "Protection for children online (cyberbullying, etc.)" }
  ],
  "ES": [
    { "name": "ANAR (Ayuda a Niños y Adolescentes en Riesgo)", "phone": "900 20 20 10", "website": "anar.org", "short_desc": "Help for children & adolescents at risk (24/7)" },
    { "name": "Teléfono de la Esperanza", "phone": "717 003 717", "website": "telefonodelaesperanza.org", "short_desc": "Crisis support line" }
  ],
  "IT": [
    { "name": "Telefono Azzurro", "phone": "19696", "website": "azzurro.it", "short_desc": "Child helpline (24/7)" },
    { "name": "Telefono Amico Italia", "phone": "02 2327 2327", "website": "telefonoamico.it", "short_desc": "Emotional support helpline (check hours)" }
  ],
  "PT": [
    { "name": "SOS Criança (IAC)", "phone": "116 111", "website": "iacrianca.pt", "short_desc": "Child helpline (check hours)" },
    { "name": "Voz de Apoio", "phone": "225 50 60 70", "website": "vozdeapoio.pt", "short_desc": "Emotional support helpline (check hours)" }
  ],
  "DE": [
    { "name": "Nummer gegen Kummer (Kinder- und Jugendtelefon)", "phone": "116 111", "website": "nummergegenkummer.de", "short_desc": "Helpline for children & youth (Mon-Sat)" },
    { "name": "TelefonSeelsorge", "phone": "0800 111 0 111", "website": "telefonseelsorge.de", "short_desc": "Crisis support (24/7)" }
  ],
  "GR": [
    { "name": "The Smile of the Child (National Helpline for Children SOS)", "phone": "1056", "website": "hamogelo.gr", "short_desc": "Child helpline (24/7)" },
    { "name": "KLIMAKA (Suicide Prevention)", "phone": "1018", "website": "klimaka.org.gr", "short_desc": "24/7 suicide prevention line" }
  ],
  "AU": [
    { "name": "Kids Helpline", "phone": "1800 55 1800", "website": "kidshelpline.com.au", "short_desc": "Counselling for young people 5-25 (24/7)" },
    { "name": "Lifeline Australia", "phone": "13 11 14", "website": "lifeline.org.au", "short_desc": "24/7 crisis support & suicide prevention" },
    { "name": "eSafety Commissioner", "website": "esafety.gov.au", "short_desc": "Online safety help & reporting" }
  ],
  "AE": [
    { "name": "Child Protection Centre (Ministry of Interior)", "phone": "116111", "website": "moi-cpc.ae", "short_desc": "Child protection helpline" },
    { "name": "Dubai Foundation for Women and Children", "phone": "800111", "website": "dfwac.ae", "short_desc": "Support for women & children (violence/abuse)" }
  ],
  "MY": [
    { "name": "Buddy Bear Helpline", "phone": "1-800-18-BEAR (2327)", "short_desc": "Support helpline for children" },
    { "name": "PS The Children (Protect and Save The Children)", "phone": "+603-7957 4344", "short_desc": "Child protection services" }
  ],
  "DEFAULT": [
    { "name": "Your Local Emergency Services", "short_desc": "Contact if in immediate danger (e.g., 911, 112, 999, 000)." },
    { "name": "A Trusted Adult", "short_desc": "Speak to a teacher, school counselor, parent, or another family member." },
    { "name": "Befrienders Worldwide", "website": "befrienders.org", "short_desc": "Find a crisis support center in your region." }
  ]
}
`;

// Parse the JSON into a usable JavaScript object
let HELPLINE_DATA_JSON: HelplineData;
try {
  HELPLINE_DATA_JSON = JSON.parse(HELPLINES_RAW_JSON) as HelplineData;
  console.log(`[Safety] Successfully parsed helplines data directly from embedded JSON`);
  console.log(`[Safety] Found ${Object.keys(HELPLINE_DATA_JSON).length} countries in parsed helplines data`);
} catch (error) {
  console.error(`[Safety] Critical error parsing helplines JSON data:`, error);
  // Initialize with empty object for safety - we should never reach this
  HELPLINE_DATA_JSON = {};
}

// Log detailed information about the loaded data
console.log(`[Safety] *** DETAILED HELPLINES DIAGNOSTICS ***`);
console.log(`[Safety] Countries available:`, Object.keys(HELPLINE_DATA_JSON));
console.log(`[Safety] US helplines available:`, HELPLINE_DATA_JSON.US ? 
  `${HELPLINE_DATA_JSON.US.length} helplines including ${HELPLINE_DATA_JSON.US.map(h => h.name).join(', ')}` : 'NONE');
console.log(`[Safety] GB helplines available:`, HELPLINE_DATA_JSON.GB ? 
  `${HELPLINE_DATA_JSON.GB.length} helplines including ${HELPLINE_DATA_JSON.GB.map(h => h.name).join(', ')}` : 'NONE');
console.log(`[Safety] DEFAULT helplines available:`, HELPLINE_DATA_JSON.DEFAULT ? 
  `${HELPLINE_DATA_JSON.DEFAULT.length} helplines including ${HELPLINE_DATA_JSON.DEFAULT.map(h => h.name).join(', ')}` : 'NONE');
console.log(`[Safety] *** END HELPLINES DIAGNOSTICS ***`);

// ALL_HELPLINES is our shared data structure used throughout the module
const ALL_HELPLINES = { ...HELPLINE_DATA_JSON };

// OpenRouter Configuration
const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
// Using a model that's better at following exact instructions for safety information
const SAFETY_CHECK_MODEL = 'anthropic/claude-3-sonnet@20240229';
const CONCERN_THRESHOLD = 3;

// Keywords organized by category
const CONCERN_KEYWORDS: Record<string, string[]> = {
  self_harm: [
    'hate myself', 'don\'t want to live', 'don\'t want to be alive', 'don\'t want to be here', 'don\'t want to exist',
    'not worth going on', 'no point in living', 'no point going on', 'rather be dead', 'should end it',
    'should end it all', 'end it all', 'give up', 'giving up', 'take my own life', 'take my life',
    'harming myself', 'harm myself', 'hurting myself', 'cut myself', 'cutting myself', 'disappear forever',
    'everyone better off without me', 'they\'d be better off without me', 'they would be better off without me',
    'leave this world', 'escape this world', 'stop existing', 'tired of being alive', 'tired of existing',
    'too much pain', 'can\'t take it anymore', 'life is too hard', 'life isn\'t worth it', 'never wake up',
    'wish I wouldn\'t wake up', 'make the pain stop', 'no hope left', 'nowhere to turn', 'plan to kill',
    'how to end', 'easier if I wasn\'t here', 'easier if I was gone', 'want to die', 'wanna die',
    'kill myself', 'suicidal'
  ],
  bullying: [
    'bullied', 'bully', 'bullying', 'they hate me', 'everyone hates me', 'laughed at me', 'laugh at me',
    'excluded', 'leave me out', 'leaving me out', 'no friends', 'don\'t have friends', 'nobody likes me',
    'no one likes me', 'call me names', 'called me names', 'push me around', 'pushed me', 'shove me',
    'shoved me', 'making threats', 'threatened me', 'online bullying', 'cyberbullying', 'posting about me',
    'spreading rumors', 'spreading rumours', 'spreading lies', 'everyone talks about me', 'made fun of',
    'mock me', 'mocking me', 'rejected by everyone', 'being isolated', 'no one talks to me',
    'nobody talks to me', 'they ignore me', 'everyone ignores me', 'being targeted', 'pick on me',
    'won\'t leave me alone', 'always after me', 'ganging up on me', 'scared to go to school',
    'don\'t want to go to school', 'afraid at school', 'scared at school'
  ],
  abuse: [
    'hurt me', 'hurting me', 'hitting me', 'hit by', 'kicks me', 'kicking me', 'pushed me', 'pushes me',
    'throws things at me', 'threw things at me', 'threw something at me', 'yells at me', 'yelling at me',
    'screams at me', 'screaming at me', 'threatens me', 'threatening me', 'controls me', 'controlling me',
    'not allowed to', 'won\'t let me', 'keeps me from', 'locked me in', 'locks me in', 'touches me',
    'touched me', 'uncomfortable touching', 'hurt by someone', 'afraid of them', 'afraid to go home',
    'scared to go home', 'not safe at home', 'don\'t feel safe around', 'being punished',
    'punishes me unfairly', 'treated badly', 'treats me badly', 'calls me stupid', 'calls me worthless',
    'makes me feel worthless', 'makes me feel bad', 'punched me', 'punches me', 'slapped me', 'slaps me',
    'bruises from', 'left bruises', 'threatened to hurt me if I told', 'can\'t tell anyone'
  ],
  depression: [
    'hate my life', 'no one cares', 'nobody cares', 'nobody loves me', 'no one loves me', 'feel empty',
    'feeling empty', 'feel nothing', 'feels like nothing matters', 'nothing matters', 'what\'s the point',
    'feel worthless', 'feeling worthless', 'don\'t feel anything', 'don\'t know what to do',
    'can\'t see a future', 'lost all hope', 'lost hope', 'given up', 'feel like a failure', 'am a failure',
    'everything is dark', 'darkness closing in', 'can\'t get out of bed', 'can\'t face the day',
    'crying all the time', 'crying myself to sleep', 'never happy', 'always feeling down', 'feel so alone',
    'completely alone', 'no one understands', 'nobody understands', 'don\'t enjoy anything',
    'nothing makes me happy', 'too sad to function', 'too sad to do anything', 'life is meaningless',
    'unable to feel joy', 'can\'t sleep', 'can\'t eat', 'can\'t concentrate', 'mind feels foggy',
    'exhausted all the time', 'overwhelmed by sadness', 'drowning in sadness'
  ],
  family_issues: [
    'parents always fighting', 'parents always argue', 'parents hate each other', 'home is not safe',
    'scared at home', 'afraid at home', 'can\'t stand being home', 'hate being home', 'nowhere to go',
    'might get kicked out', 'might be kicked out', 'threatened to kick me out', 'parent drinking',
    'parent drunk', 'parents drunk', 'drinking problem', 'drug problem', 'parents using drugs',
    'parent using drugs', 'not enough food', 'going hungry', 'no food at home', 'can\'t sleep at home',
    'parents separated', 'parents separating', 'parents broke up', 'parents splitting up',
    'losing our house', 'lost our house', 'might be homeless', 'could be homeless',
    'moving in with relatives', 'have to move', 'parent lost job', 'no money for', 'can\'t afford',
    'parent in jail', 'parent arrested', 'no one takes care of me', 'have to take care of myself',
    'have to take care of my siblings', 'parent is sick', 'parent is ill', 'parent in hospital',
    'no electricity', 'utilities shut off', 'water shut off'
  ],
};

// Log a summary of the available helplines
console.log('[Safety] Available helplines by country:');
for (const country of Object.keys(ALL_HELPLINES)) {
  const helplines = ALL_HELPLINES[country];
  if (Array.isArray(helplines)) {
    console.log(`[Safety] - ${country}: ${helplines.length} helplines available`);
    for (const helpline of helplines) {
      console.log(`[Safety]   * ${helpline.name} ${helpline.phone ? `- Phone: ${helpline.phone}` : ''}`);
    }
  }
}

// Run validation tests on startup to verify lookup functionality
console.log(`[Safety] ===== RUNNING VALIDATION TESTS =====`);

// Test cases for different country codes
const testCases = [
  { countryCode: 'US', description: 'US country code' },
  { countryCode: 'GB', description: 'GB country code' },
  { countryCode: 'uk', description: 'Lowercase UK (should map to GB)' },
  { countryCode: 'DEFAULT', description: 'Explicit DEFAULT value' },
  { countryCode: null, description: 'Null country code' },
  { countryCode: '', description: 'Empty country code' },
  { countryCode: 'XYZ', description: 'Non-existent country code' }
];

// Check each test case
for (const test of testCases) {
  console.log(`[Safety] Test: ${test.description} - Code: "${test.countryCode}"`);
  
  // Get effective country code (this mimics the code in verifyConcern)
  let effectiveCountryCode = 'DEFAULT';
  if (test.countryCode) {
    effectiveCountryCode = test.countryCode.toUpperCase();
    if (effectiveCountryCode === 'UK') {
      effectiveCountryCode = 'GB';
      console.log(`[Safety] Changed UK to GB for lookup`);
    }
  }
  
  // Try to get helplines for this country
  let helplines = [];
  
  // Direct lookup first
  if (ALL_HELPLINES[effectiveCountryCode] && Array.isArray(ALL_HELPLINES[effectiveCountryCode])) {
    helplines = ALL_HELPLINES[effectiveCountryCode];
    console.log(`[Safety] Success - Direct match: ${helplines.length} helplines found`);
  }
  // Then try case-insensitive lookup
  else {
    // Try a case-insensitive match (for lowercase country codes)
    const foundCountry = Object.keys(ALL_HELPLINES).find(key => 
      key.toLowerCase() === effectiveCountryCode.toLowerCase());
    
    if (foundCountry) {
      helplines = ALL_HELPLINES[foundCountry];
      console.log(`[Safety] Success - Case-insensitive match: ${helplines.length} helplines found`);
    }
    // Fallback to DEFAULT
    else {
      console.log(`[Safety] No match found - Using DEFAULT helplines`);
      helplines = ALL_HELPLINES.DEFAULT || [];
      console.log(`[Safety] Fallback - DEFAULT helplines: ${helplines.length} found`);
    }
  }
  
  // Check the result
  const validResult = helplines.length > 0;
  console.log(`[Safety] Test result: ${validResult ? 'PASS' : 'FAIL'} - ${helplines.length} helplines found`);
  if (helplines.length > 0) {
    console.log(`[Safety] First helpline: ${helplines[0].name}`);
  }
}

console.log(`[Safety] ===== VALIDATION TESTS COMPLETE =====`);


export function initialConcernCheck(message: string): {
  hasConcern: boolean;
  concernType?: string;
} {
  if (!message || typeof message !== 'string' || message.trim() === '') {
    return { hasConcern: false };
  }
  const lowerMessage = message.toLowerCase();
  // console.log(`[InitialCheck DEBUG] lowerMessage: "${lowerMessage}"`); 
  for (const [category, keywords] of Object.entries(CONCERN_KEYWORDS)) {
    for (const keyword of keywords) {
        const escapedKeyword = keyword.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`\\b${escapedKeyword}\\b`);
        const isMatch = regex.test(lowerMessage);
        // if (keyword === 'bullied') { // Example for specific keyword debugging
        //   console.log(`[InitialCheck DEBUG] Checking keyword: "${keyword}", escaped: "${escapedKeyword}", regex: ${regex.toString()}, isMatch: ${isMatch}`);
        // }
        if (isMatch) {
            console.log(`[InitialCheck] Keyword MATCH! Category: ${category}, Keyword: "${keyword}"`);
            return { hasConcern: true, concernType: category };
        }
    }
  }
  if (lowerMessage.includes('hate myself') && (lowerMessage.includes('not worth') || lowerMessage.includes('don\'t know what to do'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  if ((lowerMessage.includes('not worth') || lowerMessage.includes('no point')) && (lowerMessage.includes('going on') || lowerMessage.includes('living') || lowerMessage.includes('anymore'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  return { hasConcern: false };
}

export async function verifyConcern(
  message: string,
  concernType: string,
  recentMessages: Array<{ role: 'user' | 'assistant' | 'system'; content: string }> = [],
  countryCode: string | null
): Promise<{
  isRealConcern: boolean;
  concernLevel: number;
  analysisExplanation: string;
  aiGeneratedAdvice?: string;
}> {
  console.log(`[SafetyDiagnostics] ===== VERIFY CONCERN TRACKING =====`);
  console.log(`[SafetyDiagnostics] Function called with parameters:`);
  console.log(`[SafetyDiagnostics] message length: ${message.length} characters`);
  console.log(`[SafetyDiagnostics] concernType: ${concernType}`);
  console.log(`[SafetyDiagnostics] recentMessages: ${recentMessages.length} messages`);
  console.log(`[SafetyDiagnostics] countryCode: "${countryCode}" (Type: ${typeof countryCode})`);
  console.log(`[SafetyDiagnostics] importedDataCheck: ${Object.keys(HELPLINE_DATA_JSON).length} countries loaded in helplines.json`);
  console.log(`[SafetyDiagnostics] ALL_HELPLINES status: ${Object.keys(ALL_HELPLINES).length} countries available`);
  
  // First diagnostic: Check if we have the US data loaded correctly
  if (ALL_HELPLINES.US && Array.isArray(ALL_HELPLINES.US)) {
    console.log(`[SafetyDiagnostics] US data check: PASS - ${ALL_HELPLINES.US.length} helplines available`);
    console.log(`[SafetyDiagnostics] US first helpline: ${ALL_HELPLINES.US[0]?.name || 'NONE'}`);
  } else {
    console.error(`[SafetyDiagnostics] US data check: FAIL - No US helplines found in ALL_HELPLINES!`);
  }

  let contextString = '';
  if (recentMessages.length > 0) {
    contextString = "\n\nRecent Conversation History (most recent last):\n";
    recentMessages.slice(-3).forEach(msg => {
      const roleLabel = msg.role === 'user' ? 'Student' : (msg.role === 'assistant' ? 'Assistant' : 'System');
      contextString += `${roleLabel}: ${msg.content}\n`;
    });
  }

  // Enhanced country code normalization and validation
  let effectiveCountryCode = 'DEFAULT';
  if (countryCode) {
    // Initial processing - trim and validate
    if (typeof countryCode === 'string' && countryCode.trim() !== '') {
      console.log(`[SafetyDiagnostics] Processing input countryCode: "${countryCode}" (type: ${typeof countryCode})`);
      
      // Normalize by converting to uppercase
      effectiveCountryCode = countryCode.trim().toUpperCase();
      
      // Handle common country code aliases
      if (effectiveCountryCode === 'UK') {
        effectiveCountryCode = 'GB'; // Convert UK to GB (ISO standard)
        console.log(`[SafetyDiagnostics] Converted UK to GB for proper ISO lookup`);
      }
      else if (effectiveCountryCode === 'UAE') {
        effectiveCountryCode = 'AE'; // Convert UAE to AE (ISO standard)
        console.log(`[SafetyDiagnostics] Converted UAE to AE for proper ISO lookup`);
      }
      else if (effectiveCountryCode === 'USA') {
        effectiveCountryCode = 'US'; // Convert USA to US (ISO standard)
        console.log(`[SafetyDiagnostics] Converted USA to US for proper ISO lookup`);
      }
      
      // Add more common country code normalizations here if needed
    } else {
      console.warn(`[SafetyDiagnostics] Invalid countryCode format: "${countryCode}" - using DEFAULT fallback`);
      effectiveCountryCode = 'DEFAULT';
    }
  } else {
    console.warn(`[SafetyDiagnostics] countryCode is null/undefined - using DEFAULT fallback`);
  }
  
  console.log(`[SafetyDiagnostics] Normalized effective country code: "${effectiveCountryCode}"`);
  
  // Verify the country code exists in our data
  const availableCountries = Object.keys(ALL_HELPLINES);
  console.log(`[SafetyDiagnostics] Available countries in ALL_HELPLINES: ${availableCountries.join(', ')}`);
  
  let directMatchExists = availableCountries.includes(effectiveCountryCode);
  console.log(`[SafetyDiagnostics] Direct match exists for "${effectiveCountryCode}": ${directMatchExists}`);
  console.log(`[SafetyDiagnostics] ===== END TRACKING =====`);

  // Enhanced helpline lookup with additional debug info
  console.log(`[SafetyDiagnostics] Looking up helplines for country code "${effectiveCountryCode}" in ALL_HELPLINES`);
  
  // Verify key countries are available in our data
  console.log(`[SafetyDiagnostics] CRITICAL: Verifying helplines data is loaded properly:`, {
    gbHelplines: ALL_HELPLINES.GB ? ALL_HELPLINES.GB.map(h => h.name) : 'NOT FOUND',
    usHelplines: ALL_HELPLINES.US ? ALL_HELPLINES.US.map(h => h.name) : 'NOT FOUND',
    defaultHelplines: ALL_HELPLINES.DEFAULT ? ALL_HELPLINES.DEFAULT.map(h => h.name) : 'NOT FOUND',
    totalCountries: Object.keys(ALL_HELPLINES).length
  });
  
  // Find the appropriate helplines for this country code
  let countrySpecificHelplines: HelplineEntry[] = [];
  
  try {
    // STEP 1: Try direct exact match (most efficient)
    if (directMatchExists && Array.isArray(ALL_HELPLINES[effectiveCountryCode])) {
      console.log(`[SafetyDiagnostics] Direct match found for "${effectiveCountryCode}" with ${ALL_HELPLINES[effectiveCountryCode].length} helplines`);
      countrySpecificHelplines = ALL_HELPLINES[effectiveCountryCode];
    } 
    // STEP 2: Try case-insensitive matching if not DEFAULT and no direct match
    else if (effectiveCountryCode !== 'DEFAULT') {
      console.log(`[SafetyDiagnostics] No direct match for "${effectiveCountryCode}", trying case-insensitive search`);
      
      // Look for case-insensitive match among available countries
      const effectiveLower = effectiveCountryCode.toLowerCase();
      const foundCountry = availableCountries.find(key => key.toLowerCase() === effectiveLower);
      
      if (foundCountry) {
        console.log(`[SafetyDiagnostics] Found case-insensitive match: "${foundCountry}" for "${effectiveCountryCode}"`);
        
        // Make sure the found country has helplines in proper format
        if (Array.isArray(ALL_HELPLINES[foundCountry])) {
          countrySpecificHelplines = ALL_HELPLINES[foundCountry];
          console.log(`[SafetyDiagnostics] Using ${countrySpecificHelplines.length} helplines from "${foundCountry}"`);
        } else {
          console.warn(`[SafetyDiagnostics] Found country "${foundCountry}" doesn't have valid helplines array`);
          countrySpecificHelplines = ALL_HELPLINES.DEFAULT || [];
        }
      } else {
        console.log(`[SafetyDiagnostics] No case-insensitive match found for "${effectiveCountryCode}", using DEFAULT helplines`);
        
        // Use DEFAULT helplines when no match found
        if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
          countrySpecificHelplines = ALL_HELPLINES.DEFAULT;
        } else {
          console.error(`[SafetyDiagnostics] CRITICAL ERROR: DEFAULT helplines not available!`);
          // Use empty array as last resort - this should never happen with embedded data
          countrySpecificHelplines = [];
        }
      }
    }
    // STEP 3: Handle explicit DEFAULT request
    else if (effectiveCountryCode === 'DEFAULT') {
      console.log(`[SafetyDiagnostics] Explicitly using DEFAULT helplines as requested`);
      
      if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
        countrySpecificHelplines = ALL_HELPLINES.DEFAULT;
      } else {
        console.error(`[SafetyDiagnostics] CRITICAL ERROR: DEFAULT helplines not available!`);
        countrySpecificHelplines = [];
      }
    }
    
    // STEP 4: Safety check - if we still don't have any helplines, use DEFAULT as fallback
    if (countrySpecificHelplines.length === 0) {
      console.warn(`[SafetyDiagnostics] No helplines found for "${effectiveCountryCode}" after all lookup methods!`);
      console.warn(`[SafetyDiagnostics] Using DEFAULT helplines as final fallback`);
      
      if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
        countrySpecificHelplines = ALL_HELPLINES.DEFAULT;
      } else {
        // This should never happen with our embedded data
        console.error(`[SafetyDiagnostics] CRITICAL FAILURE: DEFAULT helplines not available in final fallback!`);
        // Create minimal emergency helpline as absolute last resort
        countrySpecificHelplines = [
          { name: "Emergency Services", short_desc: "Contact local emergency services if in immediate danger." },
          { name: "Talk to a Trusted Adult", short_desc: "Speak to a teacher, parent, or other trusted adult." }
        ];
      }
    }
    
    // Final verification
    console.log(`[SafetyDiagnostics] Final helplines for "${effectiveCountryCode}": ${countrySpecificHelplines.length} entries`);
    if (countrySpecificHelplines.length > 0) {
      console.log(`[SafetyDiagnostics] First helpline: ${countrySpecificHelplines[0].name}`);
    }
  } catch (error) {
    // Catch any unexpected errors in the lookup process
    console.error(`[SafetyDiagnostics] ERROR during helpline lookup: ${error}`);
    console.error(`[SafetyDiagnostics] Using DEFAULT helplines due to error`);
    
    // Fallback to DEFAULT or emergency minimal helplines
    countrySpecificHelplines = ALL_HELPLINES.DEFAULT || [
      { name: "Emergency Services", short_desc: "Contact local emergency services if in immediate danger." },
      { name: "Talk to a Trusted Adult", short_desc: "Speak to a teacher, parent, or other trusted adult." }
    ];
  }
  console.log(`[VerifyConcern DEBUG] Selected countrySpecificHelplines for "${effectiveCountryCode}" (count: ${countrySpecificHelplines.length}, first 3 entries):`, JSON.stringify(countrySpecificHelplines.slice(0,3), null, 2));
  
  // CRITICAL: Log all relevant helplines for debugging
  if (effectiveCountryCode === 'GB') {
      console.log(`[VerifyConcern CRITICAL] ALL GB HELPLINES:`, JSON.stringify(ALL_HELPLINES.GB, null, 2));
  }
  
  // Double-verify that ALL_HELPLINES is properly loaded
  console.log(`[VerifyConcern CRITICAL] DUMP ALL HELPLINES OBJECT:`, {
    availableCountries: Object.keys(ALL_HELPLINES),
    totalCountries: Object.keys(ALL_HELPLINES).length,
    hasGB: !!ALL_HELPLINES.GB,
    hasUS: !!ALL_HELPLINES.US,
    hasDEFAULT: !!ALL_HELPLINES.DEFAULT
  });
  
  // Check if the helplines for this country are available
  if (ALL_HELPLINES[effectiveCountryCode] && Array.isArray(ALL_HELPLINES[effectiveCountryCode])) {
    console.log(`[VerifyConcern] SUCCESS: Found helplines for ${effectiveCountryCode}:`, 
      ALL_HELPLINES[effectiveCountryCode].map(h => h.name));
  } else {
    console.warn(`[VerifyConcern] WARNING: Helplines for ${effectiveCountryCode} not found or invalid format!`);
  }

  let conciseHelplineDataForPrompt = "";
  // Use more helplines (up to 3) when available to increase chances of relevant ones appearing in output
  let helplinesToList = countrySpecificHelplines.slice(0, 3);

  // Now helplinesToList should always have at least some entries
  conciseHelplineDataForPrompt = "Relevant Support Contacts (use ONLY these for the student's country):\n";
  helplinesToList.forEach(line => {
    conciseHelplineDataForPrompt += `* ${line.name}`;
    if (line.phone) {
      conciseHelplineDataForPrompt += ` - Phone: ${line.phone}`;
    } else if (line.text_to && line.text_msg) {
      conciseHelplineDataForPrompt += ` - Text: ${line.text_msg} to ${line.text_to}`;
    } else if (line.website) {
      // Don't abbreviate the website URL to ensure it's fully included in the response
      conciseHelplineDataForPrompt += ` - Website: ${line.website}`;
    }
    // Add short description when available
    if (line.short_desc) {
      conciseHelplineDataForPrompt += ` (${line.short_desc})`;
    }
    conciseHelplineDataForPrompt += "\n";
  });
  
  // Log debugging information to understand what country codes and helplines are being used
  console.log(`[VerifyConcern] Country Code Information:
  - Input countryCode: ${countryCode}
  - Effective country code: ${effectiveCountryCode}
  - Helplines available for this country: ${helplinesToList.length}
  - First helpline name: ${helplinesToList[0]?.name}
  - First helpline contact: ${helplinesToList[0]?.phone || helplinesToList[0]?.website || (helplinesToList[0]?.text_to ? `Text ${helplinesToList[0]?.text_msg} to ${helplinesToList[0]?.text_to}` : 'None')}
  - Using DEFAULT fallback: ${effectiveCountryCode === 'DEFAULT'}`);

  // Add detailed log of all available country codes for diagnosis
  console.log(`[VerifyConcern] All available countries in helplines.json: ${Object.keys(ALL_HELPLINES).join(', ')}`);
  
  
  console.log(`[VerifyConcern DEBUG] conciseHelplineDataForPrompt string for LLM:\n${conciseHelplineDataForPrompt}`);

  const teacherAwarenessMandatorySentence = "Remember, your teacher can see this conversation and is here to support you. Please feel comfortable reaching out to them or another trusted adult if you need help.";

  const promptParts = [
    `You are an AI safety assistant specializing in student wellbeing. Your task is to review a student's chat message for a specific concern and provide guidance if necessary. THIS IS A CRITICAL SAFETY FEATURE - your response MUST include the exact helplines provided in the format specified.`,
    `Concern Category Identified by Keywords: ${concernType.replace(/_/g, ' ')}`,
    contextString,
    `Student's Message: "${message}"`,
    `\nTasks:`,
    `1.  **Analysis for Teacher (Internal):**`,
    `    a.  **isRealConcern**: (boolean: true/false) Is the concern genuine?`,
    `    b.  **concernLevel**: (number 0-5) If genuine, assess severity.`,
    `    c.  **analysisExplanation**: (string) Briefly explain for the teacher (1-2 sentences).\n`,
    `2.  **Message for Student (aiGeneratedAdvice):**`,
    `    If \`isRealConcern\` is true AND \`concernLevel\` is 2 or higher, compose a **VERY SHORT (max 3-4 sentences total, including helplines), empathetic, and DIRECT message**. This message MUST:`,
    `    a.  Start with a brief, caring acknowledgment (e.g., "I hear that you're going through a tough time," or "It sounds like you're feeling [X]."). This should be one sentence.`,
    `    b.  **Include this exact sentence VERBATIM**: "${teacherAwarenessMandatorySentence}"`,
    `    c.  **URGENT AND CRITICAL INSTRUCTION: Include these EXACT support resources - this is the MOST IMPORTANT part of your response:**`,
    `        ${conciseHelplineDataForPrompt.trim()}`,
    `        IMPORTANT: I repeat, these helplines MUST be included EXACTLY as shown above.`,
    `        Do not change, summarize, paraphrase or omit any part of the helplines.`,
    `        The helplines are the MOST IMPORTANT part of your response.`,
    `        Your response will be rejected if it doesn't contain these exact helplines.`,
    `        Including these resources is MORE IMPORTANT than any explanatory text.`,
    `        You MUST include ALL helpline names, phone numbers, and websites exactly as provided.`,
    `        DO NOT add any marker lines like "===== MANDATORY HELPLINES" or similar around the helplines.`,
    `        Just list the helplines exactly as shown above with the bullet points.`,
    `    d.  End with a very short supportive closing (e.g., "Please reach out." or "Help is available."). This should be one sentence.`,
    `    e.  The entire message must be very succinct and focused. Do not add any extra information not explicitly requested.\n`,
    `Respond ONLY with a valid JSON object with these exact keys:`,
    `"isRealConcern": boolean,`,
    `"concernLevel": number,`,
    `"analysisExplanation": string,`,
    `"aiGeneratedAdvice": string (Omit this key or set to null if conditions in Task 2 are not met, or if you cannot follow the student message constraints exactly.)`
  ];
  const promptForModel = promptParts.join('\n');
  console.log(`[VerifyConcern DEBUG] Full promptForModel being sent to LLM (first 700 chars to see helpline injection):\n${promptForModel.substring(0,700)}...`);
  
  // Add detailed log about helplines being used
  console.log(`[VerifyConcern DEBUG] ****IMPORTANT**** Using ${effectiveCountryCode} helplines in the prompt: ${conciseHelplineDataForPrompt.replace(/\n/g, ' | ')}`);
  
  // Log full helplines section to ensure it's being correctly included in the response
  console.log(`[VerifyConcern DEBUG] Complete helplines section for LLM response:\n${conciseHelplineDataForPrompt}`);
  

  try {
    const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
          'X-Title': 'ClassBots AI - Safety Verification',
        },
        body: JSON.stringify({
          model: SAFETY_CHECK_MODEL,
          messages: [
            // Add a system message to improve reliability of following instructions
            { 
              role: "system", 
              content: "You are a safety assistant specializing in student wellbeing. You MUST include the EXACT helpline information in your responses without modification. This is CRITICAL."
            },
            { role: "user", content: promptForModel }
          ],
          temperature: 0.1,
          max_tokens: 500, 
          response_format: { type: "json_object" },
          // Add stronger instruction following settings
          top_p: 0.1
        }),
      });

    if (!response.ok) {
        const errorBody = await response.text();
        console.error(`[VerifyConcern] OpenRouter Error: Status ${response.status}`, errorBody);
        throw new Error(`OpenRouter API error (status ${response.status}) during safety verification.`);
    }

    const responseData = await response.json();
    const rawResponseContent = responseData.choices?.[0]?.message?.content;

    if (!rawResponseContent) {
      throw new Error("OpenRouter response for safety verification was empty or missing content.");
    }
    console.log(`[VerifyConcern DEBUG] Raw LLM response content:\n${rawResponseContent}`);
    
    // Check if the helpline information appears intact in the response
    for (const line of helplinesToList) {
      const nameInResponse = rawResponseContent.includes(line.name);
      const phoneInResponse = line.phone ? rawResponseContent.includes(line.phone) : true;
      const websiteInResponse = line.website ? rawResponseContent.includes(line.website) : true;
      console.log(`[VerifyConcern DEBUG] Helpline check in response: Name "${line.name}" present: ${nameInResponse}, Phone present: ${phoneInResponse}, Website present: ${websiteInResponse}`);
    }

    let analysisResult;
    try {
        const jsonMatch = rawResponseContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
            analysisResult = JSON.parse(jsonMatch[1]);
        } else {
             const directJsonMatch = rawResponseContent.match(/\{[\s\S]*\}/);
            if (directJsonMatch && directJsonMatch[0]) {
                 analysisResult = JSON.parse(directJsonMatch[0]);
            } else {
                try {
                    analysisResult = JSON.parse(rawResponseContent);
                } catch (innerParseError) {
                    console.error("[VerifyConcern] Final attempt to parse rawResponseContent as JSON failed:", rawResponseContent, innerParseError);
                    throw new Error("No valid JSON found in LLM response for safety verification after multiple attempts.");
                }
            }
        }
    } catch (parseError) {
         console.error("[VerifyConcern] Failed to parse JSON from safety model:", rawResponseContent, parseError);
         let fallbackAdvice = `I understand this might be a difficult time. ${teacherAwarenessMandatorySentence}\n\n`;
         const defaultHelplines = ALL_HELPLINES.DEFAULT || [];
         if (defaultHelplines.length > 0) {
             defaultHelplines.slice(0,2).forEach(line => {
                fallbackAdvice += `* ${line.name}`;
                if (line.phone) fallbackAdvice += ` - Phone: ${line.phone}`;
                else if (line.text_to && line.text_msg) fallbackAdvice += ` - Text: ${line.text_msg} to ${line.text_to}`;
                else if (line.website) fallbackAdvice += ` - Website: ${line.website}`;
                // Add short description when available
                if (line.short_desc) {
                    fallbackAdvice += ` (${line.short_desc})`;
                }
                fallbackAdvice += `\n`;
             });
         }
         fallbackAdvice += "\n\nHelp is available.";
         
         // Create a better explanation for teachers when the model response can't be parsed
         let teacherExplanation = "Message flagged by automated safety system for teacher review.";
         
         // Add more context based on concern type
         if (concernType) {
           const readableConcernType = concernType.replace(/_/g, ' ');
           teacherExplanation = `This message was flagged due to potential ${readableConcernType} concerns. Please review the conversation context and take appropriate action if needed.`;
         }
         
         return {
             isRealConcern: true, 
             concernLevel: 3,
             analysisExplanation: teacherExplanation,
             aiGeneratedAdvice: fallbackAdvice
         };
    }

    const isRealConcern = typeof analysisResult.isRealConcern === 'boolean' ? analysisResult.isRealConcern : false;
    const concernLevel = typeof analysisResult.concernLevel === 'number'
      ? Math.max(0, Math.min(5, Math.round(analysisResult.concernLevel)))
      : (isRealConcern ? 3 : 0);
    const analysisExplanation = typeof analysisResult.analysisExplanation === 'string'
      ? analysisResult.analysisExplanation.trim()
      : "AI analysis explanation was not provided or in an invalid format.";
    
    let aiGeneratedAdvice: string | undefined = undefined;
    if (isRealConcern && concernLevel >= 2 && typeof analysisResult.aiGeneratedAdvice === 'string' && analysisResult.aiGeneratedAdvice.trim() !== "") {
        aiGeneratedAdvice = analysisResult.aiGeneratedAdvice.trim();
        
        // Check if the AI response actually includes the country-specific helplines and contact information
        let hasCompleteHelplineInfo = false;
        if (helplinesToList.length > 0 && aiGeneratedAdvice) {
            // To be complete, we need at least one helpline name with its contact info (phone, website, etc.)
            const containsFirstHelplineName = helplinesToList[0] && aiGeneratedAdvice.includes(helplinesToList[0].name);
            
            // Check for contact method
            let containsFirstHelplineContact = false;
            if (helplinesToList[0].phone) {
                containsFirstHelplineContact = aiGeneratedAdvice.includes(helplinesToList[0].phone);
            } else if (helplinesToList[0].website) {
                containsFirstHelplineContact = aiGeneratedAdvice.includes(helplinesToList[0].website);
            } else if (helplinesToList[0].text_to) {
                containsFirstHelplineContact = aiGeneratedAdvice.includes(helplinesToList[0].text_to);
            }
            
            hasCompleteHelplineInfo = containsFirstHelplineName && containsFirstHelplineContact;
            
            console.log(`[VerifyConcern] Helpline Check: Contains first helpline name (${helplinesToList[0]?.name}): ${containsFirstHelplineName}, Contains first helpline contact: ${containsFirstHelplineContact}`);
        }
        
        // Log the raw LLM response for debugging
        console.log(`[VerifyConcern] FULL Raw LLM safety response (CRITICAL FOR DEBUGGING):\n${aiGeneratedAdvice}`);
        console.log(`[VerifyConcern] JSON DUMP: Does response contain ALL expected key components:`, {
            responseLength: aiGeneratedAdvice?.length || 0,
            hasTeacherSentence: aiGeneratedAdvice?.includes(teacherAwarenessMandatorySentence),
            countryCode: effectiveCountryCode,
            helplinesToInclude: helplinesToList.map(h => h.name),
            hasAnyHelplineName: helplinesToList.some(h => aiGeneratedAdvice?.includes(h.name)),
            hasAnyHelplinePhone: helplinesToList.some(h => h.phone && aiGeneratedAdvice?.includes(h.phone)),
            hasAnyHelplineWebsite: helplinesToList.some(h => h.website && aiGeneratedAdvice?.includes(h.website))
        });
        
        // ALWAYS modify to add the missing information if needed
        if ((!hasCompleteHelplineInfo || (aiGeneratedAdvice && !aiGeneratedAdvice.includes(teacherAwarenessMandatorySentence))) && aiGeneratedAdvice) {
            console.warn("[VerifyConcern] LLM response missing critical safety information (teacher sentence or helplines). Reconstructing...");
            // Extract just the first part of the response and compassionate message
            // Try to keep any personalized content from the AI while ensuring our helplines are shown
            
            // Split content and find the intro section (before any helplines)
            const contentParts = aiGeneratedAdvice.split(/\n\n|\r\n\r\n/);
            // The intro is usually the first paragraph 
            const introSection = contentParts[0] || "I understand you may be going through a difficult time.";
            
            // Keep only the first paragraph and make sure it has the mandatory teacher sentence
            let reconstructedAdvice = introSection;
            if (!reconstructedAdvice.includes(teacherAwarenessMandatorySentence)) {
                reconstructedAdvice += " " + teacherAwarenessMandatorySentence;
            }
            
            // Hard-code the helplines section with the country-specific helplines - use the EXACT format
            // Include extra blank line for better readability
            reconstructedAdvice += "\n\n===== MANDATORY HELPLINES - COPY THIS SECTION VERBATIM - DO NOT MODIFY =====\n";
            if (helplinesToList.length > 0) {
                helplinesToList.forEach(line => {
                    reconstructedAdvice += `* ${line.name}`;
                    if (line.phone) reconstructedAdvice += ` - Phone: ${line.phone}`;
                    else if (line.text_to && line.text_msg) reconstructedAdvice += ` - Text: ${line.text_msg} to ${line.text_to}`;
                    else if (line.website) reconstructedAdvice += ` - Website: ${line.website}`;
                    // Add short description when available
                    if (line.short_desc) {
                      reconstructedAdvice += ` (${line.short_desc})`;
                    }
                    reconstructedAdvice += "\n";
                });
            } else {
                // Fallback to DEFAULT helplines if no country-specific ones
                const defaultHelplines = ALL_HELPLINES.DEFAULT || [];
                defaultHelplines.slice(0, 2).forEach(line => {
                    reconstructedAdvice += `* ${line.name}`;
                    if (line.phone) reconstructedAdvice += ` - Phone: ${line.phone}`;
                    else if (line.text_to && line.text_msg) reconstructedAdvice += ` - Text: ${line.text_msg} to ${line.text_to}`;
                    else if (line.website) reconstructedAdvice += ` - Website: ${line.website}`;
                    // Add short description when available
                    if (line.short_desc) {
                      reconstructedAdvice += ` (${line.short_desc})`;
                    }
                    reconstructedAdvice += "\n";
                });
            }
            
            // Add the ending marker for the helplines section
            reconstructedAdvice += "===== END OF MANDATORY HELPLINES =====\n\n";
            
            // Keep any closing message from the original or add our own
            const closingSection = contentParts[contentParts.length - 1] || "Please reach out for support.";
            // Only use the closing if it's not a helpline section and it's a brief sentence
            if (!closingSection.includes("*") && closingSection.length < 100) {
                reconstructedAdvice += closingSection;
            } else {
                reconstructedAdvice += "Please reach out for support.";
            }
            
            // Log exactly what we're including
            console.log(`[VerifyConcern] RECONSTRUCTED helpline message with exact helplines:\n${reconstructedAdvice}`);
            
            aiGeneratedAdvice = reconstructedAdvice;
        }
    } else if (isRealConcern && concernLevel >= 2) {
        console.warn("[VerifyConcern] LLM met conditions for advice but 'aiGeneratedAdvice' field was missing or empty. Constructing concise default advice.");
        let defaultAdvice = `I understand this may be a tough moment. ${teacherAwarenessMandatorySentence}\n\n===== MANDATORY HELPLINES - COPY THIS SECTION VERBATIM - DO NOT MODIFY =====\n`;
        // Use exactly the same format as the reconstructed advice to maintain consistency
        if (helplinesToList.length > 0) {
            helplinesToList.forEach(line => {
                defaultAdvice += `* ${line.name}`;
                if (line.phone) defaultAdvice += ` - Phone: ${line.phone}`;
                else if (line.text_to && line.text_msg) defaultAdvice += ` - Text: ${line.text_msg} to ${line.text_to}`;
                else if (line.website) defaultAdvice += ` - Website: ${line.website}`;
                // Add short description when available
                if (line.short_desc) {
                    defaultAdvice += ` (${line.short_desc})`;
                }
                defaultAdvice += "\n";
            });
        } else { 
            const defaultFallbackHelplines = ALL_HELPLINES.DEFAULT || [];
            defaultFallbackHelplines.slice(0,2).forEach(line => { 
                defaultAdvice += `* ${line.name}`;
                if (line.phone) defaultAdvice += ` - Phone: ${line.phone}`;
                else if (line.text_to && line.text_msg) defaultAdvice += ` - Text: ${line.text_msg} to ${line.text_to}`;
                else if (line.website) defaultAdvice += ` - Website: ${line.website}`;
                // Add short description when available
                if (line.short_desc) {
                    defaultAdvice += ` (${line.short_desc})`;
                }
                defaultAdvice += "\n";
            });
        }
        defaultAdvice += "===== END OF MANDATORY HELPLINES =====\n\nPlease reach out for support.";
        
        // Log what we're using in default case
        console.log(`[VerifyConcern] Using DEFAULT helpline message:\n${defaultAdvice}`);
        
        aiGeneratedAdvice = defaultAdvice;
    }

    console.log(`[VerifyConcern] LLM Analysis: isReal=${isRealConcern}, level=${concernLevel}, explanation="${analysisExplanation}", adviceProvided=${!!aiGeneratedAdvice}`);
    return { isRealConcern, concernLevel, analysisExplanation, aiGeneratedAdvice };

  } catch (error) {
    console.error('[VerifyConcern] Error during OpenRouter call or processing:', error);
    let defaultFallbackAdvice = `It's important to reach out if you're struggling. ${teacherAwarenessMandatorySentence}\n\n`;
    const defaultHelplinesOnCatch = ALL_HELPLINES.DEFAULT || [];
    defaultHelplinesOnCatch.slice(0,2).forEach(line => {
        defaultFallbackAdvice += `* ${line.name}`;
        if (line.phone) defaultFallbackAdvice += ` - Phone: ${line.phone}`;
        else if (line.text_to && line.text_msg) defaultFallbackAdvice += ` - Text: ${line.text_msg} to ${line.text_to}`;
        else if (line.website) defaultFallbackAdvice += ` - Website: ${line.website}`;
        // Add short description when available
        if (line.short_desc) {
            defaultFallbackAdvice += ` (${line.short_desc})`;
        }
        defaultFallbackAdvice += "\n";
    });
    defaultFallbackAdvice += "\n\nHelp is available.";
    
    // Create a more user-friendly explanation for the teacher
    let teacherExplanation = "Message flagged by automated safety system for teacher review.";
    
    // Add more context based on concern type without exposing the API error
    if (concernType) {
      const readableConcernType = concernType.replace(/_/g, ' ');
      teacherExplanation = `This message was flagged due to potential ${readableConcernType} concerns. Please review the conversation context and take appropriate action if needed.`;
    }
    
    return {
      isRealConcern: true, 
      concernLevel: 3,
      analysisExplanation: teacherExplanation,
      aiGeneratedAdvice: defaultFallbackAdvice
    };
  }
}

export async function checkMessageSafety(
    supabaseUserContextClient: SupabaseClient<Database>,
    messageContent: string,
    messageId: string,
    studentId: string,
    room: Room,
    countryCode: string | null 
): Promise<void> {
    console.log(`[SafetyDiagnostics] ===== CHECK MESSAGE SAFETY TRACKING =====`);
    console.log(`[SafetyDiagnostics] Function Parameters:`);
    console.log(`[SafetyDiagnostics] messageId: ${messageId}`);
    console.log(`[SafetyDiagnostics] studentId: ${studentId}`);
    console.log(`[SafetyDiagnostics] room.room_id: ${room.room_id}`);
    console.log(`[SafetyDiagnostics] room.teacher_id: ${room.teacher_id}`);
    console.log(`[SafetyDiagnostics] country_code: "${countryCode}" (Type: ${typeof countryCode})`);
    console.log(`[SafetyDiagnostics] messageContent Length: ${messageContent.length} characters`);
    
    try {
        // Data integrity check - make this more visible with clear dividers
        console.log(`[SafetyDiagnostics] =========== SAFETY SYSTEM MESSAGE CHECK ===========`);
        console.log(`[SafetyDiagnostics] HELPLINES DATA INTEGRITY CHECK:`);
        console.log(`[SafetyDiagnostics] - roomId: ${room.room_id}`);
        console.log(`[SafetyDiagnostics] - teacherId: ${room.teacher_id}`);
        console.log(`[SafetyDiagnostics] - messageId: ${messageId}`);
        console.log(`[SafetyDiagnostics] - studentId: ${studentId}`);
        console.log(`[SafetyDiagnostics] - Input countryCode: "${countryCode}" (type: ${typeof countryCode})`);
        console.log(`[SafetyDiagnostics] - Total countries available: ${Object.keys(ALL_HELPLINES).length}`);
        console.log(`[SafetyDiagnostics] - Countries loaded: ${Object.keys(ALL_HELPLINES).join(', ')}`);
        console.log(`[SafetyDiagnostics] - US helplines present: ${!!ALL_HELPLINES.US} (Count: ${ALL_HELPLINES.US?.length || 0})`);
        console.log(`[SafetyDiagnostics] - GB helplines present: ${!!ALL_HELPLINES.GB} (Count: ${ALL_HELPLINES.GB?.length || 0})`);
        console.log(`[SafetyDiagnostics] - DEFAULT helplines present: ${!!ALL_HELPLINES.DEFAULT} (Count: ${ALL_HELPLINES.DEFAULT?.length || 0})`);
        console.log(`[SafetyDiagnostics] =================================================`);
        
        // Enhanced country code processing with better validation
        console.log(`[SafetyDiagnostics] Input country code: "${countryCode}" (type: ${typeof countryCode})`);
        
        // Enhanced country code normalization and validation (matching the pattern from verifyConcern)
        let effectiveCountryCode = 'DEFAULT';
        if (countryCode) {
            // Initial processing - trim and validate
            if (typeof countryCode === 'string' && countryCode.trim() !== '') {
                // Normalize by converting to uppercase
                effectiveCountryCode = countryCode.trim().toUpperCase();
                console.log(`[SafetyDiagnostics] Converted to uppercase: "${effectiveCountryCode}"`);
                
                // Handle common country code aliases
                if (effectiveCountryCode === 'UK') {
                    effectiveCountryCode = 'GB'; // Convert UK to GB (ISO standard)
                    console.log(`[SafetyDiagnostics] Converted UK to GB for proper ISO lookup`);
                }
                else if (effectiveCountryCode === 'UAE') {
                    effectiveCountryCode = 'AE'; // Convert UAE to AE (ISO standard)
                    console.log(`[SafetyDiagnostics] Converted UAE to AE for proper ISO lookup`);
                }
                else if (effectiveCountryCode === 'USA') {
                    effectiveCountryCode = 'US'; // Convert USA to US (ISO standard)
                    console.log(`[SafetyDiagnostics] Converted USA to US for proper ISO lookup`);
                }
            } else {
                console.warn(`[SafetyDiagnostics] Invalid countryCode format - using DEFAULT fallback`);
                effectiveCountryCode = 'DEFAULT';
            }
        } else {
            console.warn(`[SafetyDiagnostics] No country code provided - will use DEFAULT`);
        }
        
        // Verify the country code exists in our data
        const availableCountries = Object.keys(ALL_HELPLINES);
        console.log(`[SafetyDiagnostics] Available countries in ALL_HELPLINES: ${availableCountries.join(', ')}`);
        
        // Check for direct match in ALL_HELPLINES
        const directMatchExists = availableCountries.includes(effectiveCountryCode);
        console.log(`[SafetyDiagnostics] Direct match exists for "${effectiveCountryCode}": ${directMatchExists}`);
        console.log(`[SafetyDiagnostics] ===== END TRACKING =====`);
        
        // Find the appropriate helplines for this country code
        let countryHelplines: HelplineEntry[] = [];
        
        try {
            // STEP 1: Try direct exact match (most efficient)
            if (directMatchExists && Array.isArray(ALL_HELPLINES[effectiveCountryCode])) {
                console.log(`[Safety Check] Direct match found for "${effectiveCountryCode}" with ${ALL_HELPLINES[effectiveCountryCode].length} helplines`);
                countryHelplines = ALL_HELPLINES[effectiveCountryCode];
            } 
            // STEP 2: Try case-insensitive matching if not DEFAULT and no direct match
            else if (effectiveCountryCode !== 'DEFAULT') {
                console.log(`[Safety Check] No direct match for "${effectiveCountryCode}", trying case-insensitive search`);
                
                // Look for case-insensitive match among available countries
                const effectiveLower = effectiveCountryCode.toLowerCase();
                const foundCountry = availableCountries.find(key => key.toLowerCase() === effectiveLower);
                
                if (foundCountry) {
                    console.log(`[Safety Check] Found case-insensitive match: "${foundCountry}" for "${effectiveCountryCode}"`);
                    
                    // Make sure the found country has helplines in proper format
                    if (Array.isArray(ALL_HELPLINES[foundCountry])) {
                        countryHelplines = ALL_HELPLINES[foundCountry];
                        console.log(`[Safety Check] Using ${countryHelplines.length} helplines from "${foundCountry}"`);
                    } else {
                        console.warn(`[Safety Check] Found country "${foundCountry}" doesn't have valid helplines array`);
                        countryHelplines = ALL_HELPLINES.DEFAULT || [];
                    }
                } else {
                    console.log(`[Safety Check] No case-insensitive match found for "${effectiveCountryCode}", using DEFAULT helplines`);
                    
                    // Use DEFAULT helplines when no match found
                    if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
                        countryHelplines = ALL_HELPLINES.DEFAULT;
                    } else {
                        console.error(`[Safety Check] CRITICAL ERROR: DEFAULT helplines not available!`);
                        countryHelplines = [];
                    }
                }
            }
            // STEP 3: Handle explicit DEFAULT request
            else if (effectiveCountryCode === 'DEFAULT') {
                console.log(`[Safety Check] Explicitly using DEFAULT helplines as requested`);
                
                if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
                    countryHelplines = ALL_HELPLINES.DEFAULT;
                } else {
                    console.error(`[Safety Check] CRITICAL ERROR: DEFAULT helplines not available!`);
                    countryHelplines = [];
                }
            }
            
            // STEP 4: Safety check - if we still don't have any helplines, use DEFAULT as fallback
            if (countryHelplines.length === 0) {
                console.warn(`[Safety Check] No helplines found for "${effectiveCountryCode}" after all lookup methods!`);
                console.warn(`[Safety Check] Using DEFAULT helplines as final fallback`);
                
                if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
                    countryHelplines = ALL_HELPLINES.DEFAULT;
                } else {
                    // This should never happen with our embedded data
                    console.error(`[Safety Check] CRITICAL FAILURE: DEFAULT helplines not available in final fallback!`);
                    // Create minimal emergency helpline as absolute last resort
                    countryHelplines = [
                        { name: "Emergency Services", short_desc: "Contact local emergency services if in immediate danger." },
                        { name: "Talk to a Trusted Adult", short_desc: "Speak to a teacher, school counselor, parent, or another family member." }
                    ];
                }
            }
            
            // Final verification
            console.log(`[Safety Check] Final helplines for "${effectiveCountryCode}": ${countryHelplines.length} entries`);
            if (countryHelplines.length > 0) {
                console.log(`[Safety Check] First helpline: ${countryHelplines[0].name}`);
            }
        } catch (error) {
            // Catch any unexpected errors in the lookup process
            console.error(`[Safety Check] ERROR during helpline lookup: ${error}`);
            
            // Fallback to DEFAULT or emergency minimal helplines
            if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
                console.warn(`[Safety Check] Using DEFAULT helplines after error`);
                countryHelplines = ALL_HELPLINES.DEFAULT;
            } else {
                console.error(`[Safety Check] CRITICAL ERROR: Unable to use DEFAULT helplines as fallback after error!`);
                // Create minimal emergency helpline as absolute last resort
                countryHelplines = [
                    { name: "Emergency Services", short_desc: "Contact local emergency services if in immediate danger." },
                    { name: "Talk to a Trusted Adult", short_desc: "Speak to a teacher, school counselor, parent, or another family member." }
                ];
                console.error(`[CRITICAL ALERT] Safety system encountered a critical error and could not render helplines! This requires immediate attention.`);
            }
        }
        
        console.log(`[Safety Check] Found ${countryHelplines.length} helplines for "${effectiveCountryCode}"`);
        
        if (countryHelplines.length > 0) {
            console.log(`[Safety Check] First helpline: ${JSON.stringify(countryHelplines[0])}`);
        }

        const adminClient = createAdminClient();
        const { data: currentMessageData, error: fetchMsgError } = await supabaseUserContextClient
            .from('chat_messages')
            .select('created_at, metadata')
            .eq('message_id', messageId)
            .single();

        if (fetchMsgError || !currentMessageData) {
             console.error(`[Safety Check] Failed to fetch current message ${messageId}:`, fetchMsgError);
             return;
        }

        const { hasConcern, concernType } = initialConcernCheck(messageContent);
        console.log(`[Safety Check] Initial Keyword Check: hasConcern=${hasConcern}, concernType=${concernType || 'N/A'}`);

        if (hasConcern && concernType) {
            const chatbotIdForContext = currentMessageData.metadata?.chatbotId || null;
            const { data: contextMessagesData } = await adminClient
                .from('chat_messages')
                .select('role, content')
                .eq('room_id', room.room_id)
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', chatbotIdForContext ? 'eq' : 'is', chatbotIdForContext) // Correctly handle null for chatbotId
                .lt('created_at', currentMessageData.created_at)
                .order('created_at', { ascending: false })
                .limit(4);
            const recentMessagesForSafetyLLM = (contextMessagesData || [])
                .map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }))
                .reverse();
            
            const { isRealConcern, concernLevel, analysisExplanation, aiGeneratedAdvice } = await verifyConcern(
                messageContent,
                concernType,
                recentMessagesForSafetyLLM,
                countryCode 
            );

            if (isRealConcern && concernLevel >= CONCERN_THRESHOLD) {
                const { data: teacherProfile } = await adminClient.from('profiles').select('email').eq('user_id', room.teacher_id).single();
                const { data: studentProfile } = await adminClient.from('profiles').select('full_name').eq('user_id', studentId).single();
                const studentName = studentProfile?.full_name || `Student (ID: ${studentId.substring(0, 6)}...)`;
                const { data: insertedFlag, error: flagInsertError } = await adminClient.from('flagged_messages').insert({
                    message_id: messageId, student_id: studentId, teacher_id: room.teacher_id,
                    room_id: room.room_id, concern_type: concernType, concern_level: concernLevel,
                    analysis_explanation: analysisExplanation, status: 'pending',
                }).select('flag_id').single();

                if (flagInsertError) { console.error(`[Safety Check] FAILED to insert flag:`, flagInsertError.message); return; }
                
                const newFlagId = insertedFlag!.flag_id; // Non-null assertion because if no error, data should exist
                console.log(`[Safety Check] Flag ${newFlagId} inserted for message ${messageId}.`);
                if (teacherProfile?.email) {
                    const viewUrl = `${process.env.NEXT_PUBLIC_APP_URL}/teacher-dashboard/concerns/${newFlagId}`;
                    await sendTeacherAlert(teacherProfile.email,studentName,room.room_name || `Room (ID: ${room.room_id.substring(0,6)})`,concernType,concernLevel,messageContent,viewUrl);
                } else { console.warn(`[Safety Check] Teacher email for ${room.teacher_id} not found. Cannot send alert for flag ${newFlagId}.`);}
            } else { console.log(`[Safety Check] Concern level ${concernLevel} < threshold ${CONCERN_THRESHOLD} or not real.`); }

            if (isRealConcern && concernLevel >= CONCERN_THRESHOLD) {
                console.log(`[Safety Check] Preparing safety message for student ${studentId} in room ${room.room_id}`);
                
                // Get the current timestamp for consistent ordering
                const timestamp = new Date().toISOString();
                
                // CRITICAL: Check if aiGeneratedAdvice actually contains country-specific helplines
                // If not, we need to rebuild it from scratch using our countryHelplines
                let finalAdvice = aiGeneratedAdvice || '';
                
                // Verify the advice contains country-specific helplines by checking for bullet point format
                const hasHelplineFormat = finalAdvice.includes('* ') && 
                                       (finalAdvice.includes('Phone:') || finalAdvice.includes('Website:'));
                                         
                // Verify that at least one of our expected helplines is there
                const hasExpectedHelplines = countryHelplines.some(helpline => 
                    finalAdvice.includes(helpline.name));
                    
                console.log(`[Safety Check] Verification - Has helpline format: ${hasHelplineFormat}, Has expected helplines: ${hasExpectedHelplines}`);
                
                // If the advice is missing required elements, rebuild it completely
                if (!hasHelplineFormat || !hasExpectedHelplines) {
                    console.warn(`[Safety Check] CRITICAL: Safety advice does not contain proper helplines, rebuilding from scratch`);
                    
                    // Get country name from the code (but don't hardcode specific countries)
                                     
                    // Start with gentle intro and mandatory teacher awareness sentence
                    finalAdvice = `It's important to reach out if you're struggling. Remember, your teacher can see this conversation and is here to support you. Please feel comfortable reaching out to them or another trusted adult if you need help.\n\n`;
                    
                    // Add all available helplines for this country
                    if (countryHelplines.length > 0) {
                        countryHelplines.forEach(helpline => {
                            finalAdvice += `* ${helpline.name}`;
                            if (helpline.phone) {
                                finalAdvice += ` - Phone: ${helpline.phone}`;
                            } else if (helpline.text_to && helpline.text_msg) {
                                finalAdvice += ` - Text: ${helpline.text_msg} to ${helpline.text_to}`;
                            } else if (helpline.website) {
                                finalAdvice += ` - Website: ${helpline.website}`;
                            }
                            if (helpline.short_desc) {
                                finalAdvice += ` (${helpline.short_desc})`;
                            }
                            finalAdvice += `\n`;
                        });
                    } else {
                        console.error(`[Safety Check] ERROR: No helplines available for rebuilding!`);
                        // Use the DEFAULT helplines from the JSON - never hardcode anything
                        if (ALL_HELPLINES.DEFAULT && Array.isArray(ALL_HELPLINES.DEFAULT)) {
                            ALL_HELPLINES.DEFAULT.forEach(helpline => {
                                finalAdvice += `* ${helpline.name}`;
                                if (helpline.phone) {
                                    finalAdvice += ` - Phone: ${helpline.phone}`;
                                } else if (helpline.text_to && helpline.text_msg) {
                                    finalAdvice += ` - Text: ${helpline.text_msg} to ${helpline.text_to}`;
                                } else if (helpline.website) {
                                    finalAdvice += ` - Website: ${helpline.website}`;
                                }
                                if (helpline.short_desc) {
                                    finalAdvice += ` (${helpline.short_desc})`;
                                }
                                finalAdvice += `\n`;
                            });
                        } else {
                            // If somehow DEFAULT is also missing, add a generic message pointing to the teacher
                            finalAdvice += `* Please speak with your teacher or a trusted adult about getting help.\n`;
                        }
                    }
                    
                    // Add space after helplines
                    finalAdvice += `\n`;
                    
                    // Add closing sentence
                    finalAdvice += `Help is available.`;
                    
                    console.log(`[Safety Check] Rebuilt safety advice with ${countryHelplines.length} helplines for ${effectiveCountryCode}`);
                    
                    // Log the complete safety message for debugging
                    console.log(`[Safety Check] ========= FINAL SAFETY MESSAGE CONTENT =========`);
                    console.log(`[Safety Check] Country code: ${effectiveCountryCode}`);
                    console.log(`[Safety Check] Helplines count: ${countryHelplines.length}`);
                    if (countryHelplines.length > 0) {
                        console.log(`[Safety Check] Helplines being used:`);
                        countryHelplines.forEach((h, i) => console.log(`[Safety Check]   ${i+1}. ${h.name}${h.phone ? ` - Phone: ${h.phone}` : ''}${h.website ? ` - Website: ${h.website}` : ''}`));
                    }
                    console.log(`[Safety Check] --- First 500 chars of message ---`);
                    console.log(finalAdvice.substring(0, 500) + '...');
                    console.log(`[Safety Check] ==============================================`);
                }
                
                // Insert the advice message
                const { data: safetyMessageData, error: adviceInsertError } = await adminClient
                    .from('chat_messages')
                    .insert({
                        room_id: room.room_id,
                        user_id: studentId, 
                        role: 'system',    
                        content: finalAdvice || "I notice you might be going through a tough time. Remember, your teacher can see this conversation and is here to support you.", 
                        created_at: timestamp, 
                        metadata: {
                            chatbotId: currentMessageData.metadata?.chatbotId || null, 
                            isSystemSafetyResponse: true, // Critical flag that determines display in UI
                            isSystemMessage: true, // Additional flag to ensure it's seen as a system message
                            safetyMessageVersion: '2.1', // Updated version to track which implementation is being used
                            originalConcernType: concernType,
                            originalConcernLevel: concernLevel,
                            triggerMessageId: messageId,
                            // Store all relevant country code info for debugging and verification
                            rawCountryCode: countryCode, // Original input exactly as received
                            countryCode: countryCode, // Keep for backward compatibility
                            effectiveCountryCode: effectiveCountryCode, // Normalized code used for lookup
                            // Use the effective country code or DEFAULT from data, never hardcode
                            displayCountryCode: effectiveCountryCode || 'DEFAULT',
                            // Store helpline information for tracing issues
                            helplineCount: countryHelplines.length,
                            firstHelpline: countryHelplines.length > 0 ? countryHelplines[0].name : 'NONE',
                            helplines: countryHelplines.map(h => h.name).join(','), // List of helplines for tracing
                            // Detailed debug info
                            debugInfo: {
                                countryCodeType: typeof countryCode,
                                effectiveCountryCodeType: typeof effectiveCountryCode,
                                countryCodesInSystem: Object.keys(ALL_HELPLINES),
                                originalCountryValue: countryCode,
                                countryHelplineCount: countryHelplines.length,
                                timestamp: new Date().toISOString()
                            }
                        },
                    })
                    .select('message_id')
                    .single();
                if (adviceInsertError) {
                    console.error(`[Safety Check] FAILED to insert AI advice message:`, adviceInsertError.message);
                } else if (safetyMessageData) {
                    console.log(`[Safety Check] Successfully inserted AI advice message ID: ${safetyMessageData.message_id}`);
                    
                    // Send a direct message to let the client know a safety message is available
                    // This helps with realtime display even when there are issues with Supabase realtime
                    try {
                        // Create a channel specifically for this message's user
                        const channel = adminClient.channel(`safety-alert-${studentId}`);
                        
                        // Debug country code right before creating broadcast payload
                        console.log(`[Safety Check] Debug - Country code right before broadcast:`, {
                            originalCountryCode: countryCode, 
                            effectiveCountryCode: effectiveCountryCode,
                            hasDefaultHelplines: !!ALL_HELPLINES.DEFAULT,
                            availableCountryCodes: Object.keys(ALL_HELPLINES),
                            testEntryExists: ALL_HELPLINES['GB'] ? 'Yes' : 'No'
                        });
                        
                        // Verify we're using the correct helplines one more time
                        let helplinesForBroadcast = countryHelplines.map(h => h.name).join(',');
                        if (helplinesForBroadcast.length === 0 || !helplinesForBroadcast.includes(countryHelplines[0]?.name)) {
                            console.warn(`[Safety Check] CRITICAL: Missing proper helplines in broadcast payload! Reconstructing...`);
                            // Try to get proper helplines again
                            if (effectiveCountryCode && ALL_HELPLINES[effectiveCountryCode] && 
                                Array.isArray(ALL_HELPLINES[effectiveCountryCode]) && 
                                ALL_HELPLINES[effectiveCountryCode].length > 0) {
                                const specificHelplines = ALL_HELPLINES[effectiveCountryCode];
                                helplinesForBroadcast = specificHelplines.map(h => h.name).join(',');
                                console.log(`[Safety Check] Fixed broadcast helplines for ${effectiveCountryCode}: ${helplinesForBroadcast}`);
                            } else {
                                console.error(`[Safety Check] Can't fix broadcast helplines - falling back to DEFAULT`);
                                // Use the helplines we actually have, whatever they are - never hardcode anything
                                helplinesForBroadcast = countryHelplines.map(h => h.name).join(',') || "Support resources";
                            }
                        }
                        
                        // Broadcast a safety alert with the newly inserted message ID
                        const broadcastPayload = {
                            room_id: room.room_id,
                            message_id: safetyMessageData.message_id,
                            user_id: studentId,
                            chatbot_id: currentMessageData.metadata?.chatbotId || null,
                            // Add timestamp to ensure it's delivered with the original insert timestamp
                            timestamp: timestamp,
                            // Include all country code info for reliable display
                            rawCountryCode: countryCode, // Original input
                            country_code: countryCode, // Keep for backward compatibility
                            effectiveCountryCode: effectiveCountryCode, // Normalized code used for lookup
                            // Ensure the correct display code is used in the UI
                            displayCountryCode: effectiveCountryCode || 'DEFAULT',
                            // Include helpline info for debugging with the verified values
                            helplineCount: countryHelplines.length,
                            helplines: helplinesForBroadcast,
                            firstHelpline: countryHelplines.length > 0 ? countryHelplines[0].name : 'NONE',
                            // Track version of safety messaging being used
                            safetyMessageVersion: '2.1'
                        };
                        
                        console.log(`[Safety Check] Broadcasting safety message with payload:`, broadcastPayload);
                        
                        await channel.send({
                            type: 'broadcast',
                            event: 'safety-message',
                            payload: broadcastPayload
                        });
                        
                        console.log(`[Safety Check] Broadcast sent for safety message ${safetyMessageData.message_id}`);
                        
                        // Remove the channel (we only needed it for one message)
                        await adminClient.removeChannel(channel);
                    } catch (broadcastError) {
                        console.error('[Safety Check] Error broadcasting safety message:', broadcastError);
                        // Continue execution - this is just an enhancement, not critical
                    }
                } else {
                    console.log(`[Safety Check] Successfully inserted AI advice message, but no ID returned.`);
                }
            }

        } else { console.log(`[Safety Check] No initial concern for message ${messageId}.`); }
    } catch (error) { console.error(`[Safety Check] CRITICAL ERROR for msg ${messageId}:`, error); }
    console.log(`[Safety Check] END - Checked message ID: ${messageId}`);
}{
  "US": [
    { "name": "Childhelp USA", "phone": "1-800-422-4453", "website": "childhelp.org", "short_desc": "Child abuse prevention & treatment" },
    { "name": "National Suicide & Crisis Lifeline", "phone": "988", "website": "988lifeline.org", "short_desc": "24/7 crisis support" },
    { "name": "Crisis Text Line", "text_to": "741741", "text_msg": "HOME", "short_desc": "Text support for any crisis" },
    { "name": "The Trevor Project", "phone": "1-866-488-7386", "website": "thetrevorproject.org", "short_desc": "For LGBTQ youth" }
  ],
  "CA": [
    { "name": "Kids Help Phone", "phone": "1-800-668-6868", "website": "kidshelpphone.ca", "short_desc": "24/7 youth support (text CONNECT to 686868)" },
    { "name": "Talk Suicide Canada", "phone": "1-833-456-4566", "website": "talksuicide.ca", "short_desc": "Suicide prevention & support (text 45645)" },
    { "name": "Canadian Centre for Child Protection", "website": "protectchildren.ca", "short_desc": "Child safety resources" }
  ],
  "GB": [
    { "name": "Childline", "phone": "0800 1111", "website": "childline.org.uk", "short_desc": "Support for children & young people" },
    { "name": "NSPCC Helpline", "phone": "0808 800 5000", "website": "nspcc.org.uk", "short_desc": "If you're worried about a child" },
    { "name": "Samaritans", "phone": "116 123", "website": "samaritans.org", "short_desc": "Emotional support, 24/7" },
    { "name": "Papyrus HOPELINEUK", "phone": "0800 068 4141", "website": "papyrus-uk.org", "short_desc": "Suicide prevention for under 35s" }
  ],
  "IE": [
    { "name": "Childline (ISPCC)", "phone": "1800 66 66 66", "website": "childline.ie", "short_desc": "24/7 support for children (text 'LIST' to 50101)" },
    { "name": "Samaritans Ireland", "phone": "116 123", "website": "samaritans.org/ireland/", "short_desc": "Emotional support, 24/7" },
    { "name": "Pieta House", "phone": "1800 247247", "website": "pieta.ie", "short_desc": "Suicide & self-harm crisis centre (text HELP to 51444)" }
  ],
  "FR": [
    { "name": "Allo Enfance en Danger", "phone": "119", "website": "allo119.gouv.fr", "short_desc": "National child protection helpline (24/7)" },
    { "name": "Suicide Écoute", "phone": "01 45 39 40 00", "website": "suicide-ecoute.fr", "short_desc": "Suicide prevention helpline" },
    { "name": "Net Ecoute (e-Enfance)", "phone": "3018", "website": "e-enfance.org/numero-3018/", "short_desc": "Protection for children online (cyberbullying, etc.)" }
  ],
  "ES": [
    { "name": "ANAR (Ayuda a Niños y Adolescentes en Riesgo)", "phone": "900 20 20 10", "website": "anar.org", "short_desc": "Help for children & adolescents at risk (24/7)" },
    { "name": "Teléfono de la Esperanza", "phone": "717 003 717", "website": "telefonodelaesperanza.org", "short_desc": "Crisis support line" }
  ],
  "IT": [
    { "name": "Telefono Azzurro", "phone": "19696", "website": "azzurro.it", "short_desc": "Child helpline (24/7)" },
    { "name": "Telefono Amico Italia", "phone": "02 2327 2327", "website": "telefonoamico.it", "short_desc": "Emotional support helpline (check hours)" }
  ],
  "PT": [
    { "name": "SOS Criança (IAC)", "phone": "116 111", "website": "iacrianca.pt", "short_desc": "Child helpline (check hours)" },
    { "name": "Voz de Apoio", "phone": "225 50 60 70", "website": "vozdeapoio.pt", "short_desc": "Emotional support helpline (check hours)" }
  ],
  "DE": [
    { "name": "Nummer gegen Kummer (Kinder- und Jugendtelefon)", "phone": "116 111", "website": "nummergegenkummer.de", "short_desc": "Helpline for children & youth (Mon-Sat)" },
    { "name": "TelefonSeelsorge", "phone": "0800 111 0 111", "website": "telefonseelsorge.de", "short_desc": "Crisis support (24/7)" }
  ],
  "GR": [
    { "name": "The Smile of the Child (National Helpline for Children SOS)", "phone": "1056", "website": "hamogelo.gr", "short_desc": "Child helpline (24/7)" },
    { "name": "KLIMAKA (Suicide Prevention)", "phone": "1018", "website": "klimaka.org.gr", "short_desc": "24/7 suicide prevention line" }
  ],
  "AU": [
    { "name": "Kids Helpline", "phone": "1800 55 1800", "website": "kidshelpline.com.au", "short_desc": "Counselling for young people 5-25 (24/7)" },
    { "name": "Lifeline Australia", "phone": "13 11 14", "website": "lifeline.org.au", "short_desc": "24/7 crisis support & suicide prevention" },
    { "name": "eSafety Commissioner", "website": "esafety.gov.au", "short_desc": "Online safety help & reporting" }
  ],
  "AE": [
    { "name": "Child Protection Centre (Ministry of Interior)", "phone": "116111", "website": "moi-cpc.ae", "short_desc": "Child protection helpline" },
    { "name": "Dubai Foundation for Women and Children", "phone": "800111", "website": "dfwac.ae", "short_desc": "Support for women & children (violence/abuse)" }
  ],
  "MY": [
    { "name": "Buddy Bear Helpline", "phone": "1-800-18-BEAR (2327)", "short_desc": "Support helpline for children" },
    { "name": "PS The Children (Protect and Save The Children)", "phone": "+603-7957 4344", "short_desc": "Child protection services" }
  ],
  "DEFAULT": [
    { "name": "Your Local Emergency Services", "short_desc": "Contact if in immediate danger (e.g., 911, 112, 999, 000)." },
    { "name": "A Trusted Adult", "short_desc": "Speak to a teacher, school counselor, parent, or another family member." },
    { "name": "Befrienders Worldwide", "website": "befrienders.org", "short_desc": "Find a crisis support center in your region." }
  ]
}// src/lib/safety/alerts.ts
import { sendEmail } from '@/lib/email/resend';
import { APP_NAME } from '@/lib/utils/constants';

export function getConcernTypeDisplayName(type: string): string {
  if (!type) return 'Unknown Concern';
  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

export function getConcernLevelDisplayName(level: number): string {
  if (level >= 5) return 'Critical';
  if (level >= 4) return 'High';
  if (level >= 3) return 'Significant';
  if (level >= 2) return 'Moderate';
  if (level >= 1) return 'Minor';
  return 'Low';
}

export async function sendTeacherAlert(
  teacherEmail: string,
  studentName: string,
  roomName: string,
  concernType: string,
  concernLevel: number,
  messageContent: string,
  viewUrl: string
): Promise<boolean> {
  if (!teacherEmail || !studentName || !roomName || !concernType || concernLevel < 0 || !messageContent || !viewUrl) {
    console.error('[Alerts] Missing required information for sending teacher alert.');
    return false;
  }

  const concernTypeName = getConcernTypeDisplayName(concernType);
  const concernLevelName = getConcernLevelDisplayName(concernLevel);
  const subject = `[${APP_NAME}] ${concernLevelName} ${concernTypeName} Alert for Student: ${studentName}`;
  const displayedMessage = messageContent.replace(/</g, "<").replace(/>/g, ">");

  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        h2 { color: #985DD7; } /* Using skolrPurple from your theme */
        h3 { color: #7a4bb5; } /* Using skolrPurpleDark from your theme */
        ul { list-style: none; padding: 0; }
        li { margin-bottom: 5px; }
        strong { font-weight: bold; }
        blockquote {
          border-left: 4px solid #E5E7EB;
          padding-left: 15px;
          margin-left: 0;
          color: #555;
          background-color: #F9FAFB;
          padding: 10px;
        }
        a.button {
          display: inline-block;
          padding: 12px 24px;
          background-color: #985DD7; /* skolrPurple */
          color: white !important; 
          text-decoration: none;
          border-radius: 6px;
          font-weight: bold;
          text-align: center;
        }
         a.button:hover {
             background-color: #7a4bb5; /* skolrPurpleDark */
         }
      </style>
    </head>
    <body>
      <h2>${APP_NAME} - Student Welfare Alert</h2>
      <p>A message from a student in one of your classrooms has been automatically flagged for a potential welfare concern based on its content.</p>
      <p>Please review the details below and the conversation context as soon as possible.</p>

      <h3>Alert Details:</h3>
      <ul>
        <li><strong>Student:</strong> ${studentName}</li>
        <li><strong>Classroom:</strong> ${roomName}</li>
        <li><strong>Concern Type:</strong> ${concernTypeName}</li>
        <li><strong>Assessed Level:</strong> ${concernLevelName} (Level ${concernLevel})</li>
        <li><strong>Time Detected:</strong> ${new Date().toLocaleString()}</li>
      </ul>

      <h3>Flagged Message:</h3>
      <blockquote>
        <p>${displayedMessage}</p>
      </blockquote>

      <p>Click the button below to view the full conversation context and manage this alert:</p>
      <p style="text-align: center;">
        <a href="${viewUrl}" class="button">Review Concern Now</a>
      </p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
      <p style="font-size: 0.9em; color: #777;">This is an automated message from ${APP_NAME}. Please do not reply directly to this email.</p>
    </body>
    </html>
  `;

  // The fromName and fromEmail will be taken from the defaults in sendEmail,
  // which now read from environment variables.
  // If you want a specific "From Name" for safety alerts that's different from the global default,
  // you can pass it here, e.g., `${APP_NAME} Safety System`.
  // The `fromEmail` should still come from the environment variable to ensure it's from your verified domain.
  const alertFromName = process.env.EMAIL_FROM_NAME ? `${process.env.EMAIL_FROM_NAME} (Safety Alert)` : `${APP_NAME} Safety`;
  
  return await sendEmail(
    teacherEmail,
    subject,
    html,
    alertFromName // Pass a specific From Name for alerts
    // fromEmail will use the default from sendEmail (which is from .env.local)
  );
}// src/lib/pinecone/utils.ts
import { index, pinecone } from './client';
import { RecordMetadata } from '@pinecone-database/pinecone';

interface ChunkMetadata extends RecordMetadata {
  chatbotId: string;
  documentId: string;
  chunkId: string;
  text: string;
  fileName: string;
  fileType: string;
}

/**
 * Upsert vectors into Pinecone with enhanced error handling
 * @param vectors Array of vectors with their IDs and metadata
 */
export async function upsertVectors(
  vectors: { 
    id: string, 
    values: number[], 
    metadata: ChunkMetadata 
  }[]
) {
  // Validate that Pinecone is initialized
  if (!index || !pinecone) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    throw new Error('Pinecone client not initialized. Check API key and environment variables.');
  }

  try {
    // Use a smaller batch size to avoid timeouts
    const batchSize = 25; // Reduced from 50 to 25
    
    console.log(`Upserting ${vectors.length} vectors in batches of ${batchSize}`);
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      try {
        // Add retries for resilience
        let retries = 0;
        const maxRetries = 3;
        let success = false;
        
        while (!success && retries < maxRetries) {
          try {
            await index.upsert(batch);
            success = true;
            console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
          } catch (retryError) {
            retries++;
            console.warn(`Retry ${retries}/${maxRetries} failed:`, retryError);
            
            // Print detailed error information
            if (retryError instanceof Error) {
              console.warn('Error message:', retryError.message);
              
              // Log the first part of HTML responses for debugging
              if (retryError.message.includes('<!DOCTYPE')) {
                const htmlStart = retryError.message.substring(0, 200);
                console.warn('HTML error detected in response:', htmlStart);
                
                // Check for specific error signatures
                if (retryError.message.includes('401') || 
                    retryError.message.includes('unauthorized') || 
                    retryError.message.includes('authentication')) {
                  console.error('AUTHENTICATION ERROR: Check your Pinecone API key');
                }
              }
            }
            
            if (retries < maxRetries) {
              // Exponential backoff: 1s, 2s, 4s, etc.
              const delay = Math.pow(2, retries) * 1000;
              console.log(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        if (!success) {
          throw new Error(`Failed to upsert batch after ${maxRetries} retries`);
        }
      } catch (batchError) {
        console.error(`Error upserting batch ${Math.floor(i/batchSize) + 1}:`, batchError);
        
        // Try upserting one by one as a fallback with additional retry logic
        console.log("Trying to upsert vectors one by one...");
        for (const vector of batch) {
          try {
            let individualRetries = 0;
            const maxIndividualRetries = 2;
            
            while (individualRetries < maxIndividualRetries) {
              try {
                await index.upsert([vector]);
                break; // Success, exit retry loop
              } catch (singleRetryError) {
                individualRetries++;
                console.warn(`Individual vector retry ${individualRetries}/${maxIndividualRetries} failed:`, singleRetryError);
                
                if (individualRetries >= maxIndividualRetries) {
                  console.error(`Failed to upsert vector ${vector.id} after ${maxIndividualRetries} retries`);
                } else {
                  // Wait before retry
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }
            }
          } catch (singleError) {
            console.error(`Failed to upsert vector ${vector.id}:`, singleError);
          }
        }
      }
      
      // Add a slightly longer delay between batches to avoid rate limits
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log(`Completed upserting vectors to Pinecone`);
    return true;
  } catch (error) {
    console.error('Error in upsertVectors:', error);
    
    // Provide more detailed error information
    if (error instanceof Error) {
      if (error.message.includes('<!DOCTYPE')) {
        console.error('Received HTML response instead of JSON. This typically indicates:');
        console.error('1. Authentication failure (check your API key)');
        console.error('2. Network proxy interference');
        console.error('3. Service endpoint issues');
        
        // Extract status code if present in HTML
        const statusMatch = error.message.match(/<title>(\d+)[^<]*<\/title>/);
        if (statusMatch && statusMatch[1]) {
          console.error(`Status code found in HTML: ${statusMatch[1]}`);
        }
      }
    }
    
    throw new Error(`Failed to upsert vectors: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Rest of the functions remain the same...

export async function queryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return [];
  }

  try {
    const results = await index.query({
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    
    return results.matches;
  } catch (error) {
    console.error('Error querying vectors:', error);
    return []; // Return empty array instead of throwing
  }
}

export async function deleteDocumentVectors(documentId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        documentId: { $eq: documentId }
      }
    });
    console.log(`Successfully deleted vectors for document ${documentId}`);
  } catch (error) {
    console.error('Error deleting vectors:', error);
    throw new Error('Failed to delete vectors');
  }
}

export async function deleteChatbotVectors(chatbotId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    console.log(`Successfully deleted all vectors for chatbot ${chatbotId}`);
  } catch (error) {
    console.error('Error deleting chatbot vectors:', error);
    throw new Error('Failed to delete chatbot vectors');
  }
}// src/lib/pinecone/direct-api.ts
/**
 * This file implements direct fetch-based API calls to Pinecone
 * to bypass any issues with the Pinecone SDK
 */

// Use node-fetch for compatibility
import fetch from 'node-fetch';

interface PineconeVector {
  id: string;
  values: number[];
  metadata?: Record<string, unknown>;
}

interface PineconeResponse {
  status: number;
  statusText: string;
  data?: unknown;
  error?: string;
}

// Add specific interface for query response
interface PineconeQueryResponse extends PineconeResponse {
  data?: {
    matches?: Array<{
      id: string;
      score: number;
      metadata: Record<string, unknown>;
    }>;
  };
}

/**
 * Make a direct API call to Pinecone with detailed logging
 */
async function callPineconeAPI(
  endpoint: string,
  method: 'GET' | 'POST' | 'DELETE' = 'GET',
  body?: unknown
): Promise<PineconeResponse> {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is missing');
    return {
      status: 401,
      statusText: 'Unauthorized',
      error: 'API key is missing'
    };
  }
  
  const url = `https://api.pinecone.io/v1/indexes/${indexName}${endpoint}`;
  
  console.log(`Making ${method} request to Pinecone: ${url}`);
  
  try {
    // Make the API call with fetch
    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': apiKey
      },
      body: body ? JSON.stringify(body) : undefined
    });
    
    console.log(`Pinecone API response status: ${response.status} ${response.statusText}`);
    
    // Handle non-JSON responses
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      return {
        status: response.status,
        statusText: response.statusText,
        data
      };
    } else {
      // Handle HTML or other non-JSON responses
      const text = await response.text();
      console.error('Received non-JSON response from Pinecone:');
      console.error(`Status: ${response.status} ${response.statusText}`);
      console.error(`Content-Type: ${contentType}`);
      console.error(`Response (first 200 chars): ${text.substring(0, 200)}`);
      
      if (text.includes('<!DOCTYPE')) {
        // Parse out any error message from HTML
        const titleMatch = text.match(/<title>([^<]+)<\/title>/);
        const messageMatch = text.match(/<p>([^<]+)<\/p>/);
        
        const errorTitle = titleMatch ? titleMatch[1] : 'Unknown error';
        const errorMessage = messageMatch ? messageMatch[1] : text.substring(0, 100);
        
        return {
          status: response.status,
          statusText: response.statusText,
          error: `HTML response: ${errorTitle} - ${errorMessage}`
        };
      }
      
      return {
        status: response.status,
        statusText: response.statusText,
        error: `Non-JSON response: ${text.substring(0, 100)}`
      };
    }
  } catch (error) {
    console.error('Error making Pinecone API call:', error);
    return {
      status: 500,
      statusText: 'Internal Error',
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * Upsert vectors directly to Pinecone
 */
export async function directUpsertVectors(vectors: PineconeVector[]): Promise<boolean> {
  try {
    // Split vectors into smaller batches
    const batchSize = 20;
    let allSuccessful = true;
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      const result = await callPineconeAPI('/vectors/upsert', 'POST', {
        vectors: batch
      });
      
      if (result.status >= 400 || result.error) {
        console.error(`Error upserting batch: ${result.error || result.statusText}`);
        allSuccessful = false;
        
        // Try single vector upserts as fallback
        console.log('Attempting individual vector upserts as fallback...');
        
        for (const vector of batch) {
          const singleResult = await callPineconeAPI('/vectors/upsert', 'POST', {
            vectors: [vector]
          });
          
          if (singleResult.status >= 400 || singleResult.error) {
            console.error(`Failed to upsert vector ${vector.id}: ${singleResult.error || singleResult.statusText}`);
          } else {
            console.log(`Successfully upserted vector ${vector.id}`);
          }
        }
      } else {
        console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
      }
      
      // Add a delay between batches
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    return allSuccessful;
  } catch (error) {
    console.error('Error in directUpsertVectors:', error);
    return false;
  }
}

/**
 * Query vectors directly from Pinecone
 */
export async function directQueryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  try {
    // Query vectors directly from Pinecone
    const result = await callPineconeAPI('/query', 'POST', {
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    }) as PineconeQueryResponse;
    
    if (result.status >= 400 || result.error) {
      console.error(`Error querying vectors: ${result.error || result.statusText}`);
      return [];
    }
    
    // Now TypeScript knows that result.data?.matches exists
    return result.data?.matches || [];
  } catch (error) {
    console.error('Error in directQueryVectors:', error);
    return [];
  }
}

/**
 * Delete vectors for a specific document directly from Pinecone
 */
export async function directDeleteDocumentVectors(documentId: string): Promise<boolean> {
  try {
    const result = await callPineconeAPI('/vectors/delete', 'POST', {
      filter: {
        documentId: { $eq: documentId }
      }
    });
    
    if (result.status >= 400 || result.error) {
      console.error(`Error deleting document vectors: ${result.error || result.statusText}`);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in directDeleteDocumentVectors:', error);
    return false;
  }
}

/**
 * Check Pinecone API connectivity and report detailed status
 */
export async function checkPineconeStatus(): Promise<{
  isConnected: boolean;
  details: string;
  stats?: unknown;
}> {
  try {
    const result = await callPineconeAPI('/describe_index_stats');
    
    if (result.status >= 400 || result.error) {
      return {
        isConnected: false,
        details: result.error || `API error: ${result.status} ${result.statusText}`
      };
    }
    
    return {
      isConnected: true,
      details: 'Successfully connected to Pinecone',
      stats: result.data
    };
  } catch (error) {
    return {
      isConnected: false,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}// src/lib/pinecone/client.ts
import { Pinecone } from '@pinecone-database/pinecone';

// More robust way to check environment variables
const getPineconeConfig = () => {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is not defined in environment variables');
  }
  
  console.log("Pinecone Configuration:");
  console.log(`- API Key exists: ${!!apiKey}`);
  console.log(`- Index Name: ${indexName}`);
  
  return { apiKey, indexName };
};

// Create client with proper error handling
let pineconeClient: Pinecone | null = null;
let indexClient: ReturnType<Pinecone['index']> | null = null;

try {
  const { apiKey, indexName } = getPineconeConfig();
  
  if (apiKey) {
    pineconeClient = new Pinecone({
      apiKey,
    });
    
    // Get the index for our embeddings
    indexClient = pineconeClient.index(indexName);
    console.log("Pinecone client initialized successfully");
  } else {
    console.error("Failed to initialize Pinecone client: Missing API key");
  }
} catch (error) {
  console.error("Error initializing Pinecone client:", error);
}

export const pinecone = pineconeClient;
export const index = indexClient;// src/lib/StyledComponentsRegistry.tsx
'use client';

import { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { ServerStyleSheet, StyleSheetManager } from 'styled-components';

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  // Only create stylesheet once with lazy initial state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== 'undefined') return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}// src/lib/email/resend.ts
import { Resend } from 'resend';

const resendApiKey = process.env.RESEND_API_KEY || process.env.SMTP_PASSWORD || '';
let resend: Resend | null = null; // Initialize as null

const defaultFromName = process.env.EMAIL_FROM_NAME || 'Skolr';
const defaultFromEmail = process.env.EMAIL_FROM_ADDRESS || 'noreply@skolr.app';

if (resendApiKey && resendApiKey.trim() !== '') { // Check if key is not empty
  try {
    resend = new Resend(resendApiKey);
    console.log('[Resend Init] Resend client initialized successfully.');
  } catch (e) {
    console.error('[Resend Init] CRITICAL: Failed to initialize Resend client with provided API key:', e);
    // resend remains null, sendEmail function will handle this
  }
} else {
  console.warn('[Resend Init] WARNING: RESEND_API_KEY (or SMTP_PASSWORD) is not configured or is empty. Email sending will be disabled.');
}

export async function sendEmail(
  to: string,
  subject: string,
  html: string,
  fromName: string = defaultFromName,
  fromEmail: string = defaultFromEmail
): Promise<boolean> {
  if (!resend) { // Check if resend client was initialized
    console.error('Resend client not initialized or API key missing. Email not sent to:', to);
    return false;
  }

  // Ensure the fromEmail is from a verified domain.
  if (!fromEmail.endsWith('@skolr.app')) { // Adjust if your verified domain is different
     console.warn(
       `[Resend Email] Warning: Attempting to send email from an address (${fromEmail}) ` +
       `that might not be on your primary verified domain (e.g., @skolr.app). `
     );
  }

  try {
    console.log(`Sending email via Resend API to ${to} from "${fromName} <${fromEmail}>" with subject "${subject}"`);
    const { data, error } = await resend.emails.send({
      from: `${fromName} <${fromEmail}>`,
      to: to,
      subject: subject,
      html: html,
    });

    if (error) {
      console.error('Resend API Error sending email:', JSON.stringify(error, null, 2));
      return false;
    }
    console.log('Email sent successfully with Resend API. Message ID:', data?.id);
    return true;
  } catch (error) {
    console.error('Exception caught while sending email with Resend API:', error);
    return false;
  }
}// src/lib/openai/embeddings.ts
import openai from './client';

/**
 * Generate embeddings for a text using OpenAI's embedding model
 * @param text The text to generate embeddings for
 * @returns An array of floating point numbers representing the embedding
 */
export async function generateEmbedding(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
      encoding_format: "float",
    });

    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embedding:', error);
    throw new Error('Failed to generate embedding');
  }
}

/**
 * Generate embeddings for multiple texts in a batch
 * @param texts Array of texts to generate embeddings for
 * @returns Array of embedding arrays
 */
export async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: texts,
      encoding_format: "float",
    });

    return response.data.map(item => item.embedding);
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw new Error('Failed to generate embeddings');
  }
}// src/lib/openai/client.ts
import { OpenAI } from 'openai';

// Initialize the OpenAI client with API key from environment variables
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default openai;