// src/types/student.types.ts - Add this new file
import { Room, Chatbot } from './database.types';

export interface StudentRoom extends Room {
  joined_at: string;
  chatbots: Chatbot[];
}// src/types/knowledge-base.types.ts
export type DocumentType = 'pdf' | 'docx' | 'txt';

export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error';

export type ChunkStatus = 'pending' | 'embedded' | 'error';

export interface Document {
  document_id: string;
  chatbot_id: string;
  file_name: string;
  file_path: string;
  file_type: DocumentType;
  file_size: number;
  status: DocumentStatus;
  error_message?: string;
  created_at: string;
  updated_at: string;
}

export interface DocumentChunk {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
  created_at: string;
}

export interface DocumentUploadResponse {
  document: Document;
  uploadUrl?: string;
}

export interface ProcessingStats {
  totalChunks: number;
  processedChunks: number;
  errorChunks: number;
}// src/types/pdf-parse.d.ts
declare module 'pdf-parse';
declare module 'pdf-parse/lib/pdf-parse.js';
declare module 'mammoth';// src/types/database.types.ts

// Base common fields for all tables
export interface BaseTable {
  created_at: string;
  updated_at?: string;
}

// User roles enum
export type UserRole = 'teacher' | 'student';

// Concern status enum/type
export type ConcernStatus = 'pending' | 'reviewing' | 'resolved' | 'false_positive';

// Knowledge Base Types
export type DocumentType = 'pdf' | 'docx' | 'txt';
export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error';
export type ChunkStatus = 'pending' | 'embedded' | 'error';


// --- Table Interfaces ---

// Schools table
export interface School extends BaseTable {
  school_id: string;
  name: string; // Name of the school
  magic_link_token?: string;
  token_expires_at?: string;
}

// Chatbots table
export interface Chatbot extends BaseTable {
  chatbot_id: string;
  name: string; // Name of the chatbot
  description?: string;
  system_prompt: string;
  teacher_id: string; // FK to profiles.user_id
  model?: string;
  max_tokens?: number;
  temperature?: number;
  enable_rag?: boolean;
}

// Rooms table
export interface Room extends BaseTable {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string; // FK to profiles.user_id
  school_id?: string | null; // FK to schools.school_id (can be null)
  is_active: boolean;
}

// Room to Chatbot mapping table
export interface RoomChatbot extends BaseTable {
  room_id: string; // FK to rooms.room_id
  chatbot_id: string; // FK to chatbots.chatbot_id
}

// Room memberships table (join table)
export interface RoomMembership extends BaseTable {
  room_id: string; // FK to rooms.room_id
  student_id: string; // FK to profiles.user_id
  joined_at: string;
}

// Chat messages table
export interface ChatMessage extends BaseTable {
    message_id: string;
    room_id: string; // FK to rooms.room_id
    user_id: string; // FK to profiles.user_id
    role: 'user' | 'assistant' | 'system';
    content: string;
    tokens_used?: number;
    metadata?: {
        chatbotId?: string | null; // The specific chatbot being interacted with
        error?: unknown; // Potential error storing/sending message (used on client-side)
        [key: string]: unknown; // Allow other arbitrary metadata
    } | null;
}

// User profiles table
export interface Profile extends BaseTable {
  user_id: string; // Primary Key, links to auth.users.id
  // name: string; // REMOVED - Assuming full_name is the primary field now
  full_name?: string; // ADDED - Likely populated from auth signup metadata. Make required (string;) if your trigger guarantees it.
  email: string; // Usually unique, managed by auth
  role: UserRole; // 'teacher' or 'student'
  school_id?: string | null; // FK to schools.school_id (optional)
}

// Knowledge Base Documents table
export interface Document extends BaseTable {
  document_id: string;
  chatbot_id: string; // FK to chatbots.chatbot_id
  file_name: string;
  file_path: string; // Path in Supabase Storage
  file_type: DocumentType;
  file_size: number;
  status: DocumentStatus;
  error_message?: string;
}

// Knowledge Base Document Chunks table
export interface DocumentChunk extends BaseTable {
  chunk_id: string;
  document_id: string; // FK to documents.document_id
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string; // Reference to the vector ID in Pinecone (often same as chunk_id)
}

// Flagged Messages table
export interface FlaggedMessage extends BaseTable {
  flag_id: string;
  message_id: string; // FK to chat_messages.message_id
  student_id: string; // FK to profiles.user_id
  teacher_id: string; // FK to profiles.user_id
  room_id: string; // FK to rooms.room_id
  concern_type: string;
  concern_level: number; // 0-5
  analysis_explanation?: string;
  context_messages?: Record<string, unknown>; // JSONB - Consider a more specific type if structure is known
  status: ConcernStatus;
  reviewed_at?: string;
  reviewer_id?: string | null; // FK to profiles.user_id
  notes?: string;
}


// --- Database Schema Type ---
// Combines all table interfaces for Supabase client typing
export interface Database {
  schools: School;
  profiles: Profile;
  chatbots: Chatbot;
  rooms: Room;
  room_chatbots: RoomChatbot;
  room_memberships: RoomMembership;
  chat_messages: ChatMessage;
  documents: Document;
  document_chunks: DocumentChunk;
  flagged_messages: FlaggedMessage;
}

// --- API Payload Types ---
export interface CreateSchoolPayload {
  name: string;
}

export interface CreateChatbotPayload {
  name: string;
  description?: string;
  system_prompt: string;
  model?: string;
  max_tokens?: number;
  temperature?: number;
  enable_rag?: boolean;
}

export interface CreateRoomPayload {
  room_name: string;
  chatbot_ids: string[];
}

export interface UpdateRoomChatbotsPayload {
  chatbot_ids: string[];
}

export interface JoinRoomPayload {
  room_code: string;
}

export interface SendMessagePayload {
  content: string;
  room_id: string;
  chatbot_id: string;
}

// --- API Response Detail Types ---

// Type for joined concern details (used in API response)
export interface FlaggedConcernDetails extends FlaggedMessage {
    student_name: string | null; // Joined from profiles.full_name
    room_name: string | null;    // Joined from rooms.room_name
    message_content: string | null; // Joined from chat_messages.content
}

// Type for rooms listed for students (includes joined chatbot info)
export interface StudentRoom extends Room {
  joined_at: string; // From room_memberships
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'description'>[]; // Joined via room_chatbots
}

// Type for rooms listed for teachers (includes joined chatbot info)
// This structure matches the API response from /api/teacher/rooms
export interface TeacherRoom extends Room {
   room_chatbots: {
       chatbots: Pick<Chatbot, 'chatbot_id' | 'name'> | null;
   }[] | null;
}// src/types/auth.types.ts
import { User, Session } from '@supabase/supabase-js';
import { UserRole } from './database.types';

export interface AuthUser extends User {
  role?: UserRole;
  school_id?: string;
}

export interface AuthSession extends Session {
  user: AuthUser;
}

export interface SignUpData {
  email: string;
  password: string;
  fullName?: string;
  role: UserRole;
  schoolId?: string;
}

export interface SignInData {
  email: string;
  password: string;
}

export interface MagicLinkData {
  email: string;
  schoolId: string;
}// src/types/chatbot.types.ts
import type { ChatMessage as DatabaseChatMessage } from './database.types'; // Import the corrected type

// ChatMessage is now imported and used as DatabaseChatMessage or aliased if needed.
// REMOVE the old definition:
// export interface ChatMessage { ... }

export interface ChatbotConfig {
  name: string;
  description?: string;
  systemPrompt: string;
  model?: 'x-ai/grok-3-mini-beta' | 'qwen/qwen3-235b-a22b' | 'google/gemini-2.5-flash-preview'; // Updated model options
  maxTokens?: number;
  temperature?: number;
}

export interface ChatContext {
  chatbotId: string;
  roomId: string;
  systemPrompt: string;
  conversationHistory: DatabaseChatMessage[]; // Use the imported type
}

export interface ChatResponse {
  message: string;
  tokensUsed?: number;
  error?: string;
}// src/app/room/[roomId]/student/[studentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import StudentChatHistory from '@/components/teacher/StudentChatHistory';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    align-items: flex-start;
  }
`;

const StudentInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
  }
`;

const BackButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

// Define explicit types
interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

// Define a more specific type for the chatbots nested object
interface RoomChatbotResponse {
  chatbot_id: string;
  chatbots: {
    chatbot_id: string;
    name: string;
  } | Array<{
    chatbot_id: string;
    name: string;
  }>;
}

export default function StudentChatPage() {
  const params = useParams();
  const roomId = params?.roomId as string;
  const studentId = params?.studentId as string;
  const [studentName, setStudentName] = useState<string>('Student');
  const [chatbots, setChatbots] = useState<ChatbotOption[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const supabase = createClient();

  const fetchPageData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Get user info
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }
      
      // Get student info - handle missing columns gracefully
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', studentId)
        .single();
        
      if (profile) {
        // Try different fields that might contain the name
        // The error suggests profiles.name doesn't exist, so check other fields
        if (profile.full_name) {
          setStudentName(profile.full_name);
        } else if (profile.email) {
          setStudentName(profile.email.split('@')[0]);
        } else if (profile.user_id) {
          // Last resort - use a generic label
          setStudentName('Student');
        }
      }
      
      // Get chatbots in this room
      const { data: roomChatbots } = await supabase
        .from('room_chatbots')
        .select(`
          chatbot_id,
          chatbots:chatbots!inner(
            chatbot_id,
            name
          )
        `)
        .eq('room_id', roomId);
        
      if (roomChatbots && roomChatbots.length > 0) {
        // Extract chatbot data with proper typing
        const chatbotList: ChatbotOption[] = [];
        
        // Type assertion to help TypeScript understand the structure
        const typedRoomChatbots = roomChatbots as unknown as RoomChatbotResponse[];
        
        typedRoomChatbots.forEach(item => {
          // Safely check and extract chatbot data
          if (item.chatbots) {
            if (Array.isArray(item.chatbots)) {
              item.chatbots.forEach(cb => {
                chatbotList.push({
                  chatbot_id: cb.chatbot_id,
                  name: cb.name
                });
              });
            } else {
              // It's a single object, not an array
              const cb = item.chatbots;
              chatbotList.push({
                chatbot_id: cb.chatbot_id,
                name: cb.name
              });
            }
          }
        });
        
        setChatbots(chatbotList);
      }
    } catch (err) {
      console.error('Error loading page data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load page data');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, router, supabase]);

  useEffect(() => {
    fetchPageData();
  }, [fetchPageData]);

  const handleBack = () => {
    router.push(`/room/${roomId}`);
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <Card>
            <p>Loading...</p>
          </Card>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Room
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <StudentInfo>
            <h1>{studentName}</h1>
            <p>Chat History</p>
          </StudentInfo>
          <BackButton 
            variant="outline" 
            onClick={handleBack}
          >
            ← Back to Room
          </BackButton>
        </Header>
        
        <StudentChatHistory
          roomId={roomId}
          studentId={studentId}
          studentName={studentName}
          chatbots={chatbots}
        />
      </Container>
    </PageWrapper>
  );
}// src/app/room/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Alert, Button } from '@/styles/StyledComponents';
import StudentList from '@/components/teacher/StudentList';
import type { Chatbot } from '@/types/database.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md} 0;
  }
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    gap: ${({ theme }) => theme.spacing.md};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1.5rem;
      text-align: center;
    }
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1rem;
      text-align: center;
    }
  }
  
  .room-code {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-top: ${({ theme }) => theme.spacing.xs};
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      text-align: center;
    }
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    justify-content: center;
  }
`;

const ChatbotGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  margin-top: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  cursor: pointer;
  
  &:hover {
    transform: translateY(-4px);
    box-shadow: ${({ theme }) => theme.shadows.lg};
  }
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.5rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    min-height: 3rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }
  
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    display: inline-block;
  }
  
  .chat-button {
    width: 100%;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: 44px;
    }
  }
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: {
    chatbots: Chatbot;
  }[] | null;
}

export default function RoomPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  
  const params = useParams();
  const roomId = params?.roomId as string;
  const router = useRouter();
  const supabase = createClient();

  const fetchRoomData = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Get user role
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (!profile) throw new Error('User profile not found');
      setUserRole(profile.role);

      // First, ensure we have access to this room
      let hasAccess = false;
      if (profile.role === 'teacher') {
        // For teachers, check if they own the room
        const { data: teacherRoom } = await supabase
          .from('rooms')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('teacher_id', user.id)
          .single();
        
        hasAccess = !!teacherRoom;
      } else if (profile.role === 'student') {
        // For students, check if they're a member of the room
        const { data: membership } = await supabase
          .from('room_memberships')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('student_id', user.id)
          .single();
        
        hasAccess = !!membership;
      }

      if (!hasAccess) {
        throw new Error('You do not have access to this room');
      }

      // Get basic room info
      const { data: roomData, error: roomError } = await supabase
        .from('rooms')
        .select('*')
        .eq('room_id', roomId)
        .single();

      if (roomError || !roomData) {
        throw new Error('Room not found');
      }

      // Retrieve chatbots using a two-step process to bypass potential RLS issues
      // Step 1: Get chatbot IDs for this room
      const { data: roomChatbots, error: rcError } = await supabase
        .from('room_chatbots')
        .select('chatbot_id')
        .eq('room_id', roomId);

      if (rcError) {
        console.error('Error fetching room-chatbot relations:', rcError);
        throw new Error('Failed to retrieve chatbot information');
      }

      // Step 2: Get the chatbot details
      const extractedChatbots: Chatbot[] = [];
      
      if (roomChatbots && roomChatbots.length > 0) {
        const chatbotIds = roomChatbots.map(rc => rc.chatbot_id);
        
        const { data: chatbots, error: chatbotsError } = await supabase
          .from('chatbots')
          .select('*')
          .in('chatbot_id', chatbotIds);

        if (chatbotsError) {
          console.error('Error fetching chatbots:', chatbotsError);
          throw new Error('Failed to retrieve chatbot information');
        }
        
        extractedChatbots.push(...(chatbots || []));
      }
      
      // Set the state variables
      setRoom({
        ...roomData,
        room_chatbots: []
      } as RoomQueryResult);
      setChatbots(extractedChatbots);
    } catch (err) {
      console.error('Error in fetchRoomData:', err);
      setError(err instanceof Error ? err.message : 'Failed to load room');
    } finally {
      setLoading(false);
    }
  }, [roomId, supabase]);

  useEffect(() => {
    if (roomId) {
      fetchRoomData();
    }
  }, [roomId, fetchRoomData]);

  const handleBack = () => {
    if (userRole === 'teacher') {
      router.push('/teacher-dashboard');
    } else {
      router.push('/student');
    }
  };

  const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
      'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
      'google/gemma-3-27b-it:free': 'Gemma 3 27B',
      'microsoft/phi-4-reasoning-plus:free': 'Phi 4 Reasoning',
      'qwen/qwen3-32b:free': 'Qwen3 32B',
      'qwen/qwen3-235b-a22b:free': 'Qwen3 235B'
    };
    return modelNames[model] || model;
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <Card>Loading room...</Card>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Dashboard
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!room) {
    return null;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>
              {chatbots.length === 0 ? 'No chatbots available' : 
               chatbots.length === 1 ? '1 chatbot available' :
               `${chatbots.length} chatbots available`}
            </p>
            <div className="room-code">Room Code: {room.room_code}</div>
          </RoomInfo>
          <BackButton onClick={handleBack}>
            ← Back
          </BackButton>
        </Header>

        {chatbots.length === 0 ? (
          <EmptyState>
            <h3>No Chatbots Available</h3>
            <p>This room doesn&apos;t have any chatbots assigned yet.</p>
            {userRole === 'teacher' && (
              <p>Go back to the dashboard to assign chatbots to this room.</p>
            )}
          </EmptyState>
        ) : (
          <ChatbotGrid>
            {chatbots.map((chatbot) => (
              <Link 
                key={chatbot.chatbot_id} 
                href={`/chat/${roomId}?chatbot=${chatbot.chatbot_id}`}
                style={{ textDecoration: 'none' }}
              >
                <ChatbotCard>
                  <h3>{chatbot.name}</h3>
                  <p>{chatbot.description || 'No description'}</p>
                  
                  <div className="model-info">
                    {getModelDisplayName(chatbot.model)}
                  </div>
                  
                  <Button 
                    className="chat-button"
                    as="div"  // Prevent double link
                  >
                    Start Chat
                  </Button>
                </ChatbotCard>
              </Link>
            ))}
          </ChatbotGrid>
        )}
        
        {/* Student list section - only visible to teachers */}
        {userRole === 'teacher' && (
          <StudentList roomId={roomId} />
        )}
      </Container>
    </PageWrapper>
  );
}// src/app/magic-link/page.tsx
'use client';

import MagicLink from '@/components/auth/MagicLink';
import { Container } from '@/styles/StyledComponents';

export default function MagicLinkPage() {
  return (
    <Container>
      <MagicLink />
    </Container>
  );
}// src/app/join/page.tsx
'use client';

import { useState, useEffect, useCallback, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Input, Alert } from '@/styles/StyledComponents';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const JoinCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

function JoinPageContent() {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userRole, setUserRole] = useState<string | null>(null);
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const checkAuthentication = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      setIsAuthenticated(true);
      
      // Get user role
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
      
      if (profile) {
        setUserRole(profile.role);
      }
    }
  }, [supabase]);

  useEffect(() => {
    // Get room code from URL parameter
    const codeFromUrl = searchParams?.get('code');
    if (codeFromUrl) {
      setRoomCode(codeFromUrl.toUpperCase());
    }
    
    checkAuthentication();
  }, [searchParams, checkAuthentication]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    const formattedCode = roomCode.toUpperCase();

    try {
      // Check if the room exists first
      const { data: room, error: roomError } = await supabase
        .from('rooms')
        .select('room_id, is_active')
        .eq('room_code', formattedCode)
        .single();

      if (roomError || !room) {
        throw new Error('Room not found');
      }

      if (!room.is_active) {
        throw new Error('Room is inactive');
      }

      if (isAuthenticated && userRole === 'student') {
        // If already authenticated as student, try to join directly
        const response = await fetch('/api/student/join-room', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ room_code: formattedCode }),
        });

        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to join room');
        }

        // Redirect to student dashboard
        router.push('/student');
      } else if (!isAuthenticated) {
        // If not authenticated, redirect to student signup with room code
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
      } else {
        // If authenticated but not a student, show error
        throw new Error('You need to log in with a student account to join this room.');
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to join room');
    } finally {
      setIsLoading(false);
    }
  };

  if (!isAuthenticated) {
    return (
      <PageWrapper>
        <Container>
          <JoinCard>
            <Title>Join Your Class</Title>
            <Text>You need to create a student account to join this classroom.</Text>
            
            <Button 
              onClick={() => router.push(`/auth?type=student&redirect=/join?code=${roomCode}`)}
              style={{ width: '100%' }}
            >
              Create Student Account
            </Button>
            
            {roomCode && (
              <Text style={{ marginTop: '1rem', fontSize: '0.875rem' }}>
                Room code: <strong>{roomCode}</strong>
              </Text>
            )}
          </JoinCard>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <JoinCard>
          <Title>Join Your Class</Title>
          <Text>Enter the room code your teacher provided</Text>
          
          {error && <Alert variant="error">{error}</Alert>}
          
          <Form onSubmit={handleSubmit}>
            <RoomCodeInput
              type="text"
              value={roomCode}
              onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
              placeholder="ROOM CODE"
              maxLength={6}
              required
            />
            <Button type="submit" disabled={isLoading} style={{ width: '100%' }}>
              {isLoading ? 'Joining...' : 'Join Class'}
            </Button>
          </Form>
        </JoinCard>
      </Container>
    </PageWrapper>
  );
}

export default function JoinPage() {
  return (
    <Suspense fallback={<LoadingFallback>Loading...</LoadingFallback>}>
      <JoinPageContent />
    </Suspense>
  );
}// src/app/chat/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Alert } from '@/styles/StyledComponents';
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.75rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: {
    chatbots: Chatbot;
  }[] | null;
}

export default function ChatPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const searchParams = useSearchParams();
  const roomId = params?.roomId as string;
  const chatbotId = searchParams.get('chatbot');
  const router = useRouter();
  const supabase = createClient();

  const fetchRoomData = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Get user role
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (!profile) throw new Error('User profile not found');

      // Fetch room data with chatbots
      const { data: roomData, error: roomError } = await supabase
        .from('rooms')
        .select(`
          *,
          room_chatbots!left(
            chatbots!inner(
              chatbot_id,
              name,
              description,
              system_prompt,
              model,
              max_tokens,
              temperature
            )
          )
        `)
        .eq('room_id', roomId)
        .single();

      if (roomError) {
        console.error('Room error:', roomError);
        throw new Error('Room not found');
      }

      if (!roomData) {
        throw new Error('Room not found');
      }

      // Check access permissions
      if (profile.role === 'student') {
        const { data: membership } = await supabase
          .from('room_memberships')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('student_id', user.id)
          .single();

        if (!membership) {
          throw new Error('You do not have access to this room');
        }
      } else if (profile.role === 'teacher') {
        if (roomData.teacher_id !== user.id) {
          throw new Error('You do not own this room');
        }
      }

      const typedRoomData = roomData as RoomQueryResult;
      setRoom(typedRoomData);

      // Extract chatbot data
      const fetchedChatbots = (typedRoomData.room_chatbots
        ?.map(rc => rc.chatbots)
        .filter(Boolean)) as Chatbot[];
      
      // Find the specific chatbot if chatbotId is provided
      if (chatbotId && fetchedChatbots) {
        const selectedChatbot = fetchedChatbots.find(cb => cb.chatbot_id === chatbotId);
        if (selectedChatbot) {
          setChatbot(selectedChatbot);
        } else {
          throw new Error('Chatbot not found in this room');
        }
      } else if (fetchedChatbots?.length > 0 && !chatbotId) {
        // No chatbot specified, redirect to room page
        router.replace(`/room/${roomId}`);
        return;
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load room');
    } finally {
      setLoading(false);
    }
  }, [roomId, chatbotId, router, supabase]);

  useEffect(() => {
    if (roomId) {
      fetchRoomData();
    }
  }, [roomId, fetchRoomData]);

  const handleBack = () => {
    // Always go back to the room page, regardless of user role
    router.push(`/room/${roomId}`);
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <Card>Loading...</Card>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Room
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!room || !chatbot) {
    return null;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>Chatting with {chatbot.name}</p>
          </RoomInfo>
          <BackButton onClick={handleBack}>
            ← Back to Room
          </BackButton>
        </Header>
        
        <Chat 
          roomId={roomId}
          chatbot={chatbot}
        />
      </Container>
    </PageWrapper>
  );
}// src/app/auth/callback/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const code = searchParams.get('code');

  if (code) {
    const supabase = await createServerSupabaseClient();
    const { error } = await supabase.auth.exchangeCodeForSession(code);
    
    if (error) {
      console.error('Error exchanging code for session:', error);
      return NextResponse.redirect(new URL('/auth', request.url));
    }
    
    // Get user data to determine redirect
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      // Wait for profile to be created by trigger
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
      
      // Get redirect URL from query params or use role-based default
      const redirectTo = searchParams.get('redirect');
      
      if (redirectTo) {
        return NextResponse.redirect(new URL(redirectTo, request.url));
      }
      
      // Role-based redirect
      if (profile?.role === 'teacher') {
        return NextResponse.redirect(new URL('/teacher-dashboard', request.url));
      } else if (profile?.role === 'student') {
        return NextResponse.redirect(new URL('/student', request.url));
      }
    }
  }

  // Default redirect if no specific route
  return NextResponse.redirect(new URL('/', request.url));
}// src/app/auth/page.tsx
'use client';

import { useState, Suspense } from 'react';
import styled from 'styled-components';
import { useSearchParams } from 'next/navigation';
import AuthForm from '@/components/auth/AuthForm';
import { Container } from '@/styles/StyledComponents';

const AuthPage = styled.div`
  padding: ${({ theme }) => theme.spacing.xl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const ToggleButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  margin-top: ${({ theme }) => theme.spacing.md};
  text-align: center;
  display: block;
  width: 100%;

  &:hover {
    text-decoration: underline;
  }
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

// Separate component for content that uses search params
function AuthContent() {
  const searchParams = useSearchParams();
  const isStudentSignup = searchParams?.get('type') === 'student';
  const [authType, setAuthType] = useState<'login' | 'signup'>(isStudentSignup ? 'signup' : 'login');

  return (
    <>
      <AuthForm type={authType} />
      <ToggleButton onClick={() => setAuthType(authType === 'login' ? 'signup' : 'login')}>
        {authType === 'login' ? 'Need an account? Sign up' : 'Already have an account? Login'}
      </ToggleButton>
    </>
  );
}

export default function Auth() {
  return (
    <AuthPage>
      <Container>
        <Suspense fallback={<LoadingFallback>Loading...</LoadingFallback>}>
          <AuthContent />
        </Suspense>
      </Container>
    </AuthPage>
  );
}// src/app/student/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';

const StudentLayout = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`;

export default function StudentLayoutWrapper({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkAccess = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
          router.push('/join');
          return;
        }

        // Fetch user profile to check role
        const { data: profile, error } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', user.id)
          .single();

        if (error || !profile || profile.role !== 'student') {
          router.push('/');
          return;
        }

        setIsAuthorized(true);
      } catch (error) {
        console.error('Error checking access:', error);
        router.push('/join');
      } finally {
        setIsLoading(false);
      }
    };

    checkAccess();
  }, [router, supabase]);

  if (isLoading) {
    return (
      <LoadingOverlay>
        <div>Loading...</div>
      </LoadingOverlay>
    );
  }

  if (!isAuthorized) {
    return null; // Will redirect
  }

  return (
    <StudentLayout>
      <MainContent>
        <Container>
          {children}
        </Container>
      </MainContent>
      <Footer />
    </StudentLayout>
  );
}// src/app/student/page.tsx - Modified version
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import RoomList from '@/components/student/RoomList';
import JoinRoom from '@/components/student/JoinRoom';
import type { StudentRoom } from '@/types/student.types';
import type { User } from '@supabase/supabase-js';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const Hero = styled.section`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl} 0;
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.primary};
  font-size: 3rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const CTAButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const Actions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
`;

export default function StudentPage() {
  const [user, setUser] = useState<User | null>(null);
  const [rooms, setRooms] = useState<StudentRoom[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showJoinRoom, setShowJoinRoom] = useState(false);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  const fetchRooms = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Check if user is a teacher, if so redirect
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
      
      // If user is a teacher, redirect to teacher dashboard
      if (profile?.role === 'teacher') {
        setIsRedirecting(true);
        router.push('/teacher-dashboard');
        return;
      }

      const response = await fetch('/api/student/rooms');
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to fetch rooms');
      }

      setRooms(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch rooms');
    } finally {
      setLoading(false);
    }
  }, [supabase, router]);

  useEffect(() => {
    const checkUserAndRedirect = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        setUser(user);
        
        if (user) {
          setIsRedirecting(true);
          
          // Get user profile to check role
          const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
          
          if (profile?.role === 'teacher') {
            router.push('/teacher-dashboard');
          } else {
            fetchRooms();
          }
        }
      } catch (error) {
        console.error('Error checking user:', error);
      } finally {
        setLoading(false);
        setIsRedirecting(false);
      }
    };

    checkUserAndRedirect();
  }, [router, supabase, fetchRooms]);

  if (loading || isRedirecting) {
    return (
      <PageWrapper>
        <Container>
          <Hero>
            <Title>Loading...</Title>
          </Hero>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Hero>
          <Title>ClassBots AI</Title>
          <Subtitle>AI-powered chatbots for modern classrooms</Subtitle>
          
          {!user && (
            <CTAButtons>
              <Button size="large" onClick={() => router.push('/auth')}>
                Teacher Sign In
              </Button>
              <Button size="large" variant="secondary" onClick={() => router.push('/join')}>
                Student: Join Class
              </Button>
            </CTAButtons>
          )}
        </Hero>

        {error && <Alert variant="error">{error}</Alert>}

        {user && (
          <Actions>
            <Button onClick={() => setShowJoinRoom(true)}>
              Join New Room
            </Button>
          </Actions>
        )}

        {showJoinRoom && (
          <JoinRoom 
            onClose={() => setShowJoinRoom(false)}
            onSuccess={fetchRooms}
          />
        )}

        {user && rooms.length > 0 ? (
          <RoomList rooms={rooms} />
        ) : user ? (
          <EmptyState>
            <h3>No Rooms Yet</h3>
            <p>You haven&apos;t joined any classrooms yet.</p>
            <Button onClick={() => setShowJoinRoom(true)}>
              Join Your First Room
            </Button>
          </EmptyState>
        ) : null}
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient as createStandardSupabaseClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';
import TeacherNav from '@/components/teacher/TeacherNav';

const DashboardLayoutContainer = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0; 
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.textLight};
  z-index: 1000;
`;

type AuthStatus = 'loading' | 'authorized' | 'unauthorized';

export default function TeacherDashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [authStatus, setAuthStatus] = useState<AuthStatus>('loading');
  const router = useRouter();
  const supabase = createStandardSupabaseClient();

  useEffect(() => {
    console.log('[TDL] useEffect for auth check triggered.');

    const checkAuth = async (sessionUser: User | null) => {
      if (sessionUser) {
        console.log('[TDL] User found. Fetching profile for user_id:', sessionUser.id);
        try {
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', sessionUser.id)
            .single();

          if (profileError) {
            console.error('[TDL] Profile fetch error:', profileError.message, 'Redirecting to /auth.');
            setAuthStatus('unauthorized');
            router.push('/auth');
          } else if (profile && profile.role === 'teacher') {
            console.log('[TDL] User is teacher. Authorized.');
            setAuthStatus('authorized');
          } else {
            console.log('[TDL] User is not teacher or profile missing. Unauthorized. Redirecting to /.');
            setAuthStatus('unauthorized');
            router.push('/');
          }
        } catch (e) {
          console.error('[TDL] Exception during profile fetch:', e, 'Redirecting to /auth.');
          setAuthStatus('unauthorized');
          router.push('/auth');
        }
      } else {
        console.log('[TDL] No user in session. Unauthorized. Redirecting to /auth.');
        setAuthStatus('unauthorized');
        router.push('/auth');
      }
    };

    // Initial check
    supabase.auth.getSession().then(({ data: { session } }) => {
        console.log('[TDL] Initial getSession result:', session);
        // Only process if onAuthStateChange hasn't already set a definitive state
        if (authStatus === 'loading') { // Check current authStatus
            checkAuth(session?.user || null);
        }
    });
    
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log(`[TDL] onAuthStateChange event: ${event}`, session);
        // Re-check auth whenever the state changes
        // This will also handle the INITIAL_SESSION event which is often the first one on load
        checkAuth(session?.user || null);
      }
    );

    return () => {
      console.log('[TDL] Unsubscribing from onAuthStateChange.');
      authListener.subscription?.unsubscribe();
    };
  }, [router, supabase, authStatus]); // Added authStatus to deps to re-evaluate if it changes to loading by another means

  console.log('[TDL] Render. AuthStatus:', authStatus);

  if (authStatus === 'loading') {
    return (
      <LoadingOverlay>
        <div>Loading Teacher Dashboard (Auth)...</div>
      </LoadingOverlay>
    );
  }

  if (authStatus === 'unauthorized') {
    console.log('[TDL] Rendering null because unauthorized (redirect initiated).');
    return null; 
  }

  // authStatus === 'authorized'
  console.log('[TDL] Rendering dashboard content.');
  return (
    <DashboardLayoutContainer>
      <Container>
        <TeacherNav />
        <MainContent>
            {children}
        </MainContent>
      </Container>
      <Footer />
    </DashboardLayoutContainer>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/edit/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useParams, useRouter } from 'next/navigation';
import styled from 'styled-components';
import { Container, Card, Button, FormGroup, Label, Input, TextArea, Alert } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Chatbot } from '@/types/database.types';
import type { Document as KnowledgeDocument } from '@/types/knowledge-base.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const BackButton = styled(Button)`
  margin-right: ${({ theme }) => theme.spacing.lg};
`;

const EditForm = styled.form`
  width: 100%;
  max-width: 600px;
  margin: 0 auto;
`;

const Select = styled.select`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
  }
`;

const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.sm};
`;

const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.xl} 0;
`;

const SectionTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

export default function EditChatbot() {
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [loading, setLoading] = useState(true);
  const [docsLoading, setDocsLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  const fetchChatbot = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) return;

      const { data, error } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', chatbotId)
        .eq('teacher_id', user.id)
        .single();

      if (error) throw error;
      if (!data) throw new Error('Chatbot not found');

      setChatbot(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load chatbot');
    } finally {
      setLoading(false);
    }
  }, [chatbotId, supabase]);

  const fetchDocuments = useCallback(async () => {
    try {
      setDocsLoading(true);
      setError(null);
      
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/documents`);
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch documents');
      }
      
      const data = await response.json();
      setDocuments(data);
    } catch (err) {
      console.error('Error fetching documents:', err);
      // Don't set error to not disrupt the main form
    } finally {
      setDocsLoading(false);
    }
  }, [chatbotId]);

  useEffect(() => {
    fetchChatbot();
    fetchDocuments();
  }, [fetchChatbot, fetchDocuments]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!chatbot) return;

    setSaving(true);
    setError(null);

    try {
      const { error } = await supabase
        .from('chatbots')
        .update({
          name: chatbot.name,
          description: chatbot.description,
          system_prompt: chatbot.system_prompt,
          model: chatbot.model,
          max_tokens: chatbot.max_tokens,
          temperature: chatbot.temperature,
          enable_rag: chatbot.enable_rag || false
        })
        .eq('chatbot_id', chatbot.chatbot_id);

      if (error) throw error;

      router.push('/teacher-dashboard');
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update chatbot');
    } finally {
      setSaving(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    if (!chatbot) return;

    setChatbot(prev => ({
      ...prev!,
      [name]: name === 'max_tokens' || name === 'temperature' ? Number(value) : value,
    }));
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    if (!chatbot) return;

    setChatbot(prev => ({
      ...prev!,
      [name]: checked,
    }));
  };

  const handleProcessDocument = async (documentId: string) => {
    try {
      setError(null);
      
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ documentId }),
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to process document');
      }
      
      // Update document status in the list
      setDocuments(prevDocs => 
        prevDocs.map(doc => 
          doc.document_id === documentId 
            ? { ...doc, status: 'processing' } 
            : doc
        )
      );
      
      // Show processing status
      setViewingDocumentId(documentId);
    } catch (err) {
      console.error('Error processing document:', err);
      // Don't set main error to not disrupt the form
    }
  };

  const handleDeleteDocument = async (documentId: string) => {
    try {
      setError(null);
      
      const response = await fetch(
        `/api/teacher/chatbots/${chatbotId}/documents/${documentId}`,
        { method: 'DELETE' }
      );
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to delete document');
      }
      
      // Remove document from list
      setDocuments(prevDocs => 
        prevDocs.filter(doc => doc.document_id !== documentId)
      );
      
      // If currently viewing this document, clear it
      if (viewingDocumentId === documentId) {
        setViewingDocumentId(null);
      }
    } catch (err) {
      console.error('Error deleting document:', err);
      // Don't set main error to not disrupt the form
    }
  };

  const getViewingDocument = () => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <Card>Loading chatbot...</Card>
        </Container>
      </PageWrapper>
    );
  }

  if (!chatbot) {
    return (
      <PageWrapper>
        <Container>
          <Card>Chatbot not found</Card>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <div>
            <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard')}>
              ← Back to Dashboard
            </BackButton>
          </div>
        </Header>

        <Card>
          <h2 style={{ marginBottom: '24px' }}>Edit Chatbot</h2>
          
          {error && <Alert variant="error">{error}</Alert>}

          <EditForm onSubmit={handleSubmit}>
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input
                id="name"
                name="name"
                value={chatbot.name}
                onChange={handleChange}
                required
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input
                id="description"
                name="description"
                value={chatbot.description || ''}
                onChange={handleChange}
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="system_prompt">System Prompt</Label>
              <TextArea
                id="system_prompt"
                name="system_prompt"
                value={chatbot.system_prompt}
                onChange={handleChange}
                required
                rows={4}
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="model">AI Model</Label>        

              <Select
                  id="model"
                  name="model"
                  value={chatbot.model || ''}
                  onChange={handleChange}
              >
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta (Paid)</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B (Free)</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
              </Select>
            </FormGroup>

            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens</Label>
              <Input
                id="max_tokens"
                name="max_tokens"
                type="number"
                value={chatbot.max_tokens || ''}
                onChange={handleChange}
                min="100"
                max="4000"
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="temperature">Temperature</Label>
              <Input
                id="temperature"
                name="temperature"
                type="number"
                value={chatbot.temperature || ''}
                onChange={handleChange}
                min="0"
                max="2"
                step="0.1"
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="enable_rag">Knowledge Base</Label>
              <CheckboxGroup>
                <input
                  id="enable_rag"
                  name="enable_rag"
                  type="checkbox"
                  checked={chatbot.enable_rag || false}
                  onChange={handleCheckboxChange}
                />
                <span>Enable knowledge base for this chatbot</span>
              </CheckboxGroup>
              <HelpText>
                When enabled, the chatbot will use documents you&apos;ve uploaded to enhance its responses.
              </HelpText>
            </FormGroup>

            <Button type="submit" disabled={saving} style={{ width: '100%' }}>
              {saving ? 'Saving...' : 'Save Changes'}
            </Button>
          </EditForm>
          
          <Divider />
          
          <SectionTitle>Knowledge Base Documents</SectionTitle>
          <p>Upload documents to train your chatbot with specific knowledge.</p>
          
          <DocumentUploader 
            chatbotId={chatbotId} 
            onUploadSuccess={fetchDocuments} 
          />
          
          {getViewingDocument() && (
            <EmbeddingStatus 
              document={getViewingDocument()!} 
              chatbotId={chatbotId}
              onRefresh={fetchDocuments}
            />
          )}
          
          {docsLoading ? (
            <p>Loading documents...</p>
          ) : (
            <DocumentList 
              documents={documents}
              onProcessDocument={handleProcessDocument}
              onDeleteDocument={handleDeleteDocument}
              onViewStatus={setViewingDocumentId}
            />
          )}
        </Card>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/knowledge-base/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import { Document } from '@/types/knowledge-base.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    align-items: flex-start;
  }
`;

const BackButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    font-size: 1.5rem;
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
`;

export default function KnowledgeBasePage() {
  const [documents, setDocuments] = useState<Document[]>([]);
  const [chatbotName, setChatbotName] = useState<string>('');
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  const fetchChatbotInfo = useCallback(async () => {
    try {
      const { data: chatbot, error: chatbotError } = await supabase
        .from('chatbots')
        .select('name')
        .eq('chatbot_id', chatbotId)
        .single();

      if (chatbotError) throw chatbotError;
      if (chatbot) setChatbotName(chatbot.name);
    } catch (err) {
      console.error('Error fetching chatbot info:', err);
      setError('Failed to fetch chatbot information');
    }
  }, [chatbotId, supabase]);

  const fetchDocuments = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/documents`);
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch documents');
      }
      
      const data = await response.json();
      setDocuments(data);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch documents');
    } finally {
      setLoading(false);
    }
  }, [chatbotId]);

  useEffect(() => {
    fetchChatbotInfo();
    fetchDocuments();
  }, [fetchChatbotInfo, fetchDocuments]);

  const handleProcessDocument = async (documentId: string) => {
    try {
      setError(null);
      
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ documentId }),
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to process document');
      }
      
      // Update document status in the list
      setDocuments(prevDocs => 
        prevDocs.map(doc => 
          doc.document_id === documentId 
            ? { ...doc, status: 'processing' } 
            : doc
        )
      );
      
      // Show processing status
      setViewingDocumentId(documentId);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to process document');
    }
  };

  const handleDeleteDocument = async (documentId: string) => {
    try {
      setError(null);
      
      const response = await fetch(
        `/api/teacher/chatbots/${chatbotId}/documents/${documentId}`,
        { method: 'DELETE' }
      );
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to delete document');
      }
      
      // Remove document from list
      setDocuments(prevDocs => 
        prevDocs.filter(doc => doc.document_id !== documentId)
      );
      
      // If currently viewing this document, clear it
      if (viewingDocumentId === documentId) {
        setViewingDocumentId(null);
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete document');
    }
  };

  const getViewingDocument = () => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  return (
    <PageWrapper>
      <Container>
        <Header>
          <Title>Knowledge Base: {chatbotName}</Title>
          <BackButton 
            variant="outline" 
            onClick={() => router.push('/teacher-dashboard')}
          >
            ← Back to Dashboard
          </BackButton>
        </Header>
        
        {error && <Alert variant="error">{error}</Alert>}
        
        <Card>
          <h2>Add Documents</h2>
          <p>Upload documents to train your chatbot with specific knowledge.</p>
          <DocumentUploader 
            chatbotId={chatbotId} 
            onUploadSuccess={fetchDocuments} 
          />
        </Card>
        
        {loading ? (
          <LoadingContainer>
            <p>Loading documents...</p>
          </LoadingContainer>
        ) : (
          <>
            <h2>Your Knowledge Base</h2>
            
            {getViewingDocument() && (
              <EmbeddingStatus 
                document={getViewingDocument()!} 
                chatbotId={chatbotId}
                onRefresh={fetchDocuments}
              />
            )}
            
            <DocumentList 
              documents={documents}
              onProcessDocument={handleProcessDocument}
              onDeleteDocument={handleDeleteDocument}
              onViewStatus={setViewingDocumentId}
            />
          </>
        )}
      </Container>
    </PageWrapper>
  );
}// src/app/api/teacher/chatbots/[chatbotId]/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface ContextParams {
    params: { chatbotId: string };
}

export async function GET(request: NextRequest, context: ContextParams) {
  const { chatbotId } = context.params; // Get chatbotId from dynamic route segment
  console.log(`[API /documents GET] Request for chatbotId: ${chatbotId}`);

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.log('[API /documents GET] Not authenticated');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a teacher and owns the chatbot
    // (We'll add the actual chatbot ownership check when the 'chatbots' table exists and has data)
    // For now, just check if the user is a teacher for basic auth.
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError || !profile || profile.role !== 'teacher') {
      console.log('[API /documents GET] Not authorized or profile error');
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }
    
    // TODO: Later, add a query to check if this teacher_id owns this chatbotId
    // const { data: chatbotOwner, error: ownerError } = await supabase
    //   .from('chatbots')
    //   .select('teacher_id')
    //   .eq('chatbot_id', chatbotId)
    //   .eq('teacher_id', user.id)
    //   .single();
    // if (ownerError || !chatbotOwner) {
    //   return NextResponse.json({ error: 'Chatbot not found or not owned by user' }, { status: 404 });
    // }


    console.log('[API /documents GET] Returning empty array for documents (placeholder).');
    // For now, since the 'documents' table doesn't exist yet,
    // return an empty array to satisfy the frontend component.
    return NextResponse.json([]);

  } catch (error) {
    console.error('[API /documents GET] Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch documents' },
      { status: 500 }
    );
  }
}

// We will add POST and DELETE methods here later when we build document functionality.// src/app/teacher-dashboard/chatbots/[chatbotId]/test-chat/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Alert, Button as StyledButton } from '@/styles/StyledComponents'; // Renamed Button to avoid conflict
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: calc(100vh - 120px); // Adjust based on your header/footer height
  display: flex;
  flex-direction: column;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const ChatbotInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.75rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
    margin: 0;
  }
`;

const BackButton = styled(StyledButton)`
  // specific styles if needed
`;


export default function TestChatPage() {
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  // Define a consistent "dummy" room ID for teacher test chats for this chatbot
  // This allows message history to be segmented per chatbot test.
  const testRoomId = `teacher_test_room_for_${chatbotId}`;

  const fetchChatbotData = useCallback(async () => {
    if (!chatbotId) {
      setError("Chatbot ID is missing.");
      setLoading(false);
      return;
    }
    console.log(`[TestChatPage] Fetching chatbot data for ID: ${chatbotId}`);
    setLoading(true);
    setError(null);
    try {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        throw new Error('Not authenticated. Please log in.');
      }

      // Fetch the specific chatbot details, ensuring the teacher owns it
      const { data: chatbotData, error: chatbotError } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', chatbotId)
        .eq('teacher_id', user.id) // Important: Ensure teacher owns this chatbot
        .single();

      if (chatbotError) {
        console.error('[TestChatPage] Error fetching chatbot:', chatbotError);
        throw new Error(chatbotError.message || 'Failed to fetch chatbot details.');
      }
      if (!chatbotData) {
        throw new Error('Chatbot not found or you do not have permission to access it.');
      }
      console.log('[TestChatPage] Chatbot data fetched:', chatbotData);
      setChatbot(chatbotData);
    } catch (err) {
      console.error('[TestChatPage] CATCH Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to load chatbot for testing.');
    } finally {
      setLoading(false);
    }
  }, [chatbotId, supabase]);

  useEffect(() => {
    fetchChatbotData();
  }, [fetchChatbotData]);

  const handleBack = () => {
    router.push('/teacher-dashboard/chatbots'); // Go back to the chatbots list
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
          <LoadingSpinner size="large" />
          <p style={{ marginTop: '16px' }}>Loading chatbot for testing...</p>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!chatbot) {
    // This case should ideally be caught by the error state if fetch fails
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Chatbot not available for testing.</Alert>
           <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
        <Header>
          <ChatbotInfo>
            <h1>Test: {chatbot.name}</h1>
            <p>You are interacting with your chatbot for testing purposes.</p>
          </ChatbotInfo>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Header>
        
        {/* 
          The Chat component needs a roomId. We'll use our dummy testRoomId.
          The Chat component also expects a full Chatbot object.
        */}
        <Chat 
          roomId={testRoomId} 
          chatbot={chatbot} 
        />
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Button, Alert, Card } from '@/styles/StyledComponents';
import ChatbotList from '@/components/teacher/ChatbotList';
import ChatbotForm from '@/components/teacher/ChatbotForm'; // For the modal
// import DeleteModal from '@/components/teacher/DeleteModal'; // We'll integrate delete later
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  font-size: 1.8rem;
`;

export default function ChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  // const [deleteInfo, setDeleteInfo] = useState<{ id: string; name: string } | null>(null);
  const router = useRouter();

  const fetchChatbots = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/teacher/chatbots');
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${response.status})`);
      }
      const data: Chatbot[] = await response.json();
      setChatbots(data);
    } catch (err) {
      console.error("Error fetching chatbots:", err);
      setError(err instanceof Error ? err.message : 'Could not load chatbots.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchChatbots(); // Refresh the list
  };

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbot = async (chatbotId: string, chatbotName: string) => {
    // For now, just a confirm. We will integrate DeleteModal later.
    if (window.confirm(`Are you sure you want to delete chatbot "${chatbotName}"? This will also delete associated documents.`)) {
      try {
        // We'll need a DELETE API route: /api/teacher/chatbots/[chatbotId]
        // const response = await fetch(`/api/teacher/chatbots/${chatbotId}`, { method: 'DELETE' });
        // if (!response.ok) throw new Error('Failed to delete chatbot');
        alert(`DELETE /api/teacher/chatbots/${chatbotId} would be called. Feature to be fully implemented.`);
        // fetchChatbots(); // Refresh list
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to delete chatbot.');
      }
    }
  };

  return (
    <div>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={() => setShowChatbotForm(true)}>+ Create Chatbot</Button>
      </PageHeader>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading chatbots...</Card>
      ) : (
        <ChatbotList
          chatbots={chatbots}
          onEdit={handleEditChatbot}
          onDelete={handleDeleteChatbot}
        />
      )}

      {showChatbotForm && (
        <ChatbotForm
          onClose={() => setShowChatbotForm(false)}
          onSuccess={handleChatbotCreated}
        />
      )}

      {/* {deleteInfo && (
        <DeleteModal
          itemType="Chatbot"
          itemName={deleteInfo.name}
          onConfirm={() => {
            // actual delete logic
            setDeleteInfo(null);
          }}
          onCancel={() => setDeleteInfo(null)}
          isDeleting={false} // manage this state
        />
      )} */}
    </div>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation'; // << IMPORTED
import { Button, Alert, Card } from '@/styles/StyledComponents';
import ChatbotList from '@/components/teacher/ChatbotList';
import ChatbotForm from '@/components/teacher/ChatbotForm';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  /* Add any specific page padding if needed, or let Container in layout handle it */
`;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap; 
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem; 
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

export default function ManageChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  const router = useRouter(); // << INITIALIZED ROUTER

  const fetchChatbots = useCallback(async () => {
    console.log('[ChatbotsPage] Fetching chatbots...');
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/teacher/chatbots');
      if (!response.ok) {
        const errData = await response.json().catch(() => ({ error: 'Server error' }));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${response.status})`);
      }
      const data: Chatbot[] = await response.json();
      console.log('[ChatbotsPage] Chatbots fetched:', data);
      setChatbots(data);
    } catch (err) {
      console.error("[ChatbotsPage] Error fetching chatbots:", err);
      setError(err instanceof Error ? err.message : 'Could not load your chatbots.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleChatbotCreated = (chatbotId: string) => { // << ACCEPTS chatbotId
    console.log('[ChatbotsPage] Chatbot created with ID:', chatbotId, 'Navigating to edit page.');
    setShowChatbotForm(false);
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`); // << REDIRECT
  };

  const handleEditChatbot = (chatbotId: string) => {
    console.log('[ChatbotsPage] Navigating to edit chatbot:', chatbotId);
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbot = async (chatbotId: string, chatbotName: string) => {
    if (window.confirm(`Are you sure you want to delete the chatbot "${chatbotName}"? This will also delete associated documents and knowledge base entries.`)) {
      console.log(`[ChatbotsPage] Deleting chatbot (placeholder): ${chatbotId} - ${chatbotName}`);
      // TODO: Implement API call to DELETE /api/teacher/chatbots/[chatbotId]
      // This will require a new API route: src/app/api/teacher/chatbots/[chatbotId]/route.ts
      alert(`Placeholder: Chatbot "${chatbotName}" would be deleted. API DELETE endpoint needs to be implemented.`);
      // Example:
      // try {
      //   const response = await fetch(`/api/teacher/chatbots/${chatbotId}`, { method: 'DELETE' });
      //   if (!response.ok) {
      //     const errData = await response.json().catch(() => ({}));
      //     throw new Error(errData.error || 'Failed to delete chatbot');
      //   }
      //   fetchChatbots(); // Refresh list
      // } catch (err) {
      //   setError(err instanceof Error ? err.message : 'Failed to delete chatbot.');
      // }
    }
  };

  return (
    <PageWrapper>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={() => setShowChatbotForm(true)}>+ Create New Chatbot</Button>
      </PageHeader>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner /> Loading your chatbots...
        </Card>
      ) : (
        <ChatbotList
          chatbots={chatbots}
          onEdit={handleEditChatbot}
          onDelete={handleDeleteChatbot}
        />
      )}

      {showChatbotForm && (
        <ChatbotForm
          onClose={() => setShowChatbotForm(false)}
          onSuccess={handleChatbotCreated} // This now passes chatbotId to the handler
        />
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
// import { useRouter } from 'next/navigation'; // << REMOVED UNUSED IMPORT
import { Button, Alert, Card } from '@/styles/StyledComponents';
import RoomList from '@/components/teacher/RoomList';
import RoomForm from '@/components/teacher/RoomForm';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import type { Room as BaseRoom, Chatbot, TeacherRoom } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div``;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

export default function ManageRoomsPage() {
  const [rooms, setRooms] = useState<TeacherRoom[]>([]);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null);
  // const router = useRouter(); // << REMOVED UNUSED VARIABLE

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [roomsResponse, chatbotsResponse] = await Promise.all([
        fetch('/api/teacher/rooms'),
        fetch('/api/teacher/chatbots') 
      ]);

      if (!roomsResponse.ok) {
        const errData = await roomsResponse.json().catch(()=>({}));
        throw new Error(errData.error || `Failed to fetch rooms (status ${roomsResponse.status})`);
      }
      if (!chatbotsResponse.ok) {
        const errData = await chatbotsResponse.json().catch(()=>({}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`);
      }

      const roomsData: TeacherRoom[] = await roomsResponse.json();
      const chatbotsData: Chatbot[] = await chatbotsResponse.json();
      
      setRooms(roomsData);
      setChatbots(chatbotsData);
    } catch (err) {
      console.error("Error fetching page data:", err);
      setError(err instanceof Error ? err.message : 'Could not load data.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleRoomCreatedOrUpdated = () => {
    setShowRoomForm(false);
    setEditingRoom(null);
    fetchData(); 
  };

  const handleDeleteRoom = async (room: BaseRoom) => {
     if (window.confirm(`Are you sure you want to delete room "${room.room_name}"? This will also delete associated student memberships and chat history.`)) {
        try {
            const response = await fetch(`/api/teacher/rooms/${room.room_id}`, { method: 'DELETE' });
            if (!response.ok) {
                const errData = await response.json().catch(()=>({}));
                throw new Error(errData.error || 'Failed to delete room');
            }
            fetchData(); 
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Failed to delete room.');
        }
    }
  };

  return (
    <PageWrapper>
      <PageHeader>
        <Title>Classroom Rooms</Title>
        <Button 
          onClick={() => setShowRoomForm(true)}
          disabled={chatbots.length === 0}
          title={chatbots.length === 0 ? "Create a chatbot before creating a room" : "Create New Room"}
        >
          + Create New Room
        </Button>
      </PageHeader>
      {chatbots.length === 0 && !isLoading && (
        <Alert variant='info' style={{marginBottom: '16px'}}>
            You need to create at least one chatbot before you can create a classroom room.
        </Alert>
      )}

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading rooms...</Card>
      ) : (
        <RoomList
          rooms={rooms}
          onUpdate={fetchData} 
          onEditRoom={setEditingRoom} 
          onDeleteRoom={handleDeleteRoom}
        />
      )}

      {showRoomForm && (
        <RoomForm
          chatbots={chatbots}
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreatedOrUpdated}
        />
      )}

      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={() => setEditingRoom(null)}
          onSuccess={handleRoomCreatedOrUpdated}
        />
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/page.tsx
'use client';

import styled from 'styled-components';
import DashboardOverview from '@/components/teacher/DashboardOverview'; // Import the new component

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 2rem;
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.125rem;
`;

export default function TeacherDashboardPage() {
  console.log('[TeacherDashboardPage] Rendering with DashboardOverview...');
  return (
    <div>
      <PageHeader>
        <Title>Teacher Dashboard</Title> {/* Kept general title */}
        <Subtitle>Welcome! Here&apos;s a summary of your ClassBots activities.</Subtitle>
      </PageHeader>
      <DashboardOverview /> {/* Use the new overview component */}
    </div>
  );
}// src/app/teacher-dashboard/concerns/[flagId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// Import necessary components and styles
import { Container, Card, Button, Alert, Badge, TextArea, Label, Select as StyledSelect } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types (ensure Profile includes full_name)
import type { FlaggedMessage, ConcernStatus, ChatMessage as DatabaseChatMessage, Profile, Room } from '@/types/database.types'; // Import necessary base types


// Interface for the data structure returned by the API GET request
// This includes the nested objects directly as returned by the join syntax used
// and the flattened fields for easier use, plus surroundingMessages
interface FlagDetailsResponse extends FlaggedMessage {
    student: Pick<Profile, 'full_name' | 'email'> | null; // Nested original
    room: Pick<Room, 'room_name'> | null; // Nested original
    message: DatabaseChatMessage | null; // Nested original
    student_name: string | null; // Flattened
    student_email: string | null; // Flattened
    room_name: string | null; // Flattened
    message_content: string | null; // Flattened
    surroundingMessages: DatabaseChatMessage[];
}


// --- Styled Components (Keep as previously defined) ---
const PageWrapper = styled.div` padding: ${({ theme }) => theme.spacing.xl} 0; min-height: 100vh; `;
const Header = styled.div` display: flex; justify-content: space-between; align-items: center; margin-bottom: ${({ theme }) => theme.spacing.xl}; flex-wrap: wrap; gap: ${({ theme }) => theme.spacing.md}; `;
const Title = styled.h1` color: ${({ theme }) => theme.colors.text}; margin: 0; font-size: 1.8rem; @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) { font-size: 1.5rem; } `;
const BackButton = styled(Button)``;
const Grid = styled.div` display: grid; grid-template-columns: 3fr 2fr; gap: ${({ theme }) => theme.spacing.xl}; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { grid-template-columns: 1fr; } `;
const ConversationContext = styled(Card)` max-height: 75vh; display: flex; flex-direction: column; overflow: hidden; `;
const ContextHeader = styled.h3` padding: 0 0 ${({ theme }) => theme.spacing.md} 0; margin: 0 0 ${({ theme }) => theme.spacing.md} 0; border-bottom: 1px solid ${({ theme }) => theme.colors.border}; font-size: 1.2rem; `;
const MessagesList = styled.div` flex: 1; overflow-y: auto; padding-right: ${({ theme }) => theme.spacing.sm}; margin-right: -${({ theme }) => theme.spacing.sm}; &::-webkit-scrollbar { width: 6px; } &::-webkit-scrollbar-thumb { background-color: ${({ theme }) => theme.colors.borderDark}; border-radius: 3px; } &::-webkit-scrollbar-track { background: transparent; } `;
const FlaggedMessageHighlight = styled.div` border: 3px solid ${({ theme }) => theme.colors.red}; border-radius: ${({ theme }) => theme.borderRadius.large}; margin: ${({ theme }) => theme.spacing.md} 0; background-color: rgba(248, 127, 127, 0.08); padding: 2px; & > div { margin-bottom: 0; } `;
const ConcernDetailsCard = styled(Card)` align-self: start; position: sticky; top: 80px; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { position: static; margin-top: ${({ theme }) => theme.spacing.xl}; } `;
const DetailsHeader = styled.h3` margin-bottom: ${({ theme }) => theme.spacing.lg}; font-size: 1.2rem; `;
const DetailItem = styled.div` margin-bottom: ${({ theme }) => theme.spacing.md}; font-size: 0.9rem; line-height: 1.5; strong { display: block; margin-bottom: ${({ theme }) => theme.spacing.xs}; color: ${({ theme }) => theme.colors.textLight}; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; } span, p { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; } p { margin-bottom: 0; } `;
const AnalysisText = styled.p` font-style: italic; color: ${({ theme }) => theme.colors.textLight}; background-color: ${({ theme }) => theme.colors.backgroundDark}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin-top: ${({ theme }) => theme.spacing.xs}; `;
const ActionForm = styled.form` margin-top: ${({ theme }) => theme.spacing.lg}; padding-top: ${({ theme }) => theme.spacing.lg}; border-top: 1px solid ${({ theme }) => theme.colors.border}; `;
const FormActions = styled.div` margin-top: ${({ theme }) => theme.spacing.lg}; `;
const CustomSelect = styled(StyledSelect)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; `; // Use imported Select
const StyledTextArea = styled(TextArea)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; min-height: 100px; `;
// --- End Styled Components ---

// --- Helper Functions ---
function getConcernTypeText(type: string | undefined): string { if (!type) return 'Unknown'; return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); }
function getConcernLevelText(level: number | undefined): string { if (level === undefined) return 'N/A'; if (level >= 5) return 'Critical'; if (level >= 4) return 'High'; if (level >= 3) return 'Significant'; if (level >= 2) return 'Moderate'; if (level >= 1) return 'Minor'; return 'Low'; }
// -----------------------

export default function ConcernDetailPage() {
    const [concern, setConcern] = useState<FlagDetailsResponse | null>(null); // Use the more specific type for fetched data
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [actionError, setActionError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [selectedStatus, setSelectedStatus] = useState<ConcernStatus>('pending');
    const [notes, setNotes] = useState('');

    const params = useParams();
    const router = useRouter();
    const flagId = params?.flagId as string;
    const flaggedMessageRef = useRef<HTMLDivElement>(null);

    const fetchConcernDetails = useCallback(async () => {
        if (!flagId) { setError("Flag ID missing from page parameters."); setLoading(false); return; }
        setLoading(true); setError(null); setActionError(null);
        try {
            console.log(`Fetching details for flag: ${flagId}`);
            // --- FIX: Fetch using query parameter to the collection route ---
            const response = await fetch(`/api/teacher/concerns?flagId=${flagId}`);
            // -------------------------------------------------------------
            if (!response.ok) {
                const data = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                throw new Error(data.error || `Failed to fetch concern details (status: ${response.status})`);
            }
            const data: FlagDetailsResponse = await response.json(); // Use the correct response type
            console.log("Fetched Concern Data:", data);
            setConcern(data);
            setSelectedStatus(data.status || 'pending');
            setNotes(data.notes || '');
        } catch (err) {
            console.error("Error fetching concern:", err);
            setError(err instanceof Error ? err.message : 'Failed to load concern details');
            setConcern(null);
        } finally { setLoading(false); }
    }, [flagId]); // Keep flagId as dependency

    useEffect(() => { fetchConcernDetails(); }, [fetchConcernDetails]);

    useEffect(() => {
        const timer = setTimeout(() => {
            if (concern && flaggedMessageRef.current) {
                console.log("Scrolling to flagged message ref");
                flaggedMessageRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
        return () => clearTimeout(timer);
    }, [concern]);

    const handleStatusUpdate = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!concern?.flag_id) return; // Ensure we have the concern and its ID

        setIsSubmitting(true); setActionError(null);
        try {
            console.log(`Updating flag ${concern.flag_id} with status ${selectedStatus}`);
            // --- FIX: Send PATCH to collection route, include flagId in body ---
            const response = await fetch(`/api/teacher/concerns`, { // Target the collection route
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    flagId: concern.flag_id, // Include flagId in the body
                    status: selectedStatus,
                    notes: notes
                 }),
            });
            // --- END FIX ---
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Update failed' }));
                throw new Error(errorData.error || 'Failed to update status');
            }

            const updatedData = await response.json();
            // Update state based on the response from the PATCH request
            setConcern(prev => prev ? ({ ...prev, ...updatedData }) : null);
            setSelectedStatus(updatedData.status);
            setNotes(updatedData.notes || '');
            alert("Status updated successfully!");

        } catch (err) {
            setActionError(err instanceof Error ? err.message : 'Failed to update status');
        } finally {
            setIsSubmitting(false);
        }
    };

    // --- Render Logic ---
    if (loading) { return <PageWrapper><Container><Card><LoadingSpinner /> Loading concern details...</Card></Container></PageWrapper>; }
    if (error) { return <PageWrapper><Container><Alert variant="error">{error}</Alert><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }
    if (!concern) { return <PageWrapper><Container><Card>Concern not found or permission denied.</Card><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }

    // Find the actual flagged message within the surrounding messages (if fetched) or use the direct message object
    const actualFlaggedMessage = concern.surroundingMessages?.find(m => m.message_id === concern.message_id) || concern.message;

    return (
        <PageWrapper>
            <Container>
                <Header>
                    <Title>Review Concern</Title>
                    <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard#concerns')}>← Back to Dashboard</BackButton>
                </Header>
                <Grid>
                    {/* Conversation Context */}
                    <ConversationContext>
                        <ContextHeader>Conversation Context</ContextHeader>
                        <MessagesList>
                            {concern.surroundingMessages?.length > 0 ? (
                                concern.surroundingMessages.map(msg => {
                                    const isFlagged = msg.message_id === concern.message_id;
                                    const chatbotName = concern.room_name || "Chatbot"; // Placeholder name

                                    const messageComponent = ( <ChatMessageComponent key={msg.message_id} message={msg} chatbotName={chatbotName} /> );
                                    return isFlagged ? ( <FlaggedMessageHighlight key={msg.message_id} ref={flaggedMessageRef}>{messageComponent}</FlaggedMessageHighlight> ) : messageComponent;
                                })
                            ) : ( actualFlaggedMessage ? ( <FlaggedMessageHighlight ref={flaggedMessageRef}><ChatMessageComponent key={actualFlaggedMessage.message_id} message={actualFlaggedMessage} chatbotName={concern.room_name || "Chatbot"} /></FlaggedMessageHighlight> )
                                : <p style={{ textAlign: 'center', padding: '20px', color: '#888' }}>Conversation context unavailable.</p>
                            )}
                        </MessagesList>
                    </ConversationContext>

                    {/* Details & Actions */}
                    <ConcernDetailsCard>
                        <DetailsHeader>Concern Details</DetailsHeader>
                        {/* Use flattened properties from FlagDetailsResponse */}
                        <DetailItem><strong>Student:</strong><span>{concern.student_name || 'N/A'} ({concern.student_email || 'No Email'})</span></DetailItem>
                        <DetailItem><strong>Classroom:</strong><span>{concern.room_name || 'N/A'}</span></DetailItem>
                        <DetailItem><strong>Concern Type:</strong><span>{getConcernTypeText(concern.concern_type)}</span></DetailItem>
                        <DetailItem><strong>Assessed Level:</strong><Badge variant="default" style={{ marginLeft: '8px' }}>{getConcernLevelText(concern.concern_level)} (Level {concern.concern_level})</Badge></DetailItem>
                        <DetailItem><strong>Detected At:</strong><span>{new Date(concern.created_at).toLocaleString()}</span></DetailItem>
                        {concern.analysis_explanation && (<DetailItem><strong>AI Analysis:</strong><AnalysisText>{concern.analysis_explanation}</AnalysisText></DetailItem>)}
                        {concern.reviewed_at && (<DetailItem><strong>Last Reviewed:</strong><span>{new Date(concern.reviewed_at).toLocaleString()}</span></DetailItem>)}

                        <ActionForm onSubmit={handleStatusUpdate}>
                             <Label htmlFor="status">Update Status:</Label>
                            <CustomSelect id="status" value={selectedStatus} onChange={(e) => setSelectedStatus(e.target.value as ConcernStatus)}>
                               <option value="pending">Pending Review</option>
                               <option value="reviewing">Reviewing</option>
                               <option value="resolved">Resolved</option>
                               <option value="false_positive">False Positive</option>
                            </CustomSelect>
                             <Label htmlFor="notes">Review Notes:</Label>
                             <StyledTextArea id="notes" rows={5} value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Add notes on actions taken, observations, or decision rationale..." />
                             {actionError && <Alert variant="error" style={{ marginBottom: '16px' }}>{actionError}</Alert>}
                             <FormActions><Button type="submit" disabled={isSubmitting} style={{ width: '100%' }}>{isSubmitting ? 'Updating...' : 'Update Status & Notes'}</Button></FormActions>
                        </ActionForm>
                    </ConcernDetailsCard>
                </Grid>
            </Container>
        </PageWrapper>
    );
}.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
// src/app/layout.tsx
import { Metadata } from 'next';
import Providers from './providers';
import Header from '@/components/layout/Header';
import { APP_NAME, APP_DESCRIPTION } from '@/lib/utils/constants';
import './globals.css';

export const metadata: Metadata = {
  title: APP_NAME,
  description: APP_DESCRIPTION,
  viewport: 'width=device-width, initial-scale=1.0, maximum-scale=1.0',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>
          <Header />
          {children}
        </Providers>
      </body>
    </html>
  );
}// src/app/api/chat/[roomId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateEmbedding } from '@/lib/openai/embeddings';
import { queryVectors } from '@/lib/pinecone/utils';
import { initialConcernCheck, verifyConcern } from '@/lib/safety/monitoring';
import { sendTeacherAlert } from '@/lib/safety/alerts';
import type { Database, ChatMessage, Room } from '@/types/database.types'; // Removed unused Profile
import { SupabaseClient } from '@supabase/supabase-js';
import { createAdminClient } from '@/lib/supabase/admin';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const CONCERN_THRESHOLD = 3;

const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// --- GET Function ---
export async function GET(request: NextRequest) {
    try {
        const pathname = request.nextUrl.pathname;
        const segments = pathname.split('/');
        const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
        const { searchParams } = new URL(request.url);
        const chatbotIdFilter = searchParams.get('chatbotId');

        if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });

        // If it's not a teacher test room, validate room existence and access
        if (!isTeacherTestRoom(roomId)) {
            const { data: room, error: roomError } = await supabase
                .from('rooms') // Assumes 'rooms' table exists for non-test rooms
                .select('room_id')
                .eq('room_id', roomId)
                .maybeSingle(); // Check if room exists
            // Further access check for students/teachers for this room would go here
            if (roomError || !room) {
                console.warn(`[API Chat GET] Room ${roomId} not found or access denied for user ${user.id}.`);
                return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 });
            }
        }
        // For teacher test rooms, we don't need to check 'rooms' table, teacher owns their test chat

        let query = supabase.from('chat_messages').select('*').eq('room_id', roomId).eq('user_id', user.id);
        if (chatbotIdFilter) query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
        
        const { data: messages, error: messagesError } = await query.order('created_at', { ascending: true });

        if (messagesError) { 
            console.error('[API Chat GET] Error fetching messages:', messagesError); 
            return NextResponse.json({ error: messagesError.message }, { status: 500 }); 
        }
        return NextResponse.json(messages || []);
    } catch (error) { 
        console.error('[API Chat GET] General error:', error); 
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Unknown server error' }, { status: 500 }); 
    }
}

// --- POST Handler ---
export async function POST(request: NextRequest) {
  let userMessageId: string | null = null;
  try {
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
    if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }

    const { data: userProfile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
    if (profileError || !userProfile) { return NextResponse.json({ error: 'User profile not found' }, { status: 403 }); }
    
    const isStudent = userProfile.role === 'student';
    const isTeacher = userProfile.role === 'teacher';

    const { content, chatbot_id, model: requestedModel } = await request.json();
    // ... (content and chatbot_id validation) ...
    const trimmedContent = content?.trim();
    if (!trimmedContent || typeof trimmedContent !== 'string') return NextResponse.json({ error: 'Invalid message content' }, { status: 400 });
    if (!chatbot_id) return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });


    let roomForSafetyCheck: Room | null = null; // For safety check context

    if (!isTeacherTestRoom(roomId)) {
        // For actual rooms, fetch room data
        const { data: roomData, error: roomFetchError } = await supabase
            .from('rooms') // Assumes 'rooms' table exists for non-test rooms
            .select('room_id, teacher_id, room_name')
            .eq('room_id', roomId)
            .single();
        if (roomFetchError || !roomData) { 
            console.error("[API Chat POST] Room fetch error for non-test room:", roomFetchError); 
            return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 }); 
        }
        roomForSafetyCheck = roomData as Room;
        // TODO: Add access validation here for students (member of room) or teachers (owner of room)
    } else if (isTeacherTestRoom(roomId) && !isTeacher) {
        // If it's a test room, only the teacher should be posting
        return NextResponse.json({ error: 'Not authorized for this test room' }, { status: 403 });
    }


    // Store User Message (same as before)
    const userMessageToStore: Omit<ChatMessage, 'message_id' | 'created_at' | 'updated_at'> & { metadata: { chatbotId: string } } = {
      room_id: roomId, user_id: user.id, role: 'user' as const, content: trimmedContent, metadata: { chatbotId: chatbot_id }
    };
    const { data: savedUserMessageData, error: userMessageError } = await supabase.from('chat_messages').insert(userMessageToStore).select('message_id').single();
    if (userMessageError || !savedUserMessageData) { console.error('Error storing user message:', userMessageError); return NextResponse.json({ error: 'Failed to store message' }, { status: 500 }); }
    userMessageId = savedUserMessageData.message_id;
    
    // Safety Check Trigger (only for students in actual rooms)
    if (isStudent && userMessageId && roomForSafetyCheck && !isTeacherTestRoom(roomId)) {
        console.log(`[API Chat POST] Triggering checkMessageSafety for student ${user.id}, message ${userMessageId}`);
        checkMessageSafety(supabase, trimmedContent, userMessageId, user.id, roomForSafetyCheck)
            .catch(safetyError => console.error(`[Safety Check Background Error] for message ${userMessageId}:`, safetyError));
    } else {
        console.log(`[API Chat POST] Skipping safety check. isStudent: ${isStudent}, isTeacherTestRoom: ${isTeacherTestRoom(roomId)}`);
    }

    // ... (Fetch Context Messages - this should be fine as it's scoped to user_id and room_id) ...
    // ... (Prepare and Call LLM API - this logic is fine) ...
    // ... (RAG Logic - this is fine) ...
    // ... (Stream Response Back - this logic is fine) ...

    // The rest of the POST handler (fetching context, calling LLM, streaming) can largely remain the same.
    // The crucial part was handling the room data fetch conditionally.

    // --- Placeholder for the rest of the POST logic ---
    // Fetch Context Messages
    const { data: contextMessagesData, error: contextError } = await supabase.from('chat_messages')
      .select('role, content').eq('room_id', roomId).eq('user_id', user.id)
      .filter('metadata->>chatbotId', 'eq', chatbot_id).neq('message_id', userMessageId)
      .order('created_at', { ascending: false }).limit(5);
    if (contextError) console.warn("Error fetching context messages:", contextError.message);
    const contextMessages = (contextMessagesData || []).map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }));

    let { system_prompt: systemPrompt = "You are a helpful AI assistant.", model: modelToUse = 'x-ai/grok-3-mini-beta', temperature = 0.7, max_tokens: maxTokens = 1000, enable_rag: enableRag = false } = {};
    const { data: chatbotData, error: chatbotFetchError } = await supabase.from('chatbots')
      .select('system_prompt, model, temperature, max_tokens, enable_rag').eq('chatbot_id', chatbot_id).single();
    if (chatbotFetchError) console.warn(`Error fetching chatbot ${chatbot_id} config:`, chatbotFetchError.message);
    else if (chatbotData) ({ system_prompt: systemPrompt = systemPrompt, model: modelToUse = requestedModel || chatbotData.model || modelToUse, temperature = chatbotData.temperature ?? temperature, max_tokens: maxTokens = chatbotData.max_tokens ?? maxTokens, enable_rag: enableRag = chatbotData.enable_rag ?? false } = chatbotData);

    let ragContextText = '';
    if (enableRag) { 
        try {
            const queryEmbedding = await generateEmbedding(trimmedContent);
            const searchResults = await queryVectors(queryEmbedding, chatbot_id, 3);
            if (searchResults && searchResults.length > 0) {
                ragContextText = "\n\nRelevant information from knowledge base:\n";
                searchResults.forEach((result, index) => {
                    if (result.metadata?.text) {
                        const fileName = typeof result.metadata.fileName === 'string' ? result.metadata.fileName : 'document';
                        const chunkText = String(result.metadata.text).substring(0, 500);
                        ragContextText += `\n[${index + 1}] From "${fileName}":\n${chunkText}\n`;
                    }
                });
            }
        } catch (ragError) { console.warn(`[RAG] Error:`, ragError); }
    }

    const enhancedSystemPrompt = `${systemPrompt}${ragContextText ? `\n\n${ragContextText}\n\nRemember to cite sources by their number (e.g., [1], [2]) if you use their information.` : ''}`;
    const messagesForAPI = [ { role: 'system', content: enhancedSystemPrompt }, ...contextMessages.reverse(), { role: 'user', content: trimmedContent } ];

    const openRouterResponse = await fetch(OPENROUTER_API_URL, {
        method: 'POST', headers: { 'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`, 'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000', 'X-Title': 'ClassBots AI', 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: modelToUse, messages: messagesForAPI, temperature, max_tokens: maxTokens, stream: true }),
    });

    if (!openRouterResponse.ok || !openRouterResponse.body) {
        const errorBody = await openRouterResponse.text(); console.error(`OpenRouter Error: Status ${openRouterResponse.status}`, errorBody);
        let errorMessage = `Failed to get AI response (status: ${openRouterResponse.status})`;
        try { const errorJson = JSON.parse(errorBody); errorMessage = errorJson.error?.message || errorMessage; } catch {}
        throw new Error(errorMessage);
    }

    let fullResponseContent = ''; const encoder = new TextEncoder(); let assistantMessageId: string | null = null;
    const stream = new ReadableStream({
        async start(controller) {
            const reader = openRouterResponse.body!.getReader(); const decoder = new TextDecoder();
            try {
                const { data: initData, error: initError } = await supabase.from('chat_messages')
                    .insert({ room_id: roomId, user_id: user.id, role: 'assistant', content: '', metadata: { chatbotId: chatbot_id } })
                    .select('message_id').single();
                if (initError || !initData) console.error('Error creating placeholder assistant message:', initError);
                else assistantMessageId = initData.message_id;

                while (true) {
                    const { done, value } = await reader.read(); if (done) break;
                    const chunk = decoder.decode(value, { stream: true }); const lines = chunk.split('\n').filter(l => l.trim().startsWith('data:'));
                    for (const line of lines) {
                        const dataContent = line.substring(6).trim(); if (dataContent === '[DONE]') continue;
                        try { const parsed = JSON.parse(dataContent); const piece = parsed.choices?.[0]?.delta?.content; if (typeof piece === 'string') { fullResponseContent += piece; controller.enqueue(encoder.encode(`data: ${JSON.stringify({ content: piece })}\n\n`)); } }
                        catch (e) { console.warn('Stream parse error:', e); }
                    }
                }
            } catch (streamError) { console.error('Stream error:', streamError); controller.error(streamError); }
            finally {
                const finalContent = fullResponseContent.trim();
                if (assistantMessageId && finalContent) {
                    const { error: updateError } = await supabase.from('chat_messages').update({ content: finalContent, updated_at: new Date().toISOString() }).eq('message_id', assistantMessageId);
                    if (updateError) console.error(`Error updating assistant message ${assistantMessageId}:`, updateError); else console.log(`Assistant message ${assistantMessageId} updated.`);
                } else if (!assistantMessageId && finalContent) { 
                    console.warn("Fallback: Assistant message placeholder not created, inserting full message."); 
                    await supabase.from('chat_messages').insert({ room_id: roomId, user_id: user.id, role: 'assistant', content: finalContent, metadata: { chatbotId: chatbot_id } }); 
                }
                controller.close(); console.log("Server stream closed.");
            }
        }
    });
    return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'X-Content-Type-Options': 'nosniff' } });
    // --- End of placeholder for POST logic ---

  } catch (error) { 
      console.error('Error in POST /api/chat/[roomId]:', error); 
      return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to process message' }, { status: 500 }); 
  }
}

// checkMessageSafety function (keep as is, but ensure 'room' param is handled if it can be null)
async function checkMessageSafety(
    supabase: SupabaseClient<Database>,
    messageContent: string,
    messageId: string,
    studentId: string,
    room: Room // This is now 'Room | null' conceptually from the caller
): Promise<void> {
    // ... (Safety check logic - ensure it handles cases where room might not be a "real" room if called for test chats,
    // though currently we only call it for students in actual rooms)
    // For now, the existing logic should be fine as it's only called if roomForSafetyCheck is not null.
    console.log(`[Safety Check] START - Checking message ID: ${messageId} for student ${studentId} in room ${room.room_id}`);
    console.log(`[Safety Check] Message Content Being Checked: "${messageContent}"`);
    try {
        const adminClient = createAdminClient();
        const { data: flaggedMessageData, error: fetchMsgError } = await supabase
            .from('chat_messages').select('metadata, created_at').eq('message_id', messageId).single();

        if (fetchMsgError || !flaggedMessageData) {
             console.error(`[Safety Check] Failed to fetch flagged message ${messageId} for context query:`, fetchMsgError);
             return;
        }
        const flaggedMessageChatbotId = flaggedMessageData.metadata?.chatbotId || null;
        const flaggedMessageCreatedAt = flaggedMessageData.created_at || new Date().toISOString();
        const { hasConcern, concernType } = initialConcernCheck(messageContent);
        console.log(`[Safety Check] Initial Check Result: hasConcern=${hasConcern}, concernType=${concernType}`);

        if (hasConcern && concernType) {
            console.log(`[Safety Check] Initial concern FOUND: ${concernType}. Fetching context...`);
            const { data: contextMessagesData, error: contextError } = await supabase
                .from('chat_messages').select('role, content')
                .eq('room_id', room.room_id).eq('user_id', studentId)
                .filter('metadata->>chatbotId', flaggedMessageChatbotId ? 'eq' : 'is', flaggedMessageChatbotId || null)
                .lt('created_at', flaggedMessageCreatedAt).order('created_at', { ascending: false }).limit(2);

             if (contextError) console.warn(`[Safety Check] Error fetching context for msg ${messageId}:`, contextError.message);
             const recentMessagesForSafetyCheck = (contextMessagesData || [])
                .map((m) => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }));

            console.log(`[Safety Check] Calling verifyConcern LLM...`);
            const { isRealConcern, concernLevel, analysisExplanation } = await verifyConcern(
                messageContent, concernType, recentMessagesForSafetyCheck.reverse()
            );
             console.log(`[Safety Check] verifyConcern Result: isReal=${isRealConcern}, level=${concernLevel}, explanation=${analysisExplanation}`);

            if (isRealConcern && concernLevel >= CONCERN_THRESHOLD) {
                console.log(`[Safety Check] THRESHOLD MET! Level ${concernLevel} >= ${CONCERN_THRESHOLD}. Flagging...`);
                const { data: teacherProfileData } = await supabase
                    .from('profiles').select('email').eq('user_id', room.teacher_id).single();
                const { data: studentProfileData } = await supabase
                    .from('profiles').select('full_name').eq('user_id', studentId).single();
                const teacherEmail = teacherProfileData?.email;
                const studentName = studentProfileData?.full_name || `Student (${studentId.substring(0,6)}...)`;

                console.log(`[Safety Check] Inserting flag into DB for message ${messageId} using ADMIN client...`);
                const { data: insertedFlag, error: flagError } = await adminClient
                    .from('flagged_messages').insert({
                        message_id: messageId, student_id: studentId, teacher_id: room.teacher_id, 
                        room_id: room.room_id, concern_type: concernType, concern_level: concernLevel, 
                        analysis_explanation: analysisExplanation, status: 'pending',
                    }).select('flag_id').single();

                if (flagError || !insertedFlag) {
                    console.error(`[Safety Check] FAILED to insert flag for message ${messageId} with ADMIN client:`, flagError);
                } else {
                    const newFlagId = insertedFlag.flag_id;
                    console.log(`[Safety Check] Flag ${newFlagId} inserted successfully for message ${messageId}.`);
                    if (teacherEmail) {
                        console.log(`[Safety Check] Attempting to send alert to ${teacherEmail} for flag ${newFlagId}...`);
                        const viewUrl = `${process.env.NEXT_PUBLIC_APP_URL}/teacher-dashboard/concerns/${newFlagId}`;
                        const alertSent = await sendTeacherAlert( teacherEmail, studentName, room.room_name, concernType, concernLevel, messageContent, viewUrl );
                         console.log(`[Safety Check] Alert sent status for flag ${newFlagId}: ${alertSent}`);
                    } else { console.warn(`[Safety Check] Teacher email not found. Cannot send alert for flag ${newFlagId}.`); }
                }
            } else { console.log(`[Safety Check] Concern level ${concernLevel} did NOT meet threshold ${CONCERN_THRESHOLD} or was not deemed real.`); }
        } else { console.log(`[Safety Check] No initial concern detected.`); }
    } catch (error) { console.error(`[Safety Check] UNCAUGHT ERROR in checkMessageSafety for message ID ${messageId}:`, error); }
     console.log(`[Safety Check] END - Checked message ID: ${messageId}`);
}// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Test database connection
    const { error } = await supabase
      .from('schools')
      .select('count')
      .limit(1);

    if (error) {
      return NextResponse.json({ 
        status: 'error', 
        message: 'Database connection failed',
        error: error.message 
      }, { status: 500 });
    }

    return NextResponse.json({ 
      status: 'healthy',
      database: 'connected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return NextResponse.json({ 
      status: 'error', 
      message: 'Server error',
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}// src/app/api/student/join-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { isValidRoomCode } from '@/lib/utils/room-codes'; // Ensure this utility is present

export async function POST(request: Request) {
  console.log('[API POST /student/join-room] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError || !session?.user) {
      console.warn('[API POST /student/join-room] Not authenticated or session error:', sessionError);
      return NextResponse.json({ error: sessionError?.message || 'Not authenticated' }, { status: 401 });
    }
    const studentUser = session.user;
    console.log('[API POST /student/join-room] User authenticated:', studentUser.id);

    // Verify the user trying to join actually has a 'student' role in profiles table
    const { data: studentProfile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', studentUser.id)
        .single();

    if (profileError || !studentProfile) {
        console.error('[API POST /student/join-room] Profile not found or error for student:', studentUser.id, profileError);
        return NextResponse.json({ error: 'Student profile not found.' }, { status: 403 });
    }
    if (studentProfile.role !== 'student') {
        console.warn('[API POST /student/join-room] User is not a student. Role:', studentProfile.role);
        return NextResponse.json({ error: 'Only students can join rooms this way.' }, { status: 403 });
    }
    console.log('[API POST /student/join-room] User confirmed as student.');


    const { room_code } = await request.json();
    console.log('[API POST /student/join-room] Received room_code:', room_code);

    if (!room_code || !isValidRoomCode(room_code.toUpperCase())) { // Ensure case-insensitivity if codes are stored uppercase
      console.warn('[API POST /student/join-room] Invalid room code format:', room_code);
      return NextResponse.json({ error: 'Invalid room code format' }, { status: 400 });
    }

    const formattedRoomCode = room_code.toUpperCase();

    // Find room by code
    console.log('[API POST /student/join-room] Searching for room with code:', formattedRoomCode);
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id, is_active')
      .eq('room_code', formattedRoomCode) // Ensure room_code in DB is also consistently cased or use a case-insensitive query
      .single();

    if (roomError) {
        console.error('[API POST /student/join-room] Error fetching room by code:', formattedRoomCode, roomError);
        // This could be a "relation rooms does not exist" if table is missing, or other DB error
        // But more likely if table exists, it's "0 rows" which isn't an error for .single() if it becomes !room
        // For a true DB error, throw it.
        if (roomError.code && !['PGRST116'].includes(roomError.code)) { // PGRST116 is "Searched for a single row, but found 0 rows"
             throw roomError;
        }
    }
    
    if (!room) { // This handles both "0 rows found" and if roomError was PGRST116
      console.warn('[API POST /student/join-room] Room not found with code:', formattedRoomCode);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 }); // This is your current error
    }
    console.log('[API POST /student/join-room] Room found:', room.room_id, 'Is active:', room.is_active);


    if (!room.is_active) {
      console.warn('[API POST /student/join-room] Room is inactive:', room.room_id);
      return NextResponse.json({ error: 'This room is currently inactive.' }, { status: 400 });
    }

    // Check if student is already in room
    const { data: existingMembership, error: membershipCheckError } = await supabase
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', room.room_id)
      .eq('student_id', studentUser.id)
      .maybeSingle(); // Use maybeSingle to not error if no membership found

    if (membershipCheckError) {
        console.error('[API POST /student/join-room] Error checking existing membership:', membershipCheckError);
        throw membershipCheckError;
    }

    if (existingMembership) {
      console.warn('[API POST /student/join_room] Student already a member of this room:', room.room_id);
      return NextResponse.json({ message: 'Already joined this room', roomId: room.room_id }, { status: 200 }); // Or 400 if you want to treat as error
    }

    // Add student to room
    console.log('[API POST /student/join-room] Adding student to room_memberships. RoomID:', room.room_id, 'StudentID:', studentUser.id);
    const { error: joinError } = await supabase
      .from('room_memberships')
      .insert({
        room_id: room.room_id,
        student_id: studentUser.id
        // joined_at has a default value
      });

    if (joinError) {
      console.error('[API POST /student/join-room] Error inserting into room_memberships:', joinError);
      // Check for unique constraint violation (already a member, though prior check should catch this)
      if (joinError.code === '23505') { // unique_violation
         return NextResponse.json({ message: 'Already a member of this room (insert conflict).', roomId: room.room_id }, { status: 200 });
      }
      throw joinError;
    }
    console.log('[API POST /student/join-room] Student successfully joined room:', room.room_id);
    return NextResponse.json({ success: true, roomId: room.room_id, message: 'Successfully joined room!' });
  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API POST /student/join-room] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to join room' },
      { status: 500 }
    );
  }
}// src/app/api/student/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

// Define proper interfaces for the exact Supabase query structure
interface ChatbotData {
  chatbot_id: string;
  name: string;
  description: string | null;
}

interface RoomChatbotRelation {
  chatbots: ChatbotData;
}

interface RoomData {
  room_id: string;
  room_name: string;
  room_code: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: RoomChatbotRelation[] | null;
}

interface MembershipData {
  joined_at: string;
  rooms: RoomData | null;
}

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a student
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'student') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Fetch rooms the student has joined with chatbot info - MODIFIED QUERY
    const { data: membershipData, error } = await supabase
      .from('room_memberships')
      .select(`
        joined_at,
        rooms!inner(
          room_id,
          room_name,
          room_code,
          is_active,
          created_at,
          room_chatbots(
            chatbots(
              chatbot_id,
              name,
              description
            )
          )
        )
      `)
      .eq('student_id', user.id);

    if (error) {
      throw error;
    }

    // Use unknown first, then cast to our type
    const typedMembershipData = membershipData as unknown as MembershipData[];

    // Transform the data to match expected format
    const rooms = typedMembershipData?.map(membership => {
      const room = membership.rooms;
      if (!room) return null;
      
      // Extract chatbots from room_chatbots
      const chatbots: ChatbotData[] = [];
      if (room.room_chatbots && room.room_chatbots.length > 0) {
        room.room_chatbots.forEach((rc: RoomChatbotRelation) => {
          if (rc.chatbots) {
            chatbots.push(rc.chatbots);
          }
        });
      }
      
      return {
        ...room,
        joined_at: membership.joined_at,
        chatbots
      };
    }).filter((room): room is NonNullable<typeof room> => room !== null);

    return NextResponse.json(rooms || []);
  } catch (error) {
    console.error('Error fetching student rooms:', error);
    return NextResponse.json(
      { error: 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/student-chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface ChatbotInfoFromDB {
  chatbot_id: string;
  name: string;
}

interface RoomChatbotResponseFromDB {
  chatbot_id: string;
  chatbots: ChatbotInfoFromDB;
}

export async function GET(request: NextRequest) {
  try {
    // Extract query parameters instead of path parameters
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');
    const chatbotIdFilter = searchParams.get('chatbotId');

    console.log("Fetching chats for student:", studentId, "in room:", roomId);

    if (!roomId || !studentId) {
      return NextResponse.json({ error: 'Room ID and Student ID are required' }, { status: 400 });
    }

    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.error("Room fetch error or unauthorized:", roomError);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    const { data: membership, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      console.error("Membership fetch error or not a member:", membershipError);
      return NextResponse.json({ error: 'Student is not a member of this room' }, { status: 404 });
    }

    let query = supabase
      .from('chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .eq('user_id', studentId)
      .order('created_at', { ascending: true });

    if (chatbotIdFilter) {
      query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
    }

    const { data: messagesData, error: messagesError } = await query;

    if (messagesError) {
      console.error("Error fetching messages:", messagesError);
      return NextResponse.json({ error: 'Failed to fetch chat messages' }, { status: 500 });
    }

    const allMessages: DatabaseChatMessage[] = (messagesData as DatabaseChatMessage[] | null) || [];

    const { data: roomChatbotsDataRaw, error: chatbotsError } = await supabase
      .from('room_chatbots')
      .select(`
        chatbot_id,
        chatbots:chatbots!inner(
          chatbot_id,
          name
        )
      `)
      .eq('room_id', roomId);

    if (chatbotsError) {
      console.error("Error fetching room chatbots:", chatbotsError);
    }

    const availableChatbots: Array<{ chatbot_id: string; name: string }> = [];
    if (roomChatbotsDataRaw && roomChatbotsDataRaw.length > 0) {
      const typedRoomChatbots = roomChatbotsDataRaw as unknown as RoomChatbotResponseFromDB[];
      typedRoomChatbots.forEach(item => {
        if (item.chatbots && typeof item.chatbots === 'object') {
          availableChatbots.push({
            chatbot_id: item.chatbots.chatbot_id,
            name: item.chatbots.name
          });
        }
      });
    }

    const conversations: Conversation[] = [];
    let currentConversation: Conversation | null = null;
    let currentChatbotIdForConversation: string | null = null;

    for (const message of allMessages) {
      const msgChatbotId = message.metadata?.chatbotId || null;

      if (currentConversation === null || msgChatbotId !== currentChatbotIdForConversation) {
        if (currentConversation) {
          conversations.push(currentConversation);
        }
        const matchingChatbot = availableChatbots.find(c => c.chatbot_id === msgChatbotId);
        currentChatbotIdForConversation = msgChatbotId;
        currentConversation = {
          chatbot_id: msgChatbotId,
          chatbot_name: matchingChatbot ? matchingChatbot.name : (msgChatbotId ? 'Unknown Chatbot' : 'General Chat'),
          started_at: message.created_at,
          messages: [message],
        };
      } else {
        currentConversation.messages.push(message);
      }
    }

    if (currentConversation) {
      conversations.push(currentConversation);
    }

    return NextResponse.json({
      conversations,
      chatbots: availableChatbots,
      pagination: { hasMore: false }
    });

  } catch (error) {
    console.error('Error fetching student chats:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.message, error.stack);
    }
    return NextResponse.json(
      { error: 'Failed to fetch student chats' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify teacher owns the room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    // Fetch memberships
    const { data: memberships, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id, joined_at')
      .eq('room_id', roomId);

    if (membershipError) {
      return NextResponse.json(
        { error: `Failed to fetch room memberships: ${membershipError.message}` },
        { status: 500 }
      );
    }

    if (!memberships || memberships.length === 0) {
      return NextResponse.json([]);
    }

    // Log student IDs for debugging
    console.log("Student IDs in room:", memberships.map(m => m.student_id));

    // Get all profiles - select ALL fields to see what's available
    const studentIds = memberships.map(m => m.student_id);
    const { data: profiles } = await supabase
      .from('profiles')
      .select('*')
      .in('user_id', studentIds);

    // Log first profile for debugging
    if (profiles && profiles.length > 0) {
      console.log("Sample profile fields:", Object.keys(profiles[0]));
      console.log("Sample profile data:", profiles[0]);
    } else {
      console.log("No profiles found");
    }

    // Get auth users data for better name resolution
    const studentData = await Promise.all(
      memberships.map(async (membership) => {
        // Try to find in profiles first
        const profile = profiles?.find(p => p.user_id === membership.student_id);
        
        // Fetch user auth data directly
        const { data: authData } = await supabase.auth.admin.getUserById(
          membership.student_id
        ).catch(() => ({ data: null }));
        
        // Try various name sources with detailed logging
        let name = "Student";
        let email = "No email available";
        
        // Log all potential name sources
        console.log(`Student ${membership.student_id} name sources:`, {
          profile_name: profile?.name,
          profile_full_name: profile?.full_name,
          profile_display_name: profile?.display_name,
          profile_first_name: profile?.first_name,
          profile_last_name: profile?.last_name,
          profile_email: profile?.email,
          auth_email: authData?.user?.email,
          auth_metadata: authData?.user?.user_metadata
        });
        
        // Try profile fields first
        if (profile) {
          // Try each possible name field
          if (profile.name) name = profile.name;
          else if (profile.full_name) name = profile.full_name;
          else if (profile.display_name) name = profile.display_name;
          else if (profile.first_name && profile.last_name) name = `${profile.first_name} ${profile.last_name}`;
          else if (profile.first_name) name = profile.first_name;
          
          // Get email if available
          if (profile.email) email = profile.email;
        }
        
        // If no name yet, try auth data
        if (name === "Student" && authData?.user) {
          // Try user metadata
          if (authData.user.user_metadata?.full_name) name = authData.user.user_metadata.full_name;
          else if (authData.user.user_metadata?.name) name = authData.user.user_metadata.name;
          
          // Try email username as last resort
          if (name === "Student" && authData.user.email) {
            name = authData.user.email.split('@')[0];
          }
          
          // Get email if not available yet
          if (email === "No email available" && authData.user.email) {
            email = authData.user.email;
          }
        }
        
        // Final logging of what name was found
        console.log(`Final name for student ${membership.student_id}:`, name);
        
        return {
          user_id: membership.student_id,
          name,
          email,
          joined_at: membership.joined_at,
          message_count: 0,
          last_activity: null
        };
      })
    );

    return NextResponse.json(studentData);
  } catch (error) {
    console.error('Error fetching student data:', error);
    return NextResponse.json(
      { error: 'Failed to fetch students' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/[chatbotId]/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function POST(request: NextRequest) {
  console.log("Document upload request received");
  
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Rest of the function remains the same
    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get file from formData
    const formData = await request.formData();
    console.log("FormData received:", formData);
    
    const file = formData.get('file') as File;
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("File received:", file.name, file.type, file.size);

    // Validate file type
    const fileType = getFileType(file.name);
    if (!fileType) {
      return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });
    }

    // Create storage path
    const filePath = `${user.id}/${chatbotId}/${file.name}`;
    
    // Get file buffer
    const buffer = await file.arrayBuffer();
    
    // Upload file to storage
    const { error: uploadError } = await supabase
      .storage
      .from('documents')
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: true
      });

    if (uploadError) {
      console.error("Storage upload error:", uploadError);
      return NextResponse.json({ error: `Failed to upload file: ${uploadError.message}` }, { status: 500 });
    }

    // Create document record
    const { data: document, error: documentError } = await supabase
      .from('documents')
      .insert({
        chatbot_id: chatbotId,
        file_name: file.name,
        file_path: filePath,
        file_type: fileType,
        file_size: file.size,
        status: 'uploaded'
      })
      .select()
      .single();

    if (documentError) {
      console.error("Document insert error:", documentError);
      
      // Clean up uploaded file if document record creation fails
      await supabase.storage.from('documents').remove([filePath]);
      
      return NextResponse.json({ error: `Failed to create document record: ${documentError.message}` }, { status: 500 });
    }

    return NextResponse.json({
      document: document,
      message: 'Document uploaded successfully. Processing will begin shortly.'
    });
  } catch (error) {
    console.error('Error in document upload:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to upload document' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching documents for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get all documents for this chatbot
    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 });
    }

    return NextResponse.json(documents || []);
  } catch (error) {
    console.error('Error fetching documents:', error);
    return NextResponse.json(
      { error: 'Failed to fetch documents' },
      { status: 500 }
    );
  }
}

// Helper function to determine file type
function getFileType(fileName: string): 'pdf' | 'docx' | 'txt' | null {
  const extension = fileName.split('.').pop()?.toLowerCase();
  
  switch (extension) {
    case 'pdf': return 'pdf';
    case 'docx': case 'doc': return 'docx';
    case 'txt': return 'txt';
    default: return null;
  }
}// src/app/api/teacher/chatbots/[chatbotId]/vectorize/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { processDocument as processDocumentFile } from '@/lib/document-processing/processor';
import type { Document } from '@/types/knowledge-base.types';

export async function POST(request: NextRequest) {
  console.log("Document processing request received via POST");

  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    let body;
    try {
      body = await request.json();
    } catch (parseError) {
      console.error("Error parsing request body:", parseError);
      return NextResponse.json({ error: 'Invalid request body format' }, { status: 400 });
    }

    const documentId = body.documentId;

    if (!documentId) {
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    const { data: document, error: documentError } = await supabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError || !document) {
      console.error("Document not found:", documentError);
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    if (document.status === 'processing') {
      return NextResponse.json({ error: 'Document is already being processed' }, { status: 400 });
    }

    const { error: updateError } = await supabase
      .from('documents')
      .update({
        status: 'processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', documentId);

    if (updateError) {
      console.error("Error updating document status:", updateError);
      return NextResponse.json({ error: 'Failed to update document status' }, { status: 500 });
    }

    // Process in the background using the imported function
    processDocumentFile(document as Document)
      .catch(error => console.error(`Background processing error for doc ${document.document_id}:`, error));

    return NextResponse.json({ message: 'Document processing started' });
  } catch (error) {
    console.error('Error in document processing endpoint (POST):', error);
    return NextResponse.json(
      { error: 'Internal server error during POST' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  console.log("Document processing status GET request received");
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching status for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const documentId = searchParams.get('documentId');

    if (!documentId) {
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    const { data: document, error: documentError } = await supabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError || !document) {
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    const { data: allChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .select('status')
      .eq('document_id', documentId);

    if (chunksError) {
      return NextResponse.json({ error: 'Failed to fetch document chunks' }, { status: 500 });
    }

    const totalChunks = allChunks?.length || 0;
    const processedChunks = allChunks?.filter(chunk => chunk.status === 'embedded').length || 0;
    const errorChunks = allChunks?.filter(chunk => chunk.status === 'error').length || 0;
    const percentComplete = totalChunks ? Math.round((processedChunks / totalChunks) * 100) : 0;

    console.log(`Status for doc ${documentId}: Total ${totalChunks}, Processed ${processedChunks}, Errors ${errorChunks}, Complete ${percentComplete}%`);

    return NextResponse.json({
      document,
      processingStats: {
        totalChunks,
        processedChunks,
        errorChunks,
        percentComplete
      }
    });
  } catch (error) {
    console.error('Error fetching processing status (GET):', error);
    return NextResponse.json(
      { error: 'Failed to fetch processing status' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { CreateChatbotPayload } from '@/types/database.types'; // Ensure this type is correct

// GET Handler to fetch chatbots
export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const { data: chatbots, error: fetchError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) {
      console.error('Error fetching chatbots:', fetchError);
      throw fetchError;
    }

    return NextResponse.json(chatbots || []);
  } catch (error) {
    console.error('Error in GET /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch chatbots' },
      { status: 500 }
    );
  }
}

// POST Handler to create a new chatbot
export async function POST(request: Request) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body: CreateChatbotPayload = await request.json();

    if (!body.name || !body.system_prompt) {
        return NextResponse.json({ error: 'Name and system prompt are required' }, { status: 400 });
    }

    const { data: newChatbot, error: insertError } = await supabase
      .from('chatbots')
      .insert({
        name: body.name,
        description: body.description,
        system_prompt: body.system_prompt,
        teacher_id: user.id,
        model: body.model || 'x-ai/grok-3-mini-beta',
        max_tokens: body.max_tokens || 1000,
        temperature: body.temperature || 0.7,
        enable_rag: body.enable_rag || false,
        // created_at and updated_at have defaults
      })
      .select()
      .single();

    if (insertError) {
      console.error('Error creating chatbot:', insertError);
      throw insertError;
    }

    return NextResponse.json(newChatbot, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/teacher/chatbots:', error);
    // Check for specific Supabase error codes if needed
    if (error && typeof error === 'object' && 'code' in error) {
        if (error.code === '23505') { // Unique violation
             return NextResponse.json({ error: 'A chatbot with this name might already exist or another unique constraint was violated.' }, { status: 409 });
        }
    }
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create chatbot' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/dashboard-stats/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  console.log('\n--- [API GET /dashboard-stats] --- (Reverted to simpler state)');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API STATS] Not authenticated.', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API STATS] User authenticated:', user.id);

    // Attempt to fetch profile
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role') // Only select what's absolutely needed for this check
      .eq('user_id', user.id)
      .single();

    if (profileError) {
      console.error('[API STATS] PROFILE FETCH FAILED. Error object:', JSON.stringify(profileError, null, 2));
      return NextResponse.json({ error: `Profile fetch failed: ${profileError.message}` }, { status: 500 });
    }
    if (!profile) {
        console.error('[API STATS] Profile not found for user:', user.id);
        return NextResponse.json({ error: 'Profile not found' }, { status: 403 });
    }
    if (profile.role !== 'teacher') {
      console.warn('[API STATS] User is not a teacher. Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (not a teacher)' }, { status: 403 });
    }
    console.log('[API STATS] User is teacher. Proceeding with stats (currently placeholders).');
    
    // For now, to ensure this API route itself works without DB errors for non-existent
    // tables or problematic RLS on other tables, we return placeholders for chatbot/room/concern counts.
    // We will uncomment these as we fix/verify RLS for each table.
    const stats = {
      totalChatbots: 0,       // Placeholder
      totalRooms: 0,          // Placeholder
      activeRooms: 0,         // Placeholder
      pendingConcerns: 0,     // Placeholder
    };
    
    /*
    // LATER: Uncomment when chatbots table and RLS are confirmed working
    const { count: chatbotsCount, error: chatbotsCountError } = await supabase
      .from('chatbots')
      .select('chatbot_id', { count: 'exact', head: true })
      .eq('teacher_id', user.id);

    if (chatbotsCountError) {
        console.error('[API STATS] Chatbots count query failed:', JSON.stringify(chatbotsCountError, null, 2));
        // Return current stats but log error, or throw to return 500
        // For now, let's log and continue with placeholders if this specific part fails
        // stats.totalChatbots = -1; // Indicate an error, or keep as 0
    } else {
        stats.totalChatbots = chatbotsCount || 0;
    }
    */

    console.log('[API STATS] Returning stats:', stats);
    return NextResponse.json(stats);

  } catch (error: unknown) {
    if (error instanceof Error) {
      console.error('[API STATS] CATCH BLOCK Error:', error.message);
      return NextResponse.json({ error: error.message }, { status: 500 });
    }
    console.error('[API STATS] CATCH BLOCK Error: Unknown error');
    return NextResponse.json({ error: 'Failed to fetch dashboard stats' }, { status: 500 });
  }
}// src/app/api/teacher/rooms/[roomId]/magic-link/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function POST(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // Verify user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Generate a signup link with embedded room code
    const magicLink = `${process.env.NEXT_PUBLIC_APP_URL}/join?code=${room.room_code}`;

    return NextResponse.json({ 
      magicLink: magicLink,
      roomCode: room.room_code 
    });
  } catch (error) {
    console.error('Error generating magic link:', error);
    return NextResponse.json(
      { error: 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function PATCH(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { is_active } = await request.json();
    const params = await context.params;
    const roomId = params.roomId;

    // Update room status
    const { data: room, error } = await supabase
      .from('rooms')
      .update({ is_active })
      .eq('room_id', roomId)
      .eq('teacher_id', user.id) // Ensure only the room owner can update
      .select()
      .single();

    if (error) {
      throw error;
    }

    if (!room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    return NextResponse.json(room);
  } catch (error) {
    console.error('Error updating room:', error);
    return NextResponse.json(
      { error: 'Failed to update room' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // First, check if the user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Delete the room (this will cascade to related tables via foreign key constraints)
    const { error: deleteError } = await supabase
      .from('rooms')
      .delete()
      .eq('room_id', roomId)
      .eq('teacher_id', user.id);

    if (deleteError) {
      throw deleteError;
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting room:', error);
    return NextResponse.json(
      { error: 'Failed to delete room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateRoomCode } from '@/lib/utils/room-codes'; // Ensure this utility exists
import type { CreateRoomPayload } from '@/types/database.types'; // Ensure this type is correct

// GET all rooms for the teacher
export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Fetch teacher's rooms WITH associated chatbot names for display
    const { data: rooms, error: fetchError } = await supabase
      .from('rooms')
      .select(`
        *,
        room_chatbots (
          chatbots ( chatbot_id, name )
        )
      `)
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) throw fetchError;
    return NextResponse.json(rooms || []);
  } catch (error) {
    console.error('Error in GET /api/teacher/rooms:', error);
    return NextResponse.json({ error: 'Failed to fetch rooms' }, { status: 500 });
  }
}

// POST a new room
export async function POST(request: Request) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    
    const { data: profile } = await supabase.from('profiles').select('role, school_id').eq('user_id', user.id).single();
    if (!profile || profile.role !== 'teacher') return NextResponse.json({ error: 'Not authorized' }, { status: 403 });

    const body: CreateRoomPayload = await request.json();
    if (!body.room_name || !body.chatbot_ids || body.chatbot_ids.length === 0) {
      return NextResponse.json({ error: 'Room name and at least one chatbot ID are required' }, { status: 400 });
    }

    let roomCode = '';
    let isUnique = false;
    while (!isUnique) {
      roomCode = generateRoomCode();
      const { data: existing } = await supabase.from('rooms').select('room_code').eq('room_code', roomCode).single();
      if (!existing) isUnique = true;
    }

    // Create room in a transaction
    const { data: newRoom, error: roomInsertError } = await supabase.from('rooms').insert({
      room_name: body.room_name,
      room_code: roomCode,
      teacher_id: user.id,
      school_id: profile.school_id, // from teacher's profile
      is_active: true,
    }).select().single();

    if (roomInsertError) throw roomInsertError;
    if (!newRoom) throw new Error('Room creation failed silently.');

    const roomChatbotEntries = body.chatbot_ids.map(chatbotId => ({
      room_id: newRoom.room_id,
      chatbot_id: chatbotId,
    }));

    const { error: rcInsertError } = await supabase.from('room_chatbots').insert(roomChatbotEntries);
    if (rcInsertError) {
      // Rollback room creation if linking chatbots fails
      await supabase.from('rooms').delete().eq('room_id', newRoom.room_id);
      throw rcInsertError;
    }
    
    // Fetch the complete room data to return
    const { data: completeRoomData, error: fetchCompleteError } = await supabase
        .from('rooms')
        .select(`*, room_chatbots(chatbots(chatbot_id, name))`)
        .eq('room_id', newRoom.room_id)
        .single();

    if (fetchCompleteError) throw fetchCompleteError;

    return NextResponse.json(completeRoomData, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/teacher/rooms:', error);
    return NextResponse.json({ error: 'Failed to create room' }, { status: 500 });
  }
}// src/app/api/teacher/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateRoomCode } from '@/lib/utils/room-codes';
import type { CreateRoomPayload, TeacherRoom } from '@/types/database.types';

// GET all rooms for the teacher
export async function GET() {
  console.log('[API GET /rooms] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API GET /rooms] User authenticated by getUser:', {
        id: user.id, 
        email: user.email, 
        aud: user.aud, // Should be 'authenticated'
        role: user.role // JWT role, typically 'authenticated'
    });

    console.log('[API GET /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileError) {
      console.error('[API GET /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileError, null, 2));
      console.warn('[API GET /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileError.message);
      return NextResponse.json({ error: `User profile not found or error fetching it. Details: ${profileError.message}` }, { status: 403 });
    }
    
    if (!profile) {
      console.warn('[API GET /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
      return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }

    console.log('[API GET /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API GET /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    
    console.log('[API GET /rooms] User is confirmed teacher. Fetching rooms.');
    
    const { data: rooms, error: fetchError } = await supabase
      .from('rooms')
      .select(`
        *,
        room_chatbots (
          chatbots ( chatbot_id, name )
        )
      `)
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) {
      console.error('[API GET /rooms] Error fetching rooms from DB:', fetchError);
      throw fetchError; // Let the outer catch handle it by re-throwing
    }
    console.log(`[API GET /rooms] Successfully fetched ${rooms?.length || 0} rooms.`);
    return NextResponse.json(rooms || []);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string }; // Cast with error properties
    console.error('[API GET /rooms] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}

// POST a new room
export async function POST(request: Request) {
  console.log('[API POST /rooms] Received request to create a new room.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API POST /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API POST /rooms] User authenticated by getUser:', {
        id: user.id, 
        email: user.email, 
        aud: user.aud, // Should be 'authenticated'
        role: user.role // JWT role, typically 'authenticated'
    });
    
    console.log('[API POST /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileFetchError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileFetchError) {
        console.error('[API POST /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileFetchError, null, 2));
        console.warn('[API POST /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileFetchError.message);
        return NextResponse.json({ error: `Error fetching user profile. Details: ${profileFetchError.message}` }, { status: 500 });
    }
    if (!profile) {
        console.error('[API POST /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
        return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }
     console.log('[API POST /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API POST /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    console.log('[API POST /rooms] User is confirmed teacher. Proceeding with room creation.');

    const body: CreateRoomPayload = await request.json();
    console.log('[API POST /rooms] Request body:', body);

    if (!body.room_name || !body.chatbot_ids || !Array.isArray(body.chatbot_ids) || body.chatbot_ids.length === 0) {
      console.warn('[API POST /rooms] Invalid request body: Missing room_name or chatbot_ids.');
      return NextResponse.json({ error: 'Room name and at least one chatbot ID are required' }, { status: 400 });
    }

    let roomCode = '';
    let isUnique = false;
    let attempts = 0;
    const MAX_ATTEMPTS = 10; 
    
    console.log('[API POST /rooms] Generating unique room code...');
    while (!isUnique && attempts < MAX_ATTEMPTS) {
      roomCode = generateRoomCode();
      const { data: existingRoom, error: codeCheckError } = await supabase
        .from('rooms')
        .select('room_code')
        .eq('room_code', roomCode)
        .maybeSingle(); 
      
      if (codeCheckError) {
        console.error('[API POST /rooms] Error checking room code uniqueness:', codeCheckError);
        throw codeCheckError;
      }
      if (!existingRoom) {
        isUnique = true;
      }
      attempts++;
    }

    if (!isUnique) {
        console.error('[API POST /rooms] Failed to generate a unique room code after multiple attempts.');
        throw new Error('Failed to generate a unique room code.');
    }
    console.log('[API POST /rooms] Unique room code generated:', roomCode);

    console.log('[API POST /rooms] Inserting new room into "rooms" table.');
    const { data: newRoom, error: roomInsertError } = await supabase
      .from('rooms')
      .insert({
        room_name: body.room_name,
        room_code: roomCode,
        teacher_id: user.id,
        school_id: profile.school_id, 
        is_active: true,
      })
      .select()
      .single();

    if (roomInsertError) {
      console.error('[API POST /rooms] Error inserting into "rooms" table:', roomInsertError);
      throw roomInsertError;
    }
    if (!newRoom) {
        console.error('[API POST /rooms] Room creation failed: newRoom data is null after insert.');
        throw new Error('Room creation returned no data.');
    }
    console.log('[API POST /rooms] Room inserted successfully. Room ID:', newRoom.room_id);

    console.log('[API POST /rooms] Preparing to insert into "room_chatbots" table.');
    const roomChatbotEntries = body.chatbot_ids.map(chatbotId => ({
      room_id: newRoom.room_id,
      chatbot_id: chatbotId,
    }));

    const { error: rcInsertError } = await supabase
      .from('room_chatbots')
      .insert(roomChatbotEntries);

    if (rcInsertError) {
      console.error('[API POST /rooms] Error inserting into "room_chatbots":', rcInsertError);
      console.log(`[API POST /rooms] Attempting to rollback room creation for room ID: ${newRoom.room_id} due to room_chatbots insert failure.`);
      const { error: deleteError } = await supabase.from('rooms').delete().eq('room_id', newRoom.room_id);
      if (deleteError) {
          console.error(`[API POST /rooms] CRITICAL: Failed to rollback room ${newRoom.room_id} after room_chatbots insert error:`, deleteError);
      } else {
          console.log(`[API POST /rooms] Successfully rolled back room ${newRoom.room_id}.`);
      }
      throw rcInsertError; 
    }
    console.log(`[API POST /rooms] Successfully inserted ${roomChatbotEntries.length} entries into "room_chatbots".`);
    
    console.log('[API POST /rooms] Fetching complete room data for response.');
    const { data: completeRoomData, error: fetchCompleteError } = await supabase
        .from('rooms')
        .select(`
            *,
            room_chatbots (
              chatbots ( chatbot_id, name )
            )
        `)
        .eq('room_id', newRoom.room_id)
        .single();

    if (fetchCompleteError) {
        console.error('[API POST /rooms] Error fetching complete room data after creation:', fetchCompleteError);
        throw fetchCompleteError;
    }
    if (!completeRoomData) {
        console.error('[API POST /rooms] Failed to fetch complete room data after creation, though room should exist.');
        throw new Error('Failed to retrieve newly created room details.');
    }

    console.log('[API POST /rooms] Room creation successful. Returning complete room data.');
    return NextResponse.json(completeRoomData as TeacherRoom, { status: 201 });

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string; constraint?: string };
    console.error('[API POST /rooms] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    if (typedError?.code === '23505' && typedError?.constraint === 'rooms_room_code_key') {
        return NextResponse.json({ error: 'A room with this code already exists. This is highly unlikely and might indicate an issue with room code generation.' }, { status: 409 });
    }
    return NextResponse.json(
      { error: typedError?.message || 'Failed to create room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/concerns/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { FlaggedMessage, ConcernStatus, Profile, Room, ChatMessage } from '@/types/database.types';
import { PostgrestError, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

// Intermediate type for the raw Supabase query result
type RawFlaggedMessageWithJoins = FlaggedMessage & {
    student: Pick<Profile, 'full_name' | 'email'> | null; // Use the alias from the select
    room: Pick<Room, 'room_name'> | null;      // Use the alias from the select
    message: Pick<ChatMessage, 'content'> | null; // Use the alias from the select
};

// API list response structure
interface FlaggedConcernListDetails extends FlaggedMessage {
    student_name: string | null;
    student_email: string | null;
    room_name: string | null;
    message_content: string | null;
}

// API detail response structure for a single flag
interface FlagDetailsResponse extends FlaggedMessage {
    student: Pick<Profile, 'full_name' | 'email'> | null; // Nested original
    room: Pick<Room, 'room_name'> | null; // Nested original
    message: ChatMessage | null; // Nested original
    student_name: string | null; // Flattened
    student_email: string | null; // Flattened
    room_name: string | null; // Flattened
    message_content: string | null; // Flattened
    surroundingMessages: ChatMessage[];
}

export async function GET(request: NextRequest) {
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();

        if (profileError || !profile) {
            return NextResponse.json({ error: 'User profile not found' }, { status: 403 });
        }

        if (profile.role !== 'teacher') {
            return NextResponse.json({ error: 'Not authorized. Teacher role required.' }, { status: 403 });
        }

        const { searchParams } = new URL(request.url);
        const flagId = searchParams.get('flagId');
        
        // If flagId is provided, return details for a single flag
        if (flagId) {
            return await getSingleConcernDetails(supabase, flagId, user.id);
        }
        
        // Otherwise return the list of concerns
        const statusFilter = searchParams.get('status');
        const limit = parseInt(searchParams.get('limit') || '10', 10);
        const page = parseInt(searchParams.get('page') || '0', 10);
        const offset = page * limit;

        console.log(`Fetching concerns list for teacher ${user.id}, status: ${statusFilter || 'all'}, page: ${page}, limit: ${limit}`);

        let countQuery = supabase
            .from('flagged_messages')
            .select('*', { count: 'exact', head: true })
            .eq('teacher_id', user.id);

        // Constraint names
        const studentConstraintName = 'flagged_messages_student_id_fkey';
        const roomConstraintName = 'flagged_messages_room_id_fkey';
        const messageConstraintName = 'flagged_messages_message_id_fkey';

        let dataQuery = supabase
            .from('flagged_messages')
            .select(`
                *,
                student:profiles!${studentConstraintName}(full_name, email),
                room:rooms!${roomConstraintName}(room_name),
                message:chat_messages!${messageConstraintName}(content)
            `)
            .eq('teacher_id', user.id)
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);

        const validStatuses: ConcernStatus[] = ['pending', 'reviewing', 'resolved', 'false_positive'];
        if (statusFilter && validStatuses.includes(statusFilter as ConcernStatus)) {
            const typedStatusFilter = statusFilter as ConcernStatus;
            countQuery = countQuery.eq('status', typedStatusFilter);
            dataQuery = dataQuery.eq('status', typedStatusFilter);
        }

        const [countResult, dataResult] = await Promise.all([countQuery, dataQuery]);

        const { count, error: countError } = countResult;
        const { data: flaggedMessagesRaw, error: fetchError } = dataResult as { 
            data: RawFlaggedMessageWithJoins[] | null, 
            error: PostgrestError | null 
        };

        if (countError) console.warn('Error fetching concerns count:', countError.message);
        if (fetchError) {
            console.error('Error fetching flagged messages data:', fetchError);
            if(fetchError.message.includes("does not exist")){ 
                console.error("Hint: Double-check column name ('full_name'?) and FK constraint names match your DB schema EXACTLY."); 
            }
            else if (fetchError.message.includes("Could not embed")) { 
                console.error("Hint: Ensure specified FK constraint names are correct and unique for the join."); 
            }
            else if (fetchError.message.includes("failed to parse select parameter")){ 
                console.error("Hint: Check syntax inside the .select() string for typos/invalid characters (NO COMMENTS!)."); 
            }
            throw new Error(`Failed to fetch flagged messages: ${fetchError.message}`);
        }

        // Data Transformation
        const concerns: FlaggedConcernListDetails[] = (flaggedMessagesRaw || []).map((flag: RawFlaggedMessageWithJoins) => ({
            ...flag, // Spread base FlaggedMessage props
            student_name: flag.student?.full_name || 'Unknown Student',
            student_email: flag.student?.email || null,
            room_name: flag.room?.room_name || 'Unknown Room',
            message_content: flag.message?.content || '[Message Content Unavailable]',
        }));

        // Pagination Logic
        const totalCount = count || 0;
        const hasMore = (offset + concerns.length) < totalCount;
        const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;

        console.log(`Found ${concerns.length} concerns for page ${page}, total: ${totalCount}`);

        return NextResponse.json({
            concerns,
            pagination: { currentPage: page, pageSize: limit, totalCount, totalPages, hasMore }
        });

    } catch (error) {
        console.error('Error in GET /api/teacher/concerns:', error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'An internal error occurred while fetching concerns.' },
            { status: 500 }
        );
    }
}

// Function to handle individual concern details
async function getSingleConcernDetails(
    supabase: SupabaseClient<Database>,
    flagId: string,
    teacherId: string
): Promise<NextResponse> {
    try {
        console.log(`Fetching details for concern flag ID: ${flagId}`);
        
        // Constraint names for joins
        const studentConstraintName = 'flagged_messages_student_id_fkey';
        const roomConstraintName = 'flagged_messages_room_id_fkey';
        const messageConstraintName = 'flagged_messages_message_id_fkey';
        
        // Fetch the flag with detailed joins
        const { data: flag, error: flagError } = await supabase
            .from('flagged_messages')
            .select(`
                *,
                student:profiles!${studentConstraintName}(full_name, email),
                room:rooms!${roomConstraintName}(room_name),
                message:chat_messages!${messageConstraintName}(*)
            `)
            .eq('flag_id', flagId)
            .eq('teacher_id', teacherId)  // Security: ensure it belongs to this teacher
            .single();
            
        if (flagError) {
            console.error(`Error fetching flag ${flagId}:`, flagError);
            return NextResponse.json({ error: 'Concern not found or access denied' }, { status: 404 });
        }
        
        if (!flag) {
            return NextResponse.json({ error: 'Concern not found' }, { status: 404 });
        }
        
        // Prepare response with flattened fields for convenience
        const response: FlagDetailsResponse = {
            ...flag,
            student_name: flag.student?.full_name || 'Unknown Student',
            student_email: flag.student?.email || null,
            room_name: flag.room?.room_name || 'Unknown Room',
            message_content: flag.message?.content || '[Message Content Unavailable]',
            surroundingMessages: [] // Initialize empty, will populate below
        };
        
        // Fetch surrounding conversation messages for context
        if (flag.message && flag.room_id && flag.student_id) {
            const messageCreatedAt = flag.message.created_at;
            const studentId = flag.student_id;
            const roomId = flag.room_id;
            
            // Fetch conversation context (messages before and after the flagged message)
            const { data: messagesData, error: messagesError } = await supabase
                .from('chat_messages')
                .select('*')
                .eq('room_id', roomId)
                .eq('user_id', studentId)
                // If using a chatbot filter from the flagged message metadata
                .filter('metadata->>chatbotId', flag.message.metadata?.chatbotId ? 'eq' : 'is', 
                        flag.message.metadata?.chatbotId || null)
                // Get messages around the flagged message time
                .or(`created_at.gte.${new Date(new Date(messageCreatedAt).getTime() - 3600000).toISOString()},created_at.lte.${new Date(new Date(messageCreatedAt).getTime() + 3600000).toISOString()}`)
                .order('created_at', { ascending: true })
                .limit(20);  // Reasonable limit for context
                
            if (messagesError) {
                console.warn(`Error fetching conversation context for flag ${flagId}:`, messagesError);
                // Don't fail the whole request if context fetch fails
            } else {
                response.surroundingMessages = messagesData || [];
            }
        }
        
        console.log(`Successfully fetched details for flag ${flagId} with ${response.surroundingMessages.length} context messages`);
        return NextResponse.json(response);
        
    } catch (error) {
        console.error(`Error in getSingleConcernDetails for flag ${flagId}:`, error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Failed to fetch concern details' },
            { status: 500 }
        );
    }
}

// PATCH Handler (for updating a single flag's status)
export async function PATCH(request: NextRequest) {
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) { 
            console.error("PATCH /concerns Auth Error:", authError); 
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); 
        }

        const body = await request.json();
        const { flagId, status, notes } = body; // Expect flagId in the body

        if (!flagId) return NextResponse.json({ error: 'Flag ID is required in request body' }, { status: 400 });

        const validStatuses: ConcernStatus[] = ['pending', 'reviewing', 'resolved', 'false_positive'];
        if (!status || !validStatuses.includes(status as ConcernStatus)) {
            return NextResponse.json({ error: `Invalid status provided: ${status}` }, { status: 400 });
        }
        
        if (notes !== undefined && notes !== null && typeof notes !== 'string') {
            return NextResponse.json({ error: 'Invalid notes format' }, { status: 400 });
        }

        console.log(`Updating flag ${flagId} by teacher ${user.id} to status: ${status}`);

        const updateData: { 
            status: ConcernStatus; 
            notes?: string | null; 
            reviewed_at: string; 
            reviewer_id: string; 
            updated_at: string; 
        } = {
            status: status as ConcernStatus, 
            updated_at: new Date().toISOString(),
            reviewer_id: user.id, 
            reviewed_at: new Date().toISOString(),
            ...(notes !== undefined && { notes: notes === '' ? null : notes })
        };

        // Perform update - RLS policy on flagged_messages should check if user.id == teacher_id
        const { data: updatedFlag, error: updateError } = await supabase
            .from('flagged_messages')
            .update(updateData)
            .eq('flag_id', flagId)
            .eq('teacher_id', user.id) // Explicitly check teacher ownership for PATCH safety
            .select()
            .single();

        if (updateError) {
            console.error(`Error updating flag ${flagId} status:`, updateError);
            if (updateError.code === 'PGRST116' || updateError.code === '42501') {
                return NextResponse.json({ error: 'Update failed: Flag not found or permission denied' }, { status: 404 });
            }
            if (updateError.code === '23514') {
                return NextResponse.json({ error: `Invalid input value: ${updateError.message}` }, { status: 400 });
            }
            throw new Error(`Failed to update flag status: ${updateError.message}`);
        }

        if (!updatedFlag) {
            return NextResponse.json({ error: 'Flag not found or update failed' }, { status: 404 });
        }

        console.log(`Flag ${flagId} updated successfully.`);
        return NextResponse.json(updatedFlag); // Return updated flag

    } catch (error) { 
        console.error(`Error in PATCH /api/teacher/concerns:`, error); 
        return NextResponse.json({ 
            error: error instanceof Error ? error.message : 'Failed to update concern status' 
        }, { status: 500 }); 
    }
}// src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Container, Card, Button } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';

const HomePage = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const Hero = styled.section`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl} 0;
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.primary};
  font-size: 3rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const CTAButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const Features = styled.section`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  margin-top: ${({ theme }) => theme.spacing.xxl};
`;

const FeatureCard = styled(Card)`
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  
  h3 {
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

export default function Home() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [isRedirecting, setIsRedirecting] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkUserAndRedirect = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        setUser(user);
        
        if (user) {
          setIsRedirecting(true);
          
          // Get user profile to check role
          const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
          
          if (profile?.role === 'teacher') {
            router.push('/teacher-dashboard');
          } else if (profile?.role === 'student') {
            router.push('/student');
          }
        }
      } catch (error) {
        console.error('Error checking user:', error);
      } finally {
        setLoading(false);
      }
    };

    checkUserAndRedirect();
  }, [router, supabase]);

  if (loading || isRedirecting) {
    return (
      <HomePage>
        <Container>
          <Hero>
            <Title>Loading...</Title>
          </Hero>
        </Container>
      </HomePage>
    );
  }

  return (
    <HomePage>
      <Container>
        <Hero>
          <Title>ClassBots AI</Title>
          <Subtitle>AI-powered chatbots for modern classrooms</Subtitle>
          
          {!user && (
            <CTAButtons>
              <Button size="large" onClick={() => router.push('/auth')}>
                Teacher Sign In
              </Button>
              <Button size="large" variant="secondary" onClick={() => router.push('/join')}>
                Student: Join Class
              </Button>
            </CTAButtons>
          )}
        </Hero>

        <Features>
          <FeatureCard>
            <h3>For Teachers</h3>
            <p>Create custom AI chatbots tailored to your classroom needs</p>
          </FeatureCard>
          <FeatureCard>
            <h3>For Students</h3>
            <p>Learn interactively with AI-powered classroom assistants</p>
          </FeatureCard>
          <FeatureCard>
            <h3>Easy to Use</h3>
            <p>Simple setup and magic link access for students</p>
          </FeatureCard>
        </Features>
      </Container>
    </HomePage>
  );
}/* src/app/globals.css */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}// src/app/providers.tsx
'use client';

import StyledComponentsRegistry from '@/lib/StyledComponentsRegistry';
import ThemeProvider from '@/components/ThemeProvider';

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <StyledComponentsRegistry>
      <ThemeProvider>
        {children}
      </ThemeProvider>
    </StyledComponentsRegistry>
  );
}// src/styles/GlobalStyles.ts
'use client';

import { createGlobalStyle } from 'styled-components';

export const GlobalStyles = createGlobalStyle`
  /* Use web-safe fonts for now - add Google Fonts to your layout.tsx instead */
  
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  
  html, body {
    max-width: 100vw;
    overflow-x: hidden;
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: ${({ theme }) => theme.fonts.heading};
    line-height: 1.2;
    color: ${({ theme }) => theme.colors.text};
    font-weight: 600;
  }
  
  h1 { font-size: 2.5rem; }
  h2 { font-size: 2rem; }
  h3 { font-size: 1.75rem; }
  h4 { font-size: 1.5rem; }
  h5 { font-size: 1.25rem; }
  h6 { font-size: 1rem; }
  
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }
  
  a {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: none;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primaryLight};
    }
  }
  
  button {
    font-family: ${({ theme }) => theme.fonts.body};
    cursor: pointer;
    border: none;
    background: none;
    transition: all ${({ theme }) => theme.transitions.fast};
    
    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  }
  
  input, textarea, select {
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.5;
  }
  
  /* Custom scrollbar styles */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  
  ::-webkit-scrollbar-track {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  ::-webkit-scrollbar-thumb {
    background: ${({ theme }) => theme.colors.border};
    border-radius: ${({ theme }) => theme.borderRadius.small};
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: ${({ theme }) => theme.colors.borderDark};
  }
  
  /* Focus styles */
  button:focus-visible,
  input:focus-visible,
  textarea:focus-visible,
  select:focus-visible {
    outline: 2px solid ${({ theme }) => theme.colors.focus};
    outline-offset: 2px;
  }
`;// src/styles/StyledComponents.ts
import styled from 'styled-components'; // Removed 'css' import as it's not used here

export const Container = styled.div`
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0 ${({ theme }) => theme.spacing.md};
  }
`;

export const Card = styled.div`
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.xl};
  padding: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.lg};
  }
`;

export const Button = styled.button<{
    variant?: 'primary' | 'secondary' | 'outline' | 'danger'; // Added 'danger'
    size?: 'small' | 'medium' | 'large';
  }>`
    background: ${({ theme, variant = 'primary' }) => {
      // Determine background color based on variant
      if (variant === 'primary') return theme.colors.primary;
      if (variant === 'secondary') return theme.colors.secondary;
      if (variant === 'danger') return theme.colors.red; // Danger background
      // For 'outline' or any other unspecified variant, background is transparent
      return 'transparent'; 
    }};
    color: ${({ theme, variant = 'primary' }) => {
      // Determine text color based on variant
      if (variant === 'outline') return theme.colors.primary;
      // For primary, secondary, danger, text is white (or could be adjusted)
      return 'white'; 
    }};
    border: ${({ theme, variant }) => {
      // Determine border based on variant
      if (variant === 'outline') return `2px solid ${theme.colors.primary}`;
      // Danger variant could also have a border matching its background or a darker shade
      if (variant === 'danger') return `2px solid ${theme.colors.red}`; 
      // Primary and secondary have no border by default in this setup
      return 'none'; 
    }};
    padding: ${({ theme, size = 'medium' }) =>
      size === 'small' ? `${theme.spacing.xs} ${theme.spacing.md}` :
      size === 'large' ? `${theme.spacing.md} ${theme.spacing.xl}` :
      `${theme.spacing.sm} ${theme.spacing.lg}`
    };
    border-radius: ${({ theme }) => theme.borderRadius.large};
    font-weight: 500;
    transition: all ${({ theme }) => theme.transitions.fast};
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1.2;
    text-decoration: none; // For 'as={Link}' usage

    &:hover:not(:disabled) {
      background: ${({ theme, variant = 'primary' }) => {
        if (variant === 'primary') return theme.colors.primaryDark;
        if (variant === 'secondary') return theme.colors.secondaryDark;
        if (variant === 'danger') return theme.colors.red; // Could define theme.colors.redDark
        if (variant === 'outline') return theme.colors.primary; 
        return undefined; // Fallback or inherit
      }};
      border-color: ${({ theme, variant = 'primary' }) => {
        // Ensure border color might change on hover too if desired
        if (variant === 'danger') return theme.colors.red; // Or theme.colors.redDark
        if (variant === 'outline') return theme.colors.primary; // Border remains primary for outline on hover
        return undefined; // Fallback
      }};
      color: ${({ variant }) => {
        if (variant === 'outline') return 'white'; // Outline text becomes white on hover
        // For other variants like danger, text color typically remains white
        return 'white'; 
      }};
      transform: translateY(-1px);
      box-shadow: ${({ theme }) => theme.shadows.md};
    }

    &:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    &:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  `;

// Inherit from Button for consistency
export const SecondaryButton = styled(Button).attrs({ variant: 'secondary' })``;
export const OutlineButton = styled(Button).attrs({ variant: 'outline' })``;
export const DangerButton = styled(Button).attrs({ variant: 'danger' })``; // Optional: specific export for danger

export const FormGroup = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

export const Label = styled.label`
  display: block;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.9rem;
`;

export const Input = styled.input`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast};
  min-height: 44px;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary + '40'};
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const TextArea = styled.textarea`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.6;
  transition: border-color ${({ theme }) => theme.transitions.fast};
  min-height: 100px;
  resize: vertical;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary + '40'};
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

   &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const Select = styled.select`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast};
  min-height: 44px;
  cursor: pointer;
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${({ theme }) => theme.colors.textMuted.replace('#', '')}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right ${({ theme }) => theme.spacing.md} center;
  background-size: 0.65em auto;
  padding-right: ${({ theme }) => `calc(${theme.spacing.md} * 2.5 + 1em)`};

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 2px ${({ theme }) => theme.colors.primary + '40'};
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
    background-image: none;
  }

  option {
    color: ${({ theme }) => theme.colors.text};
    background: ${({ theme }) => theme.colors.background};
  }
`;

export const Alert = styled.div<{ variant?: 'info' | 'success' | 'warning' | 'error' }>`
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  border-left: 4px solid;
  font-size: 0.9rem;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `
          background: ${theme.colors.green + '15'};
          border-color: ${theme.colors.green};
          color: ${theme.colors.text};
        `;
      case 'warning':
        return `
          background: ${theme.colors.secondary + '15'};
          border-color: ${theme.colors.secondary};
          color: ${theme.colors.text};
        `;
      case 'error':
        return `
          background: ${theme.colors.red + '15'};
          border-color: ${theme.colors.red};
          color: ${theme.colors.text};
        `;
      default: // info
        return `
          background: ${theme.colors.blue + '15'};
          border-color: ${theme.colors.blue};
          color: ${theme.colors.text};
        `;
    }
  }}
`;

export const Badge = styled.span<{ variant?: 'default' | 'success' | 'warning' | 'error' }>`
  display: inline-flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.round};
  font-size: 0.75rem;
  font-weight: 600;
  line-height: 1;
  text-transform: uppercase;
  letter-spacing: 0.05em;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `
          background: ${theme.colors.green + '20'};
          color: ${theme.colors.green};
        `;
      case 'warning':
        return `
          background: ${theme.colors.secondary + '20'};
          color: ${theme.colors.secondaryDark};
        `;
      case 'error':
        return `
          background: ${theme.colors.red + '20'};
          color: ${theme.colors.red};
        `;
      default: 
        return `
          background: ${theme.colors.primary + '20'};
          color: ${theme.colors.primary};
        `;
    }
  }}
`;// src/styles/theme.ts
import { DefaultTheme } from 'styled-components';

const theme: DefaultTheme = {
  colors: {
    // Primary colors - inspired by Canva's purple
    primary: '#6B50B7', // Canva-like purple
    primaryLight: '#9B8DD4', // Lighter purple
    primaryDark: '#4A3889', // Darker purple
    
    // Secondary colors - accent colors
    secondary: '#FFB849', // Warm accent orange
    secondaryLight: '#FFC978',
    secondaryDark: '#E5A03D',
    
    // Neutral colors
    background: '#FFFFFF', // Clean white
    backgroundDark: '#F5F5F5', // Light gray
    backgroundCard: '#F9FAFB', // Card background
    text: '#1A1E2E', // Deep dark blue
    textLight: '#5E6C7A', // Muted blue-gray
    textMuted: '#9CA3AF', // Light gray text
    
    // Accent colors
    green: '#4BCE97', // Success green
    red: '#F87F7F', // Error red/pink
    blue: '#4A9FFF', // Info blue
    
    // UI colors
    border: '#E5E7EB', // Light border
    borderDark: '#D1D5DB', // Darker border
    focus: '#6B50B7', // Focus ring color
    shadow: '0, 0, 0', // Shadow RGB
  },
  
  fonts: {
    heading: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    body: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    mono: "'SF Mono', 'Fira Code', Consolas, monospace",
  },
  
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px',
  },
  
  borderRadius: {
    small: '6px', // Slightly bigger for modern look
    medium: '8px',
    large: '12px',
    xl: '16px', // Extra large for cards
    round: '50%',
  },
  
  shadows: {
    sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
    md: '0 4px 6px rgba(0, 0, 0, 0.1)',
    lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
    xl: '0 20px 25px rgba(0, 0, 0, 0.1)',
  },
  
  gradients: {
    primary: 'linear-gradient(135deg, #6B50B7, #8A74C5)',
    secondary: 'linear-gradient(135deg, #FFB849, #FFC978)',
  },
  
  breakpoints: {
    mobile: '480px',
    tablet: '768px',
    desktop: '1024px',
    wide: '1280px',
  },
  
  transitions: {
    fast: '0.15s ease',
    normal: '0.25s ease',
    slow: '0.35s ease',
  },
};

export default theme;// src/components/auth/MagicLink.tsx
'use client';

import { useState, useEffect, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Alert } from '@/styles/StyledComponents';

const MagicCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const SubText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
`;

const RoomCode = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

function MagicLinkContent() {
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [error, setError] = useState<string>('');
  const [roomCode, setRoomCode] = useState<string>('');
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const handleMagicLink = async () => {
      // Check if we're in the browser
      if (typeof window === 'undefined') return;

      const params = new URLSearchParams(window.location.search);
      // Get all possible parameters
      const code = params.get('token') || params.get('code');
      const roomCodeParam = params.get('room');
      
      if (!code || !roomCodeParam) {
        console.log('Missing parameters:', { code, roomCodeParam });
        setError('Invalid magic link: missing required parameters');
        setStatus('error');
        return;
      }

      setRoomCode(roomCodeParam);

      try {
        // Exchange code for session using client-side supabase only
        const { error: authError } = await supabase.auth.exchangeCodeForSession(code);
        if (authError) throw authError;

        // Get user data
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) throw userError || new Error('No user found');

        // Get room details
        const { data: room, error: roomError } = await supabase
          .from('rooms')
          .select('room_id, school_id')
          .eq('room_code', roomCodeParam)
          .single();

        if (roomError || !room) throw roomError || new Error('Room not found');

        // Create or update user profile
        const { error: profileError } = await supabase
          .from('profiles')
          .upsert(
            { 
              user_id: user.id,
              email: user.email || '',
              role: 'student',
              school_id: room.school_id 
            },
            { onConflict: 'user_id' }
          );

        if (profileError) throw profileError;

        // Join the room
        const { error: joinError } = await supabase
          .from('room_memberships')
          .insert({
            room_id: room.room_id,
            student_id: user.id
          });

        // Ignore duplicate errors
        if (joinError && !joinError.message.includes('duplicate')) {
          throw joinError;
        }

        setStatus('success');
        
        // Redirect to student dashboard after 2 seconds
        setTimeout(() => {
          router.push('/student');
        }, 2000);

      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to process magic link');
        setStatus('error');
      }
    };

    handleMagicLink();
  }, [router, supabase]);

  return (
    <MagicCard>
      <Title>Join Classroom</Title>
      
      {roomCode && (
        <RoomCode>{roomCode}</RoomCode>
      )}

      {status === 'loading' && (
        <SubText>Processing your invitation...</SubText>
      )}

      {status === 'success' && (
        <>
          <Alert variant="success">Successfully joined classroom!</Alert>
          <SubText>Redirecting to your dashboard...</SubText>
        </>
      )}

      {status === 'error' && (
        <>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.push('/auth')}>
            Go to Login
          </Button>
        </>
      )}
    </MagicCard>
  );
}

export default function MagicLink() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MagicLinkContent />
    </Suspense>
  );
}// src/components/auth/AuthForm.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, FormGroup, Label, Input, Button as StyledButton, Alert } from '@/styles/StyledComponents';

const AuthCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
`;

const Title = styled.h1`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const InfoBox = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  
  p {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
  
  strong {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

interface AuthFormProps {
  type: 'login' | 'signup';
}

export default function AuthForm({ type }: AuthFormProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [fullName, setFullName] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const isStudentSignup = searchParams?.get('type') === 'student';
  const redirectTo = searchParams?.get('redirect') || '/';

  const checkUser = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      router.push(redirectTo);
    }
  }, [supabase, router, redirectTo]);

  useEffect(() => {
    checkUser();
  }, [checkUser]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    // Validate full name for all signup types
    if (type === 'signup' && !fullName.trim()) {
      setError('Full name is required');
      return;
    }
    
    setLoading(true);
    setError('');

    try {
      if (type === 'signup') {
        // Determine role based on student signup flag
        const role = isStudentSignup ? 'student' : 'teacher';
        
        // Simplified signup with just the essential data
        // Let the database trigger handle profile creation
        const { error: signUpError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/auth/callback?redirect=${encodeURIComponent(redirectTo)}`,
            data: {
              role: role,
              full_name: fullName,
            }
          },
        });
        
        if (signUpError) {
          console.error('Signup error details:', signUpError);
          throw signUpError;
        }
        
        // For student signup, wait a moment then try to sign in
        if (isStudentSignup) {
          // Wait a moment for account creation to complete
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Try to sign in
          const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
            email,
            password,
          });
          
          if (!signInError && signInData.user) {
            // Successfully signed in, redirect to join page
            router.push(redirectTo);
          } else {
            // If login fails, show error but allow student to proceed to login page
            setError('Account created! Please log in to continue.');
            setTimeout(() => {
              router.push(`/auth?type=login&redirect=${encodeURIComponent(redirectTo)}`);
            }, 3000);
          }
        } else {
          // For teachers, show success message
          alert('Check your email for the confirmation link!');
        }
      } else {
        // Handle login
        const { error: signInError } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        
        if (signInError) {
          throw signInError;
        }
        
        router.push(redirectTo);
        router.refresh();
      }
    } catch (error) {
      console.error('Auth error:', error);
      setError(error instanceof Error ? error.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  // Special UI for student signup (very similar to teacher signup now)
  if (isStudentSignup && type === 'signup') {
    return (
      <AuthCard>
        <Title>Student Sign Up</Title>
        
        <InfoBox>
          <p><strong>For Students:</strong> Sign up here to join your classroom.</p>
        </InfoBox>
        
        {error && <Alert variant="error">{error}</Alert>}
        
        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="fullName">Full Name</Label>
            <Input
              id="fullName"
              type="text"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
              placeholder="Enter your full name"
              required
            />
          </FormGroup>
          <FormGroup>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Enter your email"
              required
            />
          </FormGroup>
          <FormGroup>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Create a password"
              required
            />
          </FormGroup>
          <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
            {loading ? 'Creating Account...' : 'Sign Up as Student'}
          </StyledButton>
        </form>
      </AuthCard>
    );
  }

  // Regular auth form for teachers or login
  return (
    <AuthCard>
      <Title>{type === 'login' ? 'Login' : 'Teacher Sign Up'}</Title>
      
      {type === 'signup' && (
        <InfoBox>
          <p><strong>For Teachers:</strong> Sign up here to create your teacher account.</p>
          <p><strong>For Students:</strong> Ask your teacher for a join link to create your account.</p>
        </InfoBox>
      )}
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        {type === 'signup' && (
          <FormGroup>
            <Label htmlFor="fullName">Full Name</Label>
            <Input
              id="fullName"
              type="text"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
              placeholder="Enter your full name"
              required
            />
          </FormGroup>
        )}
        <FormGroup>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Enter your email"
            required
          />
        </FormGroup>
        <FormGroup>
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter your password"
            required
          />
        </FormGroup>
        <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
          {loading ? 'Loading...' : type === 'login' ? 'Login' : 'Sign Up as Teacher'}
        </StyledButton>
      </form>
    </AuthCard>
  );
}// src/components/layout/Footer.tsx
'use client';

import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';

const FooterWrapper = styled.footer`
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.xl} 0;
  margin-top: auto;
`;

const FooterContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    text-align: center;
  }
`;

const Copyright = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

const Links = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  
  a {
    color: ${({ theme }) => theme.colors.textMuted};
    text-decoration: none;
    font-size: 0.875rem;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primary};
    }
  }
`;

export default function Footer() {
  const currentYear = new Date().getFullYear();
  
  return (
    <FooterWrapper>
      <Container>
        <FooterContent>
          <Copyright>
            © {currentYear} {APP_NAME}. All rights reserved.
          </Copyright>
          <Links>
            <a href="/privacy">Privacy Policy</a>
            <a href="/terms">Terms of Service</a>
            <a href="/help">Help Center</a>
          </Links>
        </FooterContent>
      </Container>
    </FooterWrapper>
  );
}// src/components/layout/Header.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client';
import { Container, Button } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';
import type { User } from '@supabase/supabase-js';

const HeaderWrapper = styled.header`
  background: ${({ theme }) => theme.colors.background};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md} 0;
  position: sticky;
  top: 0;
  z-index: 100;
`;

const HeaderContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-wrap: wrap;
    gap: ${({ theme }) => theme.spacing.sm};
  }
`;

const Logo = styled(Link)`
  font-size: 1.5rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.primary};
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  
  &:hover {
    color: ${({ theme }) => theme.colors.primaryDark};
  }
`;

const Nav = styled.nav`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    order: 3;
    width: 100%;
    justify-content: center;
    margin-top: ${({ theme }) => theme.spacing.sm};
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const NavLink = styled(Link)`
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
    color: ${({ theme }) => theme.colors.primary};
  }
  
  &.active {
    background: ${({ theme }) => theme.colors.primaryLight}20;
    color: ${({ theme }) => theme.colors.primary};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.sm};
    flex: 1;
    text-align: center;
  }
`;

const UserSection = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    min-width: 100px; /* Ensure consistent space */
    justify-content: flex-end;
  }
`;

const HeaderButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    font-size: 0.9rem;
  }
`;

export default function Header() {
  const [user, setUser] = useState<User | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  const supabase = createClient();

  useEffect(() => {
    const getUserInfo = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      setUser(user);
      
      if (user) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', user.id)
          .single();
        
        if (profile) {
          setUserRole(profile.role);
        }
      }
    };
    
    getUserInfo();

    // Add auth state change listener
    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user || null);
      
      // Update role if user exists
      if (session?.user) {
        supabase
          .from('profiles')
          .select('role')
          .eq('user_id', session.user.id)
          .single()
          .then(({ data }) => {
            if (data) {
              setUserRole(data.role);
            }
          });
      } else {
        setUserRole(null);
      }
    });

    // Cleanup subscription on unmount
    return () => {
      subscription.unsubscribe();
    };
  }, [supabase]);

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    window.location.href = '/';
  };

  return (
    <HeaderWrapper>
      <Container>
        <HeaderContent>
          <Logo href="/">
            {APP_NAME}
          </Logo>
          
          {user && (
            <Nav>
              {userRole === 'teacher' && (
                <NavLink href="/teacher-dashboard">Dashboard</NavLink>
              )}
              {userRole === 'student' && (
                <NavLink href="/student">My Rooms</NavLink>
              )}
            </Nav>
          )}
          
          <UserSection>
            {user ? (
              <HeaderButton variant="outline" onClick={handleSignOut}>
                Sign Out
              </HeaderButton>
            ) : (
              <HeaderButton as={Link} href="/auth">
                Sign In
              </HeaderButton>
            )}
          </UserSection>
        </HeaderContent>
      </Container>
    </HeaderWrapper>
  );
}// src/components/student/RoomList.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button } from '@/styles/StyledComponents';
import type { StudentRoom } from '@/types/student.types';

const RoomGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCard = styled(Card)`
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    transform: translateY(-2px);
  }
`;

const RoomHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const RoomName = styled.h3`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 1.25rem;
`;

const RoomDetails = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const ChatbotsList = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ChatbotInfo = styled.div`
  font-weight: 600;
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.div`
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 0.875rem;
  
  &:last-child {
    margin-bottom: 0;
  }
  
  strong {
    color: ${({ theme }) => theme.colors.text};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-top: ${({ theme }) => theme.spacing.xs};
  }
`;

const EmptyState = styled.div`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
`;

const RoomFooter = styled.div`
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const JoinedDate = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface RoomListProps {
  rooms: StudentRoom[];
}

export default function RoomList({ rooms }: RoomListProps) {
  return (
    <RoomGrid>
      {rooms.map((room) => (
        <RoomCard key={room.room_id}>
          <RoomHeader>
            <RoomName>{room.room_name}</RoomName>
            <RoomDetails>
              Room Code: <strong>{room.room_code}</strong>
            </RoomDetails>
          </RoomHeader>
          
          <ChatbotsList>
            {room.chatbots.length > 0 ? (
              <>
                <ChatbotInfo>
                  {room.chatbots.length} chatbot{room.chatbots.length > 1 ? 's' : ''}:
                </ChatbotInfo>
                {room.chatbots.map((chatbot) => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <strong>{chatbot.name}</strong>
                    {chatbot.description && (
                      <p>{chatbot.description}</p>
                    )}
                  </ChatbotItem>
                ))}
              </>
            ) : (
              <EmptyState>No chatbots assigned</EmptyState>
            )}
          </ChatbotsList>
          
          <RoomFooter>
            <JoinedDate>
              Joined: {new Date(room.joined_at || room.created_at).toLocaleDateString()}
            </JoinedDate>
            <Button 
              as={Link} 
              href={`/room/${room.room_id}`}
              size="medium"
              style={{ 
                minWidth: '120px',
                textAlign: 'center'
              }}
            >
              Enter Room
            </Button>
          </RoomFooter>
        </RoomCard>
      ))}
    </RoomGrid>
  );
}// src/components/student/JoinRoom.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';
import { isValidRoomCode } from '@/lib/utils/room-codes';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0 0 ${({ theme }) => theme.spacing.sm} 0;
  color: ${({ theme }) => theme.colors.text};
`;

const Description = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface JoinRoomProps {
  onClose: () => void;
  onSuccess: () => void;
}

export default function JoinRoom({ onClose, onSuccess }: JoinRoomProps) {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isCheckingAuth, setIsCheckingAuth] = useState(true);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setIsAuthenticated(true);
        }
      } catch (error) {
        console.error('Auth check error:', error);
      } finally {
        setIsCheckingAuth(false);
      }
    };
    
    checkAuth();
  }, [supabase]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formattedCode = roomCode.toUpperCase();

    if (!isValidRoomCode(formattedCode)) {
      setError('Invalid room code format');
      setIsLoading(false);
      return;
    }

    try {
      if (!isAuthenticated) {
        // If not authenticated, redirect to signup with room code
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
        return;
      }

      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ room_code: formattedCode }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to join room');
      }

      onSuccess();
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to join room');
    } finally {
      setIsLoading(false);
    }
  };

  if (isCheckingAuth) {
    return (
      <Overlay>
        <JoinCard>
          <Header>
            <Title>Loading...</Title>
          </Header>
        </JoinCard>
      </Overlay>
    );
  }

  return (
    <Overlay>
      <JoinCard>
        <Header>
          <Title>Join Classroom</Title>
          <Description>
            {isAuthenticated 
              ? 'Enter the room code provided by your teacher'
              : 'You need to log in to join a classroom'
            }
          </Description>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <Form onSubmit={handleSubmit}>
          <RoomCodeInput
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
            placeholder="ROOM CODE"
            maxLength={6}
            required
          />
          
          <ButtonGroup>
            <Button 
              type="button" 
              variant="outline" 
              onClick={onClose}
              style={{ flex: 1 }}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isLoading}
              style={{ flex: 1 }}
            >
              {isLoading ? 'Joining...' : isAuthenticated ? 'Join Room' : 'Sign In'}
            </Button>
          </ButtonGroup>
        </Form>
      </JoinCard>
    </Overlay>
  );
}// src/components/student/ProfileCompletion.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';

const ProfileCard = styled(Card)`
  max-width: 500px;
  margin: 0 auto;
  padding: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
  text-align: center;
`;

const Description = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function ProfileCompletion({ onComplete }: { onComplete: () => void }) {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClient();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!firstName.trim() || !lastName.trim()) {
      setError('Please enter both first and last name');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      // Update profile with name information
      const { error: updateError } = await supabase
        .from('profiles')
        .update({
          name: `${firstName} ${lastName}`.trim(),
          // We could also add these fields if the database schema supports them
          // first_name: firstName,
          // last_name: lastName,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', user.id);
      
      if (updateError) {
        throw updateError;
      }
      
      // Call the completion callback
      onComplete();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <ProfileCard>
      <Title>Complete Your Profile</Title>
      <Description>
        Please provide your name to complete your profile setup
      </Description>
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        <FormGroup>
          <Label htmlFor="firstName">First Name</Label>
          <Input
            id="firstName"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Enter your first name"
            required
          />
        </FormGroup>
        
        <FormGroup>
          <Label htmlFor="lastName">Last Name</Label>
          <Input
            id="lastName"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            placeholder="Enter your last name"
            required
          />
        </FormGroup>
        
        <Button 
          type="submit" 
          disabled={isSubmitting}
          style={{ width: '100%' }}
        >
          {isSubmitting ? 'Saving...' : 'Complete Profile'}
        </Button>
      </form>
    </ProfileCard>
  );
}// src/components/shared/LoadingSpinner.tsx
'use client';

import styled, { keyframes } from 'styled-components';

const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const SpinnerWrapper = styled.div`
  display: inline-flex;
  align-items: center;
  justify-content: center;
`;

const Spinner = styled.div<{ size?: 'small' | 'medium' | 'large' }>`
  width: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  height: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  border: 3px solid ${({ theme }) => theme.colors.border};
  border-top-color: ${({ theme }) => theme.colors.primary};
  border-radius: 50%;
  animation: ${spin} 1s linear infinite;
`;

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
}

export default function LoadingSpinner({ size = 'medium' }: LoadingSpinnerProps) {
  return (
    <SpinnerWrapper>
      <Spinner size={size} />
    </SpinnerWrapper>
  );
}// src/components/shared/Chat.tsx
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import ChatInput from '@/components/shared/ChatInput';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// --- CORRECTED IMPORT ---
import type { ChatMessage, Chatbot } from '@/types/database.types';
// ------------------------

const ChatContainer = styled(Card)`
  display: flex;
  flex-direction: column;
  height: calc(100vh - 200px); /* Adjust as needed */
  max-height: 800px;
  position: relative;
  padding: 0; /* Remove Card padding if MessagesList/InputContainer handle it */

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    height: calc(100vh - 150px);
    max-height: none;
    margin: 0;
    border-radius: 0;
    border: none; /* Remove border on mobile */
    box-shadow: none; /* Remove shadow on mobile */
  }
`;

const MessagesList = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: ${({ theme }) => theme.spacing.lg};
  background: ${({ theme }) => theme.colors.background};
  /* No border-radius needed if ChatContainer handles it */

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const StyledChatInputContainer = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  background: ${({ theme }) => theme.colors.backgroundCard};
  /* No border-radius needed if ChatContainer handles it */


  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.xl};

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const ErrorContainer = styled(Alert)`
  margin: ${({ theme }) => theme.spacing.md};
`;

const LoadingIndicator = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  height: 100%;
`;

interface ChatProps {
  roomId: string;
  chatbot: Chatbot;
}

export default function Chat({ roomId, chatbot }: ChatProps) {
  // --- CORRECTED TYPE for messages state ---
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  // -----------------------------------------
  const [isLoading, setIsLoading] = useState(false);
  const [isFetchingMessages, setIsFetchingMessages] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [fetchError, setFetchError] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const fetchedRef = useRef(false); // To prevent multiple initial fetches
  const supabase = createClient();

  useEffect(() => {
    const getUserId = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setUserId(user.id);
        } else {
          console.warn("Chat component: User not authenticated.");
          setFetchError("Authentication error. Please log in.");
        }
      } catch (err) {
        console.error('Error getting user ID:', err);
        setFetchError("Could not verify user. Please try refreshing.");
      }
    };
    getUserId();
  }, [supabase]); // Depend only on supabase client

  const scrollToBottom = useCallback(() => { // Wrap in useCallback
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  },[]); // No dependencies needed if it only uses ref

  const fetchMessages = useCallback(async () => {
    if (!chatbot?.chatbot_id || !userId || !roomId) {
        if (!chatbot?.chatbot_id) console.log("Fetch messages waiting: no chatbotId");
        if (!userId) console.log("Fetch messages waiting: no userId");
        if (!roomId) console.log("Fetch messages waiting: no roomId");
        setIsFetchingMessages(false); // Stop loading if prerequisites aren't met
        return;
    }

    console.log(`Fetching messages for room: ${roomId}, chatbot: ${chatbot.chatbot_id}, user: ${userId}`);
    setIsFetchingMessages(true);
    setFetchError(null);
    fetchedRef.current = true;

    try {
      const url = `/api/chat/${roomId}?chatbotId=${chatbot.chatbot_id}`;
      const response = await fetch(url);

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Failed to parse error response');
        console.error(`API error fetching messages: ${response.status}`, errorText);
        throw new Error(`Failed to fetch messages (status: ${response.status})`);
      }

      const data = await response.json();
      console.log("Fetched messages data:", data);
      // --- CORRECTED TYPE for fetched data ---
      setMessages(Array.isArray(data) ? data as ChatMessage[] : []);
      // --------------------------------------
      // Use timeout to allow DOM update before scrolling
      setTimeout(scrollToBottom, 100);
    } catch (err) {
      console.error('Message fetch error:', err);
      setFetchError(err instanceof Error ? err.message : 'Failed to load messages');
      fetchedRef.current = false; // Allow retry if fetch failed
    } finally {
      setIsFetchingMessages(false);
    }
  }, [roomId, chatbot?.chatbot_id, userId, scrollToBottom]); // Add scrollToBottom to deps

  useEffect(() => {
    // Fetch only when userId and chatbotId are available, and haven't successfully fetched yet
    if (userId && chatbot?.chatbot_id && !fetchedRef.current) {
      fetchMessages();
    }
    // If chatbotId changes, reset fetchedRef and fetch again
    const chatbotId = chatbot?.chatbot_id; // Capture for effect cleanup
    return () => {
        if (chatbotId !== chatbot?.chatbot_id) {
            fetchedRef.current = false;
        }
    }

  }, [userId, chatbot?.chatbot_id, fetchMessages]);


  const handleRetryFetch = () => {
    fetchedRef.current = false; // Allow refetch attempt
    fetchMessages();
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim() || isLoading || !userId || !chatbot?.chatbot_id || !roomId) return;

    setIsLoading(true);
    setError(null);

    // --- CORRECTED TYPE for optimistic messages ---
    const optimisticUserMessage: ChatMessage = {
      message_id: `local-user-${Date.now()}`,
      room_id: roomId,
      user_id: userId,
      role: 'user',
      content: content.trim(),
      created_at: new Date().toISOString(),
      metadata: { chatbotId: chatbot.chatbot_id }
    };

    const optimisticAssistantPlaceholder: ChatMessage = {
      message_id: `local-assistant-${Date.now()}`,
      room_id: roomId,
      user_id: "assistant-placeholder", // Placeholder
      role: 'assistant',
      content: 'Thinking...',
      created_at: new Date().toISOString(),
      metadata: { chatbotId: chatbot.chatbot_id }
    };
    // --------------------------------------------

    setMessages(prev => [...prev, optimisticUserMessage, optimisticAssistantPlaceholder]);
    setTimeout(scrollToBottom, 50); // Scroll immediately

    try {
      const response = await fetch(`/api/chat/${roomId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: content.trim(),
          chatbot_id: chatbot.chatbot_id,
          model: chatbot.model // Send model preference if available
        }),
      });

      if (!response.ok || !response.body) {
        const errorData = await response.json().catch(() => ({ error: { message: 'Failed to parse API error response' } }));
        console.error("Send message API error:", errorData);
        throw new Error(errorData.error?.message || `API error sending message (status: ${response.status})`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let streamedContent = '';
      let firstChunkReceived = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

         // Update placeholder on first chunk received
         if (!firstChunkReceived) {
            setMessages(prev => prev.map(msg =>
                msg.message_id === optimisticAssistantPlaceholder.message_id
                ? { ...msg, content: '' } // Clear "Thinking..."
                : msg
            ));
            firstChunkReceived = true;
         }

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);
            if (data.trim() === '[DONE]') continue;
            try {
              const parsedData = JSON.parse(data);
              if (parsedData.content) {
                streamedContent += parsedData.content;
                setMessages(prev => prev.map(msg =>
                  msg.message_id === optimisticAssistantPlaceholder.message_id
                    ? { ...msg, content: streamedContent } // Append streamed content
                    : msg
                ));
                // Consider scrolling less frequently for performance
                 scrollToBottom();
              }
            } catch (e) {
              console.error('Error parsing stream data chunk:', e, "Data:", data);
            }
          }
        }
      }
      console.log("Stream finished. Full response:", streamedContent);
      // Backend saves the full message upon stream completion in its finally block.
      // We can optionally update the local message ID once the backend confirms saving,
      // but for now, the optimistic ID works for rendering.
      // Consider a final update here or rely on a potential WebSocket update later.
       setMessages(prev => prev.map(msg =>
        msg.message_id === optimisticAssistantPlaceholder.message_id
          ? { ...msg, content: streamedContent.trim() } // Ensure final content is trimmed
          : msg
       ));


    } catch (err) {
      console.error('Chat send/receive error:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to send or receive message';
      setError(errorMsg);
      // Remove optimistic messages on error
      setMessages(prev => prev.filter(msg =>
          msg.message_id !== optimisticUserMessage.message_id &&
          msg.message_id !== optimisticAssistantPlaceholder.message_id
      ));
       // Optionally, re-add the user message that failed to send, perhaps with an error indicator
       setMessages(prev => [...prev, {...optimisticUserMessage, metadata: {...optimisticUserMessage.metadata, error: errorMsg}}]);

    } finally {
      setIsLoading(false);
    }
  };

  return (
    <ChatContainer>
      {fetchError && (
        <ErrorContainer variant="error">
          Error loading messages: {fetchError}
          <Button onClick={handleRetryFetch} size="small" style={{ marginLeft: '10px' }}>Retry</Button>
        </ErrorContainer>
      )}

      <MessagesList>
        {isFetchingMessages && messages.length === 0 ? (
           <LoadingIndicator><LoadingSpinner /> Loading messages...</LoadingIndicator>
        ) : !isFetchingMessages && messages.length === 0 && !fetchError ? (
          <EmptyState>
            <h3>Start your conversation with {chatbot.name}</h3>
            <p>Your chat history will appear here.</p>
          </EmptyState>
        ) : (
          messages.map((message) => (
            <ChatMessageComponent
              // Use message_id if available, otherwise generate a fallback key
              key={message.message_id || `local-${message.role}-${message.created_at}-${Math.random()}`}
              message={message}
              chatbotName={chatbot.name}
            />
          ))
        )}
        <div ref={messagesEndRef} /> {/* Element to scroll to */}
      </MessagesList>

      <StyledChatInputContainer>
        <ChatInput
          onSend={handleSendMessage}
          isLoading={isLoading}
          error={error}
          onClearError={() => setError(null)}
        />
      </StyledChatInputContainer>
    </ChatContainer>
  );
}// src/components/shared/ChatMessage.tsx
'use client';

import styled from 'styled-components';
import ReactMarkdown, { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { ChatMessage } from '@/types/database.types';
// --- Type Definitions ---
interface ChatMessageProps {
  message: ChatMessage;
  chatbotName: string;
}

type MessageMetadataWithError = {
    error?: unknown;
    [key: string]: unknown;
} | null | undefined;

// --- Styled Components (Keep as previously defined) ---
interface MessageWrapperProps {
  $isUser: boolean;
  $hasError: boolean;
}
const MessageWrapper = styled.div<MessageWrapperProps>`
  display: flex;
  justify-content: ${({ $isUser }) => $isUser ? 'flex-end' : 'flex-start'};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  opacity: ${({ $hasError }) => $hasError ? 0.7 : 1};
`;

interface MessageBubbleProps {
  $isUser: boolean;
  $hasError: boolean;
}
const MessageBubble = styled.div<MessageBubbleProps>`
  max-width: 80%;
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme, $isUser }) =>
    $isUser
      ? `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small} ${theme.borderRadius.xl}`
      : `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small}`
  };
  background: ${({ theme, $isUser }) =>
    $isUser ? theme.colors.primary : theme.colors.backgroundCard
  };
  color: ${({ theme, $isUser }) =>
    $isUser ? 'white' : theme.colors.text
  };
  box-shadow: ${({ theme }) => theme.shadows.sm};
  position: relative;

   ${({ $hasError, theme }) => $hasError && `
      border: 2px solid ${theme.colors.red};
   `}
`;

const MessageHeader = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const SenderName = styled.span`
  font-weight: 600;
  font-size: 0.875rem;
  opacity: 0.8;
`;

const Timestamp = styled.span`
  font-size: 0.75rem;
  opacity: 0.7;
`;

const MessageContent = styled.div<{ $isUser: boolean }>`
  line-height: 1.5;
  word-wrap: break-word;

  /* Basic Markdown styling reset/defaults */
  h1, h2, h3, h4, h5, h6 {
    margin-top: ${({ theme }) => theme.spacing.md};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-weight: 600;
    line-height: 1.3;
    color: inherit;
  }
  h1 { font-size: 1.5em; } h2 { font-size: 1.3em; } h3 { font-size: 1.2em; }
  h4 { font-size: 1.1em; } h5 { font-size: 1em; } h6 { font-size: 0.9em; }

  p { margin-bottom: ${({ theme }) => theme.spacing.sm}; &:last-child { margin-bottom: 0; } }
  ul, ol { margin-bottom: ${({ theme }) => theme.spacing.sm}; padding-left: ${({ theme }) => theme.spacing.lg}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }

  blockquote {
    border-left: 4px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.5)' : theme.colors.border};
    padding-left: ${({ theme }) => theme.spacing.md};
    margin: ${({ theme }) => theme.spacing.sm} 0;
    font-style: italic;
    color: ${({ $isUser }) => $isUser ? 'rgba(255,255,255,0.9)' : 'inherit'};
    opacity: 0.9;
  }

  /* Specific styling for code elements via custom renderer */
  pre.code-block-wrapper {
    background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)'};
    padding: ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin: ${({ theme }) => theme.spacing.sm} 0;
    overflow-x: auto;
    code {
        background: none !important; padding: 0 !important;
        font-family: ${({ theme }) => theme.fonts.mono};
        white-space: pre; font-size: 0.9em;
        color: inherit;
    }
  }

  /* Inline code */
  code.inline-code {
    background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.1)'};
    padding: 2px 5px;
    border-radius: ${({ theme }) => theme.borderRadius.small};
    font-family: ${({ theme }) => theme.fonts.mono};
    font-size: 0.9em;
  }

  hr {
    border: none; height: 1px;
    background: ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border};
    margin: ${({ theme }) => theme.spacing.md} 0;
  }

  table {
    border-collapse: collapse; margin: ${({ theme }) => theme.spacing.sm} 0; width: auto;
     border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border};
    th, td {
      border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border};
      padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    }
    th {
      background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)'};
      font-weight: 600;
    }
  }

  a {
    color: ${({ $isUser, theme }) => $isUser ? '#c1d9ff' : theme.colors.primaryDark};
    text-decoration: underline;
    &:hover { text-decoration: none; }
  }

  ul.contains-task-list {
     list-style-type: none;
     padding-left: ${({ theme }) => theme.spacing.sm};
  }
  li.task-list-item {
     display: flex;
     align-items: center;
     input[type="checkbox"] {
        margin-right: ${({ theme }) => theme.spacing.sm};
        cursor: default; /* Indicate non-interactive checkbox */
     }
  }
`;

const ErrorIndicator = styled.div`
    font-size: 0.75rem;
    color: ${({ theme }) => theme.colors.red};
    margin-top: ${({ theme }) => theme.spacing.xs};
    font-style: italic;
`;
// --- End Styled Components ---


// --- Helper Function ---
function formatTimestamp(timestamp: string | undefined): string {
  if (!timestamp) return '';
  const date = new Date(timestamp);
  if (isNaN(date.getTime())) return '';

  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

  if (diffInSeconds < 5) return 'just now';
  if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;

  if (now.getFullYear() === date.getFullYear()) {
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  } else {
    return date.toLocaleDateString();
  }
}
// -----------------------

// --- React Markdown Custom Components (Corrected) ---
const markdownComponents: Components = {
    a: (props) => (
        <a
          {...props}
          target="_blank"
          rel="noopener noreferrer"
        />
    ),
    input: (props) => {
        // Props passed by remark-gfm for task list items include type, checked, disabled
        // We just need to render a disabled checkbox with the correct checked state.
        // We destructure to avoid passing invalid props.
        const { checked, ...rest } = props;
        return (
            <input
                type="checkbox"
                checked={!!checked} // Ensure boolean
                disabled={true} // Always disabled in display
                readOnly
                {...rest} // Pass className etc.
            />
        );
    },
    // --- FIX for code component ---
    // The `inline` prop IS provided by react-markdown.
    // The type error likely comes from spreading `...props` which might contain incompatible attributes for `pre` or `code`.
    // We need to explicitly pull out known/valid props.
    code({ className, children, inline, ...props }: React.HTMLAttributes<HTMLElement> & { className?: string; children?: React.ReactNode; inline?: boolean; }) {
        const match = /language-(\w+)/.exec(className || '');
        const codeString = String(children).replace(/\n$/, '');
    
        // Explicitly handle potential props that might clash (like style if applying classes)
        // We will apply styles via className added below
        const { style: _unused, ...restProps } = props; // Exclude style prop if applying classes
        void _unused;
    
        return !inline ? ( // Block code
            <pre className="code-block-wrapper" {...restProps}> {/* Spread remaining valid props */}
                <code className={match ? `language-${match[1]}` : undefined}>
                    {codeString}
                </code>
            </pre>
        ) : ( // Inline code
            <code className={`inline-code ${className || ''}`} {...restProps}> {/* Spread remaining valid props */}
                {codeString}
            </code>
        );
    }
    // --- End FIX for code component ---
};
// --- End React Markdown Components ---


// --- Main Component ---
function ChatMessageDisplay({ message, chatbotName }: ChatMessageProps) {
    const isUser = message.role === 'user';
    const senderName = isUser ? 'You' : chatbotName;

    const metadata = message.metadata as MessageMetadataWithError;
    const hasError = !!metadata?.error;
    const errorMessage = hasError ? String(metadata.error) : null;

    return (
        <MessageWrapper $isUser={isUser} $hasError={hasError}>
            <MessageBubble $isUser={isUser} $hasError={hasError}>
                <MessageHeader>
                    <SenderName>{senderName}</SenderName>
                    <Timestamp>
                        {formatTimestamp(message.created_at)}
                    </Timestamp>
                </MessageHeader>
                <MessageContent $isUser={isUser}>
                    <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={markdownComponents}
                    >
                        {message.content || ''}
                    </ReactMarkdown>
                </MessageContent>
                {hasError && (
                    <ErrorIndicator title={errorMessage || 'Failed to send message'}>
                        ⚠️ Failed to send
                    </ErrorIndicator>
                 )}
            </MessageBubble>
        </MessageWrapper>
    );
}
// --- End Main Component ---

export { ChatMessageDisplay as ChatMessage };'use client';

import { useState, KeyboardEvent } from 'react';
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';

const InputContainer = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: 0 0 ${({ theme }) => theme.borderRadius.xl} ${({ theme }) => theme.borderRadius.xl};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const InputForm = styled.form`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
  }
`;

const TextInput = styled.input`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
  }
  
  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  
  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px; // Better for touch inputs
  }
`;

const SendButton = styled(Button)`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.xl};
  min-width: 100px;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%; // Full width on mobile
    min-height: 48px; // Better for touch inputs
  }
`;

const ErrorAlert = styled(Alert)`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const InputHint = styled.p`
  font-size: 0.75rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.sm};
  text-align: center;
  
  @media (min-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none; // Only show on mobile
  }
`;

interface ChatInputProps {
  onSend: (content: string) => Promise<void>;
  isLoading: boolean;
  error: string | null;
  onClearError: () => void;
}

export default function ChatInput({ onSend, isLoading, error, onClearError }: ChatInputProps) {
  const [message, setMessage] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() || isLoading) return;

    const content = message.trim();
    setMessage('');
    await onSend(content);
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      handleSubmit(e);
    }
  };

  return (
    <InputContainer>
      {error && (
        <ErrorAlert variant="error" onClick={onClearError}>
          {error}
        </ErrorAlert>
      )}
      
      <InputForm onSubmit={handleSubmit}>
        <TextInput
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder="Type your message..."
          disabled={isLoading}
        />
        <SendButton 
          type="submit" 
          disabled={isLoading || !message.trim()}
        >
          {isLoading ? 'Sending...' : 'Send'}
        </SendButton>
      </InputForm>
      
      <InputHint>
        Press Enter to type a new line, tap Send when ready
      </InputHint>
    </InputContainer>
  );
}// src/components/ThemeProvider.tsx
'use client';

import { ThemeProvider as StyledThemeProvider } from 'styled-components';
import theme from '@/styles/theme';
import { GlobalStyles } from '@/styles/GlobalStyles';

export default function ThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <StyledThemeProvider theme={theme}>
      <GlobalStyles />
      {children}
    </StyledThemeProvider>
  );
}// src/components/teacher/StudentChatHistory.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

const HistoryContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.xl};
`;

const FilterCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const FilterTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterForm = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    align-items: stretch;
  }
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

const StudentNameDisplay = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.primary};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }
`;

const Select = styled.select`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  min-width: 200px;
`;

const ConversationCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ConversationHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const ConversationInfo = styled.div`
  h4 {
    margin: 0;
    color: ${({ theme }) => theme.colors.text};
  }

  .timestamp {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
`;

const MessagesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.md};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadMoreButton = styled(Button)`
  margin: ${({ theme }) => theme.spacing.md} auto;
  display: block;
`;

interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface StudentChatHistoryProps {
  roomId: string;
  studentId: string;
  studentName: string;
  chatbots: ChatbotOption[];
}

export default function StudentChatHistory({
  roomId,
  studentId,
  studentName,
  chatbots
}: StudentChatHistoryProps) {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedChatbotFilter, setSelectedChatbotFilter] = useState<string>('');
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(false);

  const fetchConversations = useCallback(async (resetPage = true) => {
    const currentPageToFetch = resetPage ? 0 : page;

    if (resetPage) {
      setPage(0);
      setConversations([]);
    }

    setLoading(true);
    setError(null);

    try {
      // Use the new flattened API endpoint
      const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';
      const url = new URL(`/api/teacher/student-chats`, baseUrl);
      
      // Add parameters as query parameters
      url.searchParams.append('roomId', roomId);
      url.searchParams.append('studentId', studentId);
      
      if (selectedChatbotFilter) {
        url.searchParams.append('chatbotId', selectedChatbotFilter);
      }

      // Add pagination params if your API supports them
      if (!resetPage && currentPageToFetch > 0) {
        url.searchParams.append('page', currentPageToFetch.toString());
        url.searchParams.append('limit', '10'); // Example limit
      }

      const response = await fetch(url.toString());

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({error: 'Failed to parse error response'}));
        throw new Error(errorData.error || 'Failed to fetch chat history');
      }

      const data = await response.json();

      if (resetPage) {
        setConversations(data.conversations || []);
      } else {
        setConversations(prev => [...prev, ...(data.conversations || [])]);
      }

      // Set has more if API returns pagination info
      setHasMore(data.pagination?.hasMore || false);

      if (!resetPage && data.conversations && data.conversations.length > 0) {
        setPage(currentPageToFetch + 1);
      } else if (resetPage) {
        setPage(0);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load chat history');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, selectedChatbotFilter, page]);

  useEffect(() => {
    // Initial fetch or fetch when filter changes
    fetchConversations(true);
  }, [roomId, studentId, selectedChatbotFilter, fetchConversations]);

  const handleLoadMore = () => {
    fetchConversations(false);
  };

  const handleChatbotChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedChatbotFilter(e.target.value);
  };

  const formatDate = (dateString: string) => {
    if (!dateString) return 'Unknown date';
    return new Date(dateString).toLocaleString();
  };

  return (
    <HistoryContainer>
      <FilterCard>
        <FilterTitle>Chat History</FilterTitle>
        <FilterForm>
          <StudentNameDisplay>
            Showing conversations for: {studentName}
          </StudentNameDisplay>
          <FilterControls>
            <Select
              value={selectedChatbotFilter}
              onChange={handleChatbotChange}
            >
              <option value="">All Chatbots</option>
              {chatbots.map(chatbot => (
                <option key={chatbot.chatbot_id} value={chatbot.chatbot_id}>
                  {chatbot.name}
                </option>
              ))}
            </Select>
          </FilterControls>
        </FilterForm>
      </FilterCard>

      {error && (
        <Alert variant="error">Error: {error}</Alert>
      )}

      {loading && conversations.length === 0 ? (
        <Card>
          <p>Loading conversations...</p>
        </Card>
      ) : conversations.length === 0 ? (
        <EmptyState>
          <h3>No conversations found</h3>
          <p>
            {selectedChatbotFilter
              ? `This student hasn't chatted with the selected chatbot yet.`
              : `This student hasn't chatted with any chatbots yet.`}
          </p>
        </EmptyState>
      ) : (
        <>
          {conversations.map((conversation, index) => {
            const chatbotNameForDisplay = conversation.chatbot_name || 'Unknown Chatbot';

            return (
              <ConversationCard key={`conv-${index}-${conversation.started_at}`}>
                <ConversationHeader>
                  <ConversationInfo>
                    <h4>{chatbotNameForDisplay}</h4>
                    <span className="timestamp">Started {formatDate(conversation.started_at)}</span>
                  </ConversationInfo>
                </ConversationHeader>

                <MessagesList>
                  {conversation.messages.map(message => (
                    <ChatMessageComponent
                      key={message.message_id}
                      message={message}
                      chatbotName={chatbotNameForDisplay}
                    />
                  ))}
                </MessagesList>
              </ConversationCard>
            );
          })}

          {hasMore && (
            <LoadMoreButton
              variant="outline"
              onClick={handleLoadMore}
              disabled={loading}
            >
              {loading ? 'Loading...' : 'Load More'}
            </LoadMoreButton>
          )}
        </>
      )}
    </HistoryContainer>
  );
}'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { Card, Button, Alert, Badge } from '@/styles/StyledComponents'; // Added Alert and Badge
import ChatbotForm from '@/components/teacher/ChatbotForm';
import RoomForm from '@/components/teacher/RoomForm';
import RoomList from '@/components/teacher/RoomList';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import ConcernsList from '@/components/teacher/ConcernsList'; // Import ConcernsList
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import Loader
import { createClient } from '@/lib/supabase/client';
import type { Chatbot, Room as BaseRoom } from '@/types/database.types'; // Use BaseRoom alias

// --- Styled Components (Keep as previously defined) ---
const DashboardContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  flex-wrap: wrap; /* Allow wrapping */
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    button {
      width: 100%;
    }
  }
`;

const SectionTitle = styled.h2`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.5rem;
  margin: 0; /* Remove default margin */
`;

const StatsCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: pointer; // Make stats cards clickable if they link somewhere
  transition: transform 0.2s ease, box-shadow 0.2s ease;

   &:hover {
      transform: translateY(-2px);
      box-shadow: ${({ theme }) => theme.shadows.md};
   }

  h3 {
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }

  .value {
    font-size: 2rem;
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const ChatbotList = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};

  &:hover {
    transform: translateY(-2px);
    box-shadow: ${({ theme }) => theme.shadows.md};
  }

  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
  }

  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1;
    min-height: 2.5rem;

    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }

  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.sm};
    margin-top: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap;
    justify-content: flex-start;

    button, a {
        flex-grow: 1;
        min-width: 100px;
        text-align: center;
    }

     @media (max-width: 550px) {
         button, a {
            width: 100%;
            flex-grow: 0;
         }
     }
  }

  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
`;


const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 450px;
  margin: 20px;
  position: relative;
  text-align: center;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

// --- Define the Room type WITH joined data (Matching API Response) ---
interface RoomWithChatbots extends BaseRoom {
  room_chatbots: {
    chatbots: {
      chatbot_id: string;
      name: string;
    } | null;
  }[] | null;
}
// ---------------------------------------------------------------


interface DeleteModalProps {
  isOpen: boolean;
  itemType: 'Chatbot' | 'Room';
  itemName: string;
  onConfirm: () => Promise<void>; // Make confirm async
  onCancel: () => void;
  isDeleting: boolean;
}

function DeleteModal({ isOpen, itemType, itemName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete {itemType}</ModalTitle>
        <ModalText>
          Are you sure you want to delete the {itemType.toLowerCase()} &quot;
          <strong>{itemName}</strong>
          &quot;? This action cannot be undone and may affect associated data (e.g., student memberships, chat history).
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
             variant="secondary" // Use secondary as base, style for danger
             style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }}
             onClick={onConfirm} // Directly call the passed async handler
             disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : `Yes, Delete ${itemType}`}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

export default function Dashboard() {
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  // --- FIX: Use the correct type for rooms state ---
  const [rooms, setRooms] = useState<RoomWithChatbots[]>([]);
  // --------------------------------------------------
  const [stats, setStats] = useState({
    totalChatbots: 0,
    totalRooms: 0,
    activeRooms: 0,
    pendingConcerns: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    type: 'Chatbot' | 'Room';
    id: string | null;
    name: string;
  }>({ isOpen: false, type: 'Chatbot', id: null, name: '' });
   const [isDeleting, setIsDeleting] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null); // Edit modal likely needs BaseRoom
  const supabase = createClient();
  const router = useRouter();

  const fetchDashboardData = useCallback(async () => {
    setError(null);

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }

      // Fetch all data concurrently
      const [chatbotsRes, roomsRes, concernsRes] = await Promise.all([
        supabase.from('chatbots').select('*').eq('teacher_id', user.id),
        // --- FIX: Fetch rooms using the API route which handles the join ---
        fetch('/api/teacher/rooms').then(res => {
            if (!res.ok) throw new Error('Failed to fetch rooms');
            return res.json();
        }),
        // --------------------------------------------------------------------
        supabase.from('flagged_messages')
          .select('flag_id', { count: 'exact', head: true })
          .eq('teacher_id', user.id)
          .eq('status', 'pending')
      ]);

      // Process Chatbots
      if (chatbotsRes.error) throw new Error(`Failed to fetch chatbots: ${chatbotsRes.error.message}`);
      const chatbotsData = chatbotsRes.data || [];
      setChatbots(chatbotsData);

      // Process Rooms (data is already fetched via API)
      const roomsData: RoomWithChatbots[] = roomsRes || []; // Type assertion based on API response
      setRooms(roomsData);

       // Process Concerns Count
       if (concernsRes.error) throw new Error(`Failed to fetch concerns count: ${concernsRes.error.message}`);
       const pendingConcernsCount = concernsRes.count || 0;

      // Update Stats
      setStats({
        totalChatbots: chatbotsData.length,
        totalRooms: roomsData.length,
        activeRooms: roomsData.filter(room => room.is_active).length,
        pendingConcerns: pendingConcernsCount,
      });

    } catch (error) {
      console.error('Error fetching dashboard data:', error);
      setError(error instanceof Error ? error.message : 'Failed to load dashboard data.');
      // Reset state on error
      setChatbots([]);
      setRooms([]);
      setStats({ totalChatbots: 0, totalRooms: 0, activeRooms: 0, pendingConcerns: 0 });
    } finally {
      setLoading(false);
    }
  }, [supabase, router]); // Dependencies

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchDashboardData();
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    fetchDashboardData();
  };

  // Test Chatbot (unused function removed)

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const openDeleteModal = (type: 'Chatbot' | 'Room', id: string, name: string) => {
    setDeleteModal({ isOpen: true, type, id, name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, type: 'Chatbot', id: null, name: '' });
  };

  // --- Combined Delete Handler ---
  const handleDeleteConfirm = async () => {
    if (!deleteModal.id || !deleteModal.type) return;

    setIsDeleting(true);
    setError(null);

    const { type, id } = deleteModal;
    const endpoint = type === 'Chatbot' ? `/api/teacher/chatbots/${id}` : `/api/teacher/rooms/${id}`;

    try {
        const response = await fetch(endpoint, { method: 'DELETE' });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete ${type.toLowerCase()}`);
        }

        console.log(`${type} ${id} deleted successfully.`);
        closeDeleteModal();
        fetchDashboardData(); // Refresh dashboard
    } catch (error) {
        console.error(`Error deleting ${type}:`, error);
        setError(error instanceof Error ? error.message : `Failed to delete ${type}.`);
        // Keep modal open on error to show feedback if desired, or close:
        // closeDeleteModal();
    } finally {
        setIsDeleting(false);
    }
};


  const handleEditRoom = (room: BaseRoom) => { // Use BaseRoom for editing modal
    setEditingRoom(room);
  };

  const handleCloseEditRoom = () => {
    setEditingRoom(null);
  };

  const handleRoomEditSuccess = () => {
    setEditingRoom(null);
    fetchDashboardData();
  };

  // Get model display name (no changes)
    const getModelDisplayName = (model: string | undefined) => {
      if (!model) return 'Default Model';
      const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B A22B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash'
      };
      return modelNames[model] || model;
    };


  if (loading) {
    return <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading dashboard...</Card>;
  }

  return (
    <div>
        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        {/* Quick Stats Section */}
        <Section>
            <DashboardContainer>
            <StatsCard onClick={() => document.getElementById('chatbots-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Chatbots</h3>
                <div className="value">{stats.totalChatbots}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Rooms</h3>
                <div className="value">{stats.totalRooms}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Active Rooms</h3>
                <div className="value">{stats.activeRooms}</div>
            </StatsCard>
            <StatsCard style={{ cursor: 'pointer' }} onClick={() => document.getElementById('concerns-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Pending Concerns</h3>
                <div className="value" style={{ color: stats.pendingConcerns > 0 ? '#F87F7F' : undefined }}>
                    {stats.pendingConcerns}
                </div>
                 {stats.pendingConcerns > 0 && <Badge variant='error' style={{ marginTop: '8px' }}>Review Needed</Badge>}
            </StatsCard>
            </DashboardContainer>
        </Section>

      {/* Concerns Section */}
      <Section id="concerns-section">
            <SectionHeader>
                 <SectionTitle>Welfare Concerns</SectionTitle>
                 {/* Can add a direct link/button to a dedicated concerns page if needed */}
            </SectionHeader>
            <ConcernsList />
       </Section>


      {/* Chatbots Section */}
      <Section id="chatbots-section">
        <SectionHeader>
          <SectionTitle>Your Chatbots</SectionTitle>
          <Button onClick={() => setShowChatbotForm(true)}>
            + Create Chatbot
          </Button>
        </SectionHeader>

        {showChatbotForm && (
          <ChatbotForm
            onClose={() => setShowChatbotForm(false)}
            onSuccess={handleChatbotCreated}
          />
        )}

        {chatbots.length > 0 ? (
          <ChatbotList>
            {chatbots.map(chatbot => (
              <ChatbotCard key={chatbot.chatbot_id}>
                <h3>{chatbot.name}</h3>
                <p className="description">{chatbot.description || 'No description provided.'}</p>
                <div className="model-info">
                  Model: {getModelDisplayName(chatbot.model)}
                </div>
                <div className="actions">
                  <Button
                    size="small"
                    variant="outline"
                    onClick={() => handleEditChatbot(chatbot.chatbot_id)}
                    title="Edit chatbot configuration"
                  >
                    Configure
                  </Button>
                   <Button
                        as={Link}
                        size="small"
                        variant="outline"
                        href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/knowledge-base`}
                        title="Manage knowledge base documents"
                    >
                        Knowledge Base
                    </Button>
                   <Button
                        size="small"
                        variant="secondary"
                         style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }} // Danger style
                        onClick={() => openDeleteModal('Chatbot', chatbot.chatbot_id, chatbot.name)}
                        title="Delete this chatbot"
                    >
                        Delete
                    </Button>
                </div>
              </ChatbotCard>
            ))}
          </ChatbotList>
        ) : (
          <Card>
            <p>No chatbots created yet. Click &quot;+ Create Chatbot&quot; to get started!</p>
          </Card>
        )}
      </Section>

      {/* Rooms Section */}
      <Section id="rooms-section">
        <SectionHeader>
          <SectionTitle>Classroom Rooms</SectionTitle>
          <Button onClick={() => setShowRoomForm(true)} disabled={chatbots.length === 0}>
            + Create Room
          </Button>
           {chatbots.length === 0 && <Alert variant='info'>Create a chatbot before creating a room.</Alert>}
        </SectionHeader>

        {showRoomForm && (
          <RoomForm
            chatbots={chatbots}
            onClose={() => setShowRoomForm(false)}
            onSuccess={handleRoomCreated}
          />
        )}

        <RoomList
          rooms={rooms} // Pass the correctly typed rooms state
          onUpdate={fetchDashboardData}
          onEditRoom={handleEditRoom}
          onDeleteRoom={(room) => openDeleteModal('Room', room.room_id, room.room_name)} // Pass handler for delete button in list
        />
      </Section>

      {/* Delete Confirmation Modal */}
      <DeleteModal
        isOpen={deleteModal.isOpen}
        itemType={deleteModal.type}
        itemName={deleteModal.name}
        onConfirm={handleDeleteConfirm} // Use the combined handler
        onCancel={closeDeleteModal}
        isDeleting={isDeleting}
      />

      {/* Edit Room Modal */}
      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={handleCloseEditRoom}
          onSuccess={handleRoomEditSuccess}
        />
      )}
    </div>
  );
}// src/components/teacher/EmbeddingStatus.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert } from '@/styles/StyledComponents';
import { Document, ProcessingStats } from '@/types/knowledge-base.types';

const StatusContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h3`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const ProgressContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ProgressBar = styled.div`
  height: 8px;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  overflow: hidden;
`;

const ProgressFill = styled.div<{ $progress: number; $hasErrors: boolean }>`
  height: 100%;
  width: ${({ $progress }) => `${$progress}%`};
  background-color: ${({ theme, $hasErrors }) => 
    $hasErrors ? theme.colors.secondary : theme.colors.green};
  transition: width 0.5s ease;
`;

const StatsContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const StatCard = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  text-align: center;
`;

const StatValue = styled.div`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: ${({ theme }) => theme.spacing.xs};
  color: ${({ theme }) => theme.colors.text};
`;

const StatLabel = styled.div`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const StatusText = styled.div<{ $isComplete: boolean; $hasErrors: boolean }>`
  color: ${({ theme, $isComplete, $hasErrors }) => 
    $isComplete 
      ? $hasErrors ? theme.colors.secondary : theme.colors.green 
      : theme.colors.text};
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

interface EmbeddingStatusProps {
  document: Document;
  chatbotId: string;
  onRefresh?: () => void;
}

export default function EmbeddingStatus({ 
  document, 
  chatbotId,
  onRefresh
}: EmbeddingStatusProps) {
  const [stats, setStats] = useState<ProcessingStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(null);

  const fetchStatus = useCallback(async () => {
    try {
      const response = await fetch(
        `/api/teacher/chatbots/${chatbotId}/vectorize?documentId=${document.document_id}`
      );
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch processing status');
      }
      
      const data = await response.json();
      setStats(data.processingStats);
      
      // Update document with latest status
      if (data.document.status !== document.status && onRefresh) {
        onRefresh();
      }
      
      // If processing is complete, stop polling
      if (data.document.status === 'completed' || data.document.status === 'error') {
        if (pollingInterval) {
          clearInterval(pollingInterval);
          setPollingInterval(null);
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch processing status');
    } finally {
      setLoading(false);
    }
  }, [document.document_id, document.status, chatbotId, onRefresh, pollingInterval]);

  useEffect(() => {
    fetchStatus();
    
    // Set up polling for processing status
    if (document.status === 'processing' && !pollingInterval) {
      const interval = setInterval(fetchStatus, 5000); // Poll every 5 seconds
      setPollingInterval(interval);
    }
    
    return () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [document.status, fetchStatus, pollingInterval]);

  if (loading) {
    return (
      <StatusContainer>
        <p>Loading processing status...</p>
      </StatusContainer>
    );
  }

  if (error) {
    return (
      <StatusContainer>
        <Alert variant="error">{error}</Alert>
      </StatusContainer>
    );
  }

  if (!stats) {
    return (
      <StatusContainer>
        <p>No processing statistics available</p>
      </StatusContainer>
    );
  }

  const progressPercent = stats.totalChunks > 0
    ? Math.round((stats.processedChunks / stats.totalChunks) * 100)
    : 0;
  
  const hasErrors = stats.errorChunks > 0;
  const isComplete = document.status === 'completed' || 
                     (document.status === 'processing' && progressPercent === 100);

  return (
    <StatusContainer>
      <Header>
        <Title>Document Processing Status</Title>
      </Header>
      
      <ProgressContainer>
        <ProgressBar>
          <ProgressFill $progress={progressPercent} $hasErrors={hasErrors} />
        </ProgressBar>
        <StatusText 
          $isComplete={isComplete} 
          $hasErrors={hasErrors}
        >
          {document.status === 'error' ? 'Processing failed' :
           isComplete ? 'Processing complete' : 'Processing in progress'}
           {hasErrors && ' (with some errors)'}
           {document.status === 'processing' && ` - ${progressPercent}%`}
        </StatusText>
      </ProgressContainer>
      
      <StatsContainer>
        <StatCard>
          <StatValue>{stats.totalChunks}</StatValue>
          <StatLabel>Total Chunks</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.processedChunks}</StatValue>
          <StatLabel>Processed</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.errorChunks}</StatValue>
          <StatLabel>Errors</StatLabel>
        </StatCard>
      </StatsContainer>
      
      {document.error_message && (
        <Alert variant="error">Error: {document.error_message}</Alert>
      )}
    </StatusContainer>
  );
}// src/components/teacher/EditRoomModal.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Card, Button, Alert } from '@/styles/StyledComponents';
import type { Room, Chatbot } from '@/types/database.types';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const SectionTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;

interface EditRoomModalProps {
  room: Room;
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function EditRoomModal({ room, chatbots, onClose, onSuccess }: EditRoomModalProps) {
  const [selectedChatbots, setSelectedChatbots] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Fetch current chatbots for this room
    const fetchRoomChatbots = async () => {
      try {
        const response = await fetch(`/api/teacher/rooms/${room.room_id}/chatbots`);
        if (!response.ok) throw new Error('Failed to fetch room chatbots');
        
        const data = await response.json();
        setSelectedChatbots(data.map((rc: { chatbot_id: string }) => rc.chatbot_id));
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load chatbots');
      } finally {
        setIsLoading(false);
      }
    };

    fetchRoomChatbots();
  }, [room.room_id]);

  const handleToggleChatbot = (chatbotId: string) => {
    setSelectedChatbots(prev => 
      prev.includes(chatbotId)
        ? prev.filter(id => id !== chatbotId)
        : [...prev, chatbotId]
    );
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch(`/api/teacher/rooms/${room.room_id}/chatbots`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ chatbot_ids: selectedChatbots }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update room chatbots');
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update room chatbots');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Edit Room: {room.room_name}</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <Section>
          <SectionTitle>Select Chatbots for this Room</SectionTitle>
          {isLoading ? (
            <div>Loading chatbots...</div>
          ) : (
            <ChatbotList>
              {chatbots.map(chatbot => (
                <ChatbotItem key={chatbot.chatbot_id}>
                  <Checkbox
                    type="checkbox"
                    checked={selectedChatbots.includes(chatbot.chatbot_id)}
                    onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                  />
                  {chatbot.name}
                  {chatbot.description && (
                    <span style={{ marginLeft: '8px', color: '#888' }}>
                      - {chatbot.description}
                    </span>
                  )}
                </ChatbotItem>
              ))}
            </ChatbotList>
          )}
        </Section>

        <Footer>
          <Button type="button" variant="outline" onClick={onClose}>
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleSubmit} 
            disabled={isSubmitting || selectedChatbots.length === 0}
          >
            {isSubmitting ? 'Saving...' : 'Save Changes'}
          </Button>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/RoomList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import type { Room as BaseRoom } from '@/types/database.types'; // Import base Room type

// --- Styled Components (Keep as they are) ---
const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* Hide table view on smaller screens if mobile view is preferred */
    /* display: none; */
  }
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  min-width: 700px; /* Ensure minimum width for desktop view */
`;

const Th = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.875rem;
  letter-spacing: 0.05em;
  white-space: nowrap;
`;

const Td = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  vertical-align: top; /* Align content nicely */
`;

const ActionButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  flex-wrap: wrap; /* Allow buttons to wrap */
`;

const RoomCode = styled.span`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  background-color: ${({ theme }) => theme.colors.backgroundDark}; /* Add background */
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  display: inline-block; /* Ensure padding works */

  &:hover {
    text-decoration: underline;
    background-color: ${({ theme }) => theme.colors.border}; /* Darker on hover */
  }
`;

const RoomNameLink = styled(Link)`
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-weight: 500;
  transition: color ${({ theme }) => theme.transitions.fast};

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: underline;
  }
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textLight};

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.md};
    color: ${({ theme }) => theme.colors.text};
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6); /* Darker overlay */
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
  text-align: center;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

// --- Mobile view styled components commented out since they're not used ---
/* 
const MobileCardList = styled.div`
  display: none;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    // Enable this block if you want to show cards instead of table on mobile
    // display: flex;
    // flex-direction: column;
    // gap: ${({ theme }) => theme.spacing.md};
  }
`;
// ... (MobileCard, RoomCardHeader, RoomCardTitle, RoomCardDetails, DetailItem, MobileActions) ...
// Add the full definitions for these if you plan to use the mobile card view.
*/

// --- Define the expected Room type WITH joined data ---
// This structure should match what the API returns from the .select() with joins
interface RoomWithChatbots extends BaseRoom {
  room_chatbots: { // The name of the joined relation
    chatbots: { // The nested object within the relation
      chatbot_id: string;
      name: string;
    } | null; // chatbots might be null if !inner fails or no match
  }[] | null; // The room_chatbots array itself might be null or empty
}

// --- Define Props for RoomList ---
interface RoomListProps {
  rooms: RoomWithChatbots[]; // Use the more specific type
  onUpdate: () => void;
  onEditRoom: (room: BaseRoom) => void; // Edit probably only needs base room info
  onDeleteRoom: (room: BaseRoom) => void; // Delete needs base room info
}

// --- Define Props for DeleteModal ---
interface DeleteModalProps {
  isOpen: boolean;
  roomName: string;
  onConfirm: () => void;
  onCancel: () => void;
  isDeleting: boolean; // Added loading state
}

// --- Delete Modal Component ---
function DeleteModal({ isOpen, roomName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete Room</ModalTitle>
        <ModalText>
          Are you sure you want to delete the room &quot;<strong>{roomName}</strong>&quot;? This action cannot be undone and will remove all student memberships and associated data.
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
            variant="secondary"
            style={{ backgroundColor: '#F87F7F', color: 'white' }} // Danger style
            onClick={onConfirm}
            disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : 'Yes, Delete Room'}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

// --- Main RoomList Component ---
export default function RoomList({ rooms, onUpdate, onEditRoom, onDeleteRoom }: RoomListProps) {
  const [loadingState, setLoadingState] = useState<{ [key: string]: boolean }>({}); // Track loading per room for actions
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    roomId: string | null;
    roomName: string;
  }>({
    isOpen: false,
    roomId: null,
    roomName: '',
  });
  const [isDeleting, setIsDeleting] = useState(false); // Loading state for delete confirmation

  // --- Action Handlers ---
  const toggleRoomStatus = async (roomId: string, currentStatus: boolean) => {
    setLoadingState(prev => ({ ...prev, [roomId]: true })); // Set loading for this specific room
    try {
      const response = await fetch(`/api/teacher/rooms/${roomId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_active: !currentStatus }),
      });
      if (!response.ok) throw new Error('Failed to update room status');
      onUpdate(); // Refresh the list via the parent component
    } catch (error) {
      console.error('Error updating room status:', error);
      alert(`Error: ${error instanceof Error ? error.message : 'Could not update room status.'}`);
    } finally {
      setLoadingState(prev => ({ ...prev, [roomId]: false })); // Clear loading for this room
    }
  };

  const copyRoomCode = async (code: string) => {
    try {
      await navigator.clipboard.writeText(code);
      alert(`Room code "${code}" copied to clipboard!`); // Simple feedback
    } catch (error) {
      console.error('Failed to copy room code:', error);
      alert('Failed to copy room code.');
    }
  };

  const generateMagicLink = async (roomId: string, roomCode: string) => {
    try {
      // No need to fetch room again, code is already available
      const joinLink = `${window.location.origin}/join?code=${roomCode}`;
      await navigator.clipboard.writeText(joinLink);
      alert(`Student join link copied to clipboard:\n${joinLink}`);
    } catch (error) {
      console.error('Error generating join link:', error);
      alert('Failed to generate join link.');
    }
  };

  const openDeleteModal = (room: BaseRoom) => { // Expect BaseRoom here
    setDeleteModal({
      isOpen: true,
      roomId: room.room_id,
      roomName: room.room_name,
    });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, roomId: null, roomName: '' });
  };

  const handleDeleteRoomConfirm = async () => {
    if (!deleteModal.roomId) return;

    setIsDeleting(true); // Set modal loading state
    try {
      // Call the prop passed from Dashboard which handles API call + refresh
      await onDeleteRoom({ room_id: deleteModal.roomId, room_name: deleteModal.roomName } as BaseRoom);
      closeDeleteModal(); // Close modal on success
    } catch (error) {
      // Error handling might be done in the parent, or show here
      console.error('Error during delete confirmation:', error);
      alert(`Failed to delete room: ${error instanceof Error ? error.message : 'Unknown error'}`);
      // Optionally keep modal open on error
    } finally {
      setIsDeleting(false); // Clear modal loading state
    }
  };

  // --- Helper to count chatbots (FIXED TYPE) ---
  const getChatbotCount = (room: RoomWithChatbots): number => {
    // Access the structure defined by the API query and RoomWithChatbots interface
    if (room.room_chatbots && Array.isArray(room.room_chatbots)) {
      // Filter out any null entries potentially caused by left join issues or empty relations
      return room.room_chatbots.filter(rc => rc && rc.chatbots).length;
    }
    return 0; // Default to 0 if the structure isn't as expected
  };
  // ----------------------------------------------


  if (rooms.length === 0) {
    return (
      <EmptyState>
        <h3>No Rooms Created</h3>
        <p>Create your first classroom room to get started!</p>
      </EmptyState>
    );
  }

  return (
    <>
      <Card>
        {/* Desktop Table View */}
        <TableContainer>
          <Table>
            <thead>
              <tr>
                <Th>Room Name</Th>
                <Th>Room Code</Th>
                <Th>Chatbots</Th>
                <Th>Status</Th>
                <Th>Created</Th>
                <Th>Actions</Th>
              </tr>
            </thead>
            <tbody>
              {rooms.map((room) => {
                const chatbotCount = getChatbotCount(room);
                const isLoading = loadingState[room.room_id] || false; // Check loading state for this room

                return (
                  <tr key={room.room_id}>
                    <Td>
                      <RoomNameLink href={`/room/${room.room_id}`} title={`Go to room: ${room.room_name}`}>
                        {room.room_name}
                      </RoomNameLink>
                    </Td>
                    <Td>
                      <RoomCode onClick={() => copyRoomCode(room.room_code)} title="Click to copy room code">
                        {room.room_code}
                      </RoomCode>
                    </Td>
                    <Td>
                      {chatbotCount > 0 ? `${chatbotCount} Attached` : 'None'}
                    </Td>
                    <Td>
                      <Badge variant={room.is_active ? 'success' : 'default'}>
                        {room.is_active ? 'Active' : 'Inactive'}
                      </Badge>
                    </Td>
                    <Td>
                      {new Date(room.created_at).toLocaleDateString()}
                    </Td>
                    <Td>
                      <ActionButtons>
                        <Button
                          size="small"
                          onClick={() => onEditRoom(room)} // Pass the base room object
                          disabled={isLoading}
                          title="Edit Chatbots for this Room"
                        >
                          Edit
                        </Button>
                        <Button
                          size="small"
                          variant="outline" // Changed variant
                          onClick={() => generateMagicLink(room.room_id, room.room_code)}
                          disabled={isLoading}
                          title="Copy Student Join Link"
                        >
                          Join Link
                        </Button>
                        <Button
                          size="small"
                          variant={room.is_active ? 'secondary' : 'primary'} // Use secondary for deactivation
                          onClick={() => toggleRoomStatus(room.room_id, room.is_active)}
                          disabled={isLoading}
                          title={room.is_active ? 'Deactivate Room' : 'Activate Room'}
                        >
                          {isLoading ? '...' : room.is_active ? 'Deactivate' : 'Activate'}
                        </Button>
                        <Button
                          size="small"
                          variant="secondary" // Keep secondary, maybe add danger style later
                           style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }} // Danger style
                          onClick={() => openDeleteModal(room)} // Pass base room object
                          disabled={isLoading}
                          title="Delete Room"
                        >
                          Delete
                        </Button>
                      </ActionButtons>
                    </Td>
                  </tr>
                );
              })}
            </tbody>
          </Table>
        </TableContainer>

        {/* Mobile Card View (Commented out for now) */}
        {/*
        <MobileCardList>
          {rooms.map((room) => {
             const chatbotCount = getChatbotCount(room);
             const isLoading = loadingState[room.room_id] || false;
             return ( <MobileCard key={room.room_id}> ... </MobileCard> );
          })}
        </MobileCardList>
         */}
      </Card>

      {/* Delete Confirmation Modal */}
      <DeleteModal
        isOpen={deleteModal.isOpen}
        roomName={deleteModal.roomName}
        onConfirm={handleDeleteRoomConfirm}
        onCancel={closeDeleteModal}
        isDeleting={isDeleting} // Pass loading state
      />
    </>
  );
}// src/components/teacher/TeacherNav.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { usePathname } from 'next/navigation';

const NavWrapper = styled.nav`
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};

  ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    gap: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap; // Allow wrapping on smaller screens
  }

  li a {
    text-decoration: none;
    color: ${({ theme }) => theme.colors.textLight};
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    font-weight: 500;
    transition: all ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.backgroundDark};
    }

    &.active {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.primary + '20'}; // Light primary background
    }
  }
`;

const navItems = [
  { href: '/teacher-dashboard', label: 'Overview' },
  { href: '/teacher-dashboard/chatbots', label: 'Chatbots' },
  { href: '/teacher-dashboard/rooms', label: 'Rooms' },
  { href: '/teacher-dashboard/concerns', label: 'Concerns' },
  // { href: '/teacher-dashboard/students', label: 'Students' }, // Future
  // { href: '/teacher-dashboard/settings', label: 'Settings' }, // Future
];

export default function TeacherNav() {
  const pathname = usePathname();

  return (
    <NavWrapper>
      <ul>
        {navItems.map((item) => (
          <li key={item.href}>
            <Link href={item.href} className={pathname === item.href ? 'active' : ''}>
              {item.label}
            </Link>
          </li>
        ))}
      </ul>
    </NavWrapper>
  );
}// src/components/teacher/DocumentUploader.tsx
'use client';

import { useState, useRef } from 'react';
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';
import { DocumentType } from '@/types/knowledge-base.types';

const UploaderContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const UploadArea = styled.div<{ $isDragging: boolean }>`
  border: 2px dashed ${({ theme, $isDragging }) => 
    $isDragging ? theme.colors.primary : theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  transition: all ${({ theme }) => theme.transitions.fast};
  background-color: ${({ theme, $isDragging }) => 
    $isDragging ? `${theme.colors.primary}10` : theme.colors.backgroundCard};
  
  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => `${theme.colors.primary}05`};
  }
`;

const FileInput = styled.input`
  display: none;
`;

const UploadIcon = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 2rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const UploadText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SelectedFile = styled.div`
  margin-top: ${({ theme }) => theme.spacing.md};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const FileName = styled.span`
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const FileSize = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface DocumentUploaderProps {
  chatbotId: string;
  onUploadSuccess: () => void;
}

export default function DocumentUploader({ chatbotId, onUploadSuccess }: DocumentUploaderProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const validateAndSetFile = (file: File) => {
    setError(null);
    
    // Validate file type
    const extension = file.name.split('.').pop()?.toLowerCase();
    const validTypes: DocumentType[] = ['pdf', 'docx', 'txt'];
    
    if (!extension || !validTypes.includes(extension as DocumentType) && extension !== 'doc') {
      setError('Invalid file type. Please upload a PDF, Word document, or text file.');
      return;
    }
    
    // Validate file size (10MB max)
    const maxSize = 10 * 1024 * 1024; // 10MB in bytes
    if (file.size > maxSize) {
      setError('File too large. Maximum size is 10MB.');
      return;
    }
    
    setSelectedFile(file);
  };

  const handleUpload = async () => {
    if (!selectedFile) return;
    
    setIsUploading(true);
    setError(null);
    
    try {
      const formData = new FormData();
      formData.append('file', selectedFile);
      
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/documents`, {
        method: 'POST',
        body: formData,
      });
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to upload document');
      }
      
      // After successful upload, clear the selected file
      setSelectedFile(null);
      onUploadSuccess();
      
      // Reset file input
      if (fileInputRef.current) {
        fileInputRef.current.value = '';
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to upload document');
    } finally {
      setIsUploading(false);
    }
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes < 1024) return `${bytes} bytes`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  return (
    <UploaderContainer>
      {error && <Alert variant="error">{error}</Alert>}
      
      <UploadArea
        $isDragging={isDragging}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={() => fileInputRef.current?.click()}
      >
        <FileInput
          type="file"
          ref={fileInputRef}
          onChange={handleFileSelect}
          accept=".pdf,.docx,.doc,.txt"
        />
        
        <UploadIcon>📄</UploadIcon>
        <UploadText>
          {isDragging ? 'Drop your file here' : 'Click or drag file to upload'}
        </UploadText>
        <FileTypeInfo>
          Supported formats: PDF, Word documents (.docx, .doc), Text files (.txt)
        </FileTypeInfo>
        
        {!selectedFile && (
          <Button size="small" variant="outline">
            Browse Files
          </Button>
        )}
      </UploadArea>
      
      {selectedFile && (
        <>
          <SelectedFile>
            <FileName>{selectedFile.name}</FileName>
            <FileSize>{formatFileSize(selectedFile.size)}</FileSize>
            <Button
              size="small"
              variant="outline"
              onClick={() => setSelectedFile(null)}
            >
              Remove
            </Button>
          </SelectedFile>
          
          <Button
            onClick={handleUpload}
            disabled={isUploading}
            style={{ marginTop: '16px' }}
          >
            {isUploading ? 'Uploading...' : 'Upload Document'}
          </Button>
        </>
      )}
    </UploaderContainer>
  );
}// src/components/teacher/StatsCard.tsx
'use client';

import styled from 'styled-components';
import { Card } from '@/styles/StyledComponents'; // Assuming Card is your base styled card

interface StatsCardProps {
  title: string;
  value: string | number;
  onClick?: () => void;
  icon?: React.ReactNode; // Optional icon
  variant?: 'default' | 'warning' | 'danger'; // For highlighting
}

const StyledStatsCard = styled(Card)<{ $clickable: boolean; $variant: StatsCardProps['variant'] }>`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: ${({ $clickable }) => ($clickable ? 'pointer' : 'default')};
  transition: transform 0.2s ease, box-shadow 0.2s ease;

  &:hover {
    transform: ${({ $clickable }) => ($clickable ? 'translateY(-3px)' : 'none')};
    box-shadow: ${({ $clickable, theme }) => ($clickable ? theme.shadows.md : theme.shadows.sm)};
  }

  .icon {
    font-size: 1.8rem;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme, $variant }) =>
      $variant === 'danger' ? theme.colors.red :
      $variant === 'warning' ? theme.colors.secondaryDark :
      theme.colors.primary};
  }
  
  h3 { // Title
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-weight: 500;
  }

  .value {
    font-size: 2.2rem;
    font-weight: 600;
    color: ${({ theme, $variant }) =>
      $variant === 'danger' ? theme.colors.red :
      $variant === 'warning' ? theme.colors.secondaryDark :
      theme.colors.primary};
    line-height: 1.2;
  }
`;

export default function StatsCard({ title, value, onClick, icon, variant = 'default' }: StatsCardProps) {
  return (
    <StyledStatsCard onClick={onClick} $clickable={!!onClick} $variant={variant}>
      {icon && <div className="icon">{icon}</div>}
      <h3>{title}</h3>
      <div className="value">{value}</div>
    </StyledStatsCard>
  );
}// src/components/teacher/ChatbotForm.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
// import { useRouter } from 'next/navigation'; // << REMOVED UNUSED IMPORT
import { 
    Card, 
    Button, 
    FormGroup, 
    Label, 
    Input, 
    TextArea, 
    Alert, 
    Select as StyledSelect
} from '@/styles/StyledComponents';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
    overflow-y: auto;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    max-height: 100%;
    min-height: 100vh;
    border-radius: 0;
    overflow-y: auto;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    position: sticky;
    top: 0;
    background: ${({ theme }) => theme.colors.backgroundCard};
    padding: ${({ theme }) => theme.spacing.sm} 0;
    z-index: 5;
  }
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

interface ChatbotFormProps {
  onClose: () => void;
  onSuccess: (chatbotId: string) => void;
}

export default function ChatbotForm({ onClose, onSuccess }: ChatbotFormProps) {
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    system_prompt: '',
    model: 'x-ai/grok-3-mini-beta',
    max_tokens: 1000,
    temperature: 0.7,
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  // const router = useRouter(); // << REMOVED UNUSED VARIABLE

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/teacher/chatbots', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      const responseData = await response.json(); 

      if (!response.ok) {
        throw new Error(responseData.error || 'Failed to create chatbot');
      }
      
      console.log('Chatbot created successfully via form:', responseData);
      onSuccess(responseData.chatbot_id);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create chatbot');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: name === 'max_tokens' || name === 'temperature' ? Number(value) : value,
    }));
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create Chatbot</Title>
          <CloseButton onClick={onClose}>×</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="name">Chatbot Name</Label>
            <Input
              id="name"
              name="name"
              value={formData.name}
              onChange={handleChange}
              placeholder="Enter chatbot name"
              required
            />
          </FormGroup>

          <FormGroup>
            <Label htmlFor="description">Description (optional)</Label>
            <Input
              id="description"
              name="description"
              value={formData.description}
              onChange={handleChange}
              placeholder="Enter chatbot description"
            />
          </FormGroup>

          <FormGroup>
            <Label htmlFor="system_prompt">System Prompt</Label>
            <TextArea
              id="system_prompt"
              name="system_prompt"
              value={formData.system_prompt}
              onChange={handleChange}
              placeholder="e.g., 'You are a helpful history tutor for Grade 10 students...'"
              required
              rows={4}
            />
          </FormGroup>

          <FormGroup>
            <Label htmlFor="model">AI Model</Label>
            <StyledSelect 
                id="model"
                name="model"
                value={formData.model}
                onChange={handleChange}
            >
                <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta (Paid)</option>
                <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B (Free)</option>
                <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
            </StyledSelect>
          </FormGroup>

          <Footer>
            <ActionButton type="button" variant="outline" onClick={onClose}>
              Cancel
            </ActionButton>
            <ActionButton type="submit" disabled={isSubmitting}>
              {isSubmitting ? 'Creating...' : 'Create & Configure'}
            </ActionButton>
          </Footer>
        </form>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/ConcernsList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button, Badge, Select as StyledSelect } from '@/styles/StyledComponents'; // Import Select
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import LoadingSpinner
import type { ConcernStatus, FlaggedMessage } from '@/types/database.types'; // Import base types

// --- Styled Components ---
const ListContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2` // Changed from h3 for better hierarchy potentially
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterControls = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  flex-wrap: wrap;
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; /* Ensure enough space for columns */
  border-collapse: collapse;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* Hide table on mobile/tablet if using mobile list */
    /* display: none; */
    /* OR, make it the primary view if MobileList isn't implemented fully */
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md}; /* Slightly less padding */
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  white-space: nowrap;
  vertical-align: bottom;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.875rem;
  vertical-align: top;
`;

const MessagePreview = styled.div`
  max-width: 200px; /* Limit width */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: ${({ theme }) => theme.colors.textLight};
  font-style: italic;
`;

// Interface for props passed to ConcernBadge
interface ConcernBadgeProps {
  $level: number; // Use transient prop syntax ($)
}

const ConcernBadge = styled(Badge)<ConcernBadgeProps>`
  background: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red + '20'; // Use alpha hex
    if ($level >= 3) return theme.colors.secondary + '20';
    return theme.colors.blue + '20'; // Use blue for moderate/minor
  }};

  color: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red;
    if ($level >= 3) return theme.colors.secondaryDark; // Use darker secondary for contrast
    return theme.colors.blue;
  }};
  font-weight: 500;
`;

// Interface for props passed to StatusBadge
interface StatusBadgeProps {
  $status: ConcernStatus; // Use transient prop syntax ($)
}

const StatusBadge = styled(Badge)<StatusBadgeProps>`
   background: ${({ theme, $status }) => {
       switch ($status) {
           case 'resolved': return theme.colors.green + '20';
           case 'false_positive': return theme.colors.textMuted + '20';
           case 'reviewing': return theme.colors.secondary + '20';
           case 'pending': return theme.colors.red + '20';
           default: return theme.colors.backgroundDark;
       }
   }};
   color: ${({ theme, $status }) => {
        switch ($status) {
           case 'resolved': return theme.colors.green;
           case 'false_positive': return theme.colors.textMuted;
           case 'reviewing': return theme.colors.secondaryDark;
           case 'pending': return theme.colors.red;
           default: return theme.colors.textLight;
       }
   }};
   font-weight: 500;
`;


const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  min-height: 100px; /* Give it some height */
`;

const PaginationControls = styled.div`
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: ${({ theme }) => theme.spacing.lg};
    gap: ${({ theme }) => theme.spacing.md};
`;

// --- Data Interface (Matching API Response) ---
interface ConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

// --- Helper Functions ---
function getConcernTypeText(type: string): string {
    if (!type) return 'Unknown';
    return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

function getConcernLevelText(level: number): string {
    if (level >= 5) return 'Critical';
    if (level >= 4) return 'High';
    if (level >= 3) return 'Significant';
    if (level >= 2) return 'Moderate';
    if (level >= 1) return 'Minor';
    return 'Low';
}

function getStatusText(status: ConcernStatus): string {
    switch (status) {
        case 'pending': return 'Pending';
        case 'reviewing': return 'Reviewing';
        case 'resolved': return 'Resolved';
        case 'false_positive': return 'False Positive';
        default: return status || 'Unknown';
    }
}
// -----------------------

interface ConcernsListProps {
  limit?: number; // Optional limit for dashboard preview
}

export default function ConcernsList({ limit }: ConcernsListProps) {
    const [concerns, setConcerns] = useState<ConcernDetails[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [statusFilter, setStatusFilter] = useState<string>('pending'); // Default to pending
    const [pagination, setPagination] = useState({ currentPage: 0, hasMore: false, totalCount: 0 });
    const router = useRouter();

    const fetchConcerns = useCallback(async (page = 0, filter = statusFilter, isNewFilter = false) => {
        setLoading(true); // Show loading indicator on fetch
        if (isNewFilter) {
             setConcerns([]); // Clear existing concerns when filter changes
             setPagination(prev => ({ ...prev, currentPage: 0, hasMore: false })); // Reset pagination
        }
        setError(null);

        try {
            const itemsPerPage = limit || 10; // Use prop limit or default to 10 for full view
            const url = new URL('/api/teacher/concerns', window.location.origin);
            url.searchParams.append('page', page.toString());
            url.searchParams.append('limit', itemsPerPage.toString());
            if (filter) {
                url.searchParams.append('status', filter);
            }

            const response = await fetch(url.toString());

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to fetch concerns (status: ${response.status})`);
            }

            const data = await response.json();
            // Append if loading more, replace if it's a new filter or first page
            setConcerns(prev => (page > 0 && !isNewFilter) ? [...prev, ...(data.concerns || [])] : (data.concerns || []));
            setPagination({
                 currentPage: data.pagination?.currentPage ?? 0,
                 hasMore: data.pagination?.hasMore ?? false,
                 totalCount: data.pagination?.totalCount ?? 0,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error loading concerns');
            setConcerns([]); // Clear concerns on error
            setPagination({ currentPage: 0, hasMore: false, totalCount: 0 }); // Reset pagination on error
        } finally {
            setLoading(false);
        }
    }, [limit, statusFilter]); // statusFilter is now a dependency

    useEffect(() => {
        // Initial fetch when component mounts
        fetchConcerns(0, statusFilter, true); // isNewFilter = true on initial load
    }, [fetchConcerns, statusFilter]); // Fetch when filter changes


    const handleViewConversation = (concern: ConcernDetails) => {
        router.push(`/teacher-dashboard/concerns/${concern.flag_id}`);
    };

    const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newFilter = e.target.value;
        setStatusFilter(newFilter);
        // Fetch will be triggered by useEffect dependency change
    };

    const handleLoadMore = () => {
        if (!loading && pagination.hasMore) {
            fetchConcerns(pagination.currentPage + 1, statusFilter, false); // isNewFilter = false
        }
    };

    // Render Logic
    const renderContent = () => {
        if (loading && concerns.length === 0) { // Show loading only on initial load
            return <LoadingState><LoadingSpinner /> Loading concerns...</LoadingState>;
        }

        if (error) {
            return <Alert variant="error">{error}</Alert>;
        }

        if (concerns.length === 0) {
            return (
            <EmptyState>
                <p>No concerns {statusFilter ? `with status "${getStatusText(statusFilter as ConcernStatus)}"` : ''} found.</p>
            </EmptyState>
            );
        }

        return (
            <>
                <TableContainer>
                    <Table>
                        <thead>
                            <tr>
                                <TableHeader>Student</TableHeader>
                                <TableHeader>Room</TableHeader>
                                <TableHeader>Concern Type</TableHeader>
                                <TableHeader>Level</TableHeader>
                                <TableHeader>Message Preview</TableHeader>
                                <TableHeader>Date Flagged</TableHeader>
                                <TableHeader>Status</TableHeader>
                                <TableHeader>Actions</TableHeader>
                            </tr>
                        </thead>
                        <tbody>
                            {concerns.map((concern) => (
                                <tr key={concern.flag_id}>
                                    <TableCell>{concern.student_name || 'N/A'}</TableCell>
                                    <TableCell>{concern.room_name || 'N/A'}</TableCell>
                                    <TableCell>{getConcernTypeText(concern.concern_type)}</TableCell>
                                    <TableCell>
                                        <ConcernBadge $level={concern.concern_level}>
                                            {getConcernLevelText(concern.concern_level)} ({concern.concern_level})
                                        </ConcernBadge>
                                    </TableCell>
                                    <TableCell>
                                        <MessagePreview title={concern.message_content || ''}>
                                            {concern.message_content || '[N/A]'}
                                        </MessagePreview>
                                    </TableCell>
                                    <TableCell>
                                        {new Date(concern.created_at).toLocaleString()}
                                    </TableCell>
                                    <TableCell>
                                        <StatusBadge $status={concern.status}>
                                            {getStatusText(concern.status)}
                                        </StatusBadge>
                                    </TableCell>
                                    <TableCell>
                                        <Button
                                            size="small"
                                            onClick={() => handleViewConversation(concern)}
                                        >
                                            Review
                                        </Button>
                                    </TableCell>
                                </tr>
                            ))}
                        </tbody>
                    </Table>
                </TableContainer>

                {/* Add Mobile List View Here if needed */}
                {/*
                <MobileList>
                   ... Mobile card rendering ...
                </MobileList>
                */}

                {!limit && pagination.hasMore && ( // Only show load more if not limited by prop
                 <PaginationControls>
                     <Button onClick={handleLoadMore} variant="outline" disabled={loading}>
                         {loading ? 'Loading...' : 'Load More Concerns'}
                     </Button>
                 </PaginationControls>
                )}
            </>
        );
    };

    return (
        <ListContainer>
            {/* Render Title and Filters only if not limited (i.e., it's the full list view) */}
            {!limit && (
                <>
                    <Title>Student Welfare Concerns</Title>
                    <FilterControls>
                        <label htmlFor="status-filter">Filter by status:</label>
                        <StyledSelect // Use the imported styled Select
                            id="status-filter"
                            value={statusFilter}
                            onChange={handleFilterChange}
                            disabled={loading}
                        >
                            <option value="pending">Pending</option>
                            <option value="reviewing">Reviewing</option>
                            <option value="resolved">Resolved</option>
                            <option value="false_positive">False Positive</option>
                            <option value="">All</option>
                        </StyledSelect>
                        {!loading && <span>Total Found: {pagination.totalCount}</span>}
                    </FilterControls>
                 </>
            )}
            {/* Render the main content (table/loading/empty/error) */}
            {renderContent()}
        </ListContainer>
    );
}// src/components/teacher/DashboardOverview.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import StatsCard from './StatsCard';
import { Button, Alert } from '@/styles/StyledComponents';
import { useRouter } from 'next/navigation'; // For linking

const OverviewWrapper = styled.div`
  // Add any specific wrapper styles if needed
`;

const StatsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Section = styled.section`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.text};
`;

interface DashboardStats {
  totalChatbots: number;
  totalRooms: number;
  activeRooms: number;
  pendingConcerns: number;
}

export default function DashboardOverview() {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  useEffect(() => {
    const fetchStats = async () => {
      setLoading(true);
      setError(null);
      try {
        const response = await fetch('/api/teacher/dashboard-stats');
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error || `Failed to fetch stats (status ${response.status})`);
        }
        const data: DashboardStats = await response.json();
        setStats(data);
      } catch (err) {
        console.error("Error fetching dashboard stats:", err);
        setError(err instanceof Error ? err.message : 'Could not load dashboard statistics.');
      } finally {
        setLoading(false);
      }
    };
    fetchStats();
  }, []);

  if (loading) {
    return <p>Loading dashboard overview...</p>;
  }

  if (error) {
    return <Alert variant="error">Error loading stats: {error}</Alert>;
  }

  return (
    <OverviewWrapper>
      {stats && (
        <StatsGrid>
          <StatsCard 
            title="Pending Concerns" 
            value={stats.pendingConcerns} 
            onClick={() => router.push('/teacher-dashboard/concerns')}
            variant={stats.pendingConcerns > 0 ? 'danger' : 'default'}
            // icon={<SomeIconForConcerns />} 
          />
          <StatsCard 
            title="Active Rooms" 
            value={stats.activeRooms} 
            onClick={() => router.push('/teacher-dashboard/rooms')}
            // icon={<SomeIconForRooms />} 
          />
          <StatsCard 
            title="My Chatbots" 
            value={stats.totalChatbots} 
            onClick={() => router.push('/teacher-dashboard/chatbots')}
            // icon={<SomeIconForChatbots />} 
          />
          <StatsCard 
            title="Total Rooms" 
            value={stats.totalRooms} 
            // icon={<SomeIconForTotalRooms />} 
          />
        </StatsGrid>
      )}

      <Section>
        <SectionHeader>
          <SectionTitle>Quick Actions</SectionTitle>
        </SectionHeader>
        <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}>
          <Button onClick={() => alert('Navigate to Create Chatbot Form/Modal')}>
            + Create New Chatbot
          </Button>
          <Button onClick={() => alert('Navigate to Create Room Form/Modal')}>
            + Create New Room
          </Button>
        </div>
      </Section>
      
      {/* Placeholder for recent activity or tips */}
      {/* 
      <Section>
        <SectionTitle>Recent Activity</SectionTitle>
        <p>No recent activity to show yet.</p>
      </Section>
      */}

    </OverviewWrapper>
  );
}// src/components/teacher/StudentList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react'; // Added useCallback
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import a spinner

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; 
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled(EmptyState)` // Reuse EmptyState style for consistency
    display: flex;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
`;


const MobileList = styled.div`
  display: none;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block;
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const StudentName = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.875rem;
  
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-right: ${({ theme }) => theme.spacing.md};
  }
  
  .value {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

interface Student {
  user_id: string;
  name: string;
  email: string;
  joined_at: string | null;
  // message_count: number; // Removed as API doesn't provide it yet
  // last_activity: string | null; // Removed
}

interface StudentListProps {
  roomId: string;
}

export default function StudentList({ roomId }: StudentListProps) {
  const [students, setStudents] = useState<Student[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const fetchStudents = useCallback(async () => {
    console.log(`[StudentList] Fetching students for roomId: ${roomId}`);
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/teacher/students?roomId=${roomId}`);
      
      if (!response.ok) {
        let errorMessage = `Failed to fetch students (status ${response.status})`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.error || errorMessage;
        } catch {
          // Failed to parse error JSON
        }
        console.error(`[StudentList] API error: ${errorMessage}`);
        throw new Error(errorMessage);
      }
      
      const data = await response.json();
      console.log('[StudentList] Students data received:', data);
      setStudents(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error('[StudentList] Catch block error fetching students:', err);
      setError(err instanceof Error ? err.message : 'Could not load student data.');
      setStudents([]); // Clear students on error
    } finally {
      console.log('[StudentList] Setting loading to false.');
      setLoading(false);
    }
  }, [roomId]); // roomId is the dependency

  useEffect(() => {
    if (roomId) { // Only fetch if roomId is available
        fetchStudents();
    } else {
        console.warn("[StudentList] RoomId is missing, not fetching students.");
        setLoading(false); // Don't hang in loading state if no roomId
    }
  }, [roomId, fetchStudents]); // fetchStudents is stable due to useCallback

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString();
    } catch {
        return 'Invalid Date';
    }
  };

  const handleViewChats = (studentId: string) => {
    router.push(`/room/${roomId}/student/${studentId}`);
  };

  if (loading) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <LoadingState><LoadingSpinner size="small" /> Loading student data...</LoadingState>
      </ListContainer>
    );
  }

  // Error display takes precedence over empty state if an error occurred
  if (error) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <Alert variant="error">
          Error: {error}
          <Button size="small" onClick={fetchStudents} style={{ marginLeft: '10px' }}>
            Retry
          </Button>
        </Alert>
      </ListContainer>
    );
  }

  if (students.length === 0) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <EmptyState>
          <p>No students have joined this room yet, or data could not be loaded.</p>
          <Button size="small" onClick={fetchStudents} style={{ marginTop: '10px' }}>
            Refresh List
          </Button>
        </EmptyState>
      </ListContainer>
    );
  }

  return (
    <ListContainer>
      <Title>Students ({students.length})</Title>
      
      <Table>
        {/* ... (thead remains the same) ... */}
        <thead>
          <tr>
            <TableHeader>Name</TableHeader>
            <TableHeader>Email</TableHeader>
            <TableHeader>Joined</TableHeader>
            <TableHeader>Actions</TableHeader>
          </tr>
        </thead>
        <tbody>
          {students.map((student) => (
            <tr key={student.user_id}>
              <TableCell>{student.name}</TableCell>
              <TableCell>{student.email}</TableCell>
              <TableCell>{formatDate(student.joined_at)}</TableCell>
              <TableCell>
                <Button
                  size="small"
                  onClick={() => handleViewChats(student.user_id)}
                >
                  View Chats
                </Button>
              </TableCell>
            </tr>
          ))}
        </tbody>
      </Table>
      
      <MobileList>
        {students.map((student) => (
          <MobileCard key={student.user_id}>
            <MobileHeader>
              <StudentName>{student.name}</StudentName>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Email:</span>
              <span className="value">{student.email}</span>
              <span className="label">Joined:</span>
              <span className="value">{formatDate(student.joined_at)}</span>
            </MobileDetails>
            <MobileActions>
              <Button
                size="small"
                onClick={() => handleViewChats(student.user_id)}
                style={{ width: '100%' }}
              >
                View Chats
              </Button>
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/teacher/ChatbotList.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { Card, Button } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

// ... (ListGrid, StyledChatbotCard, getModelDisplayName styled components remain the same) ...
const ListGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const StyledChatbotCard = styled(Card)`
  position: relative;
  display: flex;
  flex-direction: column;

  a > h3 { 
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
    text-decoration: none;
    display: block; 
    transition: color ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      text-decoration: underline;
    }
  }
  
  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1;
    min-height: 2.5rem;
  }
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.sm};
    margin-top: auto; 
    padding-top: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap;
    button, a { 
        flex-grow: 1;
        min-width: calc(33% - ${({ theme }) => theme.spacing.sm} * 2 / 3);
        text-align: center;
         @media (max-width: 420px) { 
            min-width: 100%;
         }
    }
  }
`;

const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash'
    };
    return modelNames[model] || model;
};

interface ChatbotListProps {
  chatbots: Chatbot[];
  onEdit: (chatbotId: string) => void;
  onDelete: (chatbotId: string, chatbotName: string) => void;
}

export default function ChatbotList({ chatbots, onEdit, onDelete }: ChatbotListProps) {
  if (chatbots.length === 0) {
    return <Card><p>No chatbots created yet. Click &quot;+ Create Chatbot&quot; to get started!</p></Card>;
  }

  return (
    <ListGrid>
      {chatbots.map(chatbot => (
        <StyledChatbotCard key={chatbot.chatbot_id}>
          {/* MODIFIED LINK for chatbot name */}
          <Link href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/test-chat`} title={`Test chat with ${chatbot.name}`}>
            <h3>{chatbot.name}</h3>
          </Link>
          <p className="description">{chatbot.description || 'No description provided.'}</p>
          <div className="model-info">
            Model: {getModelDisplayName(chatbot.model)}
          </div>
          <div className="actions">
            <Button
              size="small"
              variant="outline"
              onClick={() => onEdit(chatbot.chatbot_id)}
              title="Edit chatbot configuration"
            >
              Configure
            </Button>
            <Button
                as={Link} 
                href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/knowledge-base`}
                size="small"
                variant="outline"
                title="Manage knowledge base documents"
            >
                Knowledge
            </Button>
            <Button
                size="small"
                variant="danger"
                onClick={() => onDelete(chatbot.chatbot_id, chatbot.name)}
                title="Delete this chatbot"
            >
                Delete
            </Button>
          </div>
        </StyledChatbotCard>
      ))}
    </ListGrid>
  );
}'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
    overflow-y: auto;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    max-height: 100%;
    min-height: 100vh;
    border-radius: 0;
    overflow-y: auto;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    position: sticky;
    top: 0;
    background: ${({ theme }) => theme.colors.backgroundCard};
    padding: ${({ theme }) => theme.spacing.sm} 0;
    z-index: 5;
  }
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
  }
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    max-height: 200px;
  }
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
    min-height: 44px; // Better for touch inputs
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 20px;
    height: 20px;
  }
`;

const ChatbotName = styled.span`
  flex: 1;
`;

const ChatbotDescription = styled.span`
  margin-left: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none;
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px; // Better for touch inputs
  }
`;

interface RoomFormProps {
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function RoomForm({ chatbots, onClose, onSuccess }: RoomFormProps) {
  const [formData, setFormData] = useState({
    room_name: '',
    chatbot_ids: [] as string[],
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/teacher/rooms', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create room');
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create room');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({
      ...prev,
      room_name: e.target.value,
    }));
  };

  const handleToggleChatbot = (chatbotId: string) => {
    setFormData(prev => ({
      ...prev,
      chatbot_ids: prev.chatbot_ids.includes(chatbotId)
        ? prev.chatbot_ids.filter(id => id !== chatbotId)
        : [...prev.chatbot_ids, chatbotId]
    }));
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create Classroom Room</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="room_name">Room Name</Label>
            <Input
              id="room_name"
              name="room_name"
              value={formData.room_name}
              onChange={handleNameChange}
              placeholder="Enter room name"
              required
            />
          </FormGroup>

          <FormGroup>
            <Label>Select Chatbots</Label>
            {chatbots.length === 0 ? (
              <Alert variant="warning">
                You need to create a chatbot before you can create a room.
              </Alert>
            ) : (
              <ChatbotList>
                {chatbots.map(chatbot => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <Checkbox
                      type="checkbox"
                      checked={formData.chatbot_ids.includes(chatbot.chatbot_id)}
                      onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                    />
                    <ChatbotName>{chatbot.name}</ChatbotName>
                    {chatbot.description && (
                      <ChatbotDescription>
                        - {chatbot.description}
                      </ChatbotDescription>
                    )}
                  </ChatbotItem>
                ))}
              </ChatbotList>
            )}
          </FormGroup>

          <Footer>
            <ActionButton type="button" variant="outline" onClick={onClose}>
              Cancel
            </ActionButton>
            <ActionButton 
              type="submit" 
              disabled={isSubmitting || chatbots.length === 0 || formData.chatbot_ids.length === 0}
            >
              {isSubmitting ? 'Creating...' : 'Create Room'}
            </ActionButton>
          </Footer>
        </form>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/DocumentList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import { Document, DocumentStatus } from '@/types/knowledge-base.types';

const ListContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; // Hide table on mobile
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
`;

const MobileList = styled.div`
  display: none;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block;
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const FileName = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.875rem;
  
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-right: ${({ theme }) => theme.spacing.md};
  }
  
  .value {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const StatusBadge = styled(Badge)<{ $status: DocumentStatus }>`
  ${({ theme, $status }) => {
    switch ($status) {
      case 'completed':
        return `
          background: rgba(76, 206, 151, 0.1);
          color: ${theme.colors.green};
        `;
      case 'processing':
        return `
          background: rgba(74, 159, 255, 0.1);
          color: ${theme.colors.blue};
        `;
      case 'error':
        return `
          background: rgba(248, 127, 127, 0.1);
          color: ${theme.colors.red};
        `;
      default:
        return `
          background: rgba(107, 80, 183, 0.1);
          color: ${theme.colors.primary};
        `;
    }
  }}
`;

interface DocumentListProps {
  documents: Document[];
  onProcessDocument: (documentId: string) => void;
  onDeleteDocument: (documentId: string) => void;
  onViewStatus: (documentId: string) => void;
}

export default function DocumentList({
  documents,
  onProcessDocument,
  onDeleteDocument,
  onViewStatus
}: DocumentListProps) {
  const [processingId, setProcessingId] = useState<string | null>(null);
  const [deletingId, setDeletingId] = useState<string | null>(null);

  const formatDate = (dateString: string) => {
    return new Date(dateString).toLocaleString();
  };

  const formatFileSize = (bytes: number) => {
    if (bytes < 1024) return `${bytes} bytes`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
  };

  const getStatusLabel = (status: DocumentStatus) => {
    switch (status) {
      case 'uploaded': return 'Uploaded';
      case 'processing': return 'Processing';
      case 'completed': return 'Completed';
      case 'error': return 'Error';
    }
  };

  const handleProcess = async (documentId: string) => {
    setProcessingId(documentId);
    await onProcessDocument(documentId);
    setProcessingId(null);
  };

  const handleDelete = async (documentId: string) => {
    setDeletingId(documentId);
    await onDeleteDocument(documentId);
    setDeletingId(null);
  };

  if (documents.length === 0) {
    return (
      <ListContainer>
        <EmptyState>
          <p>No documents uploaded yet.</p>
        </EmptyState>
      </ListContainer>
    );
  }

  return (
    <ListContainer>
      <Table>
        <thead>
          <tr>
            <TableHeader>Name</TableHeader>
            <TableHeader>Type</TableHeader>
            <TableHeader>Size</TableHeader>
            <TableHeader>Status</TableHeader>
            <TableHeader>Uploaded</TableHeader>
            <TableHeader>Actions</TableHeader>
          </tr>
        </thead>
        <tbody>
          {documents.map((doc) => (
            <tr key={doc.document_id}>
              <TableCell>{doc.file_name}</TableCell>
              <TableCell>{doc.file_type.toUpperCase()}</TableCell>
              <TableCell>{formatFileSize(doc.file_size)}</TableCell>
              <TableCell>
                <StatusBadge $status={doc.status} variant="default">
                  {getStatusLabel(doc.status)}
                </StatusBadge>
              </TableCell>
              <TableCell>{formatDate(doc.created_at)}</TableCell>
              <TableCell>
                <div style={{ display: 'flex', gap: '8px' }}>
                  {doc.status === 'uploaded' && (
                    <Button
                      size="small"
                      onClick={() => handleProcess(doc.document_id)}
                      disabled={processingId === doc.document_id}
                    >
                      {processingId === doc.document_id ? 'Processing...' : 'Process'}
                    </Button>
                  )}
                  {['processing', 'completed'].includes(doc.status) && (
                    <Button
                      size="small"
                      variant="outline"
                      onClick={() => onViewStatus(doc.document_id)}
                    >
                      View Status
                    </Button>
                  )}
                  <Button
                    size="small"
                    variant="secondary"
                    onClick={() => handleDelete(doc.document_id)}
                    disabled={deletingId === doc.document_id}
                  >
                    {deletingId === doc.document_id ? 'Deleting...' : 'Delete'}
                  </Button>
                </div>
              </TableCell>
            </tr>
          ))}
        </tbody>
      </Table>

      <MobileList>
        {documents.map((doc) => (
          <MobileCard key={doc.document_id}>
            <MobileHeader>
              <FileName>{doc.file_name}</FileName>
              <StatusBadge $status={doc.status} variant="default">
                {getStatusLabel(doc.status)}
              </StatusBadge>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Type:</span>
              <span className="value">{doc.file_type.toUpperCase()}</span>
              
              <span className="label">Size:</span>
              <span className="value">{formatFileSize(doc.file_size)}</span>
              
              <span className="label">Uploaded:</span>
              <span className="value">{formatDate(doc.created_at)}</span>
            </MobileDetails>
            <MobileActions>
              {doc.status === 'uploaded' && (
                <Button
                  size="small"
                  onClick={() => handleProcess(doc.document_id)}
                  disabled={processingId === doc.document_id}
                  style={{ flex: 1 }}
                >
                  {processingId === doc.document_id ? 'Processing...' : 'Process'}
                </Button>
              )}
              {['processing', 'completed'].includes(doc.status) && (
                <Button
                  size="small"
                  variant="outline"
                  onClick={() => onViewStatus(doc.document_id)}
                  style={{ flex: 1 }}
                >
                  View Status
                </Button>
              )}
              <Button
                size="small"
                variant="secondary"
                onClick={() => handleDelete(doc.document_id)}
                disabled={deletingId === doc.document_id}
                style={{ flex: doc.status === 'uploaded' ? undefined : 1 }}
              >
                {deletingId === doc.document_id ? 'Deleting...' : 'Delete'}
              </Button>
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo } from 'react';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    void error;
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || <h1>Sorry.. there was an error</h1>;
    }

    return this.props.children;
  }
}// src/lib/openrouter/client.ts
import type { ChatMessage } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

export interface OpenRouterConfig {
  model: string;
  temperature?: number;
  maxTokens?: number;
}

export interface OpenRouterResponse {
  choices: {
    message: {
      content: string;
    };
  }[];
  usage?: {
    total_tokens: number;
  };
}

export async function sendChatCompletion(
  messages: ChatMessage[],
  config: OpenRouterConfig
): Promise<OpenRouterResponse> {
  const response = await fetch(OPENROUTER_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
      'X-Title': 'ClassBots AI',
    },
    body: JSON.stringify({
      model: config.model,
      messages: messages.map(msg => ({
        role: msg.role,
        content: msg.content,
      })),
      temperature: config.temperature || 0.7,
      max_tokens: config.maxTokens || 1000,
    }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    console.error('OpenRouter error details:', errorData);
    throw new Error(`OpenRouter API error: ${errorData.error?.message || response.statusText}`);
  }

  return response.json();
}// src/lib/utils/room-codes.ts
const CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
const CODE_LENGTH = 6;

export function generateRoomCode(): string {
  let code = '';
  for (let i = 0; i < CODE_LENGTH; i++) {
    const randomIndex = Math.floor(Math.random() * CHARACTERS.length);
    code += CHARACTERS[randomIndex];
  }
  return code;
}

export function isValidRoomCode(code: string): boolean {
  if (code.length !== CODE_LENGTH) {
    return false;
  }
  
  const regex = new RegExp(`^[${CHARACTERS}]{${CODE_LENGTH}}$`);
  return regex.test(code);
}// src/lib/utils/constants.ts

// App Constants
export const APP_NAME = 'ClassBots AI';
export const APP_DESCRIPTION = 'AI-powered classroom chatbots for teachers and students';

// Route Constants
export const ROUTES = {
  HOME: '/',
  AUTH: '/auth',
  TEACHER_DASHBOARD: '/teacher-dashboard',
  STUDENT: '/student',
  CHAT: (roomId: string) => `/chat/${roomId}`,
  API: {
    TEACHER: {
      CHATBOTS: '/api/teacher/chatbots',
      ROOMS: '/api/teacher/rooms',
    },
    STUDENT: {
      ROOMS: '/api/student/rooms',
      JOIN_ROOM: '/api/student/join-room',
    },
    CHAT: (roomId: string) => `/api/chat/${roomId}`,
  },
} as const;

// Default Chatbot Config
export const DEFAULT_CHATBOT_CONFIG = {
  model: 'x-ai/grok-3-mini-beta', // Keeping Grok as default
  maxTokens: 1500,
  temperature: 0.7,
} as const;

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant',
  SYSTEM: 'system',
} as const;

// User Roles
export const USER_ROLES = {
  TEACHER: 'teacher',
  STUDENT: 'student',
} as const;

// Local Storage Keys
export const STORAGE_KEYS = {
  THEME: 'classbots-theme',
  LAST_ROOM: 'classbots-last-room',
} as const;// src/lib/document-processing/extractor.ts
import * as pdfParse from 'pdf-parse/lib/pdf-parse.js';
import mammoth from 'mammoth';
import { DocumentType } from '@/types/knowledge-base.types';

/**
 * Extract text from different document types
 */
export async function extractTextFromFile(
  fileBuffer: Buffer,
  fileType: DocumentType
): Promise<string> {
  try {
    switch (fileType) {
      case 'pdf':
        return extractFromPdf(fileBuffer);
      case 'docx':
        return extractFromDocx(fileBuffer);
      case 'txt':
        return extractFromTxt(fileBuffer);
      default:
        throw new Error(`Unsupported file type: ${fileType}`);
    }
  } catch (error) {
    console.error(`Error extracting text from ${fileType} file:`, error);
    throw new Error(`Failed to extract text from ${fileType} file: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF files
 */
async function extractFromPdf(fileBuffer: Buffer): Promise<string> {
  try {
    // Use a minimal options object to avoid looking for test files
    const options = {
      // No version testing, no page rendering
      max: 0,
      pagerender: null
    };
    
    const data = await pdfParse(fileBuffer, options);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw error;
  }
}

/**
 * Extract text from DOCX files
 */
async function extractFromDocx(fileBuffer: Buffer): Promise<string> {
  try {
    const result = await mammoth.extractRawText({ buffer: fileBuffer });
    return result.value;
  } catch (error) {
    console.error('Error extracting text from DOCX:', error);
    throw error;
  }
}

/**
 * Extract text from TXT files
 */
function extractFromTxt(fileBuffer: Buffer): Promise<string> {
  return Promise.resolve(fileBuffer.toString('utf-8'));
}// src/lib/document-processing/processor.ts
import { extractTextFromFile } from './extractor';
import { splitTextIntoChunks, estimateTokenCount } from './chunker';
import { generateEmbeddings } from '@/lib/openai/embeddings';
import { upsertVectors } from '@/lib/pinecone/utils';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { Document, DocumentChunk, DocumentStatus } from '@/types/knowledge-base.types';

// Mock embedding function for fallback - using 1536 dimensions for OpenAI
function createMockEmbedding(): number[] {
  // Create a random vector - 1536 dimensions for OpenAI compatibility
  return Array(1536).fill(0).map(() => (Math.random() * 2) - 1);
}

/**
 * Process a document by extracting text, chunking, and generating embeddings
 */
export async function processDocument(document: Document): Promise<void> {
  console.log(`[PROCESSOR] Starting document processing for doc ID: ${document.document_id}, file: ${document.file_name}`);
  const supabase = await createServerSupabaseClient();

  try {
    // Update document status to processing (already done by caller, but good for robustness)
    await supabase
      .from('documents')
      .update({ status: 'processing' as DocumentStatus, updated_at: new Date().toISOString() })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Status set to processing.`);

    // Download file from storage
    console.log(`[PROCESSOR ${document.document_id}] Downloading file from storage: ${document.file_path}`);
    const { data: fileData, error: fileError } = await supabase
      .storage
      .from('documents')
      .download(document.file_path);

    if (fileError || !fileData) {
      throw new Error(`Failed to download file: ${fileError?.message}`);
    }
    console.log(`[PROCESSOR ${document.document_id}] File downloaded successfully.`);

    // Extract text from file
    console.log(`[PROCESSOR ${document.document_id}] Extracting text from file type: ${document.file_type}`);
    const extractedText = await extractTextFromFile(
      Buffer.from(await fileData.arrayBuffer()),
      document.file_type
    );
    console.log(`[PROCESSOR ${document.document_id}] Extracted ${extractedText.length} characters.`);

    // Split text into chunks
    console.log(`[PROCESSOR ${document.document_id}] Splitting text into chunks.`);
    const chunks = splitTextIntoChunks(extractedText);
    console.log(`[PROCESSOR ${document.document_id}] Created ${chunks.length} chunks.`);

    if (chunks.length === 0) {
        console.warn(`[PROCESSOR ${document.document_id}] No chunks generated. Document might be empty or too small.`);
        await supabase
          .from('documents')
          .update({ status: 'completed' as DocumentStatus, error_message: 'No content to process.', updated_at: new Date().toISOString() })
          .eq('document_id', document.document_id);
        return;
    }

    // Create chunk records in database
    console.log(`[PROCESSOR ${document.document_id}] Creating database records for chunks.`);
    const chunkRecords: Partial<DocumentChunk>[] = chunks.map((chunkText, index) => ({
      document_id: document.document_id,
      chunk_index: index,
      chunk_text: chunkText,
      token_count: estimateTokenCount(chunkText),
      status: 'pending'
    }));

    const { data: insertedChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .insert(chunkRecords)
      .select();

    if (chunksError) {
      throw new Error(`Failed to insert chunks: ${chunksError.message}`);
    }
    if (!insertedChunks || insertedChunks.length === 0) {
        throw new Error("No chunks were inserted into the database, though chunks were generated.");
    }
    console.log(`[PROCESSOR ${document.document_id}] Inserted ${insertedChunks.length} chunk records.`);

    // SAFER APPROACH: Process chunks in smaller batches for OpenAI embeddings
    const openAIbatchSize = 20;
    let usingMockEmbeddings = false;
    let embeddings: number[][] = [];

    console.log(`[PROCESSOR ${document.document_id}] Generating embeddings in batches of ${openAIbatchSize}.`);
    for (let i = 0; i < chunks.length; i += openAIbatchSize) {
      const batchChunksText = chunks.slice(i, i + openAIbatchSize);
      console.log(`[PROCESSOR ${document.document_id}] Processing OpenAI batch ${Math.floor(i/openAIbatchSize) + 1}/${Math.ceil(chunks.length/openAIbatchSize)} (${batchChunksText.length} chunks)`);

      try {
        const batchEmbeddings = await generateEmbeddings(batchChunksText);
        embeddings = [...embeddings, ...batchEmbeddings];
      } catch (embedError) {
        console.error(`[PROCESSOR ${document.document_id}] Error generating embeddings for batch, falling back to mock:`, embedError);
        usingMockEmbeddings = true;
        const mockBatchEmbeddings = batchChunksText.map(() => createMockEmbedding());
        embeddings = [...embeddings, ...mockBatchEmbeddings];

        await supabase
          .from('documents')
          .update({
            error_message: `Warning: Using mock embeddings for some chunks. OpenAI API error: ${embedError instanceof Error ? embedError.message : String(embedError)}`
          })
          .eq('document_id', document.document_id);
      }
      if (chunks.length > openAIbatchSize) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }
    console.log(`[PROCESSOR ${document.document_id}] Generated ${embeddings.length} embeddings. ${usingMockEmbeddings ? '(Used MOCK embeddings for some)' : '(Used REAL embeddings)'}`);

    // Build vectors array with an initial filter to remove nulls
    const preparedVectors = [];
    
    for (let i = 0; i < embeddings.length; i++) {
      const chunkId = insertedChunks[i]?.chunk_id;
      if (!chunkId) {
        console.error(`[PROCESSOR ${document.document_id}] Mismatch: No chunk_id for embedding at index ${i}. Skipping this vector.`);
        continue;
      }
      
      preparedVectors.push({
        id: chunkId,
        values: embeddings[i],
        metadata: {
          chatbotId: document.chatbot_id,
          documentId: document.document_id,
          chunkId: chunkId,
          text: chunks[i],
          fileName: document.file_name,
          fileType: document.file_type,
          isMockEmbedding: usingMockEmbeddings ? "true" : "false" // Use string to avoid type conflicts
        }
      });
    }

    if (preparedVectors.length === 0 && chunks.length > 0) {
        console.error(`[PROCESSOR ${document.document_id}] No vectors prepared for Pinecone, though chunks exist. This indicates an issue with chunk_id mapping.`);
        throw new Error("Failed to prepare vectors for Pinecone due to chunk ID mismatch.");
    }

    console.log(`[PROCESSOR ${document.document_id}] Prepared ${preparedVectors.length} vectors for Pinecone.`);

    let vectorsUpsertedSuccessfully = false;
    try {
      console.log(`[PROCESSOR ${document.document_id}] Upserting ${preparedVectors.length} vectors to Pinecone via SDK.`);
      await upsertVectors(preparedVectors);
      vectorsUpsertedSuccessfully = true;
      console.log(`[PROCESSOR ${document.document_id}] Successfully upserted vectors to Pinecone.`);
    } catch (pineconeError) {
        console.error(`[PROCESSOR ${document.document_id}] Error upserting vectors to Pinecone:`, pineconeError);
    }

    console.log(`[PROCESSOR ${document.document_id}] Updating chunk statuses in DB.`);
    for (const insertedChunk of insertedChunks) {
        const vectorAttempted = preparedVectors.find(v => v.id === insertedChunk.chunk_id);
        if (vectorAttempted) {
            await supabase
                .from('document_chunks')
                .update({
                    status: vectorsUpsertedSuccessfully ? 'embedded' : 'error',
                    embedding_id: vectorsUpsertedSuccessfully ? insertedChunk.chunk_id : null
                })
                .eq('chunk_id', insertedChunk.chunk_id);
        } else {
            await supabase
                .from('document_chunks')
                .update({ status: 'error' })
                .eq('chunk_id', insertedChunk.chunk_id);
        }
    }
    console.log(`[PROCESSOR ${document.document_id}] Chunk statuses updated.`);

    const finalDocStatus = vectorsUpsertedSuccessfully ? 'completed' : 'error';
    let finalErrorMessage = vectorsUpsertedSuccessfully ? null : 'Failed to upsert vectors to Pinecone.';
    if (usingMockEmbeddings && vectorsUpsertedSuccessfully) {
        finalErrorMessage = (finalErrorMessage ? finalErrorMessage + " " : "") + "Warning: Some or all embeddings are MOCK data.";
    }

    await supabase
      .from('documents')
      .update({
        status: finalDocStatus as DocumentStatus,
        error_message: finalErrorMessage,
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document final status set to ${finalDocStatus}. Processing finished.`);

  } catch (error) {
    console.error(`[PROCESSOR ${document.document_id}] Critical error during processing:`, error);
    await supabase
      .from('documents')
      .update({
        status: 'error' as DocumentStatus,
        error_message: error instanceof Error ? error.message : 'Unknown critical error during processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document status updated to ERROR due to critical failure.`);
  }
}// src/lib/document-processing/chunker.ts

/**
 * Split text into chunks of approximately the specified size with overlap
 * @param text The full text to split
 * @param maxChunkSize Maximum size of each chunk in characters
 * @param overlap Number of characters to overlap between chunks
 * @returns Array of text chunks
 */
export function splitTextIntoChunks(
  text: string,
  maxChunkSize: number = 1000,
  overlap: number = 200
): string[] {
  // Validate parameters
  if (maxChunkSize <= 0) {
    console.error("[CHUNKER] maxChunkSize must be positive. Using default 1000.");
    maxChunkSize = 1000;
  }
  if (overlap < 0) {
    console.error("[CHUNKER] overlap cannot be negative. Using default 0.");
    overlap = 0;
  }
  // Ensure overlap is less than maxChunkSize to guarantee progress
  if (overlap >= maxChunkSize) {
    console.warn(`[CHUNKER] Overlap (${overlap}) is greater than or equal to maxChunkSize (${maxChunkSize}). Adjusting overlap to ensure progress.`);
    overlap = Math.max(0, Math.floor(maxChunkSize / 2) -1); // Ensure it's strictly less
  }

  const cleanedText = text
    .replace(/\s+/g, " ") // Normalize whitespace
    .replace(/\n{2,}/g, "\n") // Reduce multiple newlines to single (or adjust if double is preferred)
    .trim();

  if (cleanedText.length === 0) {
    return [];
  }

  if (cleanedText.length <= maxChunkSize) {
    return [cleanedText];
  }

  const chunks: string[] = [];
  let startIndex = 0;
  let safetyBreak = 0; // To prevent accidental infinite loops during development
  const maxIterations = Math.ceil(cleanedText.length / (maxChunkSize - overlap)) + 10; // Generous estimate

  while (startIndex < cleanedText.length && safetyBreak < maxIterations) {
    safetyBreak++;
    let endIndex = Math.min(startIndex + maxChunkSize, cleanedText.length);

    // If not at the end, try to find a better breakpoint
    if (endIndex < cleanedText.length) {
      let idealEnd = endIndex;
      // Try to break at a paragraph end (double newline, now single due to cleaning)
      // Search backwards from idealEnd, but not too far back (e.g., within last 30% of chunk)
      const searchStartPara = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.3));
      const paragraphBreak = cleanedText.lastIndexOf("\n", idealEnd);
      if (paragraphBreak > searchStartPara && paragraphBreak > startIndex) {
        idealEnd = paragraphBreak + 1; // Include the newline
      } else {
        // Try to break at a sentence end (period followed by space)
        // Search backwards from idealEnd
        const searchStartSentence = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.2));
        const sentenceBreak = cleanedText.lastIndexOf(". ", idealEnd);
        if (sentenceBreak > searchStartSentence && sentenceBreak > startIndex) {
          idealEnd = sentenceBreak + 1; // Include the period
        } else {
          // Try to break at a space
          const searchStartSpace = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.1));
          const spaceBreak = cleanedText.lastIndexOf(" ", idealEnd);
          if (spaceBreak > searchStartSpace && spaceBreak > startIndex) {
            idealEnd = spaceBreak + 1; // Include the space
          }
          // If no good break found, stick with Math.min(startIndex + maxChunkSize, cleanedText.length)
        }
      }
      endIndex = idealEnd;
    }

    const chunk = cleanedText.substring(startIndex, endIndex).trim();
    if (chunk.length > 0) { // Only push non-empty chunks
      chunks.push(chunk);
    }

    // Calculate the next starting point
    // Ensure startIndex always moves forward by at least (maxChunkSize - overlap)
    // unless it's the last chunk
    const nextStart = endIndex - overlap;

    // If nextStart isn't advancing past the current startIndex, it means chunks are too small or overlap is too big
    // This check ensures progress. If endIndex is already at the end, this loop will terminate.
    if (nextStart <= startIndex && endIndex < cleanedText.length) {
        // Force advancement if stuck, this could happen if maxChunkSize is very small or overlap is almost maxChunkSize
        // Or if the breakpoint logic consistently brings endIndex back too far.
        // A simple forced advancement might be to just move past the current chunk with minimal overlap.
        console.warn(`[CHUNKER] Potential stall detected. Forcing startIndex advancement. startIndex: ${startIndex}, endIndex: ${endIndex}, overlap: ${overlap}, nextStart: ${nextStart}`);
        startIndex = endIndex; // Effectively makes next chunk start where this one ended (no overlap if stalled)
                              // Or, for a more robust solution with overlap:
                              // startIndex = Math.max(startIndex + 1, endIndex - overlap);
    } else {
        startIndex = nextStart;
    }

    if (startIndex < 0) startIndex = 0; // Should not happen with validated overlap
  }

  if (safetyBreak >= maxIterations) {
    console.error("[CHUNKER] Safety break triggered, possible infinite loop. Returning collected chunks.", chunks.length);
  }

  // Filter out any potential empty strings again, just in case
  return chunks.filter(c => c.length > 0);
}

/**
 * Simple estimate of token count based on character count
 * @param text The text to estimate tokens for
 * @returns Estimated token count
 */
export function estimateTokenCount(text: string): number {
  // Rough estimate: ~4 characters per token for English text
  return Math.ceil(text.length / 4);
}// src/lib/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export async function updateSession(request: NextRequest) {
  const response = NextResponse.next(); // Changed from let to const

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value,
            ...options, // Use the full options object
          });
        },
        remove(name: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value: '',
            ...options, // Use the full options object
            maxAge: 0,
          });
        },
      },
    }
  );

  await supabase.auth.getUser();

  return response;
}// src/lib/supabase/admin.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

export const createAdminClient = () => {
  return createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      }
    }
  );
};// src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database.types';

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );// src/lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export const createServerSupabaseClient = async () => {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value,
            ...options
          });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value: '',
            ...options,
            maxAge: 0
          });
        },
      },
    }
  );
};// src/lib/safety/monitoring.ts

// --- Remove OpenAI import ---
// import openai from '../openai/client';

// --- FIX: Correctly import ChatMessage type ---
// Unused import removed.
// ----------------------------------------------

// --- Add OpenRouter endpoint and Model ---
const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
// Use a model available on OpenRouter (Gemma 2 9B Instruct is a good option)
const SAFETY_CHECK_MODEL = 'meta-llama/llama-4-scout';
// ------------------------------------------

// Keywords organized by category (Keep as is)
const CONCERN_KEYWORDS: Record<string, string[]> = {
  self_harm: [
    'hate myself',
'don\'t want to live',
'don\'t want to be alive',
'don\'t want to be here',
'don\'t want to exist',
'not worth going on',
'no point in living',
'no point going on',
'rather be dead',
'should end it',
'should end it all',
'end it all',
'give up',
'giving up',
'take my own life',
'take my life',
'harming myself',
'harm myself',
'hurting myself',
'cut myself',
'cutting myself',
'disappear forever',
'everyone better off without me',
'they\'d be better off without me',
'they would be better off without me',
'leave this world',
'escape this world',
'stop existing',
'tired of being alive',
'tired of existing',
'too much pain',
'can\'t take it anymore',
'life is too hard',
'life isn\'t worth it',
'never wake up',
'wish I wouldn\'t wake up',
'make the pain stop',
'no hope left',
'nowhere to turn',
'plan to kill',
'how to end',
'easier if I wasn\'t here',
'easier if I was gone'
  ],
  bullying: [
    'bullied', 'bully', 'bullying', 
    'they hate me',
'everyone hates me',
'laughed at me',
'laugh at me',
'excluded',
'leave me out',
'leaving me out',
'no friends',
'don\'t have friends',
'nobody likes me',
'no one likes me',
'call me names',
'called me names',
'push me around',
'pushed me',
'shove me',
'shoved me',
'making threats',
'threatened me',
'online bullying',
'cyberbullying',
'posting about me',
'spreading rumors',
'spreading rumours',
'spreading lies',
'everyone talks about me',
'made fun of',
'mock me',
'mocking me',
'rejected by everyone',
'being isolated',
'no one talks to me',
'nobody talks to me',
'they ignore me',
'everyone ignores me',
'being targeted',
'pick on me',
'won\'t leave me alone',
'always after me',
'ganging up on me',
'scared to go to school',
'don\'t want to go to school',
'afraid at school',
'scared at school'
  ],
  abuse: [
    'hurt me',
'hurting me',
'hitting me',
'hit by',
'kicks me',
'kicking me',
'pushed me',
'pushes me',
'throws things at me',
'threw things at me',
'threw something at me',
'yells at me',
'yelling at me',
'screams at me',
'screaming at me',
'threatens me',
'threatening me',
'controls me',
'controlling me',
'not allowed to',
'won\'t let me',
'keeps me from',
'locked me in',
'locks me in',
'touches me',
'touched me',
'uncomfortable touching',
'hurt by someone',
'afraid of them',
'afraid to go home',
'scared to go home',
'not safe at home',
'don\'t feel safe around',
'being punished',
'punishes me unfairly',
'treated badly',
'treats me badly',
'calls me stupid',
'calls me worthless',
'makes me feel worthless',
'makes me feel bad',
'punched me',
'punches me',
'slapped me',
'slaps me',
'bruises from',
'left bruises',
'threatened to hurt me if I told',
'can\'t tell anyone'
  ],
  depression: [
    'hate myself',
'hate my life',
'no one cares',
'nobody cares',
'nobody loves me',
'no one loves me',
'feel empty',
'feeling empty',
'feel nothing',
'feels like nothing matters',
'nothing matters',
'what\'s the point',
'feel worthless',
'feeling worthless',
'don\'t feel anything',
'don\'t know what to do',
'can\'t see a future',
'lost all hope',
'lost hope',
'given up',
'feel like a failure',
'am a failure',
'everything is dark',
'darkness closing in',
'can\'t get out of bed',
'can\'t face the day',
'crying all the time',
'crying myself to sleep',
'never happy',
'always feeling down',
'feel so alone',
'completely alone',
'no one understands',
'nobody understands',
'don\'t enjoy anything',
'nothing makes me happy',
'too sad to function',
'too sad to do anything',
'life is meaningless',
'unable to feel joy',
'can\'t sleep',
'can\'t eat',
'can\'t concentrate',
'mind feels foggy',
'exhausted all the time',
'overwhelmed by sadness',
'drowning in sadness'
  ],
  family_issues: [
    'parents always fighting',
'parents always argue',
'parents hate each other',
'home is not safe',
'scared at home',
'afraid at home',
'can\'t stand being home',
'hate being home',
'nowhere to go',
'might get kicked out',
'might be kicked out',
'threatened to kick me out',
'parent drinking',
'parent drunk',
'parents drunk',
'drinking problem',
'drug problem',
'parents using drugs',
'parent using drugs',
'not enough food',
'going hungry',
'no food at home',
'can\'t sleep at home',
'parents separated',
'parents separating',
'parents broke up',
'parents splitting up',
'losing our house',
'lost our house',
'might be homeless',
'could be homeless',
'moving in with relatives',
'have to move',
'parent lost job',
'no money for',
'can\'t afford',
'parent in jail',
'parent arrested',
'no one takes care of me',
'have to take care of myself',
'have to take care of my siblings',
'parent is sick',
'parent is ill',
'parent in hospital',
'no electricity',
'utilities shut off',
'water shut off'
  ],
};

/**
 * First-pass check: Look for concerning keywords in a message.
 */
export function initialConcernCheck(message: string): {
  hasConcern: boolean;
  concernType?: string;
} {
  if (!message) {
    return { hasConcern: false };
  }
  const lowerMessage = message.toLowerCase();

  // Original keyword matching logic
  for (const [category, keywords] of Object.entries(CONCERN_KEYWORDS)) {
    for (const keyword of keywords) {
      const regex = new RegExp(`\\b${keyword.toLowerCase()}\\b`);
      if (regex.test(lowerMessage)) {
        return { hasConcern: true, concernType: category };
      }
    }
  }

  // Additional heuristic checks - add after the keyword loop
  // Self-harm combinations
  if (lowerMessage.includes('hate myself') && 
      (lowerMessage.includes('not worth') || lowerMessage.includes('don\'t know what to do'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  
  // Suicidal ideation patterns
  if ((lowerMessage.includes('not worth') || lowerMessage.includes('no point')) && 
      (lowerMessage.includes('going on') || lowerMessage.includes('living') || lowerMessage.includes('anymore'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  
  // General despair pattern - likely depression
  if (lowerMessage.includes('don\'t know what to do') && 
      (lowerMessage.includes('anymore') || lowerMessage.includes('sad') || lowerMessage.includes('feel'))) {
    return { hasConcern: true, concernType: 'depression' };
  }

  return { hasConcern: false };
}

/**
 * Second-pass check: Use specified OpenRouter model to verify concern and rate severity.
 */
export async function verifyConcern(
  message: string,
  concernType: string,
  // Expecting the {role, content} structure from the chat API caller
  recentMessages: Array<{ role: 'user' | 'assistant' | 'system'; content: string }> = []
): Promise<{
  isRealConcern: boolean;
  concernLevel: number; // 0-5 scale
  analysisExplanation: string;
}> {
  let contextString = '';
  if (recentMessages.length > 0) {
    contextString = "\n\nRecent Conversation History (most recent last):\n";
    // Use the passed context messages
    recentMessages.slice(-3).forEach(msg => { // Limit context
      contextString += `${msg.role === 'user' ? 'Student' : 'Assistant'}: ${msg.content}\n`;
    });
  }

  // --- Adjusted Prompt for Clarity and JSON Focus ---
  const promptForModel = `
You are an AI safety analyst reviewing a student's chat message.
Concern Category Identified: ${concernType.replace(/_/g, ' ')}
${contextString}
Student Message: "${message}"

Task: Evaluate the student message ONLY for the concern category mentioned above. Is it a genuine concern? Rate its severity (0=None, 1=Minor, 2=Moderate, 3=Significant, 4=High, 5=Critical). Distinguish real issues from fiction/hypotheticals.

Respond ONLY with a valid JSON object containing these exact keys:
"isRealConcern": boolean
"concernLevel": number (0-5)
"analysisExplanation": string (1-2 sentence explanation)

JSON Output:
`;
  // --- End Prompt ---

  try {
    console.log(`[Safety Verification] Calling OpenRouter model: ${SAFETY_CHECK_MODEL}`);

    // --- Using fetch to call OpenRouter ---
    const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          // Identify your app to OpenRouter
          'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
          'X-Title': 'ClassBots AI - Safety Check', // Be specific
        },
        body: JSON.stringify({
          model: SAFETY_CHECK_MODEL,
          messages: [
            // Structure for models like Gemma: put the main instruction in the user message
            { role: "user", content: promptForModel }
          ],
          temperature: 0.2, // Low temp for consistent analysis
          max_tokens: 150,  // Should be enough for the JSON response
          response_format: { type: "json_object" } // Request JSON output if model supports it
        }),
      });
    // --- End fetch call ---

    if (!response.ok) {
        const errorBody = await response.text();
        console.error(`OpenRouter Error (verifyConcern): Status ${response.status}`, errorBody);
        let errorMessage = `OpenRouter API error (status ${response.status})`;
        try {
            const errorJson = JSON.parse(errorBody);
            errorMessage = errorJson.error?.message || errorMessage;
        } catch { /* Ignore parsing error */ }
        throw new Error(errorMessage); // Throw error to be caught below
    }

    const responseData = await response.json();

    // --- Parse the response content ---
    const rawResponse = responseData.choices?.[0]?.message?.content;
    if (!rawResponse) {
      throw new Error("OpenRouter response content was empty or missing.");
    }

    let analysis;
    try {
        // Sometimes models might add extra text around the JSON, try to extract JSON
        const jsonMatch = rawResponse.match(/\{[\s\S]*\}/); // Find first '{' to last '}'
        if (jsonMatch && jsonMatch[0]) {
            analysis = JSON.parse(jsonMatch[0]);
        } else {
             // If no clear JSON block, try parsing the whole thing (might fail)
            analysis = JSON.parse(rawResponse);
        }
    } catch (parseError) {
         console.error("Failed to parse JSON response from safety model:", rawResponse, parseError);
         // Attempt to extract explanation even if JSON fails, otherwise return generic error
         const extractedExplanation = typeof rawResponse === 'string' ? rawResponse.substring(0, 150) + "..." : "Invalid format received";
         return {
             isRealConcern: true, // Err on the side of caution
             concernLevel: 2,     // Moderate concern default
             analysisExplanation: `Model response was not valid JSON. Raw response snippet: ${extractedExplanation}`
         };
    }
    // --- End response parsing ---

    // Validate the structure and types of the parsed analysis object
    const isRealConcern = typeof analysis.isRealConcern === 'boolean' ? analysis.isRealConcern : false;
    const concernLevel = typeof analysis.concernLevel === 'number'
      ? Math.max(0, Math.min(5, Math.round(analysis.concernLevel))) // Clamp and round
      : 0;
    const analysisExplanation = typeof analysis.analysisExplanation === 'string'
      ? analysis.analysisExplanation.trim()
      : "Analysis explanation missing or invalid format.";

    console.log(`[Safety Verification] LLM Analysis: isReal=${isRealConcern}, level=${concernLevel}, explanation=${analysisExplanation}`);

    return {
      isRealConcern,
      concernLevel,
      analysisExplanation,
    };

  } catch (error) {
    console.error('Error during OpenRouter concern verification:', error);
    // Fallback if API call or parsing fails
    return {
      isRealConcern: true, // Default to true on error
      concernLevel: 2,     // Default to moderate for review
      analysisExplanation: `Concern verification failed: ${error instanceof Error ? error.message : 'Unknown error'}. Flagged for manual review.`,
    };
  }
}// src/lib/safety/alerts.ts
import nodemailer from 'nodemailer';
import { APP_NAME } from '@/lib/utils/constants';

// Configure email transport - Ensure these ENV vars are set!
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: Number(process.env.SMTP_PORT) || 587,
  secure: process.env.SMTP_PORT === '465', // Usually true for port 465
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASSWORD,
  },
});

// Helper to get user-friendly concern type name
export function getConcernTypeDisplayName(type: string): string {
  if (!type) return 'Unknown Concern';
  // Simple conversion: replace underscore with space, capitalize words
  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

// Helper to get user-friendly concern level name
export function getConcernLevelDisplayName(level: number): string {
  if (level >= 5) return 'Critical';
  if (level >= 4) return 'High';
  if (level >= 3) return 'Significant';
  if (level >= 2) return 'Moderate';
  if (level >= 1) return 'Minor';
  return 'Low'; // Level 0 should ideally not trigger an alert
}


/**
 * Sends an alert email to the teacher about a flagged message.
 * @param teacherEmail The email address of the teacher.
 * @param studentName The name of the student involved.
 * @param roomName The name of the room where the message occurred.
 * @param concernType The category of the concern.
 * @param concernLevel The severity level (0-5).
 * @param messageContent The content of the flagged message.
 * @param viewUrl The URL for the teacher to view the concern details.
 * @returns Promise<boolean> indicating if the email was sent successfully.
 */
export async function sendTeacherAlert(
  teacherEmail: string,
  studentName: string,
  roomName: string,
  concernType: string,
  concernLevel: number,
  messageContent: string, // The actual flagged message content
  viewUrl: string // URL to the concern detail page
): Promise<boolean> {

  // Basic validation
  if (!teacherEmail || !studentName || !roomName || !concernType || concernLevel < 0 || !messageContent || !viewUrl) {
    console.error('Missing required information for sending teacher alert.');
    return false;
  }

  const concernTypeName = getConcernTypeDisplayName(concernType);
  const concernLevelName = getConcernLevelDisplayName(concernLevel);

  const subject = `[${APP_NAME}] ${concernLevelName} ${concernTypeName} Alert for Student: ${studentName}`;

  // Sanitize message content slightly for display (optional)
  const displayedMessage = messageContent.replace(/</g, "<").replace(/>/g, ">");

  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        h2 { color: #6B50B7; } /* Use theme primary color */
        h3 { color: #4A3889; } /* Use theme primary dark color */
        ul { list-style: none; padding: 0; }
        li { margin-bottom: 5px; }
        strong { font-weight: bold; }
        blockquote {
          border-left: 4px solid #E5E7EB; /* Use theme border color */
          padding-left: 15px;
          margin-left: 0;
          color: #555;
          background-color: #F9FAFB; /* Use theme card background */
          padding: 10px;
        }
        a.button {
          display: inline-block;
          padding: 12px 24px;
          background-color: #6B50B7; /* Use theme primary color */
          color: white !important; /* Ensure text is white */
          text-decoration: none;
          border-radius: 6px;
          font-weight: bold;
          text-align: center;
        }
         a.button:hover {
             background-color: #4A3889; /* Use theme primary dark color */
         }
      </style>
    </head>
    <body>
      <h2>${APP_NAME} - Student Welfare Alert</h2>
      <p>A message from a student in one of your classrooms has been automatically flagged for a potential welfare concern based on its content.</p>
      <p>Please review the details below and the conversation context as soon as possible.</p>

      <h3>Alert Details:</h3>
      <ul>
        <li><strong>Student:</strong> ${studentName}</li>
        <li><strong>Classroom:</strong> ${roomName}</li>
        <li><strong>Concern Type:</strong> ${concernTypeName}</li>
        <li><strong>Assessed Level:</strong> ${concernLevelName} (Level ${concernLevel})</li>
        <li><strong>Time Detected:</strong> ${new Date().toLocaleString()}</li>
      </ul>

      <h3>Flagged Message:</h3>
      <blockquote>
        <p>${displayedMessage}</p>
      </blockquote>

      <p>Click the button below to view the full conversation context and manage this alert:</p>
      <p style="text-align: center;">
        <a href="${viewUrl}" class="button">Review Concern Now</a>
      </p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
      <p style="font-size: 0.9em; color: #777;">This is an automated message from ${APP_NAME}. Please do not reply directly to this email.</p>
    </body>
    </html>
  `;

  try {
    // Ensure SMTP creds are loaded
    if (!process.env.SMTP_HOST || !process.env.SMTP_USER || !process.env.SMTP_PASSWORD) {
        console.error("SMTP configuration is missing. Cannot send alert email.");
        return false;
    }

    const info = await transporter.sendMail({
      from: process.env.ALERT_EMAIL_FROM || `"${APP_NAME} Safety" <noreply@yourdomain.com>`, // Replace with your actual sender
      to: teacherEmail,
      subject: subject,
      html: html,
    });

    console.log(`Teacher alert email sent successfully to ${teacherEmail}. Message ID: ${info.messageId}`);
    return true;
  } catch (error) {
    console.error(`Error sending teacher alert email to ${teacherEmail}:`, error);
    return false;
  }
}// src/lib/pinecone/utils.ts
import { index, pinecone } from './client';
import { RecordMetadata } from '@pinecone-database/pinecone';

interface ChunkMetadata extends RecordMetadata {
  chatbotId: string;
  documentId: string;
  chunkId: string;
  text: string;
  fileName: string;
  fileType: string;
}

/**
 * Upsert vectors into Pinecone with enhanced error handling
 * @param vectors Array of vectors with their IDs and metadata
 */
export async function upsertVectors(
  vectors: { 
    id: string, 
    values: number[], 
    metadata: ChunkMetadata 
  }[]
) {
  // Validate that Pinecone is initialized
  if (!index || !pinecone) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    throw new Error('Pinecone client not initialized. Check API key and environment variables.');
  }

  try {
    // Use a smaller batch size to avoid timeouts
    const batchSize = 25; // Reduced from 50 to 25
    
    console.log(`Upserting ${vectors.length} vectors in batches of ${batchSize}`);
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      try {
        // Add retries for resilience
        let retries = 0;
        const maxRetries = 3;
        let success = false;
        
        while (!success && retries < maxRetries) {
          try {
            await index.upsert(batch);
            success = true;
            console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
          } catch (retryError) {
            retries++;
            console.warn(`Retry ${retries}/${maxRetries} failed:`, retryError);
            
            // Print detailed error information
            if (retryError instanceof Error) {
              console.warn('Error message:', retryError.message);
              
              // Log the first part of HTML responses for debugging
              if (retryError.message.includes('<!DOCTYPE')) {
                const htmlStart = retryError.message.substring(0, 200);
                console.warn('HTML error detected in response:', htmlStart);
                
                // Check for specific error signatures
                if (retryError.message.includes('401') || 
                    retryError.message.includes('unauthorized') || 
                    retryError.message.includes('authentication')) {
                  console.error('AUTHENTICATION ERROR: Check your Pinecone API key');
                }
              }
            }
            
            if (retries < maxRetries) {
              // Exponential backoff: 1s, 2s, 4s, etc.
              const delay = Math.pow(2, retries) * 1000;
              console.log(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        if (!success) {
          throw new Error(`Failed to upsert batch after ${maxRetries} retries`);
        }
      } catch (batchError) {
        console.error(`Error upserting batch ${Math.floor(i/batchSize) + 1}:`, batchError);
        
        // Try upserting one by one as a fallback with additional retry logic
        console.log("Trying to upsert vectors one by one...");
        for (const vector of batch) {
          try {
            let individualRetries = 0;
            const maxIndividualRetries = 2;
            
            while (individualRetries < maxIndividualRetries) {
              try {
                await index.upsert([vector]);
                break; // Success, exit retry loop
              } catch (singleRetryError) {
                individualRetries++;
                console.warn(`Individual vector retry ${individualRetries}/${maxIndividualRetries} failed:`, singleRetryError);
                
                if (individualRetries >= maxIndividualRetries) {
                  console.error(`Failed to upsert vector ${vector.id} after ${maxIndividualRetries} retries`);
                } else {
                  // Wait before retry
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }
            }
          } catch (singleError) {
            console.error(`Failed to upsert vector ${vector.id}:`, singleError);
          }
        }
      }
      
      // Add a slightly longer delay between batches to avoid rate limits
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log(`Completed upserting vectors to Pinecone`);
    return true;
  } catch (error) {
    console.error('Error in upsertVectors:', error);
    
    // Provide more detailed error information
    if (error instanceof Error) {
      if (error.message.includes('<!DOCTYPE')) {
        console.error('Received HTML response instead of JSON. This typically indicates:');
        console.error('1. Authentication failure (check your API key)');
        console.error('2. Network proxy interference');
        console.error('3. Service endpoint issues');
        
        // Extract status code if present in HTML
        const statusMatch = error.message.match(/<title>(\d+)[^<]*<\/title>/);
        if (statusMatch && statusMatch[1]) {
          console.error(`Status code found in HTML: ${statusMatch[1]}`);
        }
      }
    }
    
    throw new Error(`Failed to upsert vectors: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Rest of the functions remain the same...

export async function queryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return [];
  }

  try {
    const results = await index.query({
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    
    return results.matches;
  } catch (error) {
    console.error('Error querying vectors:', error);
    return []; // Return empty array instead of throwing
  }
}

export async function deleteDocumentVectors(documentId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        documentId: { $eq: documentId }
      }
    });
    console.log(`Successfully deleted vectors for document ${documentId}`);
  } catch (error) {
    console.error('Error deleting vectors:', error);
    throw new Error('Failed to delete vectors');
  }
}

export async function deleteChatbotVectors(chatbotId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    console.log(`Successfully deleted all vectors for chatbot ${chatbotId}`);
  } catch (error) {
    console.error('Error deleting chatbot vectors:', error);
    throw new Error('Failed to delete chatbot vectors');
  }
}// src/lib/pinecone/direct-api.ts
/**
 * This file implements direct fetch-based API calls to Pinecone
 * to bypass any issues with the Pinecone SDK
 */

// Use node-fetch for compatibility
import fetch from 'node-fetch';

interface PineconeVector {
  id: string;
  values: number[];
  metadata?: Record<string, unknown>;
}

interface PineconeResponse {
  status: number;
  statusText: string;
  data?: unknown;
  error?: string;
}

// Add specific interface for query response
interface PineconeQueryResponse extends PineconeResponse {
  data?: {
    matches?: Array<{
      id: string;
      score: number;
      metadata: Record<string, unknown>;
    }>;
  };
}

/**
 * Make a direct API call to Pinecone with detailed logging
 */
async function callPineconeAPI(
  endpoint: string,
  method: 'GET' | 'POST' | 'DELETE' = 'GET',
  body?: unknown
): Promise<PineconeResponse> {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is missing');
    return {
      status: 401,
      statusText: 'Unauthorized',
      error: 'API key is missing'
    };
  }
  
  const url = `https://api.pinecone.io/v1/indexes/${indexName}${endpoint}`;
  
  console.log(`Making ${method} request to Pinecone: ${url}`);
  
  try {
    // Make the API call with fetch
    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': apiKey
      },
      body: body ? JSON.stringify(body) : undefined
    });
    
    console.log(`Pinecone API response status: ${response.status} ${response.statusText}`);
    
    // Handle non-JSON responses
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      return {
        status: response.status,
        statusText: response.statusText,
        data
      };
    } else {
      // Handle HTML or other non-JSON responses
      const text = await response.text();
      console.error('Received non-JSON response from Pinecone:');
      console.error(`Status: ${response.status} ${response.statusText}`);
      console.error(`Content-Type: ${contentType}`);
      console.error(`Response (first 200 chars): ${text.substring(0, 200)}`);
      
      if (text.includes('<!DOCTYPE')) {
        // Parse out any error message from HTML
        const titleMatch = text.match(/<title>([^<]+)<\/title>/);
        const messageMatch = text.match(/<p>([^<]+)<\/p>/);
        
        const errorTitle = titleMatch ? titleMatch[1] : 'Unknown error';
        const errorMessage = messageMatch ? messageMatch[1] : text.substring(0, 100);
        
        return {
          status: response.status,
          statusText: response.statusText,
          error: `HTML response: ${errorTitle} - ${errorMessage}`
        };
      }
      
      return {
        status: response.status,
        statusText: response.statusText,
        error: `Non-JSON response: ${text.substring(0, 100)}`
      };
    }
  } catch (error) {
    console.error('Error making Pinecone API call:', error);
    return {
      status: 500,
      statusText: 'Internal Error',
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * Upsert vectors directly to Pinecone
 */
export async function directUpsertVectors(vectors: PineconeVector[]): Promise<boolean> {
  try {
    // Split vectors into smaller batches
    const batchSize = 20;
    let allSuccessful = true;
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      const result = await callPineconeAPI('/vectors/upsert', 'POST', {
        vectors: batch
      });
      
      if (result.status >= 400 || result.error) {
        console.error(`Error upserting batch: ${result.error || result.statusText}`);
        allSuccessful = false;
        
        // Try single vector upserts as fallback
        console.log('Attempting individual vector upserts as fallback...');
        
        for (const vector of batch) {
          const singleResult = await callPineconeAPI('/vectors/upsert', 'POST', {
            vectors: [vector]
          });
          
          if (singleResult.status >= 400 || singleResult.error) {
            console.error(`Failed to upsert vector ${vector.id}: ${singleResult.error || singleResult.statusText}`);
          } else {
            console.log(`Successfully upserted vector ${vector.id}`);
          }
        }
      } else {
        console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
      }
      
      // Add a delay between batches
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    return allSuccessful;
  } catch (error) {
    console.error('Error in directUpsertVectors:', error);
    return false;
  }
}

/**
 * Query vectors directly from Pinecone
 */
export async function directQueryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  try {
    // Query vectors directly from Pinecone
    const result = await callPineconeAPI('/query', 'POST', {
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    }) as PineconeQueryResponse;
    
    if (result.status >= 400 || result.error) {
      console.error(`Error querying vectors: ${result.error || result.statusText}`);
      return [];
    }
    
    // Now TypeScript knows that result.data?.matches exists
    return result.data?.matches || [];
  } catch (error) {
    console.error('Error in directQueryVectors:', error);
    return [];
  }
}

/**
 * Delete vectors for a specific document directly from Pinecone
 */
export async function directDeleteDocumentVectors(documentId: string): Promise<boolean> {
  try {
    const result = await callPineconeAPI('/vectors/delete', 'POST', {
      filter: {
        documentId: { $eq: documentId }
      }
    });
    
    if (result.status >= 400 || result.error) {
      console.error(`Error deleting document vectors: ${result.error || result.statusText}`);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in directDeleteDocumentVectors:', error);
    return false;
  }
}

/**
 * Check Pinecone API connectivity and report detailed status
 */
export async function checkPineconeStatus(): Promise<{
  isConnected: boolean;
  details: string;
  stats?: unknown;
}> {
  try {
    const result = await callPineconeAPI('/describe_index_stats');
    
    if (result.status >= 400 || result.error) {
      return {
        isConnected: false,
        details: result.error || `API error: ${result.status} ${result.statusText}`
      };
    }
    
    return {
      isConnected: true,
      details: 'Successfully connected to Pinecone',
      stats: result.data
    };
  } catch (error) {
    return {
      isConnected: false,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}// src/lib/pinecone/client.ts
import { Pinecone } from '@pinecone-database/pinecone';

// More robust way to check environment variables
const getPineconeConfig = () => {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is not defined in environment variables');
  }
  
  console.log("Pinecone Configuration:");
  console.log(`- API Key exists: ${!!apiKey}`);
  console.log(`- Index Name: ${indexName}`);
  
  return { apiKey, indexName };
};

// Create client with proper error handling
let pineconeClient: Pinecone | null = null;
let indexClient: ReturnType<Pinecone['index']> | null = null;

try {
  const { apiKey, indexName } = getPineconeConfig();
  
  if (apiKey) {
    pineconeClient = new Pinecone({
      apiKey,
    });
    
    // Get the index for our embeddings
    indexClient = pineconeClient.index(indexName);
    console.log("Pinecone client initialized successfully");
  } else {
    console.error("Failed to initialize Pinecone client: Missing API key");
  }
} catch (error) {
  console.error("Error initializing Pinecone client:", error);
}

export const pinecone = pineconeClient;
export const index = indexClient;// src/lib/StyledComponentsRegistry.tsx
'use client';

import { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { ServerStyleSheet, StyleSheetManager } from 'styled-components';

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  // Only create stylesheet once with lazy initial state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== 'undefined') return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}// src/lib/openai/embeddings.ts
import openai from './client';

/**
 * Generate embeddings for a text using OpenAI's embedding model
 * @param text The text to generate embeddings for
 * @returns An array of floating point numbers representing the embedding
 */
export async function generateEmbedding(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
      encoding_format: "float",
    });

    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embedding:', error);
    throw new Error('Failed to generate embedding');
  }
}

/**
 * Generate embeddings for multiple texts in a batch
 * @param texts Array of texts to generate embeddings for
 * @returns Array of embedding arrays
 */
export async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: texts,
      encoding_format: "float",
    });

    return response.data.map(item => item.embedding);
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw new Error('Failed to generate embeddings');
  }
}// src/lib/openai/client.ts
import { OpenAI } from 'openai';

// Initialize the OpenAI client with API key from environment variables
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default openai;