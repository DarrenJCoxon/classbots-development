// src/types/student.types.ts - Add this new file
import { Room, Chatbot } from './database.types';

export interface StudentRoom extends Room {
  joined_at: string;
  chatbots: Chatbot[];
}// src/types/knowledge-base.types.ts
export type DocumentType = 'pdf' | 'docx' | 'txt' | 'webpage'; // MODIFIED: Added 'webpage'

export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error' | 'fetched'; // MODIFIED: Added 'fetched' for URLs

export type ChunkStatus = 'pending' | 'embedded' | 'error';

export interface Document {
  document_id: string;
  chatbot_id: string;
  file_name: string; // For webpages, this might be the <title> or a truncated URL
  file_path: string; // For webpages, this will be the original URL
  file_type: DocumentType;
  file_size: number; // For webpages, this could be the size of the extracted text
  status: DocumentStatus;
  error_message?: string;
  created_at: string;
  updated_at: string;
}

export interface DocumentChunk {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
  created_at: string;
}

export interface DocumentUploadResponse {
  document: Document;
  uploadUrl?: string; // This might not be relevant for URLs
}

export interface ProcessingStats {
  totalChunks: number;
  processedChunks: number;
  errorChunks: number;
}// src/types/pdf-parse.d.ts
declare module 'pdf-parse';
declare module 'pdf-parse/lib/pdf-parse.js';
declare module 'mammoth';// src/types/database.types.ts

// Base common fields for all tables
export interface BaseTable {
  created_at: string;
  updated_at?: string;
}

// User roles enum
export type UserRole = 'teacher' | 'student' | 'school_admin';

// Concern status enum/type
export type ConcernStatus = 'pending' | 'reviewing' | 'resolved' | 'false_positive';

// Knowledge Base Types
export type DocumentType = 'pdf' | 'docx' | 'txt' | 'webpage'; // MODIFIED: Added 'webpage'
export type DocumentStatus = 'uploaded' | 'processing' | 'completed' | 'error' | 'fetched'; // MODIFIED: Added 'fetched'
export type ChunkStatus = 'pending' | 'embedded' | 'error';

// Bot Type Enum
export type BotTypeEnum = 'learning' | 'assessment';

// Assessment Status Enum
export type AssessmentStatusEnum = 'ai_processing' | 'ai_completed' | 'teacher_reviewed';


// --- Table Interfaces ---

export interface School extends BaseTable {
  school_id: string;
  name: string;
  magic_link_token?: string;
  token_expires_at?: string;
}

export interface Chatbot extends BaseTable {
  chatbot_id: string;
  name: string;
  description?: string;
  system_prompt: string;
  teacher_id: string;
  model?: string;
  max_tokens?: number | null;
  temperature?: number | null;
  enable_rag?: boolean;
  bot_type?: BotTypeEnum;
  assessment_criteria_text?: string | null;
  welcome_message?: string | null; // <-- ADDED (This was already correct in your original file)
}

export interface Room extends BaseTable {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id?: string | null;
  is_active: boolean;
}

export interface RoomChatbot extends BaseTable {
  room_id: string;
  chatbot_id: string;
}

export interface RoomMembership extends BaseTable {
  room_id: string;
  student_id: string;
  joined_at: string;
}

export interface ChatMessage extends BaseTable {
    message_id: string;
    room_id: string;
    user_id: string;
    role: 'user' | 'assistant' | 'system';
    content: string;
    tokens_used?: number;
    metadata?: {
        chatbotId?: string | null;
        error?: unknown;
        isAssessmentFeedback?: boolean;
        isAssessmentPlaceholder?: boolean;
        assessmentId?: string | null;
        isWelcomeMessage?: boolean; // <-- ADDED (Optional, for client-side identification) (This was already correct in your original file)
        [key: string]: unknown;
    } | null;
}

export interface Profile extends BaseTable {
  user_id: string;
  full_name?: string;
  email: string;
  role: UserRole;
  school_id?: string | null;
  country_code?: string | null; // <-- ADD THIS (This was already correct in your original file)
}

// THIS IS THE Document INTERFACE WITHIN database.types.ts
export interface Document extends BaseTable {
  document_id: string;
  chatbot_id: string;
  file_name: string;
  file_path: string;
  file_type: DocumentType; // This now correctly uses the MODIFIED DocumentType above
  file_size: number;
  status: DocumentStatus;  // This now correctly uses the MODIFIED DocumentStatus above
  error_message?: string;
}

export interface DocumentChunk extends BaseTable {
  chunk_id: string;
  document_id: string;
  chunk_index: number;
  chunk_text: string;
  token_count: number;
  status: ChunkStatus;
  embedding_id?: string;
}

export interface FlaggedMessage extends BaseTable {
  flag_id: string;
  message_id: string;
  student_id: string;
  teacher_id: string;
  room_id: string;
  concern_type: string;
  concern_level: number;
  analysis_explanation?: string;
  context_messages?: Record<string, unknown>;
  status: ConcernStatus;
  reviewed_at?: string;
  reviewer_id?: string | null;
  notes?: string;
}

export interface StudentAssessment extends BaseTable {
    assessment_id: string;
    student_id: string;
    chatbot_id: string;
    room_id: string;
    assessed_message_ids?: string[];
    teacher_id?: string | null;
    teacher_assessment_criteria_snapshot?: string | null;
    ai_feedback_student?: string | null;
    ai_assessment_details_raw?: string | null;
    ai_grade_raw?: string | null;
    ai_assessment_details_teacher?: {
        summary?: string;
        strengths?: string[];
        areas_for_improvement?: string[];
        grading_rationale?: string;
        [key: string]: unknown;
    } | null;
    teacher_override_grade?: string | null;
    teacher_override_notes?: string | null;
    status?: AssessmentStatusEnum;
    assessed_at: string;
}


// --- Database Schema Type ---
export interface Database {
  schools: School;
  profiles: Profile;
  chatbots: Chatbot;
  rooms: Room;
  room_chatbots: RoomChatbot;
  room_memberships: RoomMembership;
  chat_messages: ChatMessage;
  documents: Document; // This now refers to the locally defined Document interface
  document_chunks: DocumentChunk;
  flagged_messages: FlaggedMessage;
  student_assessments: StudentAssessment;
}

// --- API Payload Types ---
export interface CreateSchoolPayload {
  name: string;
}

export interface CreateChatbotPayload {
  name: string;
  description?: string;
  system_prompt: string;
  model?: string;
  max_tokens?: number | null;
  temperature?: number | null;
  enable_rag?: boolean;
  bot_type?: BotTypeEnum;
  assessment_criteria_text?: string | null;
  welcome_message?: string | null; // <-- ADDED (This was already correct in your original file)
}

export interface CreateRoomPayload {
  room_name: string;
  chatbot_ids: string[];
}

export interface UpdateRoomChatbotsPayload {
  chatbot_ids: string[];
}

export interface JoinRoomPayload {
  room_code: string;
}

export interface SendMessagePayload {
  content: string;
  room_id: string;
  chatbot_id: string;
}

// Payload for updating an assessment (teacher review)
export interface UpdateAssessmentPayload {
    teacher_override_grade?: string | null;
    teacher_override_notes?: string | null;
    status?: AssessmentStatusEnum;
}


// --- API Response Detail Types ---

export interface FlaggedConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

export interface StudentRoom extends Room {
  joined_at: string;
  // Chatbot here now includes welcome_message if you want student dashboard to access it
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'description' | 'bot_type' | 'welcome_message'>[];
}

export interface TeacherRoom extends Room {
   room_chatbots: {
       // Chatbot here could also include welcome_message if teacher room overview needs it
       chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type' | 'welcome_message'> | null;
   }[] | null;
}

// For single student assessment detail API
export interface DetailedAssessmentResponse extends StudentAssessment {
    student_name?: string | null;
    student_email?: string | null;
    chatbot_name?: string | null;
    assessed_conversation?: ChatMessage[];
}

// For the list of assessments for a teacher
export interface AssessmentListSummary extends Pick<
    StudentAssessment,
    'assessment_id' | 'student_id' | 'chatbot_id' | 'room_id' | 'teacher_id' |
    'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'
> {
    student_name?: string | null;
    chatbot_name?: string | null;
    room_name?: string | null;
}

// For the paginated response of assessment lists
export interface PaginatedAssessmentsResponse {
    assessments: AssessmentListSummary[];
    pagination: {
        currentPage: number;
        pageSize: number;
        totalCount: number;
        totalPages: number;
    };
}// src/types/auth.types.ts
import { User, Session } from '@supabase/supabase-js';
import { UserRole } from './database.types';

export interface AuthUser extends User {
  role?: UserRole;
  school_id?: string;
}

export interface AuthSession extends Session {
  user: AuthUser;
}

export interface SignUpData {
  email: string;
  password: string;
  fullName?: string;
  role: UserRole;
  schoolId?: string;
}

export interface SignInData {
  email: string;
  password: string;
}

export interface MagicLinkData {
  email: string;
  schoolId: string;
}// src/types/chatbot.types.ts
import type { ChatMessage as DatabaseChatMessage } from './database.types'; // Import the corrected type

// ChatMessage is now imported and used as DatabaseChatMessage or aliased if needed.
// REMOVE the old definition:
// export interface ChatMessage { ... }

export interface ChatbotConfig {
  name: string;
  description?: string;
  systemPrompt: string;
  model?: 'x-ai/grok-3-mini-beta' | 'qwen/qwen3-235b-a22b' | 'google/gemini-2.5-flash-preview' | 'openai/gpt-4.1-nano'; // MODIFIED
  maxTokens?: number;
  temperature?: number;
}

export interface ChatContext {
  chatbotId: string;
  roomId: string;
  systemPrompt: string;
  conversationHistory: DatabaseChatMessage[]; // Use the imported type
}

export interface ChatResponse {
  message: string;
  tokensUsed?: number;
  error?: string;
}// src/app/room/[roomId]/student/[studentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import StudentChatHistory from '@/components/teacher/StudentChatHistory';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    align-items: flex-start;
  }
`;

const StudentInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
  }
`;

const BackButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

// Define explicit types
interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

// Define a more specific type for the chatbots nested object
interface RoomChatbotResponse {
  chatbot_id: string;
  chatbots: {
    chatbot_id: string;
    name: string;
  } | Array<{
    chatbot_id: string;
    name: string;
  }>;
}

export default function StudentChatPage() {
  const params = useParams();
  const roomId = params?.roomId as string;
  const studentId = params?.studentId as string;
  const [studentName, setStudentName] = useState<string>('Student');
  const [chatbots, setChatbots] = useState<ChatbotOption[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const supabase = createClient();

  const fetchPageData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);
      
      // Get user info
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }
      
      // Get student info - handle missing columns gracefully
      const { data: profile } = await supabase
        .from('profiles')
        .select('*')
        .eq('user_id', studentId)
        .single();
        
      if (profile) {
        // Try different fields that might contain the name
        // The error suggests profiles.name doesn't exist, so check other fields
        if (profile.full_name) {
          setStudentName(profile.full_name);
        } else if (profile.email) {
          setStudentName(profile.email.split('@')[0]);
        } else if (profile.user_id) {
          // Last resort - use a generic label
          setStudentName('Student');
        }
      }
      
      // Get chatbots in this room
      const { data: roomChatbots } = await supabase
        .from('room_chatbots')
        .select(`
          chatbot_id,
          chatbots:chatbots!inner(
            chatbot_id,
            name
          )
        `)
        .eq('room_id', roomId);
        
      if (roomChatbots && roomChatbots.length > 0) {
        // Extract chatbot data with proper typing
        const chatbotList: ChatbotOption[] = [];
        
        // Type assertion to help TypeScript understand the structure
        const typedRoomChatbots = roomChatbots as unknown as RoomChatbotResponse[];
        
        typedRoomChatbots.forEach(item => {
          // Safely check and extract chatbot data
          if (item.chatbots) {
            if (Array.isArray(item.chatbots)) {
              item.chatbots.forEach(cb => {
                chatbotList.push({
                  chatbot_id: cb.chatbot_id,
                  name: cb.name
                });
              });
            } else {
              // It's a single object, not an array
              const cb = item.chatbots;
              chatbotList.push({
                chatbot_id: cb.chatbot_id,
                name: cb.name
              });
            }
          }
        });
        
        setChatbots(chatbotList);
      }
    } catch (err) {
      console.error('Error loading page data:', err);
      setError(err instanceof Error ? err.message : 'Failed to load page data');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, router, supabase]);

  useEffect(() => {
    fetchPageData();
  }, [fetchPageData]);

  const handleBack = () => {
    router.push(`/room/${roomId}`);
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <Card>
            <p>Loading...</p>
          </Card>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Room
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <StudentInfo>
            <h1>{studentName}</h1>
            <p>Chat History</p>
          </StudentInfo>
          <BackButton 
            variant="outline" 
            onClick={handleBack}
          >
            ← Back to Room
          </BackButton>
        </Header>
        
        <StudentChatHistory
          roomId={roomId}
          studentId={studentId}
          studentName={studentName}
          chatbots={chatbots}
        />
      </Container>
    </PageWrapper>
  );
}// src/app/room/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Alert, Button } from '@/styles/StyledComponents';
import StudentList from '@/components/teacher/StudentList';
import type { Chatbot } from '@/types/database.types';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md} 0;
  }
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    gap: ${({ theme }) => theme.spacing.md};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1.5rem;
      text-align: center;
    }
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1.125rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1rem;
      text-align: center;
    }
  }
  
  .room-code {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-top: ${({ theme }) => theme.spacing.xs};
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      text-align: center;
    }
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    justify-content: center;
  }
`;

const ChatbotGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  margin-top: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  cursor: pointer;
  
  &:hover {
    transform: translateY(-4px);
    box-shadow: ${({ theme }) => theme.shadows.lg};
  }
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.5rem;
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    min-height: 3rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }
  
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
    display: inline-block;
  }
  
  .chat-button {
    width: 100%;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: 44px;
    }
  }
`;

const EmptyState = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.lg};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: {
    chatbots: Chatbot;
  }[] | null;
}

export default function RoomPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  
  const params = useParams();
  const roomId = params?.roomId as string;
  const router = useRouter();
  const supabase = createClient();

  const fetchRoomData = useCallback(async () => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Get user role
      const { data: profile } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (!profile) throw new Error('User profile not found');
      setUserRole(profile.role);

      // First, ensure we have access to this room
      let hasAccess = false;
      if (profile.role === 'teacher') {
        // For teachers, check if they own the room
        const { data: teacherRoom } = await supabase
          .from('rooms')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('teacher_id', user.id)
          .single();
        
        hasAccess = !!teacherRoom;
      } else if (profile.role === 'student') {
        // For students, check if they're a member of the room
        const { data: membership } = await supabase
          .from('room_memberships')
          .select('room_id')
          .eq('room_id', roomId)
          .eq('student_id', user.id)
          .single();
        
        hasAccess = !!membership;
      }

      if (!hasAccess) {
        throw new Error('You do not have access to this room');
      }

      // Get basic room info
      const { data: roomData, error: roomError } = await supabase
        .from('rooms')
        .select('*')
        .eq('room_id', roomId)
        .single();

      if (roomError || !roomData) {
        throw new Error('Room not found');
      }

      // Retrieve chatbots using a two-step process to bypass potential RLS issues
      // Step 1: Get chatbot IDs for this room
      const { data: roomChatbots, error: rcError } = await supabase
        .from('room_chatbots')
        .select('chatbot_id')
        .eq('room_id', roomId);

      if (rcError) {
        console.error('Error fetching room-chatbot relations:', rcError);
        throw new Error('Failed to retrieve chatbot information');
      }

      // Step 2: Get the chatbot details
      const extractedChatbots: Chatbot[] = [];
      
      if (roomChatbots && roomChatbots.length > 0) {
        const chatbotIds = roomChatbots.map(rc => rc.chatbot_id);
        
        const { data: chatbots, error: chatbotsError } = await supabase
          .from('chatbots')
          .select('*')
          .in('chatbot_id', chatbotIds);

        if (chatbotsError) {
          console.error('Error fetching chatbots:', chatbotsError);
          throw new Error('Failed to retrieve chatbot information');
        }
        
        extractedChatbots.push(...(chatbots || []));
      }
      
      // Set the state variables
      setRoom({
        ...roomData,
        room_chatbots: []
      } as RoomQueryResult);
      setChatbots(extractedChatbots);
    } catch (err) {
      console.error('Error in fetchRoomData:', err);
      setError(err instanceof Error ? err.message : 'Failed to load room');
    } finally {
      setLoading(false);
    }
  }, [roomId, supabase]);

  useEffect(() => {
    if (roomId) {
      fetchRoomData();
    }
  }, [roomId, fetchRoomData]);

  const handleBack = () => {
    if (userRole === 'teacher') {
      router.push('/teacher-dashboard');
    } else {
      router.push('/student');
    }
  };

  const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
      'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
      'google/gemma-3-27b-it:free': 'Gemma 3 27B',
      'microsoft/phi-4-reasoning-plus:free': 'Phi 4 Reasoning',
      'qwen/qwen3-32b:free': 'Qwen3 32B',
      'qwen/qwen3-235b-a22b:free': 'Qwen3 235B'
    };
    return modelNames[model] || model;
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <Card>Loading room...</Card>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <BackButton onClick={handleBack}>
            ← Back to Dashboard
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!room) {
    return null;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>
              {chatbots.length === 0 ? 'No chatbots available' : 
               chatbots.length === 1 ? '1 chatbot available' :
               `${chatbots.length} chatbots available`}
            </p>
            <div className="room-code">Room Code: {room.room_code}</div>
          </RoomInfo>
          <BackButton onClick={handleBack}>
            ← Back
          </BackButton>
        </Header>

        {chatbots.length === 0 ? (
          <EmptyState>
            <h3>No Chatbots Available</h3>
            <p>This room doesn&apos;t have any chatbots assigned yet.</p>
            {userRole === 'teacher' && (
              <p>Go back to the dashboard to assign chatbots to this room.</p>
            )}
          </EmptyState>
        ) : (
          <ChatbotGrid>
            {chatbots.map((chatbot) => (
              <Link 
                key={chatbot.chatbot_id} 
                href={`/chat/${roomId}?chatbot=${chatbot.chatbot_id}`}
                style={{ textDecoration: 'none' }}
              >
                <ChatbotCard>
                  <h3>{chatbot.name}</h3>
                  <p>{chatbot.description || 'No description'}</p>
                  
                  <div className="model-info">
                    {getModelDisplayName(chatbot.model)}
                  </div>
                  
                  <Button 
                    className="chat-button"
                    as="div"  // Prevent double link
                  >
                    Start Chat
                  </Button>
                </ChatbotCard>
              </Link>
            ))}
          </ChatbotGrid>
        )}
        
        {/* Student list section - only visible to teachers */}
        {userRole === 'teacher' && (
          <StudentList roomId={roomId} />
        )}
      </Container>
    </PageWrapper>
  );
}// src/app/magic-link/page.tsx
'use client';

import MagicLink from '@/components/auth/MagicLink';
import { Container } from '@/styles/StyledComponents';

export default function MagicLinkPage() {
  return (
    <Container>
      <MagicLink />
    </Container>
  );
}// src/app/join/page.tsx
'use client';

import { useState, useEffect, useCallback, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Input, Alert } from '@/styles/StyledComponents';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xxl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const JoinCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const Form = styled.form`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Text = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

function JoinPageContent() {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState('');
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [userRole, setUserRole] = useState<string | null>(null);
  const [isCheckingAuth, setIsCheckingAuth] = useState(true); // Added for better loading UI
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const checkAuthentication = useCallback(async () => {
    setIsCheckingAuth(true); // Start auth check
    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setIsAuthenticated(true);
          
          const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
          
          if (profile) {
            setUserRole(profile.role);
          }
        } else {
            setIsAuthenticated(false);
            setUserRole(null);
        }
    } catch (e) {
        console.error("Error during auth check on join page:", e);
        setIsAuthenticated(false); // Assume not authenticated on error
        setUserRole(null);
    } finally {
        setIsCheckingAuth(false); // End auth check
    }
  }, [supabase]);

  useEffect(() => {
    const codeFromUrl = searchParams?.get('code');
    if (codeFromUrl) {
      setRoomCode(codeFromUrl.toUpperCase());
    }
    checkAuthentication();
  }, [searchParams, checkAuthentication]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError('');

    const formattedCode = roomCode.toUpperCase();

    try {
      const { data: room, error: roomError } = await supabase
        .from('rooms')
        .select('room_id, is_active')
        .eq('room_code', formattedCode)
        .single();

      if (roomError || !room) {
        throw new Error('Room not found. Please check the code and try again.');
      }

      if (!room.is_active) {
        throw new Error('This room is currently inactive. Please contact your teacher.');
      }

      if (isAuthenticated && userRole === 'student') {
        const response = await fetch('/api/student/join-room', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ room_code: formattedCode }),
        });
        const data = await response.json();
        if (!response.ok) {
          throw new Error(data.error || 'Failed to join room. You might already be a member or the room is full.');
        }
        // Redirect to student dashboard
        console.log('[Join Page] Student joined successfully, redirecting to /student/dashboard');
        router.push('/student/dashboard'); // <<< MODIFIED LINE
        router.refresh(); // Ensure page reloads to reflect new state if needed
      } else if (!isAuthenticated) {
        console.log('[Join Page] User not authenticated, redirecting to student signup.');
        // The redirect param ensures they come back here with the code after signup/login
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
      } else if (isAuthenticated && userRole !== 'student') {
         throw new Error('Only student accounts can join rooms this way. Please log in with a student account.');
      } else {
        // This case should ideally not be hit if logic is correct (e.g. authenticated but no role yet)
        // Prompt to re-authenticate or re-check role
        setError('Authentication issue. Please try logging out and back in, or contact support if this persists.');
        console.warn('[Join Page] Unexpected auth state:', {isAuthenticated, userRole});
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred while trying to join the room.');
    } finally {
      setIsLoading(false);
    }
  };
  
  // Loading UI while checking authentication
  if (isCheckingAuth) {
    return (
        <PageWrapper><Container><JoinCard><Title>Loading...</Title></JoinCard></Container></PageWrapper>
    );
  }


  // If not authenticated, show simplified "Create Account" view
  if (!isAuthenticated) {
    return (
      <PageWrapper>
        <Container>
          <JoinCard>
            <Title>Join Your Class</Title>
            <Text>
              To join the room with code <strong>{roomCode || '...'}</strong>, you&apos;ll need a student account.
            </Text>
            <Button 
              onClick={() => router.push(`/auth?type=student&redirect=/join?code=${roomCode}`)}
              style={{ width: '100%' }}
              size="large"
            >
              Create or Log In to Student Account
            </Button>
            {roomCode && (
              <Text style={{ marginTop: '1rem', fontSize: '0.875rem' }}>
                You are trying to join room: <strong>{roomCode}</strong>
              </Text>
            )}
          </JoinCard>
        </Container>
      </PageWrapper>
    );
  }

  // If authenticated (and presumably as a student, though `handleSubmit` re-checks role)
  return (
    <PageWrapper>
      <Container>
        <JoinCard>
          <Title>Join Your Class</Title>
          <Text>Enter the room code your teacher provided, or confirm the code from the link.</Text>
          
          {error && <Alert variant="error">{error}</Alert>}
          
          <Form onSubmit={handleSubmit}>
            <RoomCodeInput
              type="text"
              value={roomCode}
              onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
              placeholder="ROOM CODE"
              maxLength={6}
              required
            />
            <Button type="submit" disabled={isLoading} style={{ width: '100%' }} size="large">
              {isLoading ? 'Joining...' : 'Join Class'}
            </Button>
          </Form>
        </JoinCard>
      </Container>
    </PageWrapper>
  );
}

export default function JoinPage() {
  return (
    <Suspense fallback={<LoadingFallback>Loading join page...</LoadingFallback>}>
      <JoinPageContent />
    </Suspense>
  );
}// src/app/chat/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter, useSearchParams } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Alert } from '@/styles/StyledComponents';
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.75rem;
  }

  p {
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const BackButton = styled.button`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundCard};
  color: ${({ theme }) => theme.colors.text};
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  cursor: pointer;
  transition: all ${({ theme }) => theme.transitions.fast};

  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 50vh;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface RoomQueryResult {
  room_id: string;
  room_name: string;
  room_code: string;
  teacher_id: string;
  school_id: string | null;
  is_active: boolean;
  created_at: string;
  updated_at?: string;
  room_chatbots: {
    chatbots: Chatbot; // This Chatbot type already includes welcome_message
  }[] | null;
}

export default function ChatPage() {
  const [room, setRoom] = useState<RoomQueryResult | null>(null);
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const params = useParams();
  const searchParams = useSearchParams();
  const router = useRouter();
  const supabase = createClient();

  const roomId = params?.roomId as string;
  const chatbotIdFromUrl = searchParams.get('chatbot');
  const initialFetchDoneRef = useRef(false);

  useEffect(() => {
    console.log('[ChatPage] Initializing/Params Update. Room ID:', roomId, 'Chatbot ID:', chatbotIdFromUrl);
    if (initialFetchDoneRef.current && (params?.roomId !== roomId || searchParams.get('chatbot') !== chatbotIdFromUrl)) {
        initialFetchDoneRef.current = false;
    }
  }, [roomId, chatbotIdFromUrl, params?.roomId, searchParams]);

  const fetchRoomData = useCallback(async () => {
    if (!roomId || !chatbotIdFromUrl) {
      console.warn("[ChatPage] fetchRoomData: Aborting fetch - RoomID or ChatbotID is missing.", { roomId, chatbotIdFromUrl });
      if (roomId && chatbotIdFromUrl === null) {
          setError("Chatbot ID is required in the URL (e.g., ?chatbot=...).");
      } else if (!roomId && chatbotIdFromUrl){
          setError("Room ID is missing from the URL path.");
      } else if (!roomId && !chatbotIdFromUrl) {
          setError("Both Room ID and Chatbot ID are missing from the URL.");
      }
      setLoading(false);
      return;
    }
    console.log(`[ChatPage] fetchRoomData: Attempting fetch. RoomID: ${roomId}, ChatbotID: ${chatbotIdFromUrl}`);
    setLoading(true);
    setError(null);
    // initialFetchDoneRef.current = true; // Moved to after successful fetch

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        initialFetchDoneRef.current = false;
        throw new Error('Not authenticated');
      }

      const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
      if (!profile) {
        initialFetchDoneRef.current = false;
        throw new Error('User profile not found');
      }

      const { data: roomData, error: roomError } = await supabase.from('rooms')
        .select(`
          *, 
          room_chatbots!inner(
            chatbots!inner(
              chatbot_id, 
              name, 
              description, 
              system_prompt, 
              model, 
              max_tokens, 
              temperature, 
              enable_rag, 
              bot_type, 
              assessment_criteria_text,
              welcome_message
            )
          )
        `)
        .eq('room_id', roomId)
        .eq('room_chatbots.chatbot_id', chatbotIdFromUrl)
        .single();

      if (roomError) {
        initialFetchDoneRef.current = false;
        throw new Error(roomError.message || 'Data not found. Check room/chatbot association or permissions.');
      }
      if (!roomData) {
        initialFetchDoneRef.current = false;
        throw new Error('No data returned for room/chatbot. Check IDs and permissions.');
      }

      if (profile.role === 'student') {
        const { data: membership } = await supabase.from('room_memberships').select('room_id').eq('room_id', roomId).eq('student_id', user.id).single();
        if (!membership) {
            initialFetchDoneRef.current = false;
            throw new Error('You do not have access to this room');
        }
      } else if (profile.role === 'teacher') {
        const typedRoomData = roomData as RoomQueryResult;
        if (typedRoomData.teacher_id !== user.id) {
            initialFetchDoneRef.current = false;
            throw new Error('You do not own this room');
        }
      }

      const typedRoomData = roomData as RoomQueryResult;
      setRoom(typedRoomData);
      if (typedRoomData.room_chatbots && typedRoomData.room_chatbots.length > 0 && typedRoomData.room_chatbots[0].chatbots) {
        setChatbot(typedRoomData.room_chatbots[0].chatbots);
      } else {
        initialFetchDoneRef.current = false;
        throw new Error('Chatbot details missing in fetched room data.');
      }
      initialFetchDoneRef.current = true; // Mark as done only on full success
    } catch (err) {
      initialFetchDoneRef.current = false; // Allow retry on error
      setError(err instanceof Error ? err.message : 'Failed to load chat page data');
      setChatbot(null); setRoom(null);
    } finally {
      setLoading(false);
    }
  }, [roomId, chatbotIdFromUrl, supabase]); // router removed from deps

  useEffect(() => {
    if (roomId && chatbotIdFromUrl && !initialFetchDoneRef.current) {
      fetchRoomData();
    }
  }, [roomId, chatbotIdFromUrl, fetchRoomData]);

  const handleBack = () => { if (roomId) router.push(`/room/${roomId}`); else router.push('/'); };

  if (loading && !initialFetchDoneRef.current) {
    return <PageWrapper><Container><LoadingContainer><LoadingSpinner size="large" /><p>Loading chat environment...</p></LoadingContainer></Container></PageWrapper>;
  }
  if (error) {
    return <PageWrapper><Container><Alert variant="error">{error}</Alert><BackButton onClick={handleBack} style={{ marginTop: '16px' }}>{'< Back to Room'}</BackButton></Container></PageWrapper>;
  }
  if (!room || !chatbot) {
    return <PageWrapper><Container><Alert variant="info">Chatbot or room information is unavailable. Ensure Chatbot ID is in URL.</Alert><BackButton onClick={handleBack} style={{ marginTop: '16px' }}>{'< Back to Room'}</BackButton></Container></PageWrapper>;
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p>Chatting with: <strong>{chatbot.name}</strong></p>
            {chatbot.bot_type === 'assessment' && <p style={{fontSize: '0.9em', fontStyle: 'italic', color: '#555'}}>This is an Assessment Bot.</p>}
          </RoomInfo>
          <BackButton onClick={handleBack}>
            {'< Back to Room'}
          </BackButton>
        </Header>
        <Chat roomId={roomId} chatbot={chatbot} />
      </Container>
    </PageWrapper>
  );
}// src/app/auth/callback/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url); // Added origin for constructing absolute URLs
  const code = searchParams.get('code');

  if (code) {
    const supabase = await createServerSupabaseClient();
    const { error } = await supabase.auth.exchangeCodeForSession(code);
    
    if (error) {
      console.error('Error exchanging code for session:', error);
      return NextResponse.redirect(new URL('/auth', origin)); // Use origin
    }
    
    // Get user data to determine redirect
    const { data: { user } } = await supabase.auth.getUser();
    
    if (user) {
      // Wait for profile to be created by trigger
      // This delay might still be needed if your trigger isn't instant
      await new Promise(resolve => setTimeout(resolve, 500)); 
      
      const { data: profile, error: profileError } = await supabase // Added error handling for profile fetch
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();

      if (profileError) {
        console.error(`Error fetching profile for user ${user.id} in auth callback:`, profileError.message);
        // Fallback to home or a generic error page if profile fetch fails criticaly
        return NextResponse.redirect(new URL('/', origin));
      }
      
      // Get redirect URL from query params or use role-based default
      // Important: Ensure 'redirect' param doesn't create open redirect vulnerabilities.
      // For now, we assume it's from trusted sources like our own app.
      const redirectToParam = searchParams.get('redirect');
      
      if (redirectToParam) {
        // Basic validation for redirectToParam to prevent open redirect
        // Ensure it's a relative path or a path starting with our app's origin
        if (redirectToParam.startsWith('/') || redirectToParam.startsWith(origin)) {
            try {
                 // If redirectToParam is already absolute and matches origin, or relative, new URL() works.
                // If it's absolute but different origin, new URL() will use it as base, potentially wrong.
                // Better to construct carefully.
                const finalRedirectUrl = redirectToParam.startsWith('/') 
                                        ? new URL(redirectToParam, origin) 
                                        : new URL(redirectToParam); // Assumes it's already a valid absolute URL matching origin

                // Final check to ensure it's still within our app domain if it was absolute
                if (finalRedirectUrl.origin === origin) {
                    console.log(`[Auth Callback] Redirecting to specified param: ${finalRedirectUrl.toString()}`);
                    return NextResponse.redirect(finalRedirectUrl);
                } else {
                    console.warn(`[Auth Callback] Invalid redirect param origin: ${redirectToParam}. Defaulting.`);
                }
            } catch (e) {
                console.warn(`[Auth Callback] Error parsing redirect param: ${redirectToParam}. Defaulting.`, e);
            }
        } else {
             console.warn(`[Auth Callback] Potentially unsafe redirect param: ${redirectToParam}. Defaulting.`);
        }
      }
      
      // Role-based redirect
      if (profile?.role === 'teacher') {
        console.log('[Auth Callback] Redirecting teacher to /teacher-dashboard');
        return NextResponse.redirect(new URL('/teacher-dashboard', origin));
      } else if (profile?.role === 'student') {
        console.log('[Auth Callback] Redirecting student to /student/dashboard');
        return NextResponse.redirect(new URL('/student/dashboard', origin)); // <<< MODIFIED LINE
      } else {
        console.warn(`[Auth Callback] User ${user.id} has no role or unknown role: ${profile?.role}. Redirecting to /.`);
        return NextResponse.redirect(new URL('/', origin));
      }
    } else {
        console.log('[Auth Callback] No user found after exchanging code. Redirecting to /auth.');
        return NextResponse.redirect(new URL('/auth', origin));
    }
  }

  console.log('[Auth Callback] No code found in request. Redirecting to /.');
  // Default redirect if no code or other issues
  return NextResponse.redirect(new URL('/', origin));
}// src/app/auth/page.tsx
'use client';

import { useState, Suspense } from 'react';
import styled from 'styled-components';
import { useSearchParams } from 'next/navigation';
import AuthForm from '@/components/auth/AuthForm';
import { Container } from '@/styles/StyledComponents';

const AuthPage = styled.div`
  padding: ${({ theme }) => theme.spacing.xl};
  min-height: 100vh;
  background: ${({ theme }) => theme.colors.background};
`;

const ToggleButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  margin-top: ${({ theme }) => theme.spacing.md};
  text-align: center;
  display: block;
  width: 100%;

  &:hover {
    text-decoration: underline;
  }
`;

const LoadingFallback = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textMuted};
`;

// Separate component for content that uses search params
function AuthContent() {
  const searchParams = useSearchParams();
  const urlAuthTypeParam = searchParams?.get('type'); // Get the 'type' param

  // MODIFIED: Logic to determine initial authType
  // Default to 'signup' if type includes 'signup' (e.g., 'student_signup', 'teacher_signup')
  // or if it's just 'student' (which implies student signup).
  // Otherwise, default to 'login'.
  const determineInitialAuthType = () => {
    if (urlAuthTypeParam) {
      if (urlAuthTypeParam.includes('signup') || urlAuthTypeParam === 'student') {
        return 'signup';
      }
    }
    return 'login'; // Default to login if no specific signup type is indicated
  };

  const [authType, setAuthType] = useState<'login' | 'signup'>(determineInitialAuthType());

  return (
    <>
      <AuthForm type={authType} />
      <ToggleButton onClick={() => setAuthType(authType === 'login' ? 'signup' : 'login')}>
        {authType === 'login' ? 'Need an account? Sign up' : 'Already have an account? Login'}
      </ToggleButton>
    </>
  );
}

export default function Auth() {
  return (
    <AuthPage>
      <Container>
        <Suspense fallback={<LoadingFallback>Loading...</LoadingFallback>}>
          <AuthContent />
        </Suspense>
      </Container>
    </AuthPage>
  );
}// src/app/student/assessments/[assessmentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { 
    Container, 
    Card, 
    Button, 
    Alert, 
    Badge
} from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { 
    StudentAssessment, 
    ChatMessage as DbChatMessage 
} from '@/types/database.types';

interface StudentDetailedAssessmentData extends StudentAssessment {
    chatbot_name?: string | null;
    room_name?: string | null; 
    assessed_conversation?: DbChatMessage[];
    student_reflection_text?: string | null;
}

// --- Styled Components (Keep as they were from the version where reflection was removed) ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const PageTitle = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.8rem;
`;

const MainGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr; 
  gap: ${({ theme }) => theme.spacing.xl};
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    grid-template-columns: 1fr; 
  }
`;

const ConversationContextCard = styled(Card)`
  max-height: 75vh; 
  display: flex;
  flex-direction: column;
  overflow: hidden; 
`;

const CardHeader = styled.h2`
  padding-bottom: ${({ theme }) => theme.spacing.md};
  margin: 0 0 ${({ theme }) => theme.spacing.md} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  font-size: 1.3rem;
  color: ${({ theme }) => theme.colors.text};
`;

const MessagesList = styled.div`
  flex-grow: 1;
  overflow-y: auto;
  padding-right: ${({ theme }) => theme.spacing.sm}; 
`;

const AssessmentDetailsCard = styled(Card)`
  align-self: start; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    margin-top: ${({ theme }) => theme.spacing.xl};
  }
`;

const DetailItem = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-size: 0.95rem;
  line-height: 1.6;
  strong { 
    display: block; font-weight: 600; color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.xs}; font-size: 0.85rem;
    text-transform: uppercase; letter-spacing: 0.03em;
  }
  span, p, div.content { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; }
  p { margin: 0; }
`;

const FeedbackBlock = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-top: ${({ theme }) => theme.spacing.xs};
  border-left: 4px solid ${({ theme }) => theme.colors.primary};
`;

const TeacherFeedbackBlock = styled(FeedbackBlock)`
  border-left-color: ${({ theme }) => theme.colors.green};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.lg} 0;
`;

const getStatusBadgeVariant = (status?: StudentAssessment['status']): 'success' | 'warning' | 'error' | 'default' => {
    if (status === 'teacher_reviewed') return 'success';
    if (status === 'ai_completed') return 'default';
    if (status === 'ai_processing') return 'warning';
    return 'default';
};

const getStatusText = (status: StudentAssessment['status'] | undefined): string => {
    if (status === 'ai_processing') return 'AI Processing';
    if (status === 'ai_completed') return 'AI Feedback Ready';
    if (status === 'teacher_reviewed') return 'Teacher Reviewed';
    return status ? String(status).replace(/_/g, ' ') : 'N/A';
};

const LoadingContainer = styled.div` // Added for loading state
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 300px;
  gap: ${({ theme }) => theme.spacing.md};
`;


export default function StudentAssessmentDetailPage() {
  const [assessment, setAssessment] = useState<StudentDetailedAssessmentData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const assessmentIdFromParams = params?.assessmentId as string; // Renamed for clarity

  const fetchAssessmentDetails = useCallback(async () => {
    if (!assessmentIdFromParams) { // Use renamed variable
      setError("Assessment ID is missing from URL.");
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      // MODIFIED FETCH URL
      const response = await fetch(`/api/student/assessment-detail?assessmentId=${assessmentIdFromParams}`); 
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch assessment details (status ${response.status})`);
      }
      const data: StudentDetailedAssessmentData = await response.json();
      setAssessment(data);
    } catch (err) {
      console.error("Error fetching assessment details:", err);
      setError(err instanceof Error ? err.message : "Could not load assessment details.");
      setAssessment(null);
    } finally {
      setLoading(false);
    }
  }, [assessmentIdFromParams]); // Depend on assessmentIdFromParams

  useEffect(() => {
    fetchAssessmentDetails();
  }, [fetchAssessmentDetails]);


  if (loading) {
    return (
      <PageWrapper><Container><LoadingContainer><LoadingSpinner size="large" /><p>Loading assessment details...</p></LoadingContainer></Container></PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper><Container><Alert variant="error">{error}</Alert><Button onClick={() => router.push('/student/dashboard')} style={{ marginTop: '16px' }}>Back to Dashboard</Button></Container></PageWrapper>
    );
  }

  if (!assessment) {
    return (
      <PageWrapper><Container><Alert variant="info">Assessment details not found.</Alert><Button onClick={() => router.push('/student/dashboard')} style={{ marginTop: '16px' }}>Back to Dashboard</Button></Container></PageWrapper>
    );
  }

  const { 
    chatbot_name, 
    room_name, 
    assessed_at, 
    ai_grade_raw, 
    ai_feedback_student, 
    teacher_override_grade, 
    teacher_override_notes,
    status,
    assessed_conversation,
    student_reflection_text 
  } = assessment;

  return (
    <PageWrapper>
      <Container>
        <Header>
          <PageTitle>Assessment Feedback</PageTitle>
          <Button variant="outline" onClick={() => router.push('/student/dashboard')}>
            ← Back to Dashboard
          </Button>
        </Header>

        <MainGrid>
          <ConversationContextCard>
            <CardHeader>Your Conversation</CardHeader>
            <MessagesList>
              {assessed_conversation && assessed_conversation.length > 0 ? (
                assessed_conversation.map(msg => (
                  <ChatMessageComponent
                    key={msg.message_id}
                    message={msg}
                    chatbotName={chatbot_name || 'Assessment Bot'}
                  />
                ))
              ) : (
                <p style={{textAlign: 'center', padding: '20px'}}>Conversation context is not available for this assessment.</p>
              )}
            </MessagesList>
          </ConversationContextCard>

          <AssessmentDetailsCard>
            <CardHeader>Feedback Details</CardHeader>
            <DetailItem><strong>Assessed By:</strong> <span>{chatbot_name || 'N/A'}</span></DetailItem>
            {room_name && <DetailItem><strong>Classroom:</strong> <span>{room_name}</span></DetailItem>}
            <DetailItem>
              <strong>Assessed On:</strong>
              <span>{assessed_at ? new Date(assessed_at).toLocaleString() : 'N/A'}</span>
            </DetailItem>
             <DetailItem><strong>Status:</strong> <Badge variant={getStatusBadgeVariant(status)}>{getStatusText(status)}</Badge></DetailItem>

            <Divider />
            
            <CardHeader style={{fontSize: '1.1rem', marginTop:'0', borderBottom: 'none', marginBottom: '8px'}}>AI Feedback</CardHeader>
            <DetailItem>
                <strong>AI Suggested Grade:</strong> 
                <Badge variant={ai_grade_raw?.toLowerCase().includes('error') ? 'error' : 'default'} style={{marginLeft: '8px'}}>
                    {ai_grade_raw || 'Not graded by AI'}
                </Badge>
            </DetailItem>
            <DetailItem>
                <strong>AI Feedback for You:</strong> 
                <FeedbackBlock><p>{ai_feedback_student || 'No AI feedback was provided.'}</p></FeedbackBlock>
            </DetailItem>

            {(status === 'teacher_reviewed' && (teacher_override_grade || teacher_override_notes)) && (
              <>
                <Divider />
                <CardHeader style={{fontSize: '1.1rem', marginTop:'0', borderBottom: 'none', marginBottom: '8px'}}>Teacher&apos;s Review</CardHeader>
                {teacher_override_grade && (
                    <DetailItem>
                        <strong>Teacher&apos;s Grade:</strong> 
                        <Badge variant="success" style={{marginLeft: '8px'}}>
                            {teacher_override_grade}
                        </Badge>
                    </DetailItem>
                )}
                {teacher_override_notes && (
                    <DetailItem>
                        <strong>Teacher&apos;s Notes:</strong> 
                        <TeacherFeedbackBlock><p>{teacher_override_notes}</p></TeacherFeedbackBlock>
                    </DetailItem>
                )}
              </>
            )}

            {student_reflection_text && (
                 <>
                    <Divider />
                    <CardHeader style={{fontSize: '1.1rem', borderBottom: 'none', marginBottom: '8px'}}>Your Saved Reflection</CardHeader>
                    <FeedbackBlock> 
                        <p>{student_reflection_text}</p>
                    </FeedbackBlock>
                 </>
            )}
          </AssessmentDetailsCard>
        </MainGrid>
      </Container>
    </PageWrapper>
  );
}// src/app/student/dashboard/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { useRouter } from 'next/navigation'; 
import { Container, Card, Button, Alert, Badge } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { 
    Room, 
    Chatbot, 
    StudentAssessment,
    Profile
} from '@/types/database.types';

// --- Interfaces matching API Response ---
interface JoinedRoomForDashboard extends Pick<Room, 'room_id' | 'room_name' | 'room_code'> {
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type'>[];
  joined_at: string;
}

interface AssessmentSummaryForDashboard extends Pick<StudentAssessment, 'assessment_id' | 'ai_grade_raw' | 'ai_feedback_student' | 'assessed_at' | 'status'> {
  room_id: string; // Keep room_id for potential use, even if room_name is primary display
  room_name: string | null;
  chatbot_id: string; // Keep chatbot_id for potential use
  chatbot_name: string | null;
}

interface StudentDashboardData {
  joinedRooms: JoinedRoomForDashboard[];
  recentAssessments: AssessmentSummaryForDashboard[];
  studentProfile: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null;
}

// --- Styled Components (Keep existing styles) ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const WelcomeHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  h1 {
    font-size: 2rem;
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
  }
  p {
    font-size: 1.1rem;
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const Section = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const RoomGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCard = styled(Card)`
  display: flex;
  flex-direction: column;
  justify-content: space-between; 
  h3 {
    font-size: 1.25rem;
    color: ${({ theme }) => theme.colors.primaryDark};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
  }
  .room-code {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.textMuted};
    font-family: ${({ theme }) => theme.fonts.mono};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }
  .chatbot-count {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
  }
`;

const AssessmentList = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
`;

const AssessmentListItem = styled.li`
  padding: ${({ theme }) => theme.spacing.md} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  &:last-child {
    border-bottom: none;
  }

  .assessment-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    flex-wrap: wrap; // Allow badge to wrap on small screens
    gap: ${({ theme }) => theme.spacing.sm};
  }
  .assessment-title {
    font-weight: 600;
    color: ${({ theme }) => theme.colors.text};
    font-size: 1.1rem;
  }
  .assessment-date {
    font-size: 0.8rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
  .assessment-details {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    span { margin-right: ${({ theme }) => theme.spacing.md}; }
  }
  .feedback-snippet {
    background-color: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.medium};
    font-style: italic;
    color: ${({ theme }) => theme.colors.text};
    font-size: 0.95rem;
    line-height: 1.5;
    margin-top: ${({ theme }) => theme.spacing.xs};
    margin-bottom: ${({ theme }) => theme.spacing.sm}; // Add margin before the button
  }
`;

const EmptyStateText = styled.p`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.lg} 0;
`;

const LoadingContainer = styled.div`
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 400px;
  gap: ${({ theme }) => theme.spacing.md};
`;

const getAssessmentStatusBadgeVariant = (status?: StudentAssessment['status']): 'success' | 'warning' | 'error' | 'default' => {
    if (!status) return 'default';
    if (status === 'teacher_reviewed') return 'success';
    if (status === 'ai_completed') return 'default'; 
    if (status === 'ai_processing') return 'warning'; 
    return 'default';
};
const getAssessmentStatusText = (status?: StudentAssessment['status']): string => {
    if (!status) return 'N/A';
    if (status === 'ai_processing') return 'Processing';
    if (status === 'ai_completed') return 'Feedback Ready'; // Changed for student view
    if (status === 'teacher_reviewed') return 'Teacher Reviewed';
    return (status as string).replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};


export default function StudentDashboardPage() {
  const [dashboardData, setDashboardData] = useState<StudentDashboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const fetchDashboardData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/student/dashboard-data');
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        if (response.status === 401 || response.status === 403) {
            router.push('/auth'); 
            return;
        }
        throw new Error(errorData.error || `Failed to fetch dashboard data (status ${response.status})`);
      }
      const data: StudentDashboardData = await response.json();
      setDashboardData(data);
    } catch (err) {
      console.error("Error fetching student dashboard data:", err);
      setError(err instanceof Error ? err.message : "Could not load your dashboard.");
      setDashboardData(null);
    } finally {
      setLoading(false);
    }
  }, [router]);

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return 'N/A';
    try {
      return new Date(dateString).toLocaleString(undefined, {dateStyle: 'medium', timeStyle: 'short'});
    } catch {
      return 'Invalid Date';
    }
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" />
            <p>Loading your dashboard...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
        </Container>
      </PageWrapper>
    );
  }

  if (!dashboardData || !dashboardData.studentProfile) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Could not load dashboard information. Please try again later.</Alert>
           <Button onClick={() => router.push('/join')} style={{ marginTop: '16px' }}> 
            Join a Room
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  const { studentProfile, joinedRooms, recentAssessments } = dashboardData;

  return (
    <PageWrapper>
      <Container>
        <WelcomeHeader>
          <h1>Welcome, {studentProfile.full_name || 'Student'}!</h1>
          <p>Here&apos;s an overview of your ClassBots activities.</p>
        </WelcomeHeader>

        <Section>
          <SectionTitle>My Active Rooms ({joinedRooms.length})</SectionTitle>
          {joinedRooms.length > 0 ? (
            <RoomGrid>
              {joinedRooms.map(room => (
                <RoomCard key={room.room_id}>
                  <div>
                    <h3>{room.room_name}</h3>
                    <p className="room-code">Code: {room.room_code}</p>
                    <p className="chatbot-count">
                      {room.chatbots.length} chatbot{room.chatbots.length !== 1 ? 's' : ''} available
                    </p>
                  </div>
                  <Button as={Link} href={`/room/${room.room_id}`} variant="primary" style={{width: '100%', marginTop: 'auto'}}>
                    Enter Room
                  </Button>
                </RoomCard>
              ))}
            </RoomGrid>
          ) : (
            <EmptyStateText>
              You haven&apos;t joined any active rooms yet. 
              <Link href="/join" style={{textDecoration: 'underline', marginLeft: '5px', color: 'inherit'}}>Join a room</Link> to get started!
            </EmptyStateText>
          )}
        </Section>

        <Section>
          <SectionTitle>Recent Assessment Feedback ({recentAssessments.length})</SectionTitle>
          {recentAssessments.length > 0 ? (
            <AssessmentList>
              {recentAssessments.map(asmnt => (
                <AssessmentListItem key={asmnt.assessment_id}>
                  <div className="assessment-header">
                    <span className="assessment-title">
                      Feedback from {asmnt.chatbot_name || 'Assessment Bot'}
                      {asmnt.room_name && ` (in ${asmnt.room_name})`}
                    </span>
                    <Badge variant={getAssessmentStatusBadgeVariant(asmnt.status)}>
                        {getAssessmentStatusText(asmnt.status)}
                    </Badge>
                  </div>
                  <div className="assessment-details">
                    <span>Grade: <strong>{asmnt.ai_grade_raw || 'Not Graded'}</strong></span>
                    <span className="assessment-date">Assessed: {formatDate(asmnt.assessed_at)}</span>
                  </div>
                  {asmnt.ai_feedback_student && (
                    <div className="feedback-snippet">
                      {/* Truncate long feedback for summary view */}
                      {asmnt.ai_feedback_student.length > 150 
                        ? `${asmnt.ai_feedback_student.substring(0, 150)}...`
                        : asmnt.ai_feedback_student
                      }
                    </div>
                  )}
                  {/* MODIFIED BUTTON LINK */}
                  <Button 
                      as={Link} 
                      href={`/student/assessments/${asmnt.assessment_id}`} 
                      size="small" 
                      variant="outline" // Changed to outline for better visual hierarchy
                      style={{marginTop: '10px'}}
                  >
                      View Full Feedback →
                  </Button>
                </AssessmentListItem>
              ))}
            </AssessmentList>
          ) : (
            <EmptyStateText>No recent assessment feedback found.</EmptyStateText>
          )}
        </Section>

      </Container>
    </PageWrapper>
  );
}// src/app/student/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';

const StudentLayout = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
`;

export default function StudentLayoutWrapper({
  children,
}: {
  children: React.ReactNode;
}) {
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthorized, setIsAuthorized] = useState(false);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkAccess = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        
        if (!user) {
          router.push('/join');
          return;
        }

        // Fetch user profile to check role
        const { data: profile, error } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', user.id)
          .single();

        if (error || !profile || profile.role !== 'student') {
          router.push('/');
          return;
        }

        setIsAuthorized(true);
      } catch (error) {
        console.error('Error checking access:', error);
        router.push('/join');
      } finally {
        setIsLoading(false);
      }
    };

    checkAccess();
  }, [router, supabase]);

  if (isLoading) {
    return (
      <LoadingOverlay>
        <div>Loading...</div>
      </LoadingOverlay>
    );
  }

  if (!isAuthorized) {
    return null; // Will redirect
  }

  return (
    <StudentLayout>
      <MainContent>
        <Container>
          {children}
        </Container>
      </MainContent>
      <Footer />
    </StudentLayout>
  );
}// src/app/student/page.tsx
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents'; // For basic layout if needed during redirect
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // For a brief loading display

const RedirectPageWrapper = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 80vh; // Take up most of the viewport
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
`;

const Message = styled.p`
  margin-top: ${({ theme }) => theme.spacing.lg};
  font-size: 1.1rem;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function StudentRedirectPage() {
  const router = useRouter();

  useEffect(() => {
    // Perform the redirect as soon as the component mounts
    console.log('[Student Page] Redirecting to /student/dashboard...');
    router.replace('/student/dashboard'); // Use replace to not add this page to history
  }, [router]);

  // Display a loading/redirecting message while the redirect happens
  return (
    <Container>
      <RedirectPageWrapper>
        <LoadingSpinner size="large" />
        <Message>Redirecting to your dashboard...</Message>
      </RedirectPageWrapper>
    </Container>
  );
}// src/app/teacher-dashboard/assessments/[assessmentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// createClient is not strictly needed here anymore if PATCH is via API route,
// but keeping it in case you want direct client-side Supabase calls for other things.
// import { createClient } from '@/lib/supabase/client'; 
import {
    Container, Card, Button, Alert, Badge,
    FormGroup, Label, Input, TextArea,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type {
    StudentAssessment,
    ChatMessage as DbChatMessage,
    AssessmentStatusEnum
} from '@/types/database.types';

interface DetailedAssessmentData extends StudentAssessment {
    student_name?: string | null;
    student_email?: string | null;
    chatbot_name?: string | null;
    assessed_conversation?: DbChatMessage[];
}

// ... (Styled Components: PageWrapper, Header, PageTitle, BackButton, MainGrid, etc. remain THE SAME as in content-reply-032)
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const PageTitle = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.8rem;
`;

const BackButton = styled(Button)``;

const MainGrid = styled.div`
  display: grid;
  grid-template-columns: 2fr 1fr; 
  gap: ${({ theme }) => theme.spacing.xl};
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    grid-template-columns: 1fr; 
  }
`;

const ConversationContextCard = styled(Card)`
  max-height: 75vh; 
  display: flex;
  flex-direction: column;
  overflow: hidden; 
`;

const CardHeader = styled.h2`
  padding-bottom: ${({ theme }) => theme.spacing.md};
  margin: 0 0 ${({ theme }) => theme.spacing.md} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  font-size: 1.3rem;
  color: ${({ theme }) => theme.colors.text};
`;

const MessagesList = styled.div`
  flex-grow: 1;
  overflow-y: auto;
  padding-right: ${({ theme }) => theme.spacing.sm}; 
`;

const AssessmentDetailsCard = styled(Card)`
  align-self: start; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    margin-top: ${({ theme }) => theme.spacing.xl};
  }
`;

const DetailItem = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-size: 0.9rem;
  line-height: 1.5;
  strong { 
    display: block; font-weight: 600; color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.xs}; font-size: 0.8rem;
    text-transform: uppercase; letter-spacing: 0.03em;
  }
  span, p, div.content { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; }
  p { margin: 0; }
`;

const AnalysisBlock = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  font-size: 0.875rem;
  margin-top: ${({ theme }) => theme.spacing.xs};
  ul { list-style-position: inside; padding-left: ${({ theme }) => theme.spacing.sm}; margin-top: ${({ theme }) => theme.spacing.xs}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }
`;

const TeacherReviewForm = styled.form`
  margin-top: ${({ theme }) => theme.spacing.lg};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;

// Simple Divider styled-component
const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.lg} 0;
`;


export default function AssessmentDetailPage() {
  const [assessment, setAssessment] = useState<DetailedAssessmentData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [teacherGrade, setTeacherGrade] = useState('');
  const [teacherNotes, setTeacherNotes] = useState('');
  const [currentStatus, setCurrentStatus] = useState<AssessmentStatusEnum>('ai_processing'); // Default
  const [isSubmittingReview, setIsSubmittingReview] = useState(false);
  const [reviewError, setReviewError] = useState<string | null>(null);
  const [reviewSuccess, setReviewSuccess] = useState<string | null>(null);

  const params = useParams();
  const router = useRouter();
  // const supabase = createClient(); // Not needed if PATCH is through API route
  const assessmentId = params?.assessmentId as string;

  const fetchAssessmentDetails = useCallback(async () => {
    if (!assessmentId) { /* ... */ setError("Assessment ID is missing."); setLoading(false); return; }
    setLoading(true); setError(null);
    try {
      const response = await fetch(`/api/teacher/assessments?assessmentId=${assessmentId}`);
      if (!response.ok) { /* ... error handling ... */ throw new Error('Failed to fetch assessment details'); }
      const data: DetailedAssessmentData = await response.json();
      setAssessment(data);
      setTeacherGrade(data.teacher_override_grade || data.ai_grade_raw || '');
      setTeacherNotes(data.teacher_override_notes || '');
      setCurrentStatus(data.status || 'ai_completed'); // Default to ai_completed if status is null
    } catch (err) { /* ... error handling ... */ setError(err instanceof Error ? err.message : 'Could not load details.'); }
    finally { setLoading(false); }
  }, [assessmentId]);

  useEffect(() => {
    if (assessmentId) { // Ensure assessmentId is present before fetching
        fetchAssessmentDetails();
    } else {
        setError("Assessment ID not found in URL.");
        setLoading(false);
    }
  }, [assessmentId, fetchAssessmentDetails]); // fetchAssessmentDetails is stable due to useCallback

  // ***** UPDATED handleReviewSubmit *****
  const handleReviewSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!assessment) return;

    setIsSubmittingReview(true);
    setReviewError(null);
    setReviewSuccess(null);

    const payload = {
        teacher_override_grade: teacherGrade.trim() === '' ? null : teacherGrade.trim(),
        teacher_override_notes: teacherNotes.trim() === '' ? null : teacherNotes.trim(),
        status: currentStatus,
    };

    try {
        const response = await fetch(`/api/teacher/assessments?assessmentId=${assessment.assessment_id}`, {
            method: 'PATCH',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(payload),
        });

        const responseData = await response.json();

        if (!response.ok) {
            throw new Error(responseData.error || 'Failed to save teacher review.');
        }

        setReviewSuccess("Teacher review saved successfully!");
        // Update local assessment state with the successfully saved data from the API response
        setAssessment(prev => prev ? ({ ...prev, ...responseData }) : null); 
        // Or, if you prefer to update fields directly from form state:
        // setAssessment(prev => prev ? ({
        //     ...prev,
        //     teacher_override_grade: payload.teacher_override_grade,
        //     teacher_override_notes: payload.teacher_override_notes,
        //     status: payload.status,
        //     updated_at: new Date().toISOString() // Or use updated_at from responseData
        // }) : null);

    } catch (err) {
        setReviewError(err instanceof Error ? err.message : 'An unknown error occurred.');
    } finally {
        setIsSubmittingReview(false);
    }
  };
  // ***** END OF UPDATED handleReviewSubmit *****


  if (loading) { /* ... loading UI ... */ }
  if (error) { /* ... error UI ... */ }
  if (!assessment) { /* ... no assessment UI ... */ }

  // (Make sure to destructure all fields you need from assessment)
  const student_name = assessment?.student_name;
  const student_email = assessment?.student_email;
  const chatbot_name = assessment?.chatbot_name;
  const assessed_at = assessment?.assessed_at;
  const teacher_assessment_criteria_snapshot = assessment?.teacher_assessment_criteria_snapshot;
  const ai_feedback_student = assessment?.ai_feedback_student;
  const ai_grade_raw = assessment?.ai_grade_raw;
  const ai_assessment_details_teacher = assessment?.ai_assessment_details_teacher;
  const assessed_conversation = assessment?.assessed_conversation;


  return (
    <PageWrapper>
      <Container>
        <Header>
          <PageTitle>Review Assessment: {student_name || 'Student'}</PageTitle>
          <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard/assessments')}>
            {'<'} All Assessments
          </BackButton>
        </Header>

        <MainGrid>
          <ConversationContextCard>
            {/* ... Conversation display ... */}
            <CardHeader>Assessed Conversation Snippet</CardHeader>
            <MessagesList>
              {assessed_conversation && assessed_conversation.length > 0 ? (
                assessed_conversation.map(msg => (
                  <ChatMessageComponent
                    key={msg.message_id}
                    message={msg}
                    chatbotName={chatbot_name || 'Assessment Bot'}
                  />
                ))
              ) : (
                <p>No conversation snippet available for this assessment.</p>
              )}
            </MessagesList>
          </ConversationContextCard>

          <AssessmentDetailsCard>
            <CardHeader>AI Assessment & Teacher Review</CardHeader>
            {/* ... Display of assessment details (student, bot, criteria, AI grade, AI feedback, AI analysis) ... */}
            {/* This part remains largely the same as in content-reply-032 */}
            <DetailItem><strong>Student:</strong> <span>{student_name || 'N/A'} ({student_email || 'No email'})</span></DetailItem>
            <DetailItem><strong>Assessment Bot:</strong> <span>{chatbot_name || 'N/A'}</span></DetailItem>
            <DetailItem>
              <strong>Assessed On:</strong>
              <span>
                {assessed_at ? new Date(assessed_at).toLocaleString() : 'N/A'}
              </span>
            </DetailItem>
            <DetailItem><strong>Teacher&apos;s Criteria Used:</strong> <p style={{whiteSpace: 'pre-wrap', fontStyle: 'italic', color: '#555'}}>{teacher_assessment_criteria_snapshot || 'N/A'}</p></DetailItem>
            
            <Divider />
            <CardHeader style={{fontSize: '1.1rem', marginTop:'1rem', borderBottom: 'none'}}>AI Generated Assessment</CardHeader>
            <DetailItem><strong>AI Suggested Grade:</strong> <Badge variant={ai_grade_raw?.toLowerCase().includes('error') ? 'error' : 'default'}>{ai_grade_raw || 'Not graded by AI'}</Badge></DetailItem>
            <DetailItem><strong>AI Feedback to Student:</strong> <p>{ai_feedback_student || 'No AI feedback provided.'}</p></DetailItem>
            
            {ai_assessment_details_teacher && (
              <DetailItem>
                <strong>AI Analysis for Teacher:</strong>
                <AnalysisBlock>
                  {ai_assessment_details_teacher.summary && <p><strong>Summary:</strong> {ai_assessment_details_teacher.summary}</p>}
                  {ai_assessment_details_teacher.strengths && ai_assessment_details_teacher.strengths.length > 0 && ( <> <p style={{marginTop: '8px'}}><strong>Strengths:</strong></p> <ul>{ai_assessment_details_teacher.strengths.map((s, i) => <li key={`s-${i}`}>{s}</li>)}</ul> </> )}
                  {ai_assessment_details_teacher.areas_for_improvement && ai_assessment_details_teacher.areas_for_improvement.length > 0 && ( <> <p style={{marginTop: '8px'}}><strong>Areas for Improvement:</strong></p> <ul>{ai_assessment_details_teacher.areas_for_improvement.map((a, i) => <li key={`a-${i}`}>{a}</li>)}</ul> </> )}
                  {ai_assessment_details_teacher.grading_rationale && <p style={{marginTop: '8px'}}><strong>Rationale:</strong> {ai_assessment_details_teacher.grading_rationale}</p>}
                </AnalysisBlock>
              </DetailItem>
            )}

            <TeacherReviewForm onSubmit={handleReviewSubmit}>
              <CardHeader style={{fontSize: '1.1rem', borderBottom: 'none'}}>Teacher&apos;s Review & Override</CardHeader>
              {reviewError && <Alert variant="error">{reviewError}</Alert>}
              {reviewSuccess && <Alert variant="success">{reviewSuccess}</Alert>}
              <FormGroup>
                <Label htmlFor="teacherGrade">Override Grade (optional)</Label>
                <Input type="text" id="teacherGrade" value={teacherGrade} onChange={(e) => setTeacherGrade(e.target.value)} placeholder="e.g., B+, 9/10, Meets Standard" />
              </FormGroup>
              <FormGroup>
                <Label htmlFor="teacherNotes">Teacher Notes/Feedback (optional)</Label>
                <TextArea id="teacherNotes" value={teacherNotes} onChange={(e) => setTeacherNotes(e.target.value)} rows={4} placeholder="Your observations, final feedback, or notes for records..." />
              </FormGroup>
              <FormGroup>
                <Label htmlFor="assessmentStatus">Update Status</Label>
                <StyledSelect id="assessmentStatus" value={currentStatus} onChange={(e) => setCurrentStatus(e.target.value as AssessmentStatusEnum)}>
                    {/* Keep ai_processing if you want teachers to manually move it out of this state */}
                    {/* <option value="ai_processing">AI Processing</option>  */}
                    <option value="ai_completed">AI Completed (Ready for Review)</option>
                    <option value="teacher_reviewed">Teacher Reviewed</option>
                </StyledSelect>
              </FormGroup>
              <Button type="submit" disabled={isSubmittingReview} style={{width: '100%'}}>
                {isSubmittingReview ? 'Saving Review...' : 'Save Teacher Review'}
              </Button>
            </TeacherReviewForm>
          </AssessmentDetailsCard>
        </MainGrid>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/assessments/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation'; // For linking to detail page
import {
    Container, Card, Button, Alert, Badge,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types from your database.types.ts
import type { AssessmentListSummary, PaginatedAssessmentsResponse, AssessmentStatusEnum } from '@/types/database.types';

// Styled Components for this page
const PageWrapper = styled(Container)` // Use Container as base
  padding-top: ${({ theme }) => theme.spacing.xl};
  padding-bottom: ${({ theme }) => theme.spacing.xl};
`;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;



const PageTitle = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto; /* Enable horizontal scrolling on smaller viewports */
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; /* Ensure table has a minimum width */
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    white-space: nowrap; /* Prevent text wrapping in cells initially */
  }

  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
  }

  td {
    font-size: 0.9rem;
    color: ${({ theme }) => theme.colors.text};
  }

  td.actions {
    white-space: nowrap;
    width: 1%; /* Allow this column to be just wide enough for content */
  }
  
  .truncate {
    max-width: 150px; /* Adjust as needed */
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const PaginationControls = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const EmptyStateCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
`;

// Helper to get display text for status
const getStatusText = (status?: AssessmentStatusEnum): string => {
    if (!status) return 'N/A';
    switch (status) {
        case 'ai_processing': return 'AI Processing';
        case 'ai_completed': return 'AI Completed (Ready for Review)';
        case 'teacher_reviewed': return 'Teacher Reviewed';
        default: return status;
    }
};
const getStatusBadgeVariant = (status?: AssessmentStatusEnum): 'success' | 'warning' | 'error' | 'default' => {
    if (!status) return 'default';
    switch (status) {
        case 'ai_processing': return 'default';
        case 'ai_completed': return 'warning'; // Yellow/Orange indicating action needed
        case 'teacher_reviewed': return 'success';
        default: return 'default';
    }
};


export default function AssessmentsListPage() {
  const [assessments, setAssessments] = useState<AssessmentListSummary[]>([]);
  const [pagination, setPagination] = useState({
    currentPage: 0,
    pageSize: 10,
    totalCount: 0,
    totalPages: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [statusFilter, setStatusFilter] = useState<AssessmentStatusEnum | ''>(''); // Empty string for 'all'

  const router = useRouter();

  const fetchAssessments = useCallback(async (pageToFetch: number, currentStatusFilter: AssessmentStatusEnum | '') => {
    setLoading(true);
    setError(null);
    console.log(`[AssessmentsPage] Fetching assessments. Page: ${pageToFetch}, Status: ${currentStatusFilter || 'all'}`);

    try {
      const queryParams = new URLSearchParams({
        page: pageToFetch.toString(),
        limit: pagination.pageSize.toString(),
      });
      if (currentStatusFilter) {
        queryParams.append('status', currentStatusFilter);
      }

      const response = await fetch(`/api/teacher/assessments?${queryParams.toString()}`);
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch assessments (status ${response.status})`);
      }
      const data: PaginatedAssessmentsResponse = await response.json();
      setAssessments(data.assessments || []);
      setPagination(data.pagination || { currentPage: 0, pageSize: 10, totalCount: 0, totalPages: 0 });
    } catch (err) {
      console.error("Error fetching assessments:", err);
      setError(err instanceof Error ? err.message : 'Could not load assessments.');
      setAssessments([]); // Clear on error
    } finally {
      setLoading(false);
    }
  }, [pagination.pageSize]); // pageSize can be a dependency if you allow changing it

  useEffect(() => {
    fetchAssessments(0, statusFilter); // Fetch initial page on mount or when filter changes
  }, [statusFilter, fetchAssessments]); // fetchAssessments is stable due to useCallback

  const handlePageChange = (newPage: number) => {
    if (newPage >= 0 && newPage < pagination.totalPages) {
      fetchAssessments(newPage, statusFilter);
    }
  };

  const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setStatusFilter(e.target.value as AssessmentStatusEnum | '');
    // useEffect will trigger refetch due to statusFilter change
  };

  const handleViewDetails = (assessmentId: string) => {
    router.push(`/teacher-dashboard/assessments/${assessmentId}`);
  };

  if (loading && assessments.length === 0) { // Show full page loader only on initial load
    return (
      <PageWrapper>
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner size="large" />
          <p>Loading assessments...</p>
        </Card>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <PageHeader>
        <PageTitle>Student Assessments</PageTitle>
        {/* Add a button to create new assessment type or similar if needed in future */}
      </PageHeader>

      <FilterControls>
        <label htmlFor="statusFilter">Filter by Status:</label>
        <StyledSelect id="statusFilter" value={statusFilter} onChange={handleFilterChange} disabled={loading}>
          <option value="">All Statuses</option>
          <option value="ai_processing">AI Processing</option>
          <option value="ai_completed">AI Completed (Ready for Review)</option>
          <option value="teacher_reviewed">Teacher Reviewed</option>
        </StyledSelect>
      </FilterControls>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      
      {loading && assessments.length > 0 && <Alert variant='info' style={{textAlign:'center'}}>Loading more...</Alert>} {/* Subtle loading more indicator */}


      {!loading && assessments.length === 0 && !error ? (
        <EmptyStateCard>
          <h3>No Assessments Found</h3>
          <p>There are no assessments matching your current filters, or no assessments have been processed yet.</p>
        </EmptyStateCard>
      ) : assessments.length > 0 ? (
        <Card> {/* Wrap table in a card for consistent styling */}
          <TableContainer>
            <Table>
              <thead>
                <tr>
                  <th>Student</th>
                  <th>Room</th>
                  <th>Assessment Bot</th>
                  <th>AI Grade</th>
                  <th>Teacher Grade</th>
                  <th>Status</th>
                  <th>Date Assessed</th>
                  <th className="actions">Actions</th>
                </tr>
              </thead>
              <tbody>
                {assessments.map((asmnt) => (
                  <tr key={asmnt.assessment_id}>
                    <td className="truncate" title={asmnt.student_name || undefined}>{asmnt.student_name || 'N/A'}</td>
                    <td className="truncate" title={asmnt.room_name || undefined}>{asmnt.room_name || 'N/A'}</td>
                    <td className="truncate" title={asmnt.chatbot_name || undefined}>{asmnt.chatbot_name || 'N/A'}</td>
                    <td>{asmnt.ai_grade_raw || '-'}</td>
                    <td>{asmnt.teacher_override_grade || '-'}</td>
                    <td>
                      <Badge variant={getStatusBadgeVariant(asmnt.status)}>
                        {getStatusText(asmnt.status)}
                      </Badge>
                    </td>
                    <td>{new Date(asmnt.assessed_at).toLocaleDateString()}</td>
                    <td className="actions">
                      <Button size="small" onClick={() => handleViewDetails(asmnt.assessment_id)}>
                        Review Details
                      </Button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </Table>
          </TableContainer>
        </Card>
      ) : null}

      {pagination.totalPages > 1 && (
        <PaginationControls>
          <Button
            onClick={() => handlePageChange(pagination.currentPage - 1)}
            disabled={pagination.currentPage === 0 || loading}
            variant="outline"
          >
            Previous
          </Button>
          <span>
            Page {pagination.currentPage + 1} of {pagination.totalPages}
          </span>
          <Button
            onClick={() => handlePageChange(pagination.currentPage + 1)}
            disabled={pagination.currentPage >= pagination.totalPages - 1 || loading}
            variant="outline"
          >
            Next
          </Button>
        </PaginationControls>
      )}
    </PageWrapper>
  );
}// src/app/teacher-dashboard/layout.tsx
'use client';

import styled from 'styled-components';
import { useEffect, useState } from 'react';
import { useRouter } from 'next/navigation';
import { createClient as createStandardSupabaseClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';
import { Container } from '@/styles/StyledComponents';
import Footer from '@/components/layout/Footer';
import TeacherNav from '@/components/teacher/TeacherNav';

const DashboardLayoutContainer = styled.div`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  background: ${({ theme }) => theme.colors.background};
`;

const MainContent = styled.main`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.xl} 0; 
`;

const LoadingOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: ${({ theme }) => theme.colors.background};
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.textLight};
  z-index: 1000;
`;

type AuthStatus = 'loading' | 'authorized' | 'unauthorized';

export default function TeacherDashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  const [authStatus, setAuthStatus] = useState<AuthStatus>('loading');
  const router = useRouter();
  const supabase = createStandardSupabaseClient();

  useEffect(() => {
    console.log('[TDL] useEffect for auth check triggered.');

    const checkAuth = async (sessionUser: User | null) => {
      if (sessionUser) {
        console.log('[TDL] User found. Fetching profile for user_id:', sessionUser.id);
        try {
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', sessionUser.id)
            .single();

          if (profileError) {
            console.error('[TDL] Profile fetch error:', profileError.message, 'Redirecting to /auth.');
            setAuthStatus('unauthorized');
            router.push('/auth');
          } else if (profile && profile.role === 'teacher') {
            console.log('[TDL] User is teacher. Authorized.');
            setAuthStatus('authorized');
          } else {
            console.log('[TDL] User is not teacher or profile missing. Unauthorized. Redirecting to /.');
            setAuthStatus('unauthorized');
            router.push('/');
          }
        } catch (e) {
          console.error('[TDL] Exception during profile fetch:', e, 'Redirecting to /auth.');
          setAuthStatus('unauthorized');
          router.push('/auth');
        }
      } else {
        console.log('[TDL] No user in session. Unauthorized. Redirecting to /auth.');
        setAuthStatus('unauthorized');
        router.push('/auth');
      }
    };

    // Initial check
    supabase.auth.getSession().then(({ data: { session } }) => {
        console.log('[TDL] Initial getSession result:', session);
        // Only process if onAuthStateChange hasn't already set a definitive state
        if (authStatus === 'loading') { // Check current authStatus
            checkAuth(session?.user || null);
        }
    });
    
    const { data: authListener } = supabase.auth.onAuthStateChange(
      (event, session) => {
        console.log(`[TDL] onAuthStateChange event: ${event}`, session);
        // Re-check auth whenever the state changes
        // This will also handle the INITIAL_SESSION event which is often the first one on load
        checkAuth(session?.user || null);
      }
    );

    return () => {
      console.log('[TDL] Unsubscribing from onAuthStateChange.');
      authListener.subscription?.unsubscribe();
    };
  }, [router, supabase, authStatus]); // Added authStatus to deps to re-evaluate if it changes to loading by another means

  console.log('[TDL] Render. AuthStatus:', authStatus);

  if (authStatus === 'loading') {
    return (
      <LoadingOverlay>
        <div>Loading Teacher Dashboard (Auth)...</div>
      </LoadingOverlay>
    );
  }

  if (authStatus === 'unauthorized') {
    console.log('[TDL] Rendering null because unauthorized (redirect initiated).');
    return null; 
  }

  // authStatus === 'authorized'
  console.log('[TDL] Rendering dashboard content.');
  return (
    <DashboardLayoutContainer>
      <Container>
        <TeacherNav />
        <MainContent>
            {children}
        </MainContent>
      </Container>
      <Footer />
    </DashboardLayoutContainer>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/edit/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useParams, useRouter } from 'next/navigation';
import styled from 'styled-components';
import {
    Container, Card, Button, FormGroup, Label, Input, TextArea, Alert,
    Select as StyledSelect
} from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Chatbot, Document as KnowledgeDocument, BotTypeEnum as BotType, CreateChatbotPayload } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
  min-height: 100vh;
`;

const HeaderControls = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const BackButton = styled(Button)`
  margin-right: ${({ theme }) => theme.spacing.lg};
`;

const MainTitle = styled.h1`
    font-size: 1.8rem;
    color: ${({ theme }) => theme.colors.text};
`;

const CheckboxGroup = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  input[type="checkbox"] {
    width: 1.15em;
    height: 1.15em;
    cursor: pointer;
  }
`;

const Divider = styled.hr`
  border: none;
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  margin: ${({ theme }) => theme.spacing.xl} 0;
`;

const SectionTitle = styled.h2`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 1.5rem;
`;

const LoadingCard = styled(Card)`
    text-align: center;
    padding: ${({ theme }) => theme.spacing.xl};
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: ${({ theme }) => theme.spacing.md};
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const AssessmentCriteriaSection = styled(FormGroup)`
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
`;

const RubricInfoText = styled(HelpText)`
  font-style: italic;
  margin-top: ${({ theme }) => theme.spacing.md};
`;

const LoadingStateContainer = styled.div`
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
    padding: ${({ theme }) => theme.spacing.lg};
    color: ${({ theme }) => theme.colors.textLight};
`;

// MODIFIED: Styled component for URL input section
const UrlInputSection = styled.div`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  padding: ${({ theme }) => theme.spacing.lg};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background}; // Slightly different background
`;

const UrlInputForm = styled.form`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: flex-start; // Align items to the start for better layout with potential error messages

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
  }
`;

const UrlInput = styled(Input)`
  flex-grow: 1;
`;

const AddUrlButton = styled(Button)`
  white-space: nowrap; // Prevent button text from wrapping
  min-width: 120px; // Ensure button has a decent minimum width

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;


const initialChatbotState: Chatbot = {
    chatbot_id: '',
    name: '',
    description: '',
    system_prompt: `You are a helpful AI assistant.`,
    teacher_id: '',
    model: 'openai/gpt-4.1-nano',
    max_tokens: 1000,
    temperature: 0.7,
    enable_rag: false,
    bot_type: 'learning',
    assessment_criteria_text: null,
    welcome_message: null,
    created_at: new Date().toISOString(),
    updated_at: new Date().toISOString(),
};

export default function ConfigureChatbotPage() {
  const [chatbot, setChatbot] = useState<Chatbot>(initialChatbotState);
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [isCreateMode, setIsCreateMode] = useState(false);
  const [pageLoading, setPageLoading] = useState(true);
  const [docsLoading, setDocsLoading] = useState(false);
  const [saving, setSaving] = useState(false);
  const [formError, setFormError] = useState<string | null>(null);
  const [docsError, setDocsError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const [currentUserId, setCurrentUserId] = useState<string | null>(null);

  // MODIFIED: Added states for URL input
  const [webpageUrl, setWebpageUrl] = useState('');
  const [isAddingUrl, setIsAddingUrl] = useState(false);
  const [urlError, setUrlError] = useState<string | null>(null);


  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotIdFromParams = params?.chatbotId as string;

  const fetchChatbotData = useCallback(async (id: string, teacherId: string) => {
    setFormError(null);
    try {
      const { data, error } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', id)
        .eq('teacher_id', teacherId)
        .single();

      if (error) throw error;
      if (!data) throw new Error('Chatbot not found or you do not have permission.');

      const fetchedData = data as Chatbot;
      if (!fetchedData.bot_type) {
        fetchedData.bot_type = 'learning';
      }
      fetchedData.welcome_message = fetchedData.welcome_message || null;
      setChatbot(fetchedData);

    } catch (err) {
      setFormError(err instanceof Error ? err.message : 'Failed to load chatbot data.');
      setChatbot(initialChatbotState);
    } finally {
      setPageLoading(false);
    }
  }, [supabase]);

  useEffect(() => {
    const initializePage = async () => {
        setPageLoading(true);
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
            router.push('/auth');
            return;
        }
        setCurrentUserId(user.id);

        if (chatbotIdFromParams === 'new') {
            setIsCreateMode(true);
            setChatbot({ ...initialChatbotState, teacher_id: user.id });
            setDocuments([]);
            setPageLoading(false);
        } else {
            setIsCreateMode(false);
            await fetchChatbotData(chatbotIdFromParams, user.id);
        }
    };
    if (chatbotIdFromParams) {
        initializePage();
    }
  }, [chatbotIdFromParams, router, supabase, fetchChatbotData]);

  const fetchDocumentsData = useCallback(async (currentChatbotId: string) => {
    if (!currentChatbotId) return;
    setDocsLoading(true);
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/documents?chatbotId=${currentChatbotId}`);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
        throw new Error(errorData.error || `Failed to fetch documents (status ${response.status})`);
      }
      const dataResult: KnowledgeDocument[] = await response.json();
      setDocuments(dataResult);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not load documents.');
    } finally {
      setDocsLoading(false);
    }
  }, []);

  useEffect(() => {
    if (!isCreateMode && chatbot.chatbot_id && chatbot.bot_type === 'learning' && chatbot.enable_rag) {
        fetchDocumentsData(chatbot.chatbot_id);
    } else if (!isCreateMode && chatbot.chatbot_id && (chatbot.bot_type !== 'learning' || !chatbot.enable_rag)) {
        setDocuments([]);
    }
  }, [chatbot.chatbot_id, chatbot.bot_type, chatbot.enable_rag, isCreateMode, fetchDocumentsData]);


  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!currentUserId) {
        setFormError("User session expired. Please refresh.");
        return;
    }

    setSaving(true);
    setFormError(null);
    setSuccessMessage(null);

    const currentBotType = chatbot.bot_type || 'learning';

    const supabaseUpdatePayload: Partial<Omit<Chatbot, 'chatbot_id' | 'created_at' | 'updated_at' | 'teacher_id'>> & { teacher_id?: string } = {
        name: chatbot.name,
        description: chatbot.description || undefined,
        system_prompt: chatbot.system_prompt,
        model: chatbot.model,
        max_tokens: (chatbot.max_tokens === undefined || chatbot.max_tokens === null || String(chatbot.max_tokens).trim() === ``) ? null : Number(chatbot.max_tokens),
        temperature: (chatbot.temperature === undefined || chatbot.temperature === null || String(chatbot.temperature).trim() === ``) ? null : Number(chatbot.temperature),
        enable_rag: currentBotType === 'learning' ? (chatbot.enable_rag || false) : false,
        bot_type: currentBotType,
        assessment_criteria_text: currentBotType === 'assessment' ? (chatbot.assessment_criteria_text || null) : null,
        welcome_message: chatbot.welcome_message || null,
    };
    if (supabaseUpdatePayload.description === undefined) delete supabaseUpdatePayload.description;

    try {
        if (isCreateMode) {
            const apiCreatePayload: CreateChatbotPayload = {
                name: chatbot.name,
                system_prompt: chatbot.system_prompt,
                description: chatbot.description || undefined,
                model: chatbot.model || 'qwen/qwen3-235b-a22b',
                max_tokens: supabaseUpdatePayload.max_tokens,
                temperature: supabaseUpdatePayload.temperature,
                enable_rag: supabaseUpdatePayload.enable_rag,
                bot_type: supabaseUpdatePayload.bot_type,
                assessment_criteria_text: supabaseUpdatePayload.assessment_criteria_text,
                welcome_message: supabaseUpdatePayload.welcome_message,
            };

            const response = await fetch('/api/teacher/chatbots', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(apiCreatePayload),
            });
            const responseData = await response.json();
            if (!response.ok) throw new Error(responseData.error || 'Failed to create chatbot');

            setSuccessMessage('Chatbot created successfully! You can now configure its knowledge base if RAG is enabled.');
            const newBotData = responseData as Chatbot;
            setChatbot(newBotData);
            setIsCreateMode(false);
            router.replace(`/teacher-dashboard/chatbots/${newBotData.chatbot_id}/edit`, { scroll: false });

        } else {
            const updateDataForSupabase = { ...supabaseUpdatePayload };
            delete updateDataForSupabase.teacher_id;

            const { error: updateError } = await supabase
                .from('chatbots')
                .update({ ...updateDataForSupabase, updated_at: new Date().toISOString() })
                .eq('chatbot_id', chatbot.chatbot_id)
                .eq('teacher_id', currentUserId);

            if (updateError) throw updateError;
            setSuccessMessage('Chatbot updated successfully!');
        }
    } catch (err) {
        setFormError(err instanceof Error ? err.message : (isCreateMode ? 'Failed to create chatbot.' : 'Failed to update chatbot.'));
    } finally {
        setSaving(false);
    }
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    let processedValue: string | number | boolean | undefined | null | BotType = value;

    if (name === "max_tokens" || name === "temperature") {
        processedValue = value === `` ? null : Number(value);
    } else if (name === "bot_type") {
        processedValue = value as BotType;
    } else if (name === "enable_rag") {
        return;
    }
    else if ((name === "welcome_message" || name === "assessment_criteria_text") && value.trim() === "") {
        processedValue = null;
    }

    setChatbot(prev => ({ ...prev, [name]: processedValue } as Chatbot));
  };

  const handleCheckboxChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, checked } = e.target;
    setChatbot(prev => ({ ...prev, [name]: checked } as Chatbot));
  };

  const handleProcessDocument = async (documentId: string) => {
    if (isCreateMode || !chatbot.chatbot_id) return;
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/chatbots/${chatbot.chatbot_id}/vectorize`, {
        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ documentId }),
      });
      if (!response.ok) { const data = await response.json().catch(() => ({})); throw new Error(data.error || 'Failed to start document processing'); }
      setDocuments(prevDocs => prevDocs.map(doc => doc.document_id === documentId ? { ...doc, status: 'processing' } : doc));
      setViewingDocumentId(documentId);
      setSuccessMessage('Document processing started. You can monitor its status below.');
    } catch (err) { setDocsError(err instanceof Error ? err.message : 'Could not process document.'); }
  };

  const handleDeleteDocument = async (documentId: string) => {
    if (isCreateMode || !chatbot.chatbot_id) return;
    setDocsError(null);
    try {
      const response = await fetch(`/api/teacher/documents?documentId=${documentId}`, { method: 'DELETE' });
      if (!response.ok) { const data = await response.json().catch(() => ({})); throw new Error(data.error || 'Failed to delete document'); }
      setDocuments(prevDocs => prevDocs.filter(doc => doc.document_id !== documentId));
      if (viewingDocumentId === documentId) { setViewingDocumentId(null); }
      setSuccessMessage('Document deleted successfully.');
    } catch (err) { setDocsError(err instanceof Error ? err.message : 'Could not delete document.'); }
  };

  const getViewingDocument = (): KnowledgeDocument | null => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  // MODIFIED: Function to handle adding a webpage URL
  const handleAddWebpage = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!webpageUrl.trim() || !chatbot.chatbot_id) {
      setUrlError('Please enter a valid URL.');
      return;
    }
    if (!/^https?:\/\//i.test(webpageUrl)) {
      setUrlError('URL must start with http:// or https://');
      return;
    }

    setIsAddingUrl(true);
    setUrlError(null);
    setSuccessMessage(null);
    setDocsError(null);

    const formData = new FormData();
    formData.append('url', webpageUrl);
    formData.append('chatbotId', chatbot.chatbot_id);

    try {
      const response = await fetch('/api/teacher/documents', { // Uses the same POST endpoint
        method: 'POST',
        body: formData, // API will detect it's a URL based on form data
      });
      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Failed to add webpage');
      }
      setSuccessMessage(data.message || 'Webpage added successfully! Refreshing list...');
      setWebpageUrl(''); // Clear input
      fetchDocumentsData(chatbot.chatbot_id); // Refresh the document list
    } catch (err) {
      setUrlError(err instanceof Error ? err.message : 'Could not add webpage.');
      console.error("Error adding webpage:", err);
    } finally {
      setIsAddingUrl(false);
    }
  };


  if (pageLoading) {
    return ( <PageWrapper><Container><LoadingCard><LoadingSpinner size="large" /><p>{`Loading configuration page...`}</p></LoadingCard></Container></PageWrapper> );
  }
  if (!isCreateMode && !chatbot.chatbot_id && !pageLoading) {
     return ( <PageWrapper><Container><Alert variant="error">{formError || `Chatbot data could not be initialized. Please go back and try again.`}</Alert></Container></PageWrapper> );
  }

  const displayBotType = chatbot.bot_type || 'learning';

  return (
    <PageWrapper>
      <Container>
        <HeaderControls>
          <MainTitle>{isCreateMode ? `Create New Chatbot` : `Edit Chatbot: ${chatbot.name}`}</MainTitle>
          <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard/chatbots')}>
            {`<`} Back to Chatbots
          </BackButton>
        </HeaderControls>

        <Card>
          {formError && <Alert variant="error" style={{ marginBottom: '16px'}}>{formError}</Alert>}
          {successMessage && <Alert variant="success" style={{ marginBottom: '16px'}}>{successMessage}</Alert>}

          <form onSubmit={handleSubmit}>
            {/* ... (chatbot configuration form fields: name, description, bot_type, etc.) ... */}
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input id="name" name="name" value={chatbot.name || ``} onChange={handleChange} required />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input id="description" name="description" value={chatbot.description || ``} onChange={handleChange} />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="bot_type">Bot Type</Label>
              <StyledSelect id="bot_type" name="bot_type" value={displayBotType} onChange={handleChange}>
                <option value="learning">Learning Bot</option>
                <option value="assessment">Assessment Bot</option>
              </StyledSelect>
              <HelpText>{`'Learning' bots are for general interaction. 'Assessment' bots can evaluate student responses based on criteria you define.`}</HelpText>
            </FormGroup>
            {displayBotType === 'assessment' && (
              <AssessmentCriteriaSection>
                <Label htmlFor="assessment_criteria_text">Define Assessment Rubric / Criteria</Label>
                <TextArea id="assessment_criteria_text" name="assessment_criteria_text" value={chatbot.assessment_criteria_text || ``} onChange={handleChange} rows={5} placeholder={`Clearly describe what the AI should assess. For example:\n1. Accuracy of answers to key concepts.\n2. Clarity of student's explanations.\n3. Use of specific examples or evidence.\n4. Critical thinking demonstrated.`} required={displayBotType === 'assessment'} />
                <HelpText>This text will guide the AI in evaluating student responses. Be specific.</HelpText>
                <RubricInfoText>{`For now, provide a text-based summary here. In the future, you may be able to upload structured rubric documents after saving.`}</RubricInfoText>
              </AssessmentCriteriaSection>
            )}
            <FormGroup>
              <Label htmlFor="system_prompt">{`System Prompt (AI's Persona & Core Instructions)`}</Label>
              <TextArea id="system_prompt" name="system_prompt" value={chatbot.system_prompt || ``} onChange={handleChange} required rows={displayBotType === 'assessment' ? 3 : 5} placeholder={ displayBotType === 'assessment' ? `e.g., 'You are an assessment assistant...'` : `e.g., 'You are a friendly history tutor...'` }/>
              <HelpText>{`This defines the AI's general behavior.`}{displayBotType === 'assessment' && ` For Assessment Bots, instructions from 'Assessment Criteria' are key.`}</HelpText>
            </FormGroup>

            <FormGroup>
              <Label htmlFor="welcome_message">Welcome Message (Optional)</Label>
              <TextArea
                id="welcome_message"
                name="welcome_message"
                value={chatbot.welcome_message || ''}
                onChange={handleChange}
                rows={3}
                placeholder="e.g., Hi there! I'm here to help you with [topic]. What would you like to discuss first?"
              />
              <HelpText>
                This message will be shown to students as the first message from the chatbot when they start a new chat. Leave blank for no welcome message.
              </HelpText>
            </FormGroup>

            <FormGroup>
              <Label htmlFor="model">AI Model (for Chatting)</Label>
              <StyledSelect id="model" name="model" value={chatbot.model || 'qwen/qwen3-235b-a22b'} onChange={handleChange}>
                  <option value="openai/gpt-4.1-nano">OpenAI GPT-4.1 Nano</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B</option> 
              </StyledSelect>
              <HelpText>This model is used for general chat. Assessment evaluation will use Qwen3 235B.</HelpText>
            </FormGroup>
            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens (Chat Response Length)</Label>
              <Input id="max_tokens" name="max_tokens" type="number" value={chatbot.max_tokens === null || chatbot.max_tokens === undefined ? `` : chatbot.max_tokens} onChange={handleChange} min="100" max="8000" placeholder="e.g., 1000" />
            </FormGroup>
            <FormGroup>
              <Label htmlFor="temperature">Temperature (Chat Creativity)</Label>
              <Input id="temperature" name="temperature" type="number" value={chatbot.temperature === null || chatbot.temperature === undefined ? `` : chatbot.temperature} onChange={handleChange} min="0" max="2" step="0.1" placeholder="e.g., 0.7"/>
               <HelpText>{`0.0 = most deterministic, 2.0 = most creative. Default is 0.7.`}</HelpText>
            </FormGroup>
            {displayBotType === 'learning' && (
                <FormGroup>
                <Label htmlFor="enable_rag">Knowledge Base (RAG)</Label>
                <CheckboxGroup>
                    <input id="enable_rag" name="enable_rag" type="checkbox" checked={!!chatbot.enable_rag} onChange={handleCheckboxChange} />
                    <span>Enable RAG: Allow chatbot to use uploaded documents to answer questions.</span>
                </CheckboxGroup>
                <HelpText>If enabled, this learning bot can use documents you upload below. (Save first to enable uploads if creating a new bot).</HelpText>
                </FormGroup>
            )}
            <Button type="submit" disabled={saving || pageLoading} style={{ width: `100%`, marginTop: `16px` }}>
              {saving ? (isCreateMode ? 'Creating...' : 'Saving...') : (isCreateMode ? 'Create & Configure Chatbot' : 'Save Changes')}
            </Button>
          </form>

          {/* MODIFIED: Knowledge Base Section */}
          {!isCreateMode && displayBotType === 'learning' && chatbot.enable_rag && chatbot.chatbot_id && (
            <>
                <Divider />
                <SectionTitle>Knowledge Base Documents (for RAG)</SectionTitle>
                
                {/* URL Input Section */}
                <UrlInputSection>
                    <Label htmlFor="webpageUrl">Add Webpage by URL</Label>
                    <UrlInputForm onSubmit={handleAddWebpage}>
                        <UrlInput
                            type="url"
                            id="webpageUrl"
                            name="webpageUrl"
                            value={webpageUrl}
                            onChange={(e) => { setWebpageUrl(e.target.value); setUrlError(null); }}
                            placeholder="https://example.com/your-article-here"
                            disabled={isAddingUrl}
                        />
                        <AddUrlButton type="submit" variant="outline" disabled={isAddingUrl || !webpageUrl.trim()}>
                            {isAddingUrl ? 'Adding...' : 'Add URL'}
                        </AddUrlButton>
                    </UrlInputForm>
                    {urlError && <Alert variant="error" style={{ marginTop: '8px' }}>{urlError}</Alert>}
                    <HelpText style={{marginTop: '8px'}}>
                        The system will attempt to extract the main content from the provided URL.
                    </HelpText>
                </UrlInputSection>

                {/* Existing Document Uploader */}
                <HelpText>{`Alternatively, upload PDF, Word, or TXT files directly.`}</HelpText>
                {docsError && <Alert variant="error">{docsError}</Alert>}
                <DocumentUploader 
                    chatbotId={chatbot.chatbot_id} 
                    onUploadSuccess={() => { 
                        setSuccessMessage("Document uploaded. Refreshing list..."); 
                        fetchDocumentsData(chatbot.chatbot_id!); 
                    }} 
                />
                
                {/* Document List and Status */}
                {viewingDocumentId && getViewingDocument() && (
                    <EmbeddingStatus
                      document={{ ...getViewingDocument()!, updated_at: getViewingDocument()!.updated_at ?? new Date().toISOString() }}
                      chatbotId={chatbot.chatbot_id!}
                      onRefresh={() => { 
                          setSuccessMessage("Document status refreshed."); 
                          fetchDocumentsData(chatbot.chatbot_id!); 
                        }}
                    />
                )}
                {docsLoading ? ( <LoadingStateContainer><LoadingSpinner size="small"/><span>Loading documents...</span></LoadingStateContainer> ) : (
                    <DocumentList
                      documents={documents.map(doc => ({ ...doc, updated_at: doc.updated_at ?? new Date().toISOString() }))}
                      onProcessDocument={handleProcessDocument}
                      onDeleteDocument={handleDeleteDocument}
                      onViewStatus={setViewingDocumentId}
                    />
                )}
            </>
          )}
          {isCreateMode && displayBotType === 'learning' && (
            <HelpText style={{marginTop: '20px', textAlign: 'center', fontStyle: 'italic'}}>Save this chatbot first to enable RAG document uploads and URL additions.</HelpText>
          )}
        </Card>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/knowledge-base/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Card, Button, Alert } from '@/styles/StyledComponents';
import DocumentUploader from '@/components/teacher/DocumentUploader';
import DocumentList from '@/components/teacher/DocumentList';
import EmbeddingStatus from '@/components/teacher/EmbeddingStatus';
import type { Document as KnowledgeDocument } from '@/types/knowledge-base.types'; // Ensure path

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.xl} 0;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap; /* Allow wrapping on smaller screens */
  gap: ${({ theme }) => theme.spacing.md};
`;

const BackButton = styled(Button)`
  /* Add specific styles if BackButton needs to differ from general Button */
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
  font-size: 1.7rem; // Slightly smaller if needed
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 200px;
  text-align: center; // Center text if using p tag
`;

const Section = styled(Card)` // Use Card as base for sections
    margin-bottom: ${({ theme }) => theme.spacing.xl};
    h2 {
        margin-top: 0;
        margin-bottom: ${({ theme }) => theme.spacing.sm};
    }
    p {
        color: ${({ theme }) => theme.colors.textLight};
        font-size: 0.9rem;
        margin-bottom: ${({ theme }) => theme.spacing.lg};
    }
`;


export default function KnowledgeBasePage() {
  const [documents, setDocuments] = useState<KnowledgeDocument[]>([]);
  const [chatbotName, setChatbotName] = useState<string>('');
  const [loading, setLoading] = useState(true); // For initial page load (chatbot name + initial docs)
  const [docsLoading, setDocsLoading] = useState(false); // For subsequent document list refreshes
  const [pageError, setPageError] = useState<string | null>(null); // Renamed from error
  const [docsError, setDocsError] = useState<string | null>(null);
  const [viewingDocumentId, setViewingDocumentId] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  const fetchChatbotInfo = useCallback(async () => {
    if(!chatbotId) return;
    try {
      const { data: chatbot, error: chatbotError } = await supabase
        .from('chatbots')
        .select('name, teacher_id') // Also get teacher_id for auth check
        .eq('chatbot_id', chatbotId)
        .single();

      if (chatbotError) throw chatbotError;
      if (!chatbot) throw new Error("Chatbot not found.");

      // Authorization check: ensure current user owns this chatbot
      const { data: { user } } = await supabase.auth.getUser();
      if (!user || user.id !== chatbot.teacher_id) {
        throw new Error("You are not authorized to manage this chatbot's knowledge base.");
      }
      setChatbotName(chatbot.name);
    } catch (err) {
      console.error('Error fetching chatbot info:', err);
      setPageError(err instanceof Error ? err.message : 'Failed to fetch chatbot information');
    }
  }, [chatbotId, supabase]);

  const fetchDocuments = useCallback(async () => {
    if (!chatbotId) return;
    setDocsLoading(true);
    setDocsError(null);
    try {
      // << MODIFICATION: Use new API endpoint >>
      const response = await fetch(`/api/teacher/documents?chatbotId=${chatbotId}`);
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to fetch documents');
      }
      const data: KnowledgeDocument[] = await response.json();
      setDocuments(data);
    } catch (err) {
      console.error('Error fetching documents:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not load documents.');
    } finally {
      setDocsLoading(false);
    }
  }, [chatbotId]);

  useEffect(() => {
    const loadInitialData = async () => {
        setLoading(true);
        await fetchChatbotInfo();
        await fetchDocuments();
        setLoading(false);
    }
    if (chatbotId) {
        loadInitialData();
    } else {
        setPageError("Chatbot ID is missing from the URL.");
        setLoading(false);
    }
  }, [chatbotId, fetchChatbotInfo, fetchDocuments]);

  const handleProcessDocument = async (documentId: string) => {
    setDocsError(null);
    setSuccessMessage(null);
    try {
      const response = await fetch(`/api/teacher/chatbots/${chatbotId}/vectorize`, { // Assuming vectorize endpoint remains nested
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ documentId }),
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to start document processing');
      }
      setSuccessMessage("Document processing started.");
      setDocuments(prevDocs => 
        prevDocs.map(doc => 
          doc.document_id === documentId ? { ...doc, status: 'processing' } : doc
        )
      );
      setViewingDocumentId(documentId);
    } catch (err) {
      console.error('Error processing document:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not process document.');
    }
  };

  const handleDeleteDocument = async (documentId: string) => {
    setDocsError(null);
    setSuccessMessage(null);
    try {
      // << MODIFICATION: Use new API endpoint >>
      const response = await fetch(`/api/teacher/documents?documentId=${documentId}`, { 
          method: 'DELETE' 
      });
      if (!response.ok) {
        const data = await response.json().catch(() => ({}));
        throw new Error(data.error || 'Failed to delete document');
      }
      setSuccessMessage("Document deleted successfully.");
      setDocuments(prevDocs => prevDocs.filter(doc => doc.document_id !== documentId));
      if (viewingDocumentId === documentId) {
        setViewingDocumentId(null);
      }
    } catch (err) {
      console.error('Error deleting document:', err);
      setDocsError(err instanceof Error ? err.message : 'Could not delete document.');
    }
  };

  const getViewingDocument = (): KnowledgeDocument | null => {
    if (!viewingDocumentId) return null;
    return documents.find(doc => doc.document_id === viewingDocumentId) || null;
  };

  if (loading) {
    return (
        <PageWrapper>
            <Container>
                <LoadingContainer><p>Loading knowledge base...</p></LoadingContainer>
            </Container>
        </PageWrapper>
    );
  }

  if (pageError) {
    return (
        <PageWrapper>
            <Container>
                <Alert variant="error" style={{marginTop: '20px'}}>{pageError}</Alert>
                <Button onClick={() => router.push('/teacher-dashboard/chatbots')} style={{marginTop: '16px'}}>
                    Back to Chatbots
                </Button>
            </Container>
        </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container>
        <Header>
          <Title>Knowledge Base: {chatbotName || "Chatbot"}</Title>
          <BackButton 
            variant="outline" 
            onClick={() => router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`)} // Link back to edit page
          >
            ← Back to Chatbot Config
          </BackButton>
        </Header>
        
        {successMessage && <Alert variant="success" style={{marginBottom: '16px'}}>{successMessage}</Alert>}
        {docsError && <Alert variant="error" style={{marginBottom: '16px'}}>{docsError}</Alert>}
        
        <Section>
          <h2>Add Documents</h2>
          <p>Upload PDF, Word, or TXT files. These will be processed and made available for your chatbot to use when RAG is enabled.</p>
          <DocumentUploader 
            chatbotId={chatbotId} 
            onUploadSuccess={() => {
                setSuccessMessage("Document uploaded! Refreshing list...");
                fetchDocuments();
            }}
          />
        </Section>
        
        <Section>
            <h2>Uploaded Documents</h2>
            {getViewingDocument() && (
              <EmbeddingStatus 
                document={getViewingDocument()!} 
                chatbotId={chatbotId}
                onRefresh={() => {
                    setSuccessMessage("Document status refreshed.");
                    fetchDocuments();
                }}
              />
            )}
            
            {docsLoading && documents.length === 0 ? ( // Show loading only if no docs are displayed yet
              <LoadingContainer><p>Loading documents...</p></LoadingContainer>
            ) : (
              <DocumentList 
                documents={documents}
                onProcessDocument={handleProcessDocument}
                onDeleteDocument={handleDeleteDocument}
                onViewStatus={setViewingDocumentId}
              />
            )}
        </Section>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/[chatbotId]/test-chat/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Container, Alert, Button as StyledButton } from '@/styles/StyledComponents'; // Renamed Button to avoid conflict
import Chat from '@/components/shared/Chat';
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: calc(100vh - 120px); // Adjust based on your header/footer height
  display: flex;
  flex-direction: column;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const ChatbotInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.75rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
    margin: 0;
  }
`;

const BackButton = styled(StyledButton)`
  // specific styles if needed
`;


export default function TestChatPage() {
  const [chatbot, setChatbot] = useState<Chatbot | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const supabase = createClient();
  const chatbotId = params?.chatbotId as string;

  // Define a consistent "dummy" room ID for teacher test chats for this chatbot
  // This allows message history to be segmented per chatbot test.
  const testRoomId = `teacher_test_room_for_${chatbotId}`;

  const fetchChatbotData = useCallback(async () => {
    if (!chatbotId) {
      setError("Chatbot ID is missing.");
      setLoading(false);
      return;
    }
    console.log(`[TestChatPage] Fetching chatbot data for ID: ${chatbotId}`);
    setLoading(true);
    setError(null);
    try {
      const { data: { user }, error: authError } = await supabase.auth.getUser();
      if (authError || !user) {
        throw new Error('Not authenticated. Please log in.');
      }

      // Fetch the specific chatbot details, ensuring the teacher owns it
      const { data: chatbotData, error: chatbotError } = await supabase
        .from('chatbots')
        .select('*')
        .eq('chatbot_id', chatbotId)
        .eq('teacher_id', user.id) // Important: Ensure teacher owns this chatbot
        .single();

      if (chatbotError) {
        console.error('[TestChatPage] Error fetching chatbot:', chatbotError);
        throw new Error(chatbotError.message || 'Failed to fetch chatbot details.');
      }
      if (!chatbotData) {
        throw new Error('Chatbot not found or you do not have permission to access it.');
      }
      console.log('[TestChatPage] Chatbot data fetched:', chatbotData);
      setChatbot(chatbotData);
    } catch (err) {
      console.error('[TestChatPage] CATCH Error:', err);
      setError(err instanceof Error ? err.message : 'Failed to load chatbot for testing.');
    } finally {
      setLoading(false);
    }
  }, [chatbotId, supabase]);

  useEffect(() => {
    fetchChatbotData();
  }, [fetchChatbotData]);

  const handleBack = () => {
    router.push('/teacher-dashboard/chatbots'); // Go back to the chatbots list
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container style={{ textAlign: 'center', paddingTop: '50px' }}>
          <LoadingSpinner size="large" />
          <p style={{ marginTop: '16px' }}>Loading chatbot for testing...</p>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  if (!chatbot) {
    // This case should ideally be caught by the error state if fetch fails
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Chatbot not available for testing.</Alert>
           <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Container>
      </PageWrapper>
    );
  }

  return (
    <PageWrapper>
      <Container style={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
        <Header>
          <ChatbotInfo>
            <h1>Test: {chatbot.name}</h1>
            <p>You are interacting with your chatbot for testing purposes.</p>
          </ChatbotInfo>
          <BackButton variant="outline" onClick={handleBack}>
            ← Back to Chatbots List
          </BackButton>
        </Header>
        
        {/* 
          The Chat component needs a roomId. We'll use our dummy testRoomId.
          The Chat component also expects a full Chatbot object.
        */}
        <Chat 
          roomId={testRoomId} 
          chatbot={chatbot} 
        />
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Button, Alert, Card } from '@/styles/StyledComponents';
import ChatbotList from '@/components/teacher/ChatbotList';
import ChatbotForm from '@/components/teacher/ChatbotForm'; // For the modal
// import DeleteModal from '@/components/teacher/DeleteModal'; // We'll integrate delete later
import type { Chatbot } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  font-size: 1.8rem;
`;

export default function ChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  // const [deleteInfo, setDeleteInfo] = useState<{ id: string; name: string } | null>(null);
  const router = useRouter();

  const fetchChatbots = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/teacher/chatbots');
      if (!response.ok) {
        const errData = await response.json().catch(() => ({}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${response.status})`);
      }
      const data: Chatbot[] = await response.json();
      setChatbots(data);
    } catch (err) {
      console.error("Error fetching chatbots:", err);
      setError(err instanceof Error ? err.message : 'Could not load chatbots.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchChatbots(); // Refresh the list
  };

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbot = async (chatbotId: string, chatbotName: string) => {
    // For now, just a confirm. We will integrate DeleteModal later.
    if (window.confirm(`Are you sure you want to delete chatbot "${chatbotName}"? This will also delete associated documents.`)) {
      try {
        // We'll need a DELETE API route: /api/teacher/chatbots/[chatbotId]
        // const response = await fetch(`/api/teacher/chatbots/${chatbotId}`, { method: 'DELETE' });
        // if (!response.ok) throw new Error('Failed to delete chatbot');
        alert(`DELETE /api/teacher/chatbots/${chatbotId} would be called. Feature to be fully implemented.`);
        // fetchChatbots(); // Refresh list
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to delete chatbot.');
      }
    }
  };

  return (
    <div>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={() => setShowChatbotForm(true)}>+ Create Chatbot</Button>
      </PageHeader>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

      {isLoading ? (
        <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading chatbots...</Card>
      ) : (
        <ChatbotList
          chatbots={chatbots}
          onEdit={handleEditChatbot}
          onDelete={handleDeleteChatbot}
        />
      )}

      {showChatbotForm && (
        <ChatbotForm
          onClose={() => setShowChatbotForm(false)}
          onSuccess={handleChatbotCreated}
        />
      )}

      {/* {deleteInfo && (
        <DeleteModal
          itemType="Chatbot"
          itemName={deleteInfo.name}
          onConfirm={() => {
            // actual delete logic
            setDeleteInfo(null);
          }}
          onCancel={() => setDeleteInfo(null)}
          isDeleting={false} // manage this state
        />
      )} */}
    </div>
  );
}// src/app/teacher-dashboard/chatbots/page.tsx
'use client';

import { useState, useEffect, useCallback, useMemo } from 'react';
import styled, { useTheme } from 'styled-components';
import { useRouter } from 'next/navigation';
import { Button, Alert, Card, Input, Select as StyledSelect, FormGroup, Label } from '@/styles/StyledComponents';
import ChatbotList, { type ChatbotListProps } from '@/components/teacher/ChatbotList'; // Ensure type ChatbotListProps is imported
import type { Chatbot, BotTypeEnum } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div`
  /* Add any specific wrapper styles if needed */
`;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg}; 
  flex-wrap: wrap; 
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0; 
`;

const ControlsContainer = styled(Card)`
  padding: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  background-color: ${({ theme }) => theme.colors.background}; 
`;

const FilterGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.md};
  align-items: flex-end; 
`;

const ViewToggleContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-left: auto; 
  
  @media (max-width: 768px) { 
    margin-left: 0;
    width: 100%;
    justify-content: flex-start; 
    margin-top: ${({ theme }) => theme.spacing.md};
  }
`;


export default function ManageChatbotsPage() {
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();
  const theme = useTheme(); 

  const [searchTerm, setSearchTerm] = useState('');
  const [selectedBotType, setSelectedBotType] = useState<BotTypeEnum | ''>('');
  const [selectedRagStatus, setSelectedRagStatus] = useState<'any' | 'true' | 'false'>('any');
  const [sortBy, setSortBy] = useState('created_at_desc');
  const [viewMode, setViewMode] = useState<'card' | 'list'>('card');

  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState(searchTerm);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedSearchTerm(searchTerm);
    }, 500); 

    return () => {
      clearTimeout(handler);
    };
  }, [searchTerm]);

  const fetchChatbots = useCallback(async () => {
    console.log('[ChatbotsPage] Fetching chatbots with filters:', 
        { debouncedSearchTerm, selectedBotType, selectedRagStatus, sortBy });
    setIsLoading(true);
    setError(null);
    try {
      const params = new URLSearchParams();
      if (debouncedSearchTerm) {
        params.append('searchTerm', debouncedSearchTerm);
      }
      if (selectedBotType) {
        params.append('botType', selectedBotType);
      }
      if (selectedRagStatus !== 'any') {
        params.append('ragEnabled', selectedRagStatus);
      }
      if (sortBy) {
        params.append('sortBy', sortBy);
      }

      const response = await fetch(`/api/teacher/chatbots?${params.toString()}`);
      if (!response.ok) {
        let errorMessage = `Failed to fetch chatbots (status ${response.status})`;
        try {
            const errData = await response.json();
            errorMessage = errData.error || errorMessage;
        } catch {}
        throw new Error(errorMessage);
      }
      const data = await response.json();
      if (Array.isArray(data)) {
        setChatbots(data as Chatbot[]);
      } else {
        console.warn('[ChatbotsPage] API returned non-array data for chatbots:', data);
        setChatbots([]);
      }
    } catch (err) {
      console.error('[ChatbotsPage] Error fetching chatbots:', err);
      setError(err instanceof Error ? err.message : 'Could not load your chatbots.');
      setChatbots([]);
    } finally {
      setIsLoading(false);
    }
  }, [debouncedSearchTerm, selectedBotType, selectedRagStatus, sortBy]);

  useEffect(() => {
    fetchChatbots();
  }, [fetchChatbots]);

  const handleEditChatbot = useCallback((chatbotId: string) => {
      router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  }, [router]);

  const handleDeleteChatbot = useCallback(async (chatbotId: string, chatbotName: string) => {
      if (window.confirm(`Are you sure you want to delete the chatbot "${chatbotName}"? This will also delete associated documents and knowledge base entries if RAG was used.`)) {
          setError(null);
          try {
              const response = await fetch(`/api/teacher/chatbots?chatbotId=${chatbotId}`, { method: 'DELETE' }); 
              if (!response.ok) {
                  let errorMessage = `Failed to delete chatbot (status ${response.status})`;
                  try {
                      const errData = await response.json();
                      errorMessage = errData.error || errorMessage;
                  } catch {}
                  throw new Error(errorMessage);
              }
              const result = await response.json();
              alert(result.message || `Chatbot "${chatbotName}" deleted successfully.`);
              fetchChatbots(); 
          } catch (err) {
              const errorMessage = err instanceof Error ? err.message : 'Failed to delete chatbot.';
              setError(errorMessage);
          }
      }
  }, [fetchChatbots]); 
  
  const handleCreateNewChatbot = useCallback(() => {
      router.push(`/teacher-dashboard/chatbots/new/edit`);
  }, [router]);

  const content = useMemo(() => {
    if (isLoading && chatbots.length === 0) { 
      return (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
          <LoadingSpinner /> Loading your chatbots...
        </Card>
      );
    } 
    if (!isLoading && !error && chatbots.length === 0) {
      return (
        <Card style={{ textAlign: 'center', padding: '20px' }}>
          <p>No chatbots found matching your current filters. Try adjusting them or create a new chatbot!</p>
        </Card>
      );
    }
    if (chatbots.length > 0) {
      const propsForChatbotList: ChatbotListProps = { 
        chatbots: chatbots,
        onEdit: handleEditChatbot,     
        onDelete: handleDeleteChatbot,
        viewMode: viewMode
      };
      return (
        <ChatbotList {...propsForChatbotList} /> 
      );
    }
    return null; 
  }, [isLoading, error, chatbots, handleEditChatbot, handleDeleteChatbot, viewMode]);


  return (
    <PageWrapper>
      <PageHeader>
        <Title>My Chatbots</Title>
        <Button onClick={handleCreateNewChatbot}>+ Create New Chatbot</Button>
      </PageHeader>

      <ControlsContainer $accentSide="top" $accentColor={theme.colors.blue}>
        <FilterGrid>
          <FormGroup style={{ marginBottom: 0 }}> 
            <Label htmlFor="searchTerm">Search</Label>
            <Input
              type="text"
              id="searchTerm"
              placeholder="Search by name or description..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
            />
          </FormGroup>
          <FormGroup style={{ marginBottom: 0 }}>
            <Label htmlFor="botTypeFilter">Bot Type</Label>
            <StyledSelect
              id="botTypeFilter"
              value={selectedBotType}
              onChange={(e) => setSelectedBotType(e.target.value as BotTypeEnum | '')}
            >
              <option value="">All Types</option>
              <option value="learning">Learning</option>
              <option value="assessment">Assessment</option>
            </StyledSelect>
          </FormGroup>
          <FormGroup style={{ marginBottom: 0 }}>
            <Label htmlFor="ragStatusFilter">RAG Status</Label>
            <StyledSelect
              id="ragStatusFilter"
              value={selectedRagStatus}
              onChange={(e) => setSelectedRagStatus(e.target.value as 'any' | 'true' | 'false')}
            >
              <option value="any">Any RAG Status</option>
              <option value="true">RAG Enabled</option>
              <option value="false">RAG Disabled</option>
            </StyledSelect>
          </FormGroup>
          <FormGroup style={{ marginBottom: 0 }}>
            <Label htmlFor="sortBy">Sort By</Label>
            <StyledSelect
              id="sortBy"
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value)}
            >
              <option value="created_at_desc">Newest First</option>
              <option value="created_at_asc">Oldest First</option>
              <option value="name_asc">Name (A-Z)</option>
              <option value="name_desc">Name (Z-A)</option>
              <option value="updated_at_desc">Last Modified</option>
            </StyledSelect>
          </FormGroup>
          <ViewToggleContainer>
            <Button
              variant={viewMode === 'card' ? 'primary' : 'outline'}
              onClick={() => setViewMode('card')}
              size="small"
              title="Card View"
            >
              🗂️ Card
            </Button>
            <Button
              variant={viewMode === 'list' ? 'primary' : 'outline'}
              onClick={() => setViewMode('list')}
              size="small"
              title="List View"
            >
              📄 List
            </Button>
          </ViewToggleContainer>
        </FilterGrid>
      </ControlsContainer>

      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      
      {isLoading && chatbots.length > 0 && (
        <div style={{ textAlign: 'center', padding: '10px' }}>
          <LoadingSpinner size="small" /> Updating list...
        </div>
      )}
      {content}

    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/[roomId]/students/[studentId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { Container, Card, Button, Alert, Badge } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import StudentChatHistory from '@/components/teacher/StudentChatHistory'; // To be used in a tab

import type { 
    Profile, 
    StudentAssessment, 
    FlaggedMessage, 
    Chatbot as RoomChatbotType // Type for chatbots in the room
} from '@/types/database.types';

// --- Data Structures for Page State ---
interface AssessmentSummaryForStudent extends Pick<StudentAssessment, 'assessment_id' | 'chatbot_id' | 'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'> {
  chatbot_name?: string | null;
}

interface ConcernSummaryForStudent extends Pick<FlaggedMessage, 'flag_id' | 'concern_type' | 'concern_level' | 'created_at' | 'status'> {
  message_preview?: string | null;
}

interface StudentRoomAllDetails {
  student: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null;
  assessments: AssessmentSummaryForStudent[];
  concerns: ConcernSummaryForStudent[];
  // We also need the list of chatbots available in this room for the StudentChatHistory component
  roomChatbots: Pick<RoomChatbotType, 'chatbot_id' | 'name'>[]; 
}

// --- Styled Components ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const StudentInfoBar = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.8rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1rem;
    margin: 0;
  }
`;

const TabContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const TabButton = styled.button<{ $isActive: boolean }>`
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border: none;
  background: none;
  cursor: pointer;
  font-size: 1rem;
  font-weight: 500;
  color: ${({ theme, $isActive }) => $isActive ? theme.colors.primary : theme.colors.textLight};
  border-bottom: 3px solid ${({ theme, $isActive }) => $isActive ? theme.colors.primary : 'transparent'};
  transition: all 0.2s ease;

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const TabContent = styled.div`
  padding-top: ${({ theme }) => theme.spacing.lg};
`;

const SummarySection = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const SectionTitle = styled.h3`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.3rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SummaryList = styled.ul`
  list-style: none;
  padding: 0;
  margin: 0;
`;

const SummaryListItem = styled.li`
  padding: ${({ theme }) => theme.spacing.sm} 0;
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};

  &:last-child {
    border-bottom: none;
  }

  .info {
    flex-grow: 1;
  }
  .title {
    font-weight: 500;
    color: ${({ theme }) => theme.colors.text};
    text-decoration: none;
    &:hover { text-decoration: underline; }
  }
  .date {
    font-size: 0.85rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
  .preview {
    font-size: 0.85rem;
    color: ${({ theme }) => theme.colors.textLight};
    font-style: italic;
    max-width: 300px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
  gap: ${({ theme }) => theme.spacing.md};
`;

const getStatusBadgeVariant = (status?: StudentAssessment['status'] | FlaggedMessage['status']): 'success' | 'warning' | 'error' | 'default' => {
    if (!status) return 'default';
    // Assessment Statuses
    if (status === 'teacher_reviewed') return 'success';
    if (status === 'ai_completed') return 'warning';
    if (status === 'ai_processing') return 'default';
    // Concern Statuses
    if (status === 'resolved') return 'success';
    if (status === 'false_positive') return 'default';
    if (status === 'reviewing') return 'warning';
    if (status === 'pending') return 'error';
    return 'default';
};

const getStatusText = (status?: StudentAssessment['status'] | FlaggedMessage['status']): string => {
    if (!status) return 'N/A';
    // Assessment Statuses
    if (status === 'ai_processing') return 'AI Processing';
    if (status === 'ai_completed') return 'AI Completed';
    if (status === 'teacher_reviewed') return 'Teacher Reviewed';
    // Concern Statuses (assuming they are distinct from assessment statuses)
    if (status === 'pending') return 'Pending';
    if (status === 'reviewing') return 'Reviewing';
    if (status === 'resolved') return 'Resolved';
    if (status === 'false_positive') return 'False Positive';
    return String(status).replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
};


type TabName = 'overview' | 'chats' | 'assessments' | 'concerns';

export default function StudentRoomDetailPage() {
  const [details, setDetails] = useState<StudentRoomAllDetails | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [activeTab, setActiveTab] = useState<TabName>('overview');

  const params = useParams();
  const router = useRouter();
  const roomId = params?.roomId as string;
  const studentId = params?.studentId as string;

  const fetchStudentRoomDetails = useCallback(async () => {
    if (!roomId || !studentId) {
      setError("Room ID or Student ID not found in URL.");
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      // API for student's aggregated details (profile, assessment summaries, concern summaries)
      const studentDetailsResponse = await fetch(`/api/teacher/student-room-details?roomId=${roomId}&studentId=${studentId}`);
      if (!studentDetailsResponse.ok) {
        const errorData = await studentDetailsResponse.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch student details (status ${studentDetailsResponse.status})`);
      }
      const studentData: StudentRoomAllDetails = await studentDetailsResponse.json();

      // API for room's general details (to get chatbots for StudentChatHistory)
      // We could combine this into the above API, but for now, separate for clarity
      const roomGenDetailsResponse = await fetch(`/api/teacher/room-details?roomId=${roomId}`);
       if (!roomGenDetailsResponse.ok) {
        const errorData = await roomGenDetailsResponse.json().catch(() => ({}));
        console.warn(errorData.error || `Failed to fetch room general details (status ${roomGenDetailsResponse.status})`);
        // Don't fail entirely, StudentChatHistory might handle missing chatbots gracefully
        setDetails({ ...studentData, roomChatbots: [] });
      } else {
        const roomGenData = await roomGenDetailsResponse.json();
        setDetails({
          ...studentData,
          roomChatbots: roomGenData.chatbots || [],
        });
      }

    } catch (err) {
      console.error("Error fetching student room details:", err);
      setError(err instanceof Error ? err.message : "Could not load student details.");
      setDetails(null);
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId]);

  useEffect(() => {
    fetchStudentRoomDetails();
  }, [fetchStudentRoomDetails]);

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleString();
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" /> <p>Loading student details...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.back()} style={{ marginTop: '16px' }}>
            ← Back
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  if (!details || !details.student) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Student details not found.</Alert>
          <Button onClick={() => router.back()} style={{ marginTop: '16px' }}>
            ← Back
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  const { student, assessments, concerns, roomChatbots } = details;

  return (
    <PageWrapper>
      <Container>
        <Header>
          <StudentInfoBar>
            <h1>{student.full_name || 'Student'}</h1>
            <p>{student.email || 'No email provided'}</p>
          </StudentInfoBar>
          <Button variant="outline" onClick={() => router.push(`/teacher-dashboard/rooms/${roomId}`)}>
            ← Back to Room Overview
          </Button>
        </Header>

        <TabContainer>
          <TabButton $isActive={activeTab === 'overview'} onClick={() => setActiveTab('overview')}>Overview</TabButton>
          <TabButton $isActive={activeTab === 'chats'} onClick={() => setActiveTab('chats')}>Chat History</TabButton>
          <TabButton $isActive={activeTab === 'assessments'} onClick={() => setActiveTab('assessments')}>Assessments</TabButton>
          <TabButton $isActive={activeTab === 'concerns'} onClick={() => setActiveTab('concerns')}>Concerns</TabButton>
        </TabContainer>

        <TabContent>
          {activeTab === 'overview' && (
            <div>
              <SummarySection>
                <SectionTitle>Recent Assessments ({assessments.length})</SectionTitle>
                {assessments.length > 0 ? (
                  <SummaryList>
                    {assessments.slice(0, 5).map(asmnt => ( // Show first 5
                      <SummaryListItem key={asmnt.assessment_id}>
                        <div className="info">
                           <Link href={`/teacher-dashboard/assessments/${asmnt.assessment_id}`} className="title">
                             Assessment with {asmnt.chatbot_name || 'Bot'}
                           </Link>
                          <p className="date">Date: {formatDate(asmnt.assessed_at)}</p>
                        </div>
                        <div>
                            Grade: {asmnt.teacher_override_grade || asmnt.ai_grade_raw || 'N/A'}
                            <Badge 
                                variant={getStatusBadgeVariant(asmnt.status)} 
                                style={{marginLeft: '10px'}}
                            >
                                {getStatusText(asmnt.status)}
                            </Badge>
                        </div>
                      </SummaryListItem>
                    ))}
                  </SummaryList>
                ) : <p>No assessments found for this student in this room.</p>}
                 {assessments.length > 5 && <Button variant="outline" onClick={() => setActiveTab('assessments')} style={{marginTop: '10px'}}>View All Assessments ({assessments.length})</Button>}
              </SummarySection>

              <SummarySection>
                <SectionTitle>Recent Concerns ({concerns.length})</SectionTitle>
                {concerns.length > 0 ? (
                  <SummaryList>
                    {concerns.slice(0, 5).map(cncrn => ( // Show first 5
                      <SummaryListItem key={cncrn.flag_id}>
                        <div className="info">
                          <Link href={`/teacher-dashboard/concerns/${cncrn.flag_id}`} className="title">
                            {cncrn.concern_type.replace(/_/g, ' ')} (Level {cncrn.concern_level})
                          </Link>
                          <p className="date">Date: {formatDate(cncrn.created_at)}</p>
                          {cncrn.message_preview && <p className="preview">&quot;{cncrn.message_preview}&quot;</p>}
                        </div>
                         <Badge 
                            variant={getStatusBadgeVariant(cncrn.status)}
                         >
                            {getStatusText(cncrn.status)}
                        </Badge>
                      </SummaryListItem>
                    ))}
                  </SummaryList>
                ) : <p>No concerns flagged for this student in this room.</p>}
                {concerns.length > 5 && <Button variant="outline" onClick={() => setActiveTab('concerns')} style={{marginTop: '10px'}}>View All Concerns ({concerns.length})</Button>}
              </SummarySection>
            </div>
          )}

          {activeTab === 'chats' && (
            <Card> {/* Wrap StudentChatHistory in a Card for consistent styling */}
              <StudentChatHistory
                roomId={roomId}
                studentId={studentId}
                studentName={student.full_name || 'Student'}
                chatbots={roomChatbots || []} // Pass the fetched chatbots for the room
              />
            </Card>
          )}

          {activeTab === 'assessments' && (
            <Card>
              <SectionTitle>All Assessments ({assessments.length})</SectionTitle>
              {assessments.length > 0 ? (
                <SummaryList>
                  {assessments.map(asmnt => (
                    <SummaryListItem key={asmnt.assessment_id}>
                      <div className="info">
                        <Link href={`/teacher-dashboard/assessments/${asmnt.assessment_id}`} className="title">
                            Assessment with {asmnt.chatbot_name || 'Bot'}
                        </Link>
                        <p className="date">Date: {formatDate(asmnt.assessed_at)}</p>
                      </div>
                      <div>
                        Grade: {asmnt.teacher_override_grade || asmnt.ai_grade_raw || 'N/A'}
                         <Badge 
                            variant={getStatusBadgeVariant(asmnt.status)} 
                            style={{marginLeft: '10px'}}
                         >
                            {getStatusText(asmnt.status)}
                        </Badge>
                      </div>
                    </SummaryListItem>
                  ))}
                </SummaryList>
              ) : <p>No assessments found for this student in this room.</p>}
            </Card>
          )}

          {activeTab === 'concerns' && (
            <Card>
              <SectionTitle>All Concerns ({concerns.length})</SectionTitle>
               {concerns.length > 0 ? (
                <SummaryList>
                  {concerns.map(cncrn => (
                    <SummaryListItem key={cncrn.flag_id}>
                      <div className="info">
                        <Link href={`/teacher-dashboard/concerns/${cncrn.flag_id}`} className="title">
                            {cncrn.concern_type.replace(/_/g, ' ')} (Level {cncrn.concern_level})
                        </Link>
                        <p className="date">Date: {formatDate(cncrn.created_at)}</p>
                        {cncrn.message_preview && <p className="preview">&quot;{cncrn.message_preview}&quot;</p>}
                      </div>
                      <Badge 
                        variant={getStatusBadgeVariant(cncrn.status)}
                      >
                        {getStatusText(cncrn.status)}
                      </Badge>
                    </SummaryListItem>
                  ))}
                </SummaryList>
              ) : <p>No concerns flagged for this student in this room.</p>}
            </Card>
          )}
        </TabContent>
      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/[roomId]/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
import Link from 'next/link';
import { Container, Card, Button, Alert, Badge } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { Room, Chatbot, Profile } from '@/types/database.types'; // Base types

// --- Data Structure for the Page State ---
interface StudentInRoom extends Pick<Profile, 'user_id' | 'full_name' | 'email'> {
  joined_at: string;
}

interface RoomDetailsData {
  room: Room;
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'description' | 'bot_type'>[];
  students: StudentInRoom[];
}

// --- Styled Components ---
const PageWrapper = styled.div`
  padding: ${({ theme }) => theme.spacing.lg} 0;
  min-height: 100vh;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md} 0;
  }
`;

const Header = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const RoomInfo = styled.div`
  h1 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 2rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1.5rem;
    }
  }
  
  .room-code {
    font-family: ${({ theme }) => theme.fonts.mono};
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-top: ${({ theme }) => theme.spacing.xs};
    font-size: 1.1rem;
    
    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      font-size: 1rem;
    }
  }
`;

const BackButton = styled(Button)`
  // No specific styles needed if general Button styling is sufficient
`;

const Section = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const SectionTitle = styled.h2`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

// Chatbots Section
const ChatbotGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const ChatbotCard = styled(Card)`
  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-size: 1.2rem;
  }
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.9rem;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    min-height: 40px; /* Ensure some consistent height */
  }
  .bot-type {
    font-size: 0.8rem;
    font-style: italic;
  }
`;

// Students Section
const StudentListTable = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  }
  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
  }
  
  // Styled Link for student names in table
  td a { // Target <a> rendered by <Link>
    color: ${({ theme }) => theme.colors.text};
    text-decoration: none;
    font-weight: 500;
    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      text-decoration: underline;
    }
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; // Hide table on smaller screens
  }
`;

const StudentListMobile = styled.div`
  display: none;
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block; // Show cards on smaller screens
  }
`;

const StudentCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};

  .student-name-link { // Use a class for the Link component itself
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    display: block;
    text-decoration: none;
     &:hover {
        text-decoration: underline;
     }
  }
  .student-email, .joined-at {
    font-size: 0.85rem;
    color: ${({ theme }) => theme.colors.textMuted};
    margin-bottom: ${({ theme }) => theme.spacing.xs};
  }
`;


const EmptyStateText = styled.p`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.lg} 0;
`;

const LoadingContainer = styled.div`
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 300px;
  gap: ${({ theme }) => theme.spacing.md};
`;

export default function TeacherRoomDetailPage() {
  const [roomDetails, setRoomDetails] = useState<RoomDetailsData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const params = useParams();
  const router = useRouter();
  const roomId = params?.roomId as string;

  const fetchRoomDetails = useCallback(async () => {
    if (!roomId) {
      setError("Room ID not found in URL.");
      setLoading(false);
      return;
    }
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/teacher/room-details?roomId=${roomId}`);
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch room details (status ${response.status})`);
      }
      const data: RoomDetailsData = await response.json();
      setRoomDetails(data);
    } catch (err) {
      console.error("Error fetching room details:", err);
      setError(err instanceof Error ? err.message : "Could not load room details.");
      setRoomDetails(null);
    } finally {
      setLoading(false);
    }
  }, [roomId]);

  useEffect(() => {
    fetchRoomDetails();
  }, [fetchRoomDetails]);

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return 'N/A';
    try {
      return new Date(dateString).toLocaleDateString();
    } catch {
      return 'Invalid Date';
    }
  };

  if (loading) {
    return (
      <PageWrapper>
        <Container>
          <LoadingContainer>
            <LoadingSpinner size="large" />
            <p>Loading room details...</p>
          </LoadingContainer>
        </Container>
      </PageWrapper>
    );
  }

  if (error) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.push('/teacher-dashboard/rooms')} style={{ marginTop: '16px' }}>
            Back to Rooms
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  if (!roomDetails) {
    return (
      <PageWrapper>
        <Container>
          <Alert variant="info">Room details not found.</Alert>
           <Button onClick={() => router.push('/teacher-dashboard/rooms')} style={{ marginTop: '16px' }}>
            Back to Rooms
          </Button>
        </Container>
      </PageWrapper>
    );
  }

  const { room, chatbots, students } = roomDetails;

  return (
    <PageWrapper>
      <Container>
        <Header>
          <RoomInfo>
            <h1>{room.room_name}</h1>
            <p className="room-code">Room Code: {room.room_code}</p>
          </RoomInfo>
          <BackButton 
            variant="outline"
            onClick={() => router.push('/teacher-dashboard/rooms')}
          >
            ← All Rooms
          </BackButton>
        </Header>

        <Section>
          <SectionTitle>Assigned Chatbots ({chatbots.length})</SectionTitle>
          {chatbots.length > 0 ? (
            <ChatbotGrid>
              {chatbots.map(bot => (
                <ChatbotCard key={bot.chatbot_id}>
                  <h3>{bot.name}</h3>
                  <p>{bot.description || 'No description provided.'}</p>
                  <Badge variant={bot.bot_type === 'assessment' ? 'warning' : 'default'}>
                    Type: {bot.bot_type || 'Learning'}
                  </Badge>
                </ChatbotCard>
              ))}
            </ChatbotGrid>
          ) : (
            <EmptyStateText>No chatbots are currently assigned to this room.</EmptyStateText>
          )}
        </Section>

        <Section>
          <SectionTitle>Enrolled Students ({students.length})</SectionTitle>
          {students.length > 0 ? (
            <>
              <StudentListTable>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Email</th>
                    <th>Joined On</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {students.map(student => (
                    <tr key={student.user_id}>
                      <td>
                        {/* Corrected Link usage: No <a> child */}
                        <Link href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`}>
                           {student.full_name}
                        </Link>
                      </td>
                      <td>{student.email}</td>
                      <td>{formatDate(student.joined_at)}</td>
                      <td>
                        <Button 
                          size="small" 
                          as={Link} 
                          href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`}
                          variant="outline"
                        >
                          View Details
                        </Button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </StudentListTable>

              <StudentListMobile>
                {students.map(student => (
                  <StudentCard key={`mobile-${student.user_id}`}>
                    {/* Corrected Link usage: No <a> child */}
                    <Link href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`} className="student-name-link">
                        {student.full_name}
                    </Link>
                    <p className="student-email">{student.email}</p>
                    <p className="joined-at">Joined: {formatDate(student.joined_at)}</p>
                     <Button 
                        size="small" 
                        as={Link} 
                        href={`/teacher-dashboard/rooms/${roomId}/students/${student.user_id}`}
                        variant="outline"
                        style={{marginTop: '8px', width: '100%'}}
                      >
                        View Student Details
                      </Button>
                  </StudentCard>
                ))}
              </StudentListMobile>
            </>
          ) : (
            <EmptyStateText>No students have joined this room yet.</EmptyStateText>
          )}
        </Section>

      </Container>
    </PageWrapper>
  );
}// src/app/teacher-dashboard/rooms/page.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled, { useTheme } from 'styled-components';
// No longer need useRouter if not used directly on this page for navigation
// import { useRouter } from 'next/navigation';
import { Button, Alert, Card, Container } from '@/styles/StyledComponents';
import RoomList from '@/components/teacher/RoomList';
import RoomForm from '@/components/teacher/RoomForm';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import type { Room as BaseRoom, Chatbot, TeacherRoom } from '@/types/database.types';
import LoadingSpinner from '@/components/shared/LoadingSpinner';

const PageWrapper = styled.div``;

const PageHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.md};
`;

const Title = styled.h1`
  font-size: 1.8rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

// Styled components for DeleteModal
const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 450px;
  margin: 20px;
  position: relative;
  text-align: center;
  border-top: none !important;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

interface DeleteModalProps {
  isOpen: boolean;
  itemType: 'Room';
  itemName: string;
  onConfirm: () => Promise<void>;
  onCancel: () => void;
  isDeleting: boolean;
}

function DeleteModal({ isOpen, itemType, itemName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete {itemType}</ModalTitle>
        <ModalText>
          Are you sure you want to delete the {itemType.toLowerCase()} &quot;
          <strong>{itemName}</strong>
          &quot;? This action cannot be undone and may affect associated data (e.g., student memberships, chat history).
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
             variant="danger"
             onClick={onConfirm}
             disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : `Yes, Delete ${itemType}`}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}


export default function ManageRoomsPage() {
  const [rooms, setRooms] = useState<TeacherRoom[]>([]);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null);
  const theme = useTheme();
  // const router = useRouter(); // Removed if not used

  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    type: 'Room';
    id: string | null;
    name: string;
  }>({ isOpen: false, type: 'Room', id: null, name: '' });
  const [isDeleting, setIsDeleting] = useState(false);

  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [roomsResponse, chatbotsResponse] = await Promise.all([
        fetch('/api/teacher/rooms'),
        fetch('/api/teacher/chatbots')
      ]);

      if (!roomsResponse.ok) {
        const errData = await roomsResponse.json().catch(()=>({error: `Failed to parse rooms error response (status ${roomsResponse.status})`}));
        throw new Error(errData.error || `Failed to fetch rooms (status ${roomsResponse.status})`);
      }
      if (!chatbotsResponse.ok) {
        const errData = await chatbotsResponse.json().catch(()=>({error: `Failed to parse chatbots error response (status ${chatbotsResponse.status})`}));
        throw new Error(errData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`);
      }

      const roomsData: TeacherRoom[] = await roomsResponse.json();
      const chatbotsData: Chatbot[] = await chatbotsResponse.json();

      setRooms(roomsData);
      setChatbots(chatbotsData);
    } catch (err) {
      console.error("Error fetching page data:", err);
      setError(err instanceof Error ? err.message : 'Could not load data.');
    } finally {
      setIsLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const handleRoomCreatedOrUpdated = () => {
    setShowRoomForm(false);
    setEditingRoom(null);
    fetchData();
  };

  const openDeleteModal = (room: BaseRoom) => {
    setDeleteModal({ isOpen: true, type: 'Room', id: room.room_id, name: room.room_name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, type: 'Room', id: null, name: '' });
  };

  const handleDeleteConfirm = async () => {
    if (!deleteModal.id) return;

    setIsDeleting(true);
    setError(null);

    try {
        const response = await fetch(`/api/teacher/rooms/${deleteModal.id}`, { method: 'DELETE' });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete room`);
        }

        console.log(`Room ${deleteModal.id} deleted successfully.`);
        closeDeleteModal();
        fetchData();
    } catch (error) {
        console.error(`Error deleting Room:`, error);
        setError(error instanceof Error ? error.message : `Failed to delete Room.`);
    } finally {
        setIsDeleting(false);
    }
  };

  const handleEditRoom = (room: BaseRoom) => {
    setEditingRoom(room);
  };

  const handleCloseEditRoom = () => {
    setEditingRoom(null);
  };

  const handleRoomEditSuccess = () => {
    setEditingRoom(null);
    fetchData();
  };


  return (
    <PageWrapper>
      <Container>
        <PageHeader>
          <Title>Classroom Rooms</Title>
          <Button
            onClick={() => setShowRoomForm(true)}
            disabled={chatbots.length === 0 && !isLoading}
            title={chatbots.length === 0 && !isLoading ? "Create a chatbot before creating a room" : "Create New Room"}
          >
            + Create New Room
          </Button>
        </PageHeader>

        {chatbots.length === 0 && !isLoading && !error && (
          <Alert variant='info' style={{marginBottom: '16px'}}>
              You need to create at least one chatbot before you can create a classroom room.
          </Alert>
        )}

        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        {isLoading ? (
          <Card style={{ textAlign: 'center', padding: '40px' }}>
            <LoadingSpinner /> Loading rooms...
          </Card>
        ) : error ? null : (
          <RoomList
            rooms={rooms}
            onUpdate={fetchData}
            onEditRoom={handleEditRoom}
            onDeleteRoom={openDeleteModal}
            // 👇 CORRECTED: Pass the blue (skolrCyan) color from the theme
            accentColor={theme.colors.blue}
          />
        )}
      </Container>

      {showRoomForm && (
        <RoomForm
          chatbots={chatbots}
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreatedOrUpdated}
        />
      )}

      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={handleCloseEditRoom}
          onSuccess={handleRoomEditSuccess}
        />
      )}

      <DeleteModal
        isOpen={deleteModal.isOpen}
        itemType={deleteModal.type}
        itemName={deleteModal.name}
        onConfirm={handleDeleteConfirm}
        onCancel={closeDeleteModal}
        isDeleting={isDeleting}
      />
    </PageWrapper>
  );
}// src/app/teacher-dashboard/page.tsx
'use client';

import styled from 'styled-components';
import DashboardOverview from '@/components/teacher/DashboardOverview'; // Import the new component

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 2rem;
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 1.125rem;
`;

export default function TeacherDashboardPage() {
  console.log('[TeacherDashboardPage] Rendering with DashboardOverview...');
  return (
    <div>
      <PageHeader>
        <Title>Teacher Dashboard</Title> {/* Kept general title */}
        <Subtitle>Welcome! Here&apos;s a summary of your Skolr activities.</Subtitle>
      </PageHeader>
      <DashboardOverview /> {/* Use the new overview component */}
    </div>
  );
}// src/app/teacher-dashboard/concerns/page.tsx
'use client';

import styled, { useTheme } from 'styled-components'; // Import useTheme
import ConcernsList from '@/components/teacher/ConcernsList';
import { Container } from '@/styles/StyledComponents';

const PageHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.8rem; 
`;

export default function ConcernsPage() {
  const theme = useTheme(); // Get the theme object

  return (
    <Container>
      <PageHeader>
        <Title>Student Welfare Concerns</Title>
      </PageHeader>
      {/* Pass the desired accent color to ConcernsList */}
      <ConcernsList accentColor={theme.colors.green} /> 
    </Container>
  );
}// src/app/teacher-dashboard/concerns/[flagId]/page.tsx
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import styled from 'styled-components';
import { useParams, useRouter } from 'next/navigation';
// Import necessary components and styles
import { Container, Card, Button, Alert, Badge, TextArea, Label, Select as StyledSelect } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
// Import types (ensure Profile includes full_name)
import type { FlaggedMessage, ConcernStatus, ChatMessage as DatabaseChatMessage, Profile, Room } from '@/types/database.types'; // Import necessary base types


// Interface for the data structure returned by the API GET request
// This includes the nested objects directly as returned by the join syntax used
// and the flattened fields for easier use, plus surroundingMessages
interface FlagDetailsResponse extends FlaggedMessage {
    student: Pick<Profile, 'full_name' | 'email'> | null; // Nested original
    room: Pick<Room, 'room_name'> | null; // Nested original
    message: DatabaseChatMessage | null; // Nested original
    student_name: string | null; // Flattened
    student_email: string | null; // Flattened
    room_name: string | null; // Flattened
    message_content: string | null; // Flattened
    surroundingMessages: DatabaseChatMessage[];
}


// --- Styled Components (Keep as previously defined) ---
const PageWrapper = styled.div` padding: ${({ theme }) => theme.spacing.xl} 0; min-height: 100vh; `;
const Header = styled.div` display: flex; justify-content: space-between; align-items: center; margin-bottom: ${({ theme }) => theme.spacing.xl}; flex-wrap: wrap; gap: ${({ theme }) => theme.spacing.md}; `;
const Title = styled.h1` color: ${({ theme }) => theme.colors.text}; margin: 0; font-size: 1.8rem; @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) { font-size: 1.5rem; } `;
const BackButton = styled(Button)``;
const Grid = styled.div` display: grid; grid-template-columns: 3fr 2fr; gap: ${({ theme }) => theme.spacing.xl}; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { grid-template-columns: 1fr; } `;
const ConversationContext = styled(Card)` max-height: 75vh; display: flex; flex-direction: column; overflow: hidden; `;
const ContextHeader = styled.h3` padding: 0 0 ${({ theme }) => theme.spacing.md} 0; margin: 0 0 ${({ theme }) => theme.spacing.md} 0; border-bottom: 1px solid ${({ theme }) => theme.colors.border}; font-size: 1.2rem; `;
const MessagesList = styled.div` flex: 1; overflow-y: auto; padding-right: ${({ theme }) => theme.spacing.sm}; margin-right: -${({ theme }) => theme.spacing.sm}; &::-webkit-scrollbar { width: 6px; } &::-webkit-scrollbar-thumb { background-color: ${({ theme }) => theme.colors.borderDark}; border-radius: 3px; } &::-webkit-scrollbar-track { background: transparent; } `;
const FlaggedMessageHighlight = styled.div` border: 3px solid ${({ theme }) => theme.colors.red}; border-radius: ${({ theme }) => theme.borderRadius.large}; margin: ${({ theme }) => theme.spacing.md} 0; background-color: rgba(248, 127, 127, 0.08); padding: 2px; & > div { margin-bottom: 0; } `;
const ConcernDetailsCard = styled(Card)` align-self: start; position: sticky; top: 80px; @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) { position: static; margin-top: ${({ theme }) => theme.spacing.xl}; } `;
const DetailsHeader = styled.h3` margin-bottom: ${({ theme }) => theme.spacing.lg}; font-size: 1.2rem; `;
const DetailItem = styled.div` margin-bottom: ${({ theme }) => theme.spacing.md}; font-size: 0.9rem; line-height: 1.5; strong { display: block; margin-bottom: ${({ theme }) => theme.spacing.xs}; color: ${({ theme }) => theme.colors.textLight}; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 0.05em; } span, p { color: ${({ theme }) => theme.colors.text}; word-wrap: break-word; } p { margin-bottom: 0; } `;
const AnalysisText = styled.p` font-style: italic; color: ${({ theme }) => theme.colors.textLight}; background-color: ${({ theme }) => theme.colors.backgroundDark}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin-top: ${({ theme }) => theme.spacing.xs}; `;
const ActionForm = styled.form` margin-top: ${({ theme }) => theme.spacing.lg}; padding-top: ${({ theme }) => theme.spacing.lg}; border-top: 1px solid ${({ theme }) => theme.colors.border}; `;
const FormActions = styled.div` margin-top: ${({ theme }) => theme.spacing.lg}; `;
const CustomSelect = styled(StyledSelect)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; `; // Use imported Select
const StyledTextArea = styled(TextArea)` width: 100%; margin-bottom: ${({ theme }) => theme.spacing.md}; min-height: 100px; `;
// --- End Styled Components ---

// --- Helper Functions ---
function getConcernTypeText(type: string | undefined): string { if (!type) return 'Unknown'; return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()); }
function getConcernLevelText(level: number | undefined): string { if (level === undefined) return 'N/A'; if (level >= 5) return 'Critical'; if (level >= 4) return 'High'; if (level >= 3) return 'Significant'; if (level >= 2) return 'Moderate'; if (level >= 1) return 'Minor'; return 'Low'; }
// -----------------------

export default function ConcernDetailPage() {
    const [concern, setConcern] = useState<FlagDetailsResponse | null>(null); // Use the more specific type for fetched data
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [actionError, setActionError] = useState<string | null>(null);
    const [isSubmitting, setIsSubmitting] = useState(false);
    const [selectedStatus, setSelectedStatus] = useState<ConcernStatus>('pending');
    const [notes, setNotes] = useState('');

    const params = useParams();
    const router = useRouter();
    const flagId = params?.flagId as string;
    const flaggedMessageRef = useRef<HTMLDivElement>(null);

    const fetchConcernDetails = useCallback(async () => {
        if (!flagId) { setError("Flag ID missing from page parameters."); setLoading(false); return; }
        setLoading(true); setError(null); setActionError(null);
        try {
            console.log(`Fetching details for flag: ${flagId}`);
            // --- FIX: Fetch using query parameter to the collection route ---
            const response = await fetch(`/api/teacher/concerns?flagId=${flagId}`);
            // -------------------------------------------------------------
            if (!response.ok) {
                const data = await response.json().catch(() => ({ error: `HTTP error ${response.status}` }));
                throw new Error(data.error || `Failed to fetch concern details (status: ${response.status})`);
            }
            const data: FlagDetailsResponse = await response.json(); // Use the correct response type
            console.log("Fetched Concern Data:", data);
            setConcern(data);
            setSelectedStatus(data.status || 'pending');
            setNotes(data.notes || '');
        } catch (err) {
            console.error("Error fetching concern:", err);
            setError(err instanceof Error ? err.message : 'Failed to load concern details');
            setConcern(null);
        } finally { setLoading(false); }
    }, [flagId]); // Keep flagId as dependency

    useEffect(() => { fetchConcernDetails(); }, [fetchConcernDetails]);

    useEffect(() => {
        const timer = setTimeout(() => {
            if (concern && flaggedMessageRef.current) {
                console.log("Scrolling to flagged message ref");
                flaggedMessageRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
        return () => clearTimeout(timer);
    }, [concern]);

    const handleStatusUpdate = async (e: React.FormEvent) => {
        e.preventDefault();
        if (!concern?.flag_id) return; // Ensure we have the concern and its ID

        setIsSubmitting(true); setActionError(null);
        try {
            console.log(`Updating flag ${concern.flag_id} with status ${selectedStatus}`);
            // --- FIX: Send PATCH to collection route, include flagId in body ---
            const response = await fetch(`/api/teacher/concerns`, { // Target the collection route
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    flagId: concern.flag_id, // Include flagId in the body
                    status: selectedStatus,
                    notes: notes
                 }),
            });
            // --- END FIX ---
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({ error: 'Update failed' }));
                throw new Error(errorData.error || 'Failed to update status');
            }

            const updatedData = await response.json();
            // Update state based on the response from the PATCH request
            setConcern(prev => prev ? ({ ...prev, ...updatedData }) : null);
            setSelectedStatus(updatedData.status);
            setNotes(updatedData.notes || '');
            alert("Status updated successfully!");

        } catch (err) {
            setActionError(err instanceof Error ? err.message : 'Failed to update status');
        } finally {
            setIsSubmitting(false);
        }
    };

    // --- Render Logic ---
    if (loading) { return <PageWrapper><Container><Card><LoadingSpinner /> Loading concern details...</Card></Container></PageWrapper>; }
    if (error) { return <PageWrapper><Container><Alert variant="error">{error}</Alert><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }
    if (!concern) { return <PageWrapper><Container><Card>Concern not found or permission denied.</Card><Button variant="outline" onClick={() => router.back()} style={{ marginTop: '16px' }}>← Back</Button></Container></PageWrapper>; }

    // Find the actual flagged message within the surrounding messages (if fetched) or use the direct message object
    const actualFlaggedMessage = concern.surroundingMessages?.find(m => m.message_id === concern.message_id) || concern.message;

    return (
        <PageWrapper>
            <Container>
                <Header>
                    <Title>Review Concern</Title>
                    <BackButton variant="outline" onClick={() => router.push('/teacher-dashboard#concerns')}>← Back to Dashboard</BackButton>
                </Header>
                <Grid>
                    {/* Conversation Context */}
                    <ConversationContext>
                        <ContextHeader>Conversation Context</ContextHeader>
                        <MessagesList>
                            {concern.surroundingMessages?.length > 0 ? (
                                concern.surroundingMessages.map(msg => {
                                    const isFlagged = msg.message_id === concern.message_id;
                                    const chatbotName = concern.room_name || "Chatbot"; // Placeholder name

                                    const messageComponent = ( <ChatMessageComponent key={msg.message_id} message={msg} chatbotName={chatbotName} /> );
                                    return isFlagged ? ( <FlaggedMessageHighlight key={msg.message_id} ref={flaggedMessageRef}>{messageComponent}</FlaggedMessageHighlight> ) : messageComponent;
                                })
                            ) : ( actualFlaggedMessage ? ( <FlaggedMessageHighlight ref={flaggedMessageRef}><ChatMessageComponent key={actualFlaggedMessage.message_id} message={actualFlaggedMessage} chatbotName={concern.room_name || "Chatbot"} /></FlaggedMessageHighlight> )
                                : <p style={{ textAlign: 'center', padding: '20px', color: '#888' }}>Conversation context unavailable.</p>
                            )}
                        </MessagesList>
                    </ConversationContext>

                    {/* Details & Actions */}
                    <ConcernDetailsCard>
                        <DetailsHeader>Concern Details</DetailsHeader>
                        {/* Use flattened properties from FlagDetailsResponse */}
                        <DetailItem><strong>Student:</strong><span>{concern.student_name || 'N/A'} ({concern.student_email || 'No Email'})</span></DetailItem>
                        <DetailItem><strong>Classroom:</strong><span>{concern.room_name || 'N/A'}</span></DetailItem>
                        <DetailItem><strong>Concern Type:</strong><span>{getConcernTypeText(concern.concern_type)}</span></DetailItem>
                        <DetailItem><strong>Assessed Level:</strong><Badge variant="default" style={{ marginLeft: '8px' }}>{getConcernLevelText(concern.concern_level)} (Level {concern.concern_level})</Badge></DetailItem>
                        <DetailItem><strong>Detected At:</strong><span>{new Date(concern.created_at).toLocaleString()}</span></DetailItem>
                        {concern.analysis_explanation && (<DetailItem><strong>AI Analysis:</strong><AnalysisText>{concern.analysis_explanation}</AnalysisText></DetailItem>)}
                        {concern.reviewed_at && (<DetailItem><strong>Last Reviewed:</strong><span>{new Date(concern.reviewed_at).toLocaleString()}</span></DetailItem>)}

                        <ActionForm onSubmit={handleStatusUpdate}>
                             <Label htmlFor="status">Update Status:</Label>
                            <CustomSelect id="status" value={selectedStatus} onChange={(e) => setSelectedStatus(e.target.value as ConcernStatus)}>
                               <option value="pending">Pending Review</option>
                               <option value="reviewing">Reviewing</option>
                               <option value="resolved">Resolved</option>
                               <option value="false_positive">False Positive</option>
                            </CustomSelect>
                             <Label htmlFor="notes">Review Notes:</Label>
                             <StyledTextArea id="notes" rows={5} value={notes} onChange={(e) => setNotes(e.target.value)} placeholder="Add notes on actions taken, observations, or decision rationale..." />
                             {actionError && <Alert variant="error" style={{ marginBottom: '16px' }}>{actionError}</Alert>}
                             <FormActions><Button type="submit" disabled={isSubmitting} style={{ width: '100%' }}>{isSubmitting ? 'Updating...' : 'Update Status & Notes'}</Button></FormActions>
                        </ActionForm>
                    </ConcernDetailsCard>
                </Grid>
            </Container>
        </PageWrapper>
    );
}.page {
  --gray-rgb: 0, 0, 0;
  --gray-alpha-200: rgba(var(--gray-rgb), 0.08);
  --gray-alpha-100: rgba(var(--gray-rgb), 0.05);

  --button-primary-hover: #383838;
  --button-secondary-hover: #f2f2f2;

  display: grid;
  grid-template-rows: 20px 1fr 20px;
  align-items: center;
  justify-items: center;
  min-height: 100svh;
  padding: 80px;
  gap: 64px;
  font-family: var(--font-geist-sans);
}

@media (prefers-color-scheme: dark) {
  .page {
    --gray-rgb: 255, 255, 255;
    --gray-alpha-200: rgba(var(--gray-rgb), 0.145);
    --gray-alpha-100: rgba(var(--gray-rgb), 0.06);

    --button-primary-hover: #ccc;
    --button-secondary-hover: #1a1a1a;
  }
}

.main {
  display: flex;
  flex-direction: column;
  gap: 32px;
  grid-row-start: 2;
}

.main ol {
  font-family: var(--font-geist-mono);
  padding-left: 0;
  margin: 0;
  font-size: 14px;
  line-height: 24px;
  letter-spacing: -0.01em;
  list-style-position: inside;
}

.main li:not(:last-of-type) {
  margin-bottom: 8px;
}

.main code {
  font-family: inherit;
  background: var(--gray-alpha-100);
  padding: 2px 4px;
  border-radius: 4px;
  font-weight: 600;
}

.ctas {
  display: flex;
  gap: 16px;
}

.ctas a {
  appearance: none;
  border-radius: 128px;
  height: 48px;
  padding: 0 20px;
  border: none;
  border: 1px solid transparent;
  transition:
    background 0.2s,
    color 0.2s,
    border-color 0.2s;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  line-height: 20px;
  font-weight: 500;
}

a.primary {
  background: var(--foreground);
  color: var(--background);
  gap: 8px;
}

a.secondary {
  border-color: var(--gray-alpha-200);
  min-width: 158px;
}

.footer {
  grid-row-start: 3;
  display: flex;
  gap: 24px;
}

.footer a {
  display: flex;
  align-items: center;
  gap: 8px;
}

.footer img {
  flex-shrink: 0;
}

/* Enable hover only on non-touch devices */
@media (hover: hover) and (pointer: fine) {
  a.primary:hover {
    background: var(--button-primary-hover);
    border-color: transparent;
  }

  a.secondary:hover {
    background: var(--button-secondary-hover);
    border-color: transparent;
  }

  .footer a:hover {
    text-decoration: underline;
    text-underline-offset: 4px;
  }
}

@media (max-width: 600px) {
  .page {
    padding: 32px;
    padding-bottom: 80px;
  }

  .main {
    align-items: center;
  }

  .main ol {
    text-align: center;
  }

  .ctas {
    flex-direction: column;
  }

  .ctas a {
    font-size: 14px;
    height: 40px;
    padding: 0 16px;
  }

  a.secondary {
    min-width: auto;
  }

  .footer {
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
  }
}

@media (prefers-color-scheme: dark) {
  .logo {
    filter: invert();
  }
}
// src/app/layout.tsx
import { Metadata } from 'next';
import Providers from './providers';
import Header from '@/components/layout/Header';
import { APP_NAME, APP_DESCRIPTION } from '@/lib/utils/constants';
import './globals.css';

export const metadata: Metadata = {
  title: APP_NAME,
  description: APP_DESCRIPTION,
  viewport: 'width=device-width, initial-scale=1.0, maximum-scale=1.0',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        <Providers>
          <Header />
          {children}
        </Providers>
      </body>
    </html>
  );
}// src/app/api/chat/[roomId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateEmbedding } from '@/lib/openai/embeddings';
import { queryVectors } from '@/lib/pinecone/utils';
import { checkMessageSafety } from '@/lib/safety/monitoring';
import type { ChatMessage, Room } from '@/types/database.types'; // Removed unused Profile

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const ASSESSMENT_TRIGGER_COMMAND = "/assess";
const ASSESSMENT_CONTEXT_MESSAGE_COUNT = 5;

const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// --- GET Function ---
export async function GET(request: NextRequest) {
    try {
        const pathname = request.nextUrl.pathname;
        const segments = pathname.split('/');
        const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
        const { searchParams } = new URL(request.url);
        const chatbotIdFilter = searchParams.get('chatbotId');

        if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });

        if (!isTeacherTestRoom(roomId)) {
            const { data: roomResult, error: roomError } = await supabase
                .from('rooms')
                .select('room_id')
                .eq('room_id', roomId)
                .maybeSingle();
            if (roomError || !roomResult) {
                console.warn(`[API Chat GET] Room ${roomId} not found or access denied for user ${user.id}.`);
                return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 });
            }
        }

        let query = supabase.from('chat_messages').select('*').eq('room_id', roomId).eq('user_id', user.id);
        if (chatbotIdFilter) query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
        
        const { data: messages, error: messagesError } = await query.order('created_at', { ascending: true });

        if (messagesError) { 
            console.error('[API Chat GET] Error fetching messages:', messagesError); 
            return NextResponse.json({ error: messagesError.message }, { status: 500 }); 
        }
        return NextResponse.json(messages || []);
    } catch (error) { 
        console.error('[API Chat GET] General error:', error); 
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Unknown server error' }, { status: 500 }); 
    }
}


// --- POST Handler ---
export async function POST(request: NextRequest) {
  let userMessageId: string | null = null;
  const supabase = await createServerSupabaseClient(); 

  try {
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const roomId = segments.length > 0 ? segments[segments.length - 1] : null;
    if (!roomId) return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });

    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }
    
    const { data: userProfile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', user.id)
        .single();
    if (profileError || !userProfile) { return NextResponse.json({ error: 'User profile not found' }, { status: 403 }); }
    
    const isStudent = userProfile.role === 'student';
    const isTeacher = userProfile.role === 'teacher';

    const { content, chatbot_id, model: requestedModel } = await request.json();
    const trimmedContent = content?.trim();
    if (!trimmedContent || typeof trimmedContent !== 'string') return NextResponse.json({ error: 'Invalid message content' }, { status: 400 });
    if (!chatbot_id) return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });

    const { data: chatbotConfig, error: chatbotFetchError } = await supabase
        .from('chatbots')
        .select('system_prompt, model, temperature, max_tokens, enable_rag, bot_type, assessment_criteria_text, welcome_message, teacher_id')
        .eq('chatbot_id', chatbot_id)
        .single();

    if (chatbotFetchError || !chatbotConfig) {
        console.warn(`[API Chat POST] Error fetching chatbot ${chatbot_id} config:`, chatbotFetchError?.message);
        return NextResponse.json({ error: 'Chatbot configuration not found.' }, { status: 404 });
    }

    let roomForSafetyCheck: Room | null = null;
    let teacherCountryCode: string | null = null;

    if (!isTeacherTestRoom(roomId)) {
        const { data: roomData, error: roomFetchError } = await supabase
            .from('rooms')
            .select('room_id, teacher_id, room_name, school_id') 
            .eq('room_id', roomId)
            .single();
        if (roomFetchError || !roomData) { 
            console.error("[API Chat POST] Room fetch error for non-test room:", roomFetchError); 
            return NextResponse.json({ error: 'Room not found or access denied' }, { status: 404 }); 
        }
        roomForSafetyCheck = roomData as Room;
        
        if (roomData.teacher_id) { // This teacher_id is from the 'rooms' table
            const { data: roomTeacherProfile, error: roomTeacherProfileError } = await supabase
                .from('profiles')
                .select('country_code')
                .eq('user_id', roomData.teacher_id)
                .single();
            if (roomTeacherProfileError) {
                console.warn(`[API Chat POST] Error fetching teacher profile for room's teacher (${roomData.teacher_id}):`, roomTeacherProfileError.message);
            } else if (roomTeacherProfile) {
                teacherCountryCode = roomTeacherProfile.country_code || null;
            }
        }
    } else if (isTeacherTestRoom(roomId)) {
        if (!isTeacher) {
            return NextResponse.json({ error: 'Not authorized for this test room' }, { status: 403 });
        }
        // For teacher test rooms, the "user" (who is the teacher) uses their own country code.
        // The chatbotConfig.teacher_id should match user.id here.
        if (user.id === chatbotConfig.teacher_id) {
            const { data: testTeacherProfile, error: testTeacherProfileError } = await supabase
                .from('profiles')
                .select('country_code')
                .eq('user_id', user.id) // Fetch profile of the current teacher user
                .single();
            if (testTeacherProfileError) {
                console.warn(`[API Chat POST] Error fetching teacher profile for test room user (${user.id}):`, testTeacherProfileError.message);
            } else if (testTeacherProfile) {
                teacherCountryCode = testTeacherProfile.country_code || null;
            }
        } else {
             // Fallback: If chatbot's teacher_id doesn't match current user (e.g., admin testing, or complex scenario)
             // try to get country code from the chatbot's designated teacher_id
            const { data: designatedTeacherProfile, error: designatedTeacherProfileError } = await supabase
                .from('profiles')
                .select('country_code')
                .eq('user_id', chatbotConfig.teacher_id)
                .single();
            if (designatedTeacherProfileError) {
                console.warn(`[API Chat POST] Error fetching designated teacher profile for chatbot (${chatbotConfig.teacher_id}):`, designatedTeacherProfileError.message);
            } else if (designatedTeacherProfile) {
                teacherCountryCode = designatedTeacherProfile.country_code || null;
            }
        }
    }


    const userMessageToStore: Omit<ChatMessage, 'message_id' | 'created_at' | 'updated_at'> & { metadata: { chatbotId: string } } = {
      room_id: roomId, user_id: user.id, role: 'user' as const, content: trimmedContent, metadata: { chatbotId: chatbot_id }
    };
    const { data: savedUserMessageData, error: userMessageError } = await supabase.from('chat_messages').insert(userMessageToStore).select('message_id, created_at').single();
    if (userMessageError || !savedUserMessageData) { console.error('Error storing user message:', userMessageError); return NextResponse.json({ error: 'Failed to store message' }, { status: 500 }); }
    userMessageId = savedUserMessageData.message_id;
    const userMessageCreatedAt = savedUserMessageData.created_at;
    
    if (isStudent && userMessageId && roomForSafetyCheck && !isTeacherTestRoom(roomId)) {
        console.log(`[API Chat POST] Triggering imported checkMessageSafety for student ${user.id}, message ${userMessageId}, teacher's country: ${teacherCountryCode || 'Unknown'}`);
        checkMessageSafety(supabase, trimmedContent, userMessageId, user.id, roomForSafetyCheck, teacherCountryCode) 
            .catch(safetyError => console.error(`[Safety Check Background Error] for message ${userMessageId}:`, safetyError));
    } else {
        console.log(`[API Chat POST] Skipping safety check. isStudent: ${isStudent}, isTeacherTestRoom: ${isTeacherTestRoom(roomId)}, roomForSafetyCheck: ${!!roomForSafetyCheck}`);
    }

    if (isStudent && chatbotConfig.bot_type === 'assessment' && trimmedContent.toLowerCase() === ASSESSMENT_TRIGGER_COMMAND) {
        console.log(`[API Chat POST] Assessment trigger detected for student ${user.id}, bot ${chatbot_id}, room ${roomId}.`);
        const { data: contextMessagesForAssessment, error: contextMsgsError } = await supabase
            .from('chat_messages')
            .select('message_id')
            .eq('room_id', roomId)
            .eq('user_id', user.id) 
            .eq('metadata->>chatbotId', chatbot_id)
            .lt('created_at', userMessageCreatedAt)
            .order('created_at', { ascending: false })
            .limit(ASSESSMENT_CONTEXT_MESSAGE_COUNT * 2 + 5); 
        if (contextMsgsError) {
            console.error(`[API Chat POST] Error fetching message IDs for assessment context: ${contextMsgsError.message}`);
        }
        const messageIdsToAssess = (contextMessagesForAssessment || []).map(m => m.message_id).reverse();
        const assessmentPayload = { student_id: user.id, chatbot_id: chatbot_id, room_id: roomId, message_ids_to_assess: messageIdsToAssess };
        console.log(`[API Chat POST] Asynchronously calling /api/assessment/process.`);
        const baseUrl = process.env.NEXT_PUBLIC_APP_URL || `http://localhost:${process.env.PORT || 3000}`;
        fetch(`${baseUrl}/api/assessment/process`, { 
            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(assessmentPayload),
        }).catch(fetchError => console.error(`[API Chat POST] Error calling /api/assessment/process internally:`, fetchError));
        return NextResponse.json({ type: "assessment_pending", message: "Your responses are being submitted for assessment. Feedback will appear here shortly." });
    }

    const { data: contextMessagesData, error: contextError } = await supabase.from('chat_messages')
      .select('role, content').eq('room_id', roomId).eq('user_id', user.id)
      .filter('metadata->>chatbotId', 'eq', chatbot_id).neq('message_id', userMessageId)
      .order('created_at', { ascending: false }).limit(5);
    if (contextError) console.warn("Error fetching context messages:", contextError.message);
    const contextMessages = (contextMessagesData || []).map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }));

    // Use teacher-defined system prompt, or a safe default if somehow missing
    const teacherSystemPrompt = chatbotConfig.system_prompt || "You are a safe, ethical, and supportive AI learning assistant for students. Your primary goal is to help students understand educational topics in an engaging and age-appropriate manner.";
    
    const { 
        model: modelToUseFromConfig = 'openai/gpt-4.1-nano', 
        temperature: temperatureToUse = 0.7, 
        max_tokens: maxTokensToUse = 1000, 
        enable_rag: enableRagFromConfig = false 
    } = chatbotConfig;
    
    const finalModelToUse = requestedModel || modelToUseFromConfig;

    let ragContextText = '';
    if (enableRagFromConfig && chatbotConfig.bot_type === 'learning') { 
        try {
            const queryEmbedding = await generateEmbedding(trimmedContent);
            const searchResults = await queryVectors(queryEmbedding, chatbot_id, 3);
            if (searchResults && searchResults.length > 0) {
                ragContextText = "\n\nRelevant information from knowledge base:\n";
                searchResults.forEach((result) => { 
                    if (result.metadata?.text) {
                        const fileName = typeof result.metadata.fileName === 'string' ? result.metadata.fileName : 'document';
                        const chunkText = String(result.metadata.text).substring(0, 500);
                        ragContextText += `\nFrom document "${fileName}":\n${chunkText}\n`; 
                    }
                });
            }
        } catch (ragError) { console.warn(`[RAG] Error:`, ragError); }
    }

    let regionalInstruction = '';
    if (teacherCountryCode === 'GB' || teacherCountryCode === 'AE') { // Added AE for British English
        regionalInstruction = " Please use British English spelling (e.g., 'colour', 'analyse').";
    } else if (teacherCountryCode === 'AU') {
        regionalInstruction = " Please use Australian English spelling.";
    } else if (teacherCountryCode === 'CA') {
        regionalInstruction = " Please use Canadian English spelling.";
    }
    // Add more country codes and their preferred spellings as needed.

    const CORE_SAFETY_INSTRUCTIONS = `
SAFETY OVERRIDE: The following are non-negotiable rules for your responses.
- You are an AI assistant interacting with students. All interactions must be strictly age-appropriate, safe, and ethical.
- NEVER generate responses that are sexually explicit, suggestive, or exploit, abuse, or endanger children.
- NEVER engage in discussions about graphic violence, hate speech, illegal activities, or self-harm promotion.
- NEVER ask for or store personally identifiable information (PII) from students, such as full names (beyond a first name if offered by the student in conversation), exact age, home address, phone number, email, specific school name, or social media details.
- If a student's query is ambiguous or could lead to an inappropriate response, err on the side of caution and provide a generic, safe, educational answer or politely decline to answer if the topic is clearly out of scope or unsafe.
- If a student expresses direct intent for self-harm or mentions ongoing abuse, the system has separate alerts, but your immediate response should be brief, empathetic, and guide them to seek help from a trusted adult without engaging in therapeutic conversation.
- These safety rules override any conflicting instructions in the user-provided prompt below.
--- END OF SAFETY OVERRIDE ---
`;

    const systemPromptForLLM = `${CORE_SAFETY_INSTRUCTIONS}\n\nTeacher's Prompt:\n${teacherSystemPrompt}${regionalInstruction}${ragContextText ? `\n\nRelevant Information:\n${ragContextText}\n\nBase your answer on the provided information. Do not explicitly mention "Source:" or bracketed numbers like [1], [2] in your response.` : ''}`;
    
    console.log(`[API Chat POST] Final System Prompt (first 500 chars): ${systemPromptForLLM.substring(0,500)}...`);
    
    const messagesForAPI = [ { role: 'system', content: systemPromptForLLM }, ...contextMessages.reverse(), { role: 'user', content: trimmedContent } ];

    const openRouterResponse = await fetch(OPENROUTER_API_URL, {
        method: 'POST', headers: { 'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`, 'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000', 'X-Title': 'ClassBots AI', 'Content-Type': 'application/json' },
        body: JSON.stringify({ model: finalModelToUse, messages: messagesForAPI, temperature: temperatureToUse, max_tokens: maxTokensToUse, stream: true }),
    });

    if (!openRouterResponse.ok || !openRouterResponse.body) {
        const errorBody = await openRouterResponse.text(); console.error(`OpenRouter Error: Status ${openRouterResponse.status}`, errorBody);
        let errorMessage = `Failed to get AI response (status: ${openRouterResponse.status})`;
        try { const errorJson = JSON.parse(errorBody); errorMessage = errorJson.error?.message || errorMessage; } catch {}
        throw new Error(errorMessage);
    }

    let fullResponseContent = ''; const encoder = new TextEncoder(); let assistantMessageId: string | null = null;
    const stream = new ReadableStream({
        async start(controller) {
            const reader = openRouterResponse.body!.getReader(); const decoder = new TextDecoder();
            try {
                const { data: initData, error: initError } = await supabase.from('chat_messages')
                    .insert({ room_id: roomId, user_id: user.id, role: 'assistant', content: '', metadata: { chatbotId: chatbot_id } })
                    .select('message_id').single();
                if (initError || !initData) console.error('Error creating placeholder assistant message:', initError);
                else assistantMessageId = initData.message_id;

                while (true) {
                    const { done, value } = await reader.read(); if (done) break;
                    const chunk = decoder.decode(value, { stream: true }); const lines = chunk.split('\n').filter(l => l.trim().startsWith('data:'));
                    for (const line of lines) {
                        const dataContent = line.substring(6).trim(); if (dataContent === '[DONE]') continue;
                        try { const parsed = JSON.parse(dataContent); const piece = parsed.choices?.[0]?.delta?.content; if (typeof piece === 'string') { fullResponseContent += piece; controller.enqueue(encoder.encode(`data: ${JSON.stringify({ content: piece })}\n\n`)); } }
                        catch (e) { console.warn('Stream parse error:', e); }
                    }
                }
            } catch (streamError) { console.error('Stream error:', streamError); controller.error(streamError); }
            finally {
                let finalContent = fullResponseContent.trim();
                finalContent = finalContent.replace(/\s*Source:\s*\[\d+\]\s*$/gm, '').trim(); 
                finalContent = finalContent.replace(/\s*\[\d+\]\s*$/gm, '').trim(); 
                finalContent = finalContent.replace(/(\r\n|\n|\r){2,}/gm, '$1').replace(/ +/g, ' ');

                if (assistantMessageId && finalContent) {
                    const { error: updateError } = await supabase.from('chat_messages').update({ content: finalContent, updated_at: new Date().toISOString() }).eq('message_id', assistantMessageId);
                    if (updateError) console.error(`Error updating assistant message ${assistantMessageId}:`, updateError); else console.log(`Assistant message ${assistantMessageId} updated.`);
                } else if (!assistantMessageId && finalContent) { 
                    console.warn("Fallback: Assistant message placeholder not created, inserting full message."); 
                    await supabase.from('chat_messages').insert({ room_id: roomId, user_id: user.id, role: 'assistant', content: finalContent, metadata: { chatbotId: chatbot_id } }); 
                }
                controller.close(); console.log("Server stream closed.");
            }
        }
    });
    return new Response(stream, { headers: { 'Content-Type': 'text/event-stream', 'Cache-Control': 'no-cache', 'Connection': 'keep-alive', 'X-Content-Type-Options': 'nosniff' } });

  } catch (error) { 
      console.error('Error in POST /api/chat/[roomId]:', error); 
      return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to process message' }, { status: 500 }); 
  }
}// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    
    // Test database connection
    const { error } = await supabase
      .from('schools')
      .select('count')
      .limit(1);

    if (error) {
      return NextResponse.json({ 
        status: 'error', 
        message: 'Database connection failed',
        error: error.message 
      }, { status: 500 });
    }

    return NextResponse.json({ 
      status: 'healthy',
      database: 'connected',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    return NextResponse.json({ 
      status: 'error', 
      message: 'Server error',
      error: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}// src/app/api/student/join-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { isValidRoomCode } from '@/lib/utils/room-codes'; // Ensure this utility is present

export async function POST(request: Request) {
  console.log('[API POST /student/join-room] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    
    const { data: { session }, error: sessionError } = await supabase.auth.getSession();
    
    if (sessionError || !session?.user) {
      console.warn('[API POST /student/join-room] Not authenticated or session error:', sessionError);
      return NextResponse.json({ error: sessionError?.message || 'Not authenticated' }, { status: 401 });
    }
    const studentUser = session.user;
    console.log('[API POST /student/join-room] User authenticated:', studentUser.id);

    // Verify the user trying to join actually has a 'student' role in profiles table
    const { data: studentProfile, error: profileError } = await supabase
        .from('profiles')
        .select('role')
        .eq('user_id', studentUser.id)
        .single();

    if (profileError || !studentProfile) {
        console.error('[API POST /student/join-room] Profile not found or error for student:', studentUser.id, profileError);
        return NextResponse.json({ error: 'Student profile not found.' }, { status: 403 });
    }
    if (studentProfile.role !== 'student') {
        console.warn('[API POST /student/join-room] User is not a student. Role:', studentProfile.role);
        return NextResponse.json({ error: 'Only students can join rooms this way.' }, { status: 403 });
    }
    console.log('[API POST /student/join-room] User confirmed as student.');


    const { room_code } = await request.json();
    console.log('[API POST /student/join-room] Received room_code:', room_code);

    if (!room_code || !isValidRoomCode(room_code.toUpperCase())) { // Ensure case-insensitivity if codes are stored uppercase
      console.warn('[API POST /student/join-room] Invalid room code format:', room_code);
      return NextResponse.json({ error: 'Invalid room code format' }, { status: 400 });
    }

    const formattedRoomCode = room_code.toUpperCase();

    // Find room by code
    console.log('[API POST /student/join-room] Searching for room with code:', formattedRoomCode);
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id, is_active')
      .eq('room_code', formattedRoomCode) // Ensure room_code in DB is also consistently cased or use a case-insensitive query
      .single();

    if (roomError) {
        console.error('[API POST /student/join-room] Error fetching room by code:', formattedRoomCode, roomError);
        // This could be a "relation rooms does not exist" if table is missing, or other DB error
        // But more likely if table exists, it's "0 rows" which isn't an error for .single() if it becomes !room
        // For a true DB error, throw it.
        if (roomError.code && !['PGRST116'].includes(roomError.code)) { // PGRST116 is "Searched for a single row, but found 0 rows"
             throw roomError;
        }
    }
    
    if (!room) { // This handles both "0 rows found" and if roomError was PGRST116
      console.warn('[API POST /student/join-room] Room not found with code:', formattedRoomCode);
      return NextResponse.json({ error: 'Room not found' }, { status: 404 }); // This is your current error
    }
    console.log('[API POST /student/join-room] Room found:', room.room_id, 'Is active:', room.is_active);


    if (!room.is_active) {
      console.warn('[API POST /student/join-room] Room is inactive:', room.room_id);
      return NextResponse.json({ error: 'This room is currently inactive.' }, { status: 400 });
    }

    // Check if student is already in room
    const { data: existingMembership, error: membershipCheckError } = await supabase
      .from('room_memberships')
      .select('room_id')
      .eq('room_id', room.room_id)
      .eq('student_id', studentUser.id)
      .maybeSingle(); // Use maybeSingle to not error if no membership found

    if (membershipCheckError) {
        console.error('[API POST /student/join-room] Error checking existing membership:', membershipCheckError);
        throw membershipCheckError;
    }

    if (existingMembership) {
      console.warn('[API POST /student/join_room] Student already a member of this room:', room.room_id);
      return NextResponse.json({ message: 'Already joined this room', roomId: room.room_id }, { status: 200 }); // Or 400 if you want to treat as error
    }

    // Add student to room
    console.log('[API POST /student/join-room] Adding student to room_memberships. RoomID:', room.room_id, 'StudentID:', studentUser.id);
    const { error: joinError } = await supabase
      .from('room_memberships')
      .insert({
        room_id: room.room_id,
        student_id: studentUser.id
        // joined_at has a default value
      });

    if (joinError) {
      console.error('[API POST /student/join-room] Error inserting into room_memberships:', joinError);
      // Check for unique constraint violation (already a member, though prior check should catch this)
      if (joinError.code === '23505') { // unique_violation
         return NextResponse.json({ message: 'Already a member of this room (insert conflict).', roomId: room.room_id }, { status: 200 });
      }
      throw joinError;
    }
    console.log('[API POST /student/join-room] Student successfully joined room:', room.room_id);
    return NextResponse.json({ success: true, roomId: room.room_id, message: 'Successfully joined room!' });
  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API POST /student/join-room] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to join room' },
      { status: 500 }
    );
  }
}// src/app/api/student/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

// Define proper interfaces for the exact Supabase query structure
interface ChatbotData {
  chatbot_id: string;
  name: string;
  description: string | null;
}

interface RoomChatbotRelation {
  chatbots: ChatbotData;
}

interface RoomData {
  room_id: string;
  room_name: string;
  room_code: string;
  is_active: boolean;
  created_at: string;
  room_chatbots: RoomChatbotRelation[] | null;
}

interface MembershipData {
  joined_at: string;
  rooms: RoomData | null;
}

export async function GET() {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a student
    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'student') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // Fetch rooms the student has joined with chatbot info - MODIFIED QUERY
    const { data: membershipData, error } = await supabase
      .from('room_memberships')
      .select(`
        joined_at,
        rooms!inner(
          room_id,
          room_name,
          room_code,
          is_active,
          created_at,
          room_chatbots(
            chatbots(
              chatbot_id,
              name,
              description
            )
          )
        )
      `)
      .eq('student_id', user.id);

    if (error) {
      throw error;
    }

    // Use unknown first, then cast to our type
    const typedMembershipData = membershipData as unknown as MembershipData[];

    // Transform the data to match expected format
    const rooms = typedMembershipData?.map(membership => {
      const room = membership.rooms;
      if (!room) return null;
      
      // Extract chatbots from room_chatbots
      const chatbots: ChatbotData[] = [];
      if (room.room_chatbots && room.room_chatbots.length > 0) {
        room.room_chatbots.forEach((rc: RoomChatbotRelation) => {
          if (rc.chatbots) {
            chatbots.push(rc.chatbots);
          }
        });
      }
      
      return {
        ...room,
        joined_at: membership.joined_at,
        chatbots
      };
    }).filter((room): room is NonNullable<typeof room> => room !== null);

    return NextResponse.json(rooms || []);
  } catch (error) {
    console.error('Error fetching student rooms:', error);
    return NextResponse.json(
      { error: 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}// src/app/api/student/assessment-detail/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { 
    StudentAssessment, 
    ChatMessage as DbChatMessage
} from '@/types/database.types';

// StudentDetailedAssessmentResponse interface remains the same
export interface StudentDetailedAssessmentResponse extends StudentAssessment {
    chatbot_name?: string | null;
    room_name?: string | null;
    assessed_conversation?: DbChatMessage[];
}

export async function GET(request: NextRequest) { // Removed the second 'params' argument
  const { searchParams } = new URL(request.url);
  const assessmentId = searchParams.get('assessmentId'); // Get assessmentId from query params

  console.log(`[API GET /student/assessment-detail] Received request for assessmentId: ${assessmentId}`);

  if (!assessmentId) {
    return NextResponse.json({ error: 'Assessment ID query parameter is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn(`[API GET /student/assessment-detail] Not authenticated:`, authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: assessment, error: assessmentError } = await supabase
      .from('student_assessments')
      .select('*')
      .eq('assessment_id', assessmentId)
      .eq('student_id', user.id)
      .single();

    if (assessmentError || !assessment) {
      console.warn(`[API GET /student/assessment-detail] Assessment ${assessmentId} not found or student ${user.id} not authorized:`, assessmentError?.message);
      return NextResponse.json({ error: 'Assessment not found or you are not authorized to view it.' }, { status: 404 });
    }
    console.log(`[API GET /student/assessment-detail] Assessment ${assessmentId} found and student ${user.id} authorized.`);

    let chatbotName: string | null = null;
    if (assessment.chatbot_id) {
      const { data: chatbotData } = await supabase
        .from('chatbots')
        .select('name')
        .eq('chatbot_id', assessment.chatbot_id)
        .single();
      chatbotName = chatbotData?.name || 'Assessment Bot';
    }

    let roomName: string | null = null;
    if (assessment.room_id && !assessment.room_id.startsWith('teacher_test_room_')) {
        const { data: roomData } = await supabase
            .from('rooms')
            .select('room_name')
            .eq('room_id', assessment.room_id)
            .single();
        roomName = roomData?.room_name || null;
    } else if (assessment.room_id && assessment.room_id.startsWith('teacher_test_room_')) {
        roomName = 'Teacher Test Chat';
    }

    let assessedConversation: DbChatMessage[] = [];
    if (assessment.assessed_message_ids && Array.isArray(assessment.assessed_message_ids) && assessment.assessed_message_ids.length > 0) {
      const { data: messagesData, error: messagesError } = await supabase
        .from('chat_messages')
        .select('*')
        .in('message_id', assessment.assessed_message_ids)
        .order('created_at', { ascending: true });

      if (messagesError) {
        console.error(`[API GET /student/assessment-detail] Error fetching assessed conversation for ${assessmentId}:`, messagesError.message);
      } else {
        assessedConversation = (messagesData || []) as DbChatMessage[];
      }
    }
    console.log(`[API GET /student/assessment-detail] Fetched ${assessedConversation.length} messages for ${assessmentId}.`);

    const responseData: StudentDetailedAssessmentResponse = {
      ...(assessment as StudentAssessment),
      chatbot_name: chatbotName,
      room_name: roomName,
      assessed_conversation: assessedConversation,
    };
    
    console.log(`[API GET /student/assessment-detail] Successfully prepared data for ${assessmentId}. Returning response.`);
    return NextResponse.json(responseData);

  } catch (error) {
    const typedError = error as Error;
    console.error(`[API GET /student/assessment-detail] CATCH BLOCK Error for ${assessmentId}:`, typedError.message);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch assessment details' },
      { status: 500 }
    );
  }
}// src/app/api/student/dashboard-data/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { 
    Room, 
    Chatbot, 
    StudentAssessment,
    Profile
} from '@/types/database.types';

// --- Interfaces for API Response ---

interface JoinedRoomForDashboard extends Pick<Room, 'room_id' | 'room_name' | 'room_code'> {
  chatbots: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type'>[]; // Added bot_type
  joined_at: string;
}

interface AssessmentSummaryForDashboard extends Pick<StudentAssessment, 'assessment_id' | 'ai_grade_raw' | 'ai_feedback_student' | 'assessed_at' | 'status'> {
  room_id: string;
  room_name: string | null;
  chatbot_id: string;
  chatbot_name: string | null;
}

interface StudentDashboardDataResponse {
  joinedRooms: JoinedRoomForDashboard[];
  recentAssessments: AssessmentSummaryForDashboard[];
  studentProfile: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null;
}

// Helper type for Supabase query for joined rooms
interface MembershipWithRoomAndChatbots {
  joined_at: string;
  rooms: { // Nullable if inner join fails or no room
    room_id: string;
    room_name: string;
    room_code: string;
    is_active: boolean;
    created_at: string;
    room_chatbots: { // Nullable array
      chatbots: { // Nullable chatbot
        chatbot_id: string;
        name: string;
        description: string | null;
        bot_type: Chatbot['bot_type']; // Ensure bot_type is selected
      } | null;
    }[] | null;
  } | null;
}


export async function GET() {
  console.log('[API GET /student/dashboard-data] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /student/dashboard-data] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a student
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('user_id, role, full_name, email') // Fetch full_name and email too
      .eq('user_id', user.id)
      .single();

    if (profileError || !profile) {
      console.warn(`[API GET /student/dashboard-data] Profile error for user ${user.id}:`, profileError?.message);
      return NextResponse.json({ error: 'User profile not found.' }, { status: 403 });
    }
    if (profile.role !== 'student') {
      console.warn(`[API GET /student/dashboard-data] User ${user.id} is not a student. Role: ${profile.role}`);
      return NextResponse.json({ error: 'Not authorized (user is not a student)' }, { status: 403 });
    }
    console.log(`[API GET /student/dashboard-data] User ${user.id} (${profile.email}) authenticated as student.`);
    
    const studentProfileInfo: Pick<Profile, 'user_id' | 'full_name' | 'email'> = {
        user_id: profile.user_id,
        full_name: profile.full_name,
        email: profile.email
    };

    // 1. Fetch joined rooms (adapted from /api/student/rooms)
    const { data: membershipsData, error: roomsError } = await supabase
      .from('room_memberships')
      .select(`
        joined_at,
        rooms!inner(
          room_id,
          room_name,
          room_code,
          is_active,
          created_at,
          room_chatbots(
            chatbots!inner(
              chatbot_id,
              name,
              description,
              bot_type
            )
          )
        )
      `)
      .eq('student_id', user.id)
      .eq('rooms.is_active', true); // Only fetch active rooms for the dashboard

    if (roomsError) {
      console.error('[API GET /student/dashboard-data] Error fetching student rooms:', roomsError.message);
      // Don't fail entirely, dashboard might still show assessments
    }

    const typedMembershipsData = (membershipsData || []) as unknown as MembershipWithRoomAndChatbots[];
    const joinedRooms: JoinedRoomForDashboard[] = typedMembershipsData.map(membership => {
      const room = membership.rooms;
      if (!room) return null;

      const chatbotsInRoom: Pick<Chatbot, 'chatbot_id' | 'name' | 'bot_type'>[] = [];
      if (room.room_chatbots && Array.isArray(room.room_chatbots)) {
        room.room_chatbots.forEach(rc => {
          if (rc && rc.chatbots) { // Check if rc and rc.chatbots are not null
            chatbotsInRoom.push({
              chatbot_id: rc.chatbots.chatbot_id,
              name: rc.chatbots.name,
              bot_type: rc.chatbots.bot_type || 'learning', // Default if bot_type is null
            });
          }
        });
      }
      
      return {
        room_id: room.room_id,
        room_name: room.room_name,
        room_code: room.room_code,
        chatbots: chatbotsInRoom,
        joined_at: membership.joined_at,
      };
    }).filter((room): room is JoinedRoomForDashboard => room !== null);
    console.log(`[API GET /student/dashboard-data] Fetched ${joinedRooms.length} joined active rooms.`);


    // 2. Fetch recent assessments (e.g., last 5-10 completed or reviewed by teacher)
    // For assessments, we need joins to get room_name and chatbot_name
    const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey"; // FK from student_assessments to chatbots
                                                                        // If room_id in student_assessments is TEXT and not a direct FK, we'll need a two-step fetch or careful query

    // Check if room_id in student_assessments is a direct FK to rooms.room_id
    // For now, assuming student_assessments.room_id is TEXT and might be 'teacher_test_room_...',
    // so a direct join on rooms might only work for actual UUID room_ids.
    // Let's fetch assessments and then enrich with room names.

    const { data: assessmentsData, error: assessmentsError } = await supabase
      .from('student_assessments')
      .select(`
        assessment_id,
        room_id, 
        chatbot_id,
        ai_grade_raw,
        ai_feedback_student,
        assessed_at,
        status,
        chatbot:chatbots${chatbotForeignKeyHint}!inner(name) 
      `)
      .eq('student_id', user.id)
      // .in('status', ['ai_completed', 'teacher_reviewed']) // Only show actionable/finalized feedback
      .order('assessed_at', { ascending: false })
      .limit(10); // Limit to recent ones

    if (assessmentsError) {
      console.error('[API GET /student/dashboard-data] Error fetching student assessments:', assessmentsError.message);
      // Don't fail entirely
    }
    
    let recentAssessments: AssessmentSummaryForDashboard[] = [];
    if (assessmentsData && assessmentsData.length > 0) {
        const roomIdsFromAssessments = [...new Set(
            assessmentsData.map(a => a.room_id).filter(id => id && !id.startsWith('teacher_test_room_'))
        )] as string[];

        const roomNamesMap: Map<string, string> = new Map();
        if (roomIdsFromAssessments.length > 0) {
            const { data: roomNameData, error: roomNameError } = await supabase
                .from('rooms')
                .select('room_id, room_name')
                .in('room_id', roomIdsFromAssessments);
            if (roomNameError) {
                console.warn('[API GET /student/dashboard-data] Error fetching room names for assessments:', roomNameError.message);
            } else {
                roomNameData?.forEach(r => roomNamesMap.set(r.room_id, r.room_name));
            }
        }

        recentAssessments = assessmentsData.map(asmnt => {
            const chatbotData = asmnt.chatbot as { name?: string | null } | null;
            let roomNameDisplay = 'N/A';
            if (asmnt.room_id) {
                if (asmnt.room_id.startsWith('teacher_test_room_')) {
                    // This case should ideally not appear for student-facing dashboard
                    // but handled just in case tests by teachers appear in their own 'student_assessments'
                    roomNameDisplay = 'Test Environment'; 
                } else {
                    roomNameDisplay = roomNamesMap.get(asmnt.room_id) || `Room ID: ${asmnt.room_id.substring(0,6)}`;
                }
            }

            return {
                assessment_id: asmnt.assessment_id,
                room_id: asmnt.room_id,
                room_name: roomNameDisplay,
                chatbot_id: asmnt.chatbot_id,
                chatbot_name: chatbotData?.name || 'Assessment Bot',
                ai_grade_raw: asmnt.ai_grade_raw,
                ai_feedback_student: asmnt.ai_feedback_student,
                assessed_at: asmnt.assessed_at,
                status: asmnt.status
            };
        });
    }
    console.log(`[API GET /student/dashboard-data] Fetched ${recentAssessments.length} recent assessments.`);


    const responsePayload: StudentDashboardDataResponse = {
      studentProfile: studentProfileInfo,
      joinedRooms,
      recentAssessments,
    };

    console.log('[API GET /student/dashboard-data] Successfully prepared data. Returning response.');
    return NextResponse.json(responsePayload);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string };
    console.error('[API GET /student/dashboard-data] CATCH BLOCK Error:', typedError.message, 'Code:', typedError.code, 'Details:', typedError.details);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch student dashboard data' },
      { status: 500 }
    );
  }
}// src/app/api/assessment/process/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { DocumentType } from '@/types/knowledge-base.types'; // For extractTextFromFile
import { extractTextFromFile } from '@/lib/document-processing/extractor';
// Import AssessmentStatusEnum for setting status
import type { AssessmentStatusEnum } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const ASSESSMENT_LLM_MODEL = 'google/gemini-2.5-flash-preview'; // Or your preferred model like 'microsoft/phi-3-medium-128k-instruct'

interface ProcessAssessmentPayload {
  student_id: string; // For teacher tests, this will be the teacher's user_id
  chatbot_id: string;
  room_id: string; // Will be "teacher_test_room_for_..." for teacher tests
  message_ids_to_assess: string[];
}

// Helper function to identify teacher test rooms
const isTeacherTestRoom = (roomId: string) => roomId.startsWith('teacher_test_room_for_');

// Define expected structure for LLM's JSON response (the content part)
interface LLMAssessmentOutput {
    grade: string;
    student_feedback: string;
    teacher_analysis: {
        summary: string;
        strengths: string[];
        areas_for_improvement: string[];
        grading_rationale: string;
    };
}

export async function POST(request: NextRequest) {
  console.log('--------------------------------------------------');
  console.log('[API /assessment/process] Received assessment processing request.');
  const adminSupabase = createAdminClient();

  try {
    const payload: ProcessAssessmentPayload = await request.json();
    const { student_id: userId, chatbot_id, room_id, message_ids_to_assess } = payload;
    const isTestByTeacher = isTeacherTestRoom(room_id);

    console.log(`[API /assessment/process] Payload: userId=${userId}, chatbot_id=${chatbot_id}, room_id=${room_id}, isTestByTeacher=${isTestByTeacher}, messages_count=${message_ids_to_assess.length}`);

    // 1. Fetch the Assessment Bot's configuration
    const { data: assessmentBotConfig, error: botConfigError } = await adminSupabase
      .from('chatbots')
      .select('assessment_criteria_text, enable_rag, teacher_id')
      .eq('chatbot_id', chatbot_id)
      .eq('bot_type', 'assessment')
      .single();

    if (botConfigError || !assessmentBotConfig) {
      console.error(`[API /assessment/process] CRITICAL: Error fetching assessment bot ${chatbot_id} config:`, botConfigError?.message);
      return NextResponse.json({ error: 'Assessment bot configuration not found or not an assessment bot.' }, { status: 404 });
    }
    if (!assessmentBotConfig.assessment_criteria_text) {
      console.warn(`[API /assessment/process] CRITICAL: Assessment bot ${chatbot_id} has no assessment criteria defined.`);
        await adminSupabase.from('chat_messages').insert({
            room_id: room_id, user_id: userId, role: 'system',
            content: "This assessment bot doesn't have its criteria defined by the teacher yet. Please set the criteria in the chatbot configuration.",
            metadata: { chatbotId: chatbot_id, isAssessmentFeedback: true, error: "Missing assessment criteria" }
        });
        return NextResponse.json({ success: true, message: "Assessment criteria missing, user notified." });
    }
    console.log(`[API /assessment/process] Fetched bot config. RAG enabled: ${assessmentBotConfig.enable_rag}`);

    // 2. Fetch the conversation segment to be assessed
    const { data: conversationMessages, error: messagesError } = await adminSupabase
      .from('chat_messages')
      .select('role, content, user_id')
      .in('message_id', message_ids_to_assess)
      .order('created_at', { ascending: true });

    if (messagesError || !conversationMessages || conversationMessages.length === 0) {
      console.error(`[API /assessment/process] CRITICAL: Error fetching conversation messages for assessment:`, messagesError?.message);
      return NextResponse.json({ error: 'Could not retrieve conversation for assessment.' }, { status: 500 });
    }
    console.log(`[API /assessment/process] Fetched ${conversationMessages.length} conversation messages.`);

    const conversationSegmentForPrompt = conversationMessages
      .map(m => `${m.user_id === userId ? (isTestByTeacher ? 'Tester (Teacher)' : 'Student') : 'Quiz Bot'}: ${m.content}`)
      .join('\n');

    // 3. Fetch the original passage/document text if this bot is RAG-enabled
    let originalPassageText = "No specific passage was used by the Quiz Bot for these questions, or it could not be retrieved for this assessment.";
    if (assessmentBotConfig.enable_rag) {
      console.log(`[API /assessment/process] Bot has RAG. Fetching primary document for passage context.`);
      const { data: botDocument, error: docError } = await adminSupabase
        .from('documents')
        .select('file_path, file_type')
        .eq('chatbot_id', chatbot_id)
        .order('created_at', { ascending: false })
        .limit(1)
        .single();

      if (docError || !botDocument) {
        console.warn(`[API /assessment/process] No document found for RAG-enabled assessment bot ${chatbot_id}, or error:`, docError?.message);
      } else {
        try {
          console.log(`[API /assessment/process] Downloading document: ${botDocument.file_path}`);
          const { data: fileData, error: downloadError } = await adminSupabase.storage.from('documents').download(botDocument.file_path);
          if (!downloadError && fileData) {
            originalPassageText = await extractTextFromFile(Buffer.from(await fileData.arrayBuffer()), botDocument.file_type as DocumentType);
            console.log(`[API /assessment/process] Extracted text from passage (length: ${originalPassageText.length}).`);
          } else { console.warn(`[API /assessment/process] Failed to download document ${botDocument.file_path}:`, downloadError?.message); }
        } catch (extractionError) { console.warn(`[API /assessment/process] Error extracting text from document ${botDocument.file_path}:`, extractionError); }
      }
    }

    // 4. Construct the detailed assessment prompt for the LLM
    const finalAssessmentPrompt = `
You are an AI teaching assistant. Your task is to evaluate a student's (or tester's) interaction based on the teacher's criteria, the original passage (if provided), and the conversation history.

Teacher's Assessment Criteria:
--- TEACHER'S CRITERIA START ---
${assessmentBotConfig.assessment_criteria_text}
--- TEACHER'S CRITERIA END ---

Original Passage Context (if applicable, MCQs should be based on this):
--- ORIGINAL PASSAGE START ---
${originalPassageText}
--- ORIGINAL PASSAGE END ---

Conversation History to Assess (User is '${isTestByTeacher ? 'Tester (Teacher)' : 'Student'}'):
--- CONVERSATION HISTORY START ---
${conversationSegmentForPrompt}
--- CONVERSATION HISTORY END ---

Provide your evaluation ONLY as a single, valid JSON object matching the following structure EXACTLY:
{
  "grade": "string (e.g., 'Meets Expectations', '8/10', 'B', 'Needs Improvement'. Be concise.)",
  "student_feedback": "string (2-4 sentences of constructive feedback for the student, directly addressing their performance against the criteria. Start with 'Here is some feedback on your interaction:')",
  "teacher_analysis": {
    "summary": "string (A 1-2 sentence overall summary of the student's performance for the teacher.)",
    "strengths": [
      "string (A specific strength observed, referencing criteria/conversation. Be specific.)",
      "string (Another specific strength, if any. Up to 2-3 strengths total.)"
    ],
    "areas_for_improvement": [
      "string (A specific area for improvement, referencing criteria/conversation. Be specific.)",
      "string (Another specific area, if any. Up to 2-3 areas total.)"
    ],
    "grading_rationale": "string (A brief explanation of how the grade was derived based on the criteria and the student's performance in the conversation.)"
  }
}

Ensure all string values are properly escaped within the JSON. Do not include any text outside of this JSON object.
`;

    // 5. Call the Assessment LLM
    console.log(`[API /assessment/process] STEP 5: Calling Assessment LLM: ${ASSESSMENT_LLM_MODEL}.`);
    let llmOutput: LLMAssessmentOutput = {
        grade: "Error: AI Grade Not Generated",
        student_feedback: "An error occurred during AI assessment. The AI could not generate feedback based on your interaction. Please inform your teacher.",
        teacher_analysis: {
            summary: "AI assessment could not be completed due to an error or unexpected LLM response.",
            strengths: [],
            areas_for_improvement: [],
            grading_rationale: "Error during LLM processing or response parsing."
        }
    };
    let aiAssessmentDetailsRaw = JSON.stringify({ error: "LLM call not successfully completed or parsing failed." }); // Full raw response from LLM provider
    let llmCallSuccessful = false;

    try {
        const assessmentLLMResponse = await fetch(OPENROUTER_API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
                'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
                'X-Title': 'ClassBots AI - Assessment Processing'
            },
            body: JSON.stringify({
                model: ASSESSMENT_LLM_MODEL,
                messages: [{ role: 'user', content: finalAssessmentPrompt }],
                temperature: 0.3,
                max_tokens: 800,
                response_format: { type: "json_object" }
            })
        });

        aiAssessmentDetailsRaw = await assessmentLLMResponse.text(); // Store the full raw text response

        if (!assessmentLLMResponse.ok) {
            console.error(`[API /assessment/process] LLM CALL FAILED: Status ${assessmentLLMResponse.status}. Raw Response Preview:`, aiAssessmentDetailsRaw.substring(0, 1000));
            // llmOutput remains the default error structure
        } else {
            console.log(`[API /assessment/process] LLM Call Successful (Status ${assessmentLLMResponse.status}). Raw Response for Parsing (first 1000 chars):\n`, aiAssessmentDetailsRaw.substring(0,1000));
            try {
                const outerParsedJson = JSON.parse(aiAssessmentDetailsRaw); // This is the OpenRouter/Provider's response structure
                // console.log("[API /assessment/process] Parsed outer LLM provider response:", outerParsedJson); // For deep debugging

                const contentString = outerParsedJson.choices?.[0]?.message?.content;

                if (typeof contentString === 'string') {
                    console.log("[API /assessment/process] Extracted content string for inner JSON parse (first 500 chars):", contentString.substring(0, 500) + "...");
                    let jsonStringToParse = contentString.trim();
                    
                    const markdownJsonMatch = jsonStringToParse.match(/```json\s*([\s\S]*?)\s*```/);
                    if (markdownJsonMatch && markdownJsonMatch[1]) {
                        jsonStringToParse = markdownJsonMatch[1].trim();
                        console.log("[API /assessment/process] Extracted inner JSON from markdown block.");
                    } else {
                        if (!jsonStringToParse.startsWith('{') || !jsonStringToParse.endsWith('}')) {
                             console.warn("[API /assessment/process] Inner content string doesn't look like a direct JSON object or markdown JSON. Attempting parse anyway.");
                        }
                    }

                    const innerParsedJson = JSON.parse(jsonStringToParse);
                    console.log("[API /assessment/process] Successfully parsed inner assessment JSON:", innerParsedJson);

                    if (
                        innerParsedJson &&
                        typeof innerParsedJson.grade === 'string' &&
                        typeof innerParsedJson.student_feedback === 'string' &&
                        typeof innerParsedJson.teacher_analysis === 'object' &&
                        innerParsedJson.teacher_analysis !== null &&
                        typeof innerParsedJson.teacher_analysis.summary === 'string' &&
                        Array.isArray(innerParsedJson.teacher_analysis.strengths) &&
                        Array.isArray(innerParsedJson.teacher_analysis.areas_for_improvement) &&
                        typeof innerParsedJson.teacher_analysis.grading_rationale === 'string'
                    ) {
                        llmOutput = innerParsedJson as LLMAssessmentOutput;
                        llmCallSuccessful = true;
                        console.log(`[API /assessment/process] Successfully validated structured assessment from LLM. Grade: ${llmOutput.grade}`);
                    } else {
                        console.warn(`[API /assessment/process] LLM response valid inner JSON but missed one or more expected fields. Parsed inner JSON:`, innerParsedJson);
                        llmOutput.grade = typeof innerParsedJson.grade === 'string' ? innerParsedJson.grade : "Format Error (Grade Missing)";
                        llmOutput.student_feedback = typeof innerParsedJson.student_feedback === 'string' ? innerParsedJson.student_feedback : "AI feedback format was incomplete.";
                        if (typeof innerParsedJson.teacher_analysis === 'object' && innerParsedJson.teacher_analysis !== null) {
                            llmOutput.teacher_analysis.summary = typeof innerParsedJson.teacher_analysis.summary === 'string' ? innerParsedJson.teacher_analysis.summary : "Summary missing.";
                            llmOutput.teacher_analysis.strengths = Array.isArray(innerParsedJson.teacher_analysis.strengths) ? innerParsedJson.teacher_analysis.strengths : [];
                            llmOutput.teacher_analysis.areas_for_improvement = Array.isArray(innerParsedJson.teacher_analysis.areas_for_improvement) ? innerParsedJson.teacher_analysis.areas_for_improvement : [];
                            llmOutput.teacher_analysis.grading_rationale = typeof innerParsedJson.teacher_analysis.grading_rationale === 'string' ? innerParsedJson.teacher_analysis.grading_rationale : "Rationale missing.";
                        }
                    }
                } else {
                    console.error("[API /assessment/process] 'content' string not found or not a string in LLM choices. Full choices[0].message:", outerParsedJson.choices?.[0]?.message);
                }
            } catch (parseError) {
                console.error(`[API /assessment/process] FAILED TO PARSE JSON (either outer provider response or inner content string). Raw Preview:`, aiAssessmentDetailsRaw.substring(0, 1000), parseError);
            }
        }
    } catch (llmCallException) {
        console.error(`[API /assessment/process] EXCEPTION during Assessment LLM call:`, llmCallException);
        aiAssessmentDetailsRaw = JSON.stringify({ error: `LLM Call Exception: ${llmCallException instanceof Error ? llmCallException.message : String(llmCallException)}` });
    }
    
    let savedAssessmentId: string | null = null;
    const assessmentStatusToSave: AssessmentStatusEnum = llmCallSuccessful ? 'ai_completed' : 'ai_processing';

    if (!isTestByTeacher) {
      console.log(`[API /assessment/process] STEP 6: Attempting to save student assessment. Student ID: ${userId}, LLM Call Successful: ${llmCallSuccessful}, Status to Save: ${assessmentStatusToSave}`);
      const insertPayload = {
        student_id: userId,
        chatbot_id: chatbot_id,
        room_id: room_id,
        assessed_message_ids: message_ids_to_assess,
        teacher_id: assessmentBotConfig.teacher_id,
        teacher_assessment_criteria_snapshot: assessmentBotConfig.assessment_criteria_text,
        ai_feedback_student: llmOutput.student_feedback,
        ai_assessment_details_raw: aiAssessmentDetailsRaw,
        ai_grade_raw: llmOutput.grade,
        ai_assessment_details_teacher: llmOutput.teacher_analysis,
        status: assessmentStatusToSave,
      };
      // console.log("[API /assessment/process] Payload for student_assessments insert:", JSON.stringify(insertPayload, null, 2));

      const { data: savedAssessmentData, error: assessmentSaveError } = await adminSupabase
        .from('student_assessments')
        .insert(insertPayload)
        .select('assessment_id').single();

      if (assessmentSaveError) {
        console.error(`[API /assessment/process] CRITICAL: Error saving student assessment to DB:`, assessmentSaveError.message, assessmentSaveError.details, assessmentSaveError.hint);
      } else if (savedAssessmentData) {
        savedAssessmentId = savedAssessmentData.assessment_id;
        console.log(`[API /assessment/process] Student assessment ${savedAssessmentId} saved successfully with status: ${assessmentStatusToSave}.`);
      } else {
        console.warn(`[API /assessment/process] Student assessment insert attempt completed but no data/ID returned, and no explicit error.`);
      }
    } else {
        console.log(`[API /assessment/process] STEP 6: Teacher test assessment. LLM Call Successful: ${llmCallSuccessful}. Skipping save to student_assessments table.`);
    }

    console.log(`[API /assessment/process] STEP 7: Inserting feedback message into chat_messages for user ${userId}. Feedback snippet: "${String(llmOutput.student_feedback).substring(0, 100)}..."`);
    const { error: feedbackMessageError } = await adminSupabase
        .from('chat_messages')
        .insert({
            room_id: room_id, 
            user_id: userId,
            role: 'system', 
            content: llmOutput.student_feedback,
            metadata: {
                chatbotId: chatbot_id, 
                isAssessmentFeedback: true,
                assessmentId: savedAssessmentId 
            }
        });

    if (feedbackMessageError) {
        console.error(`[API /assessment/process] Error inserting feedback message into chat_messages for user ${userId}:`, 
            feedbackMessageError.message, feedbackMessageError.details, feedbackMessageError.hint);
    } else {
        console.log(`[API /assessment/process] Feedback message successfully inserted into chat for user ${userId}.`);
    }

    console.log('[API /assessment/process] Processing complete. Returning response.');
    console.log('--------------------------------------------------');
    return NextResponse.json({ success: true, message: 'Assessment processed.', assessmentId: savedAssessmentId });

  } catch (error) {
    console.error('[API /assessment/process] CRITICAL UNHANDLED error:', error);
    console.log('--------------------------------------------------');
    return NextResponse.json({ error: 'Failed to process assessment due to a critical internal server error.' }, { status: 500 });
  }
}// src/app/api/teacher/assessments/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
// Ensure all necessary types from database.types.ts are imported
import type {
    StudentAssessment,
    Profile,
    ChatMessage as DbChatMessage,
    AssessmentStatusEnum,
    AssessmentListSummary,      // These should be in your database.types.ts now
    PaginatedAssessmentsResponse,
    DetailedAssessmentResponse,
    UpdateAssessmentPayload
} from '@/types/database.types';


// getSingleDetailedAssessment function (remains exactly as in your provided code)
async function getSingleDetailedAssessment(
    assessmentId: string,
    requestingUserId: string,
    adminSupabase: ReturnType<typeof createAdminClient>
): Promise<NextResponse> {
    console.log(`[API GET /assessments?assessmentId=${assessmentId}] Fetching single assessment details.`);
    const { data: assessment, error: assessmentError } = await adminSupabase.from('student_assessments').select('*').eq('assessment_id', assessmentId).single();
    if (assessmentError || !assessment) { return NextResponse.json({ error: 'Assessment not found or error fetching it.' }, { status: 404 }); }
    const { data: chatbotOwner, error: chatbotOwnerError } = await adminSupabase.from('chatbots').select('teacher_id, name').eq('chatbot_id', assessment.chatbot_id).single();
    if (chatbotOwnerError || !chatbotOwner || chatbotOwner.teacher_id !== requestingUserId) { return NextResponse.json({ error: 'Not authorized to view this assessment' }, { status: 403 });}
    let studentProfile: Pick<Profile, 'full_name' | 'email'> | null = null;
    if (assessment.student_id) {
        const { data: studentData } = await adminSupabase.from('profiles').select('full_name, email').eq('user_id', assessment.student_id).single();
        studentProfile = studentData;
    }
    let assessedConversation: DbChatMessage[] = [];
    if (assessment.assessed_message_ids && Array.isArray(assessment.assessed_message_ids) && assessment.assessed_message_ids.length > 0) {
        const { data: messagesData } = await adminSupabase.from('chat_messages').select('*').in('message_id', assessment.assessed_message_ids).order('created_at', { ascending: true });
        assessedConversation = (messagesData || []) as DbChatMessage[];
    }
    const responseData: DetailedAssessmentResponse = {
        ...(assessment as StudentAssessment), student_name: studentProfile?.full_name || null, student_email: studentProfile?.email || null,
        chatbot_name: chatbotOwner?.name || null, assessed_conversation: assessedConversation,
    };
    return NextResponse.json(responseData);
}


export async function GET(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const assessmentId = searchParams.get('assessmentId');
    const page = parseInt(searchParams.get('page') || '0', 10);
    const limit = parseInt(searchParams.get('limit') || '10', 10);
    const statusFilter = searchParams.get('status') as AssessmentStatusEnum | null;
    const roomIdFilter = searchParams.get('roomId');
    const studentIdFilter = searchParams.get('studentId');

    console.log(`[API GET /assessments] Request: assessmentId=${assessmentId||'list'}, page=${page}, limit=${limit}, status=${statusFilter||'all'}`);

    const supabaseUserClient = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();

    const { data: { user }, error: authError } = await supabaseUserClient.auth.getUser();
    if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }

    const { data: profile, error: profileError } = await supabaseUserClient.from('profiles').select('role').eq('user_id', user.id).single();
    if (profileError || !profile || profile.role !== 'teacher') { return NextResponse.json({ error: 'Not authorized' }, { status: 403 });}
    
    if (assessmentId) {
        return getSingleDetailedAssessment(assessmentId, user.id, adminSupabase);
    } else {
        console.log(`[API GET /assessments] Fetching list for teacher ${user.id}. Filters: status=${statusFilter}, room=${roomIdFilter}, student=${studentIdFilter}`);
        const offset = page * limit;
        try {
            const studentForeignKeyHint = "!student_assessments_student_id_fkey"; // Using the name from your FK list
            const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey"; // Using the name from your FK list

            let query = adminSupabase
                .from('student_assessments')
                .select(`
                    assessment_id,
                    student_id,
                    chatbot_id,
                    room_id,
                    teacher_id, 
                    assessed_at,
                    ai_grade_raw,
                    teacher_override_grade,
                    status,
                    student:profiles${studentForeignKeyHint}!inner(full_name), 
                    chatbot:chatbots${chatbotForeignKeyHint}!inner(name)
                `, { count: 'exact' })
                .eq('teacher_id', user.id) 
                .order('assessed_at', { ascending: false })
                .range(offset, offset + limit - 1);

            if (statusFilter) query = query.eq('status', statusFilter);
            if (roomIdFilter) query = query.eq('room_id', roomIdFilter);
            if (studentIdFilter) query = query.eq('student_id', studentIdFilter);

            const { data, error, count } = await query;

            if (error) {
                console.error(`[API GET /assessments] DB Error fetching list (initial query):`, JSON.stringify(error, null, 2));
                throw error;
            }

            if (!data) { // Should not happen if error is null, but good check
                console.warn("[API GET /assessments] No assessment data returned from initial query, though no explicit error.");
                 return NextResponse.json({ assessments: [], pagination: { currentPage: page, pageSize: limit, totalCount: 0, totalPages: 0 }});
            }
            
            // Step 2: Fetch room names separately for valid UUID room_ids
            const roomIdsToFetchNames = [...new Set(
                data.map(item => item.room_id).filter(id => id && !id.startsWith('teacher_test_room_'))
            )] as string[]; // Ensure it's an array of strings

            const roomNamesMap: Map<string, string> = new Map();
            if (roomIdsToFetchNames.length > 0) {
                const { data: roomData, error: roomNameError } = await adminSupabase
                    .from('rooms')
                    .select('room_id, room_name')
                    .in('room_id', roomIdsToFetchNames);
                
                if (roomNameError) {
                    console.warn("[API GET /assessments] Error fetching room names separately:", roomNameError.message);
                } else if (roomData) {
                    roomData.forEach(room => roomNamesMap.set(room.room_id, room.room_name));
                }
            }

            const assessments: AssessmentListSummary[] = data.map(item => {
                const studentData = item.student as { full_name?: string | null } | null;
                const chatbotData = item.chatbot as { name?: string | null } | null;
                
                let resolvedRoomName = 'N/A';
                if (item.room_id) {
                    if (item.room_id.startsWith('teacher_test_room_')) {
                        resolvedRoomName = 'Teacher Test Chat';
                    } else if (roomNamesMap.has(item.room_id)) {
                        resolvedRoomName = roomNamesMap.get(item.room_id)!;
                    } else {
                        // Fallback if room_id is a UUID but not found in rooms table (e.g., room deleted)
                        resolvedRoomName = `Room ID: ${item.room_id.substring(0,8)}...`;
                    }
                }

                return {
                    assessment_id: item.assessment_id, student_id: item.student_id, chatbot_id: item.chatbot_id,
                    room_id: item.room_id, teacher_id: item.teacher_id, assessed_at: item.assessed_at,
                    ai_grade_raw: item.ai_grade_raw, teacher_override_grade: item.teacher_override_grade, status: item.status,
                    student_name: studentData?.full_name || 'N/A',
                    chatbot_name: chatbotData?.name || 'N/A',
                    room_name: resolvedRoomName
                };
            });
            
            const totalCount = count || 0;
            const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;
            const responsePayload: PaginatedAssessmentsResponse = {
                assessments,
                pagination: { currentPage: page, pageSize: limit, totalCount, totalPages }
            };
            console.log(`[API GET /assessments] Returning ${assessments.length} assessments. Total: ${totalCount}`);
            return NextResponse.json(responsePayload);

        } catch (error) {
            console.error(`[API GET /assessments] CATCH BLOCK fetching list:`, error);
            return NextResponse.json({ error: 'Failed to fetch assessments list' }, { status: 500 });
        }
    }
}

// PATCH handler (remains exactly as you provided)
export async function PATCH(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const assessmentId = searchParams.get('assessmentId');
    if (!assessmentId) { return NextResponse.json({ error: 'Assessment ID is required for PATCH' }, { status: 400 });}
    console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] Request to update.`);
    const supabaseUserClient = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();
    try {
        const { data: { user }, error: authError } = await supabaseUserClient.auth.getUser();
        if (authError || !user) { return NextResponse.json({ error: 'Not authenticated' }, { status: 401 }); }
        const { data: assessment, error: fetchError } = await adminSupabase.from('student_assessments').select('chatbot_id').eq('assessment_id', assessmentId).single();
        if (fetchError || !assessment) { return NextResponse.json({ error: 'Assessment not found' }, { status: 404 });}
        const { data: chatbotOwner, error: chatbotOwnerError } = await adminSupabase.from('chatbots').select('teacher_id').eq('chatbot_id', assessment.chatbot_id).single();
        if (chatbotOwnerError || !chatbotOwner || chatbotOwner.teacher_id !== user.id) { return NextResponse.json({ error: 'Not authorized' }, { status: 403 });}
        const body: UpdateAssessmentPayload = await request.json();
        const updateData: Partial<Omit<StudentAssessment, 'created_at' | 'assessment_id'>> = {};
        if (body.hasOwnProperty('teacher_override_grade')) updateData.teacher_override_grade = body.teacher_override_grade;
        if (body.hasOwnProperty('teacher_override_notes')) updateData.teacher_override_notes = body.teacher_override_notes;
        if (body.status) {
            const validStatuses: AssessmentStatusEnum[] = ['ai_processing', 'ai_completed', 'teacher_reviewed'];
            if (validStatuses.includes(body.status)) updateData.status = body.status;
            else console.warn(`[API PATCH /assessments?assessmentId=${assessmentId}] Invalid status: ${body.status}`);
        }
        updateData.updated_at = new Date().toISOString();
        if (Object.keys(updateData).length <= 1 && updateData.updated_at) { console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] No data fields to update.`); }
        console.log(`[API PATCH /assessments?assessmentId=${assessmentId}] Updating with:`, updateData);
        const { data: updatedAssessment, error: updateError } = await adminSupabase.from('student_assessments').update(updateData).eq('assessment_id', assessmentId).select().single();
        if (updateError) { return NextResponse.json({ error: 'Failed to update assessment', details: updateError.message }, { status: 500 });}
        return NextResponse.json(updatedAssessment);
    } catch (error) {
        console.error(`[API PATCH /assessments?assessmentId=${assessmentId}] General error:`, error);
        if (error instanceof SyntaxError) return NextResponse.json({ error: 'Invalid JSON payload.' }, { status: 400 });
        return NextResponse.json({ error: 'Internal server error during PATCH.' }, { status: 500 });
    }
}// src/app/api/teacher/student-room-details/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import type { Profile, StudentAssessment, FlaggedMessage } from '@/types/database.types';

// Simplified types for summaries
interface AssessmentSummaryForStudent extends Pick<StudentAssessment, 'assessment_id' | 'chatbot_id' | 'assessed_at' | 'ai_grade_raw' | 'teacher_override_grade' | 'status'> {
  chatbot_name?: string | null;
}

interface ConcernSummaryForStudent extends Pick<FlaggedMessage, 'flag_id' | 'concern_type' | 'concern_level' | 'created_at' | 'status'> {
  message_preview?: string | null;
}

interface StudentRoomDetailsResponse {
  student: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null;
  assessments: AssessmentSummaryForStudent[];
  concerns: ConcernSummaryForStudent[];
  // We could add a flag like hasChatHistory: boolean;
}

export async function GET(request: NextRequest) {
  console.log('[API GET /teacher/student-room-details] Received request.');
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');

    if (!roomId || !studentId) {
      console.warn('[API GET /student-room-details] roomId or studentId query parameter is missing.');
      return NextResponse.json({ error: 'Room ID and Student ID are required' }, { status: 400 });
    }
    console.log(`[API GET /student-room-details] Processing for roomId: ${roomId}, studentId: ${studentId}`);

    const supabase = await createServerSupabaseClient(); // User-context client
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /student-room-details] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify teacher role
    const { data: teacherProfile, error: teacherProfileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (teacherProfileError || !teacherProfile || teacherProfile.role !== 'teacher') {
      console.warn(`[API GET /student-room-details] User ${user.id} not a teacher or profile error.`);
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }
    console.log(`[API GET /student-room-details] User ${user.id} authenticated as teacher.`);

    // Verify teacher owns the room
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !roomData) {
      console.warn(`[API GET /student-room-details] Room ${roomId} not found or teacher ${user.id} not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    // Verify student is a member of this room
    const { data: membership, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      console.warn(`[API GET /student-room-details] Student ${studentId} is not a member of room ${roomId}:`, membershipError?.message);
      return NextResponse.json({ error: 'Student not found in this room' }, { status: 404 });
    }
    console.log(`[API GET /student-room-details] Verified teacher ownership and student membership for room ${roomId}, student ${studentId}.`);

    const adminSupabase = createAdminClient();

    // Fetch student profile
    const { data: studentProfileData, error: studentProfileFetchError } = await adminSupabase
      .from('profiles')
      .select('user_id, full_name, email')
      .eq('user_id', studentId)
      .single();

    if (studentProfileFetchError || !studentProfileData) {
      console.error(`[API GET /student-room-details] Error fetching profile for student ${studentId}:`, studentProfileFetchError?.message);
      // Continue, but student info might be partial
    }
    
    const studentInfo: Pick<Profile, 'user_id' | 'full_name' | 'email'> | null = studentProfileData 
        ? { user_id: studentProfileData.user_id, full_name: studentProfileData.full_name || 'Student', email: studentProfileData.email || 'No email' } 
        : null;

    // Fetch assessments for this student in this room (limit for summary, e.g., last 10)
    // Re-using the foreign key hint strategy from the main assessments list API
    const chatbotForeignKeyHint = "!student_assessments_chatbot_id_fkey";
    const { data: assessmentsData, error: assessmentsError } = await adminSupabase
      .from('student_assessments')
      .select(`
        assessment_id,
        chatbot_id,
        assessed_at,
        ai_grade_raw,
        teacher_override_grade,
        status,
        chatbot:chatbots${chatbotForeignKeyHint}!inner(name)
      `)
      .eq('student_id', studentId)
      .eq('room_id', roomId) // Filter by room
      .eq('teacher_id', user.id) // And ensure teacher owns the assessment bot
      .order('assessed_at', { ascending: false })
      .limit(10); // Example limit

    if (assessmentsError) {
      console.error(`[API GET /student-room-details] Error fetching assessments for student ${studentId} in room ${roomId}:`, assessmentsError.message);
    }
    const assessments: AssessmentSummaryForStudent[] = (assessmentsData || []).map(item => {
        const chatbotData = item.chatbot as { name?: string | null } | null; // Type assertion
        return {
            assessment_id: item.assessment_id,
            chatbot_id: item.chatbot_id,
            assessed_at: item.assessed_at,
            ai_grade_raw: item.ai_grade_raw,
            teacher_override_grade: item.teacher_override_grade,
            status: item.status,
            chatbot_name: chatbotData?.name || 'N/A'
        };
    });
    console.log(`[API GET /student-room-details] Fetched ${assessments.length} assessments for student ${studentId} in room ${roomId}.`);

    // Fetch flagged concerns for this student in this room (limit for summary)
    const { data: concernsData, error: concernsError } = await adminSupabase
      .from('flagged_messages')
      .select('flag_id, concern_type, concern_level, created_at, status, message:chat_messages!fk_message(content)') // Include message content for preview
      .eq('student_id', studentId)
      .eq('room_id', roomId) // Filter by room
      .eq('teacher_id', user.id) // Ensure teacher owns the concern record
      .order('created_at', { ascending: false })
      .limit(10); // Example limit

    if (concernsError) {
      console.error(`[API GET /student-room-details] Error fetching concerns for student ${studentId} in room ${roomId}:`, concernsError.message);
    }
    const concerns: ConcernSummaryForStudent[] = (concernsData || []).map(item => {
        const messageData = item.message as { content?: string | null } | null; // Type assertion
        return {
            flag_id: item.flag_id,
            concern_type: item.concern_type,
            concern_level: item.concern_level,
            created_at: item.created_at,
            status: item.status,
            message_preview: messageData?.content?.substring(0, 50) + (messageData?.content && messageData.content.length > 50 ? '...' : '') || null
        };
    });
    console.log(`[API GET /student-room-details] Fetched ${concerns.length} concerns for student ${studentId} in room ${roomId}.`);

    const responsePayload: StudentRoomDetailsResponse = {
      student: studentInfo,
      assessments,
      concerns,
    };

    console.log(`[API GET /student-room-details] Successfully prepared data. Returning response.`);
    return NextResponse.json(responsePayload);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string };
    console.error('[API GET /student-room-details] CATCH BLOCK Error:', typedError.message, 'Code:', typedError.code, 'Details:', typedError.details);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch student room details' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/student-chats/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface ChatbotInfoFromDB {
  chatbot_id: string;
  name: string;
}

interface RoomChatbotResponseFromDB {
  chatbot_id: string;
  chatbots: ChatbotInfoFromDB;
}

export async function GET(request: NextRequest) {
  try {
    // Extract query parameters instead of path parameters
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    const studentId = searchParams.get('studentId');
    const chatbotIdFilter = searchParams.get('chatbotId');

    console.log("Fetching chats for student:", studentId, "in room:", roomId);

    if (!roomId || !studentId) {
      return NextResponse.json({ error: 'Room ID and Student ID are required' }, { status: 400 });
    }

    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.error("Room fetch error or unauthorized:", roomError);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    const { data: membership, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id')
      .eq('room_id', roomId)
      .eq('student_id', studentId)
      .single();

    if (membershipError || !membership) {
      console.error("Membership fetch error or not a member:", membershipError);
      return NextResponse.json({ error: 'Student is not a member of this room' }, { status: 404 });
    }

    let query = supabase
      .from('chat_messages')
      .select('*')
      .eq('room_id', roomId)
      .eq('user_id', studentId)
      .order('created_at', { ascending: true });

    if (chatbotIdFilter) {
      query = query.filter('metadata->>chatbotId', 'eq', chatbotIdFilter);
    }

    const { data: messagesData, error: messagesError } = await query;

    if (messagesError) {
      console.error("Error fetching messages:", messagesError);
      return NextResponse.json({ error: 'Failed to fetch chat messages' }, { status: 500 });
    }

    const allMessages: DatabaseChatMessage[] = (messagesData as DatabaseChatMessage[] | null) || [];

    const { data: roomChatbotsDataRaw, error: chatbotsError } = await supabase
      .from('room_chatbots')
      .select(`
        chatbot_id,
        chatbots:chatbots!inner(
          chatbot_id,
          name
        )
      `)
      .eq('room_id', roomId);

    if (chatbotsError) {
      console.error("Error fetching room chatbots:", chatbotsError);
    }

    const availableChatbots: Array<{ chatbot_id: string; name: string }> = [];
    if (roomChatbotsDataRaw && roomChatbotsDataRaw.length > 0) {
      const typedRoomChatbots = roomChatbotsDataRaw as unknown as RoomChatbotResponseFromDB[];
      typedRoomChatbots.forEach(item => {
        if (item.chatbots && typeof item.chatbots === 'object') {
          availableChatbots.push({
            chatbot_id: item.chatbots.chatbot_id,
            name: item.chatbots.name
          });
        }
      });
    }

    const conversations: Conversation[] = [];
    let currentConversation: Conversation | null = null;
    let currentChatbotIdForConversation: string | null = null;

    for (const message of allMessages) {
      const msgChatbotId = message.metadata?.chatbotId || null;

      if (currentConversation === null || msgChatbotId !== currentChatbotIdForConversation) {
        if (currentConversation) {
          conversations.push(currentConversation);
        }
        const matchingChatbot = availableChatbots.find(c => c.chatbot_id === msgChatbotId);
        currentChatbotIdForConversation = msgChatbotId;
        currentConversation = {
          chatbot_id: msgChatbotId,
          chatbot_name: matchingChatbot ? matchingChatbot.name : (msgChatbotId ? 'Unknown Chatbot' : 'General Chat'),
          started_at: message.created_at,
          messages: [message],
        };
      } else {
        currentConversation.messages.push(message);
      }
    }

    if (currentConversation) {
      conversations.push(currentConversation);
    }

    return NextResponse.json({
      conversations,
      chatbots: availableChatbots,
      pagination: { hasMore: false }
    });

  } catch (error) {
    console.error('Error fetching student chats:', error);
    if (error instanceof Error) {
      console.error('Error details:', error.message, error.stack);
    }
    return NextResponse.json(
      { error: 'Failed to fetch student chats' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/students/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server'; // For initial auth and room check
import { createAdminClient } from '@/lib/supabase/admin';         // << IMPORT ADMIN CLIENT

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient(); // Standard client for user context
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API /teacher/students] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API /teacher/students] Authenticated user:', user.id);

    // Verify teacher owns the room using the standard client (respects RLS)
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      console.warn(`[API /teacher/students] Room not found (ID: ${roomId}) or teacher (ID: ${user.id}) not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }
    console.log(`[API /teacher/students] Teacher ${user.id} authorized for room ${roomId}.`);

    // Fetch memberships using the standard client (respects RLS)
    const { data: memberships, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id, joined_at')
      .eq('room_id', roomId);

    if (membershipError) {
      console.error(`[API /teacher/students] Failed to fetch room memberships for room ${roomId}:`, membershipError.message);
      return NextResponse.json(
        { error: `Failed to fetch room memberships: ${membershipError.message}` },
        { status: 500 }
      );
    }

    if (!memberships || memberships.length === 0) {
      console.log(`[API /teacher/students] No student memberships found for room ${roomId}.`);
      return NextResponse.json([]); // No students in the room
    }

    const studentIds = memberships.map(m => m.student_id);
    console.log(`[API /teacher/students] Student IDs in room ${roomId}:`, studentIds);

    // >> MODIFICATION: Use Admin Client to fetch profiles <<
    const adminSupabase = createAdminClient(); 

    const { data: profilesData, error: profilesError } = await adminSupabase
      .from('profiles')
      .select('user_id, full_name, email') // Select only necessary fields
      .in('user_id', studentIds);

    if (profilesError) {
      console.error(`[API /teacher/students] Admin client failed to fetch profiles for student IDs (${studentIds.join(', ')}):`, profilesError.message);
      // Fall through, error will be handled by studentData mapping if profilesData is null/empty
    } else {
        console.log('[API /teacher/students] Profiles data fetched with admin client:', profilesData);
    }
    
    const studentData = await Promise.all(
      memberships.map(async (membership) => {
        const profile = profilesData?.find(p => p.user_id === membership.student_id);
        
        let name = "Student"; 
        let email = "No email available";

        if (profile) {
          if (profile.full_name) name = profile.full_name;
          else if (profile.email) name = profile.email.split('@')[0]; // Fallback to email username if full_name is missing
          
          if (profile.email) email = profile.email;
        }
        console.log(`[API /teacher/students] Student ${membership.student_id} initial data from profiles: Name='${name}', Email='${email}'`);

        // Fallback to auth.admin.getUserById if profile info is still default,
        // AND if the admin client was available (service_role key is set)
        if ((name === "Student" || email === "No email available") && process.env.SUPABASE_SERVICE_ROLE_KEY) {
          console.log(`[API /teacher/students] Profile for ${membership.student_id} still default, trying auth.admin.getUserById.`);
          try {
            // Use the adminSupabase instance for auth.admin calls too
            const { data: authUserData, error: authUserError } = await adminSupabase.auth.admin.getUserById(membership.student_id);

            if (authUserError) {
              console.warn(`[API /teacher/students] auth.admin.getUserById error for student ${membership.student_id}:`, authUserError.message);
            } else if (authUserData?.user) {
              const fetchedUser = authUserData.user;
              console.log(`[API /teacher/students] auth.admin.getUserById success for ${membership.student_id}. Email: ${fetchedUser.email}, Metadata:`, fetchedUser.user_metadata);
              if (name === "Student") { // Only overwrite if still default
                if (fetchedUser.user_metadata?.full_name) name = fetchedUser.user_metadata.full_name;
                else if (fetchedUser.user_metadata?.name) name = fetchedUser.user_metadata.name;
                else if (fetchedUser.email) name = fetchedUser.email.split('@')[0];
              }
              if (email === "No email available" && fetchedUser.email) { // Only overwrite if still default
                email = fetchedUser.email;
              }
            } else {
              console.log(`[API /teacher/students] auth.admin.getUserById for ${membership.student_id} returned no user data.`);
            }
          } catch (e) {
            console.error(`[API /teacher/students] Exception calling auth.admin.getUserById for ${membership.student_id}:`, e);
          }
        }
        
        console.log(`[API /teacher/students] Final data for student ${membership.student_id}: Name='${name}', Email='${email}'`);
        return {
          user_id: membership.student_id,
          name,
          email,
          joined_at: membership.joined_at,
        };
      })
    );

    return NextResponse.json(studentData);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: unknown };
    console.error('[API /teacher/students] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to fetch students' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/room-chatbots-associations/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { UpdateRoomChatbotsPayload } from '@/types/database.types';

// GET current chatbots for a room
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');
  
  console.log(`[API GET /room-chatbots-associations] Request for roomId: ${roomId}`);

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID query parameter is required' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    const { data: roomChatbots, error } = await supabase
      .from('room_chatbots')
      .select('chatbot_id') 
      .eq('room_id', roomId);

    if (error) {
      console.error(`[API GET /room-chatbots-associations] Error fetching room chatbots for ${roomId}:`, error);
      return NextResponse.json({ error: 'Failed to fetch room chatbots' }, { status: 500 });
    }
    
    return NextResponse.json(roomChatbots || []); 

  } catch (error) {
    console.error('[API GET /room-chatbots-associations] Catch error:', error);
    return NextResponse.json(
      { error: 'Internal server error fetching room chatbots' },
      { status: 500 }
    );
  }
}

// PUT (update) chatbots for a room
export async function PUT(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const roomId = searchParams.get('roomId');

  console.log(`[API PUT /room-chatbots-associations] Request for roomId: ${roomId}`);

  if (!roomId) {
    return NextResponse.json({ error: 'Room ID query parameter is required for PUT' }, { status: 400 });
  }

  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const body: UpdateRoomChatbotsPayload = await request.json();

    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }

    // Perform in a transaction if Supabase JS client supported it easily,
    // otherwise, it's two separate operations.
    const { error: deleteError } = await supabase
      .from('room_chatbots')
      .delete()
      .eq('room_id', roomId);

    if (deleteError) {
      console.error(`[API PUT /room-chatbots-associations] Error deleting existing room chatbots for ${roomId}:`, deleteError);
      return NextResponse.json({ error: 'Failed to clear existing chatbots for room', details: deleteError.message }, { status: 500 });
    }

    if (body.chatbot_ids && body.chatbot_ids.length > 0) {
      const newEntries = body.chatbot_ids.map(chatbotId => ({
        room_id: roomId,
        chatbot_id: chatbotId,
      }));
      const { error: insertError } = await supabase
        .from('room_chatbots')
        .insert(newEntries);

      if (insertError) {
        console.error(`[API PUT /room-chatbots-associations] Error inserting new room chatbots for ${roomId}:`, insertError);
        // Potentially try to rollback delete, or just report error.
        return NextResponse.json({ error: 'Failed to insert new chatbots for room', details: insertError.message }, { status: 500 });
      }
    }
    
    console.log(`[API PUT /room-chatbots-associations] Room chatbots updated successfully for ${roomId}.`);
    return NextResponse.json({ success: true, message: 'Room chatbots updated successfully' });

  } catch (error) {
    const typedError = error as Error;
    console.error('[API PUT /room-chatbots-associations] Catch error:', typedError.message);
    if (typedError instanceof SyntaxError) {
        return NextResponse.json({ error: 'Invalid JSON payload in PUT request.' }, { status: 400 });
    }
    return NextResponse.json(
      { error: typedError.message || 'Failed to update room chatbots' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/[chatbotId]/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function POST(request: NextRequest) {
  console.log("Document upload request received");
  
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Rest of the function remains the same
    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get file from formData
    const formData = await request.formData();
    console.log("FormData received:", formData);
    
    const file = formData.get('file') as File;
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }

    console.log("File received:", file.name, file.type, file.size);

    // Validate file type
    const fileType = getFileType(file.name);
    if (!fileType) {
      return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });
    }

    // Create storage path
    const filePath = `${user.id}/${chatbotId}/${file.name}`;
    
    // Get file buffer
    const buffer = await file.arrayBuffer();
    
    // Upload file to storage
    const { error: uploadError } = await supabase
      .storage
      .from('documents')
      .upload(filePath, buffer, {
        contentType: file.type,
        upsert: true
      });

    if (uploadError) {
      console.error("Storage upload error:", uploadError);
      return NextResponse.json({ error: `Failed to upload file: ${uploadError.message}` }, { status: 500 });
    }

    // Create document record
    const { data: document, error: documentError } = await supabase
      .from('documents')
      .insert({
        chatbot_id: chatbotId,
        file_name: file.name,
        file_path: filePath,
        file_type: fileType,
        file_size: file.size,
        status: 'uploaded'
      })
      .select()
      .single();

    if (documentError) {
      console.error("Document insert error:", documentError);
      
      // Clean up uploaded file if document record creation fails
      await supabase.storage.from('documents').remove([filePath]);
      
      return NextResponse.json({ error: `Failed to create document record: ${documentError.message}` }, { status: 500 });
    }

    return NextResponse.json({
      document: document,
      message: 'Document uploaded successfully. Processing will begin shortly.'
    });
  } catch (error) {
    console.error('Error in document upload:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to upload document' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching documents for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Check if the chatbot belongs to the user
    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('chatbot_id')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    // Get all documents for this chatbot
    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      return NextResponse.json({ error: 'Failed to fetch documents' }, { status: 500 });
    }

    return NextResponse.json(documents || []);
  } catch (error) {
    console.error('Error fetching documents:', error);
    return NextResponse.json(
      { error: 'Failed to fetch documents' },
      { status: 500 }
    );
  }
}

// Helper function to determine file type
function getFileType(fileName: string): 'pdf' | 'docx' | 'txt' | null {
  const extension = fileName.split('.').pop()?.toLowerCase();
  
  switch (extension) {
    case 'pdf': return 'pdf';
    case 'docx': case 'doc': return 'docx';
    case 'txt': return 'txt';
    default: return null;
  }
}// src/app/api/teacher/chatbots/[chatbotId]/vectorize/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { processDocument as processDocumentFile } from '@/lib/document-processing/processor';
import type { Document } from '@/types/knowledge-base.types';

export async function POST(request: NextRequest) {
  console.log("Document processing request received via POST");

  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Processing for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    let body;
    try {
      body = await request.json();
    } catch (parseError) {
      console.error("Error parsing request body:", parseError);
      return NextResponse.json({ error: 'Invalid request body format' }, { status: 400 });
    }

    const documentId = body.documentId;

    if (!documentId) {
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    const { data: document, error: documentError } = await supabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError || !document) {
      console.error("Document not found:", documentError);
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    if (document.status === 'processing') {
      return NextResponse.json({ error: 'Document is already being processed' }, { status: 400 });
    }

    const { error: updateError } = await supabase
      .from('documents')
      .update({
        status: 'processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', documentId);

    if (updateError) {
      console.error("Error updating document status:", updateError);
      return NextResponse.json({ error: 'Failed to update document status' }, { status: 500 });
    }

    // Process in the background using the imported function
    processDocumentFile(document as Document)
      .catch(error => console.error(`Background processing error for doc ${document.document_id}:`, error));

    return NextResponse.json({ message: 'Document processing started' });
  } catch (error) {
    console.error('Error in document processing endpoint (POST):', error);
    return NextResponse.json(
      { error: 'Internal server error during POST' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  console.log("Document processing status GET request received");
  try {
    // Extract chatbotId from URL
    const pathname = request.nextUrl.pathname;
    const segments = pathname.split('/');
    const chatbotId = segments[segments.indexOf('chatbots') + 1];
    
    if (!chatbotId) {
      return NextResponse.json({ error: 'Chatbot ID is required' }, { status: 400 });
    }
    
    console.log("Fetching status for chatbot ID:", chatbotId);
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const documentId = searchParams.get('documentId');

    if (!documentId) {
      return NextResponse.json({ error: 'Document ID is required' }, { status: 400 });
    }

    const { data: chatbot, error: chatbotError } = await supabase
      .from('chatbots')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .eq('teacher_id', user.id)
      .single();

    if (chatbotError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found or unauthorized' }, { status: 404 });
    }

    const { data: document, error: documentError } = await supabase
      .from('documents')
      .select('*')
      .eq('document_id', documentId)
      .eq('chatbot_id', chatbotId)
      .single();

    if (documentError || !document) {
      return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    const { data: allChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .select('status')
      .eq('document_id', documentId);

    if (chunksError) {
      return NextResponse.json({ error: 'Failed to fetch document chunks' }, { status: 500 });
    }

    const totalChunks = allChunks?.length || 0;
    const processedChunks = allChunks?.filter(chunk => chunk.status === 'embedded').length || 0;
    const errorChunks = allChunks?.filter(chunk => chunk.status === 'error').length || 0;
    const percentComplete = totalChunks ? Math.round((processedChunks / totalChunks) * 100) : 0;

    console.log(`Status for doc ${documentId}: Total ${totalChunks}, Processed ${processedChunks}, Errors ${errorChunks}, Complete ${percentComplete}%`);

    return NextResponse.json({
      document,
      processingStats: {
        totalChunks,
        processedChunks,
        errorChunks,
        percentComplete
      }
    });
  } catch (error) {
    console.error('Error fetching processing status (GET):', error);
    return NextResponse.json(
      { error: 'Failed to fetch processing status' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/chatbots/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';
import { deleteChatbotVectors } from '@/lib/pinecone/utils';
import type { CreateChatbotPayload, Chatbot as DatabaseChatbot, BotTypeEnum } from '@/types/database.types'; // MODIFIED: Added BotTypeEnum

// GET Handler
export async function GET(request: NextRequest) { // MODIFIED: Added request parameter
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    // MODIFIED: Extract query parameters for filtering and sorting
    const { searchParams } = new URL(request.url);
    const searchTerm = searchParams.get('searchTerm');
    const botType = searchParams.get('botType') as BotTypeEnum | null;
    const ragEnabledParam = searchParams.get('ragEnabled'); // Will be 'true' or 'false' as string
    const sortBy = searchParams.get('sortBy') || 'created_at_desc'; // Default sort

    let query = supabase
      .from('chatbots')
      .select('*')
      .eq('teacher_id', user.id);

    // Apply search term filter (searches name and description)
    if (searchTerm) {
      // Using .or() for searching in multiple columns.
      // The syntax `description.ilike.%${searchTerm}%` means description case-insensitive LIKE '%searchTerm%'
      query = query.or(`name.ilike.%${searchTerm}%,description.ilike.%${searchTerm}%`);
    }

    // Apply botType filter
    if (botType && (botType === 'learning' || botType === 'assessment')) {
      query = query.eq('bot_type', botType);
    }

    // Apply ragEnabled filter
    if (ragEnabledParam === 'true') {
      query = query.eq('enable_rag', true);
    } else if (ragEnabledParam === 'false') {
      query = query.eq('enable_rag', false);
    }

    // Apply sorting
    // Example: sortBy = "name_asc" or "created_at_desc"
    const [sortField, sortOrder] = sortBy.split('_');
    if (sortField && sortOrder && ['name', 'created_at', 'updated_at', 'bot_type'].includes(sortField)) {
      query = query.order(sortField as keyof DatabaseChatbot, { ascending: sortOrder === 'asc' });
    } else {
      // Default sort if sortBy parameter is invalid or not provided fully
      query = query.order('created_at', { ascending: false });
    }
    
    const { data: chatbots, error: fetchError } = await query;

    if (fetchError) {
      console.error('Error fetching chatbots:', fetchError);
      throw fetchError;
    }

    return NextResponse.json(chatbots || []);
  } catch (error) {
    console.error('Error in GET /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch chatbots' },
      { status: 500 }
    );
  }
}

// POST Handler
// ... (POST Handler remains the same as you provided)
export async function POST(request: NextRequest) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: profile } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (!profile || profile.role !== 'teacher') {
      return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
    }

    const body: CreateChatbotPayload = await request.json();
    console.log("[API POST /teacher/chatbots] Received payload for creation:", body);

    if (!body.name || !body.system_prompt) {
        return NextResponse.json({ error: 'Name and system prompt are required' }, { status: 400 });
    }
    if (body.bot_type === 'assessment' && (!body.assessment_criteria_text || body.assessment_criteria_text.trim() === '')) {
        return NextResponse.json({ error: 'Assessment criteria are required for assessment bots.' }, { status: 400 });
    }

    const chatbotDataToInsert: Omit<DatabaseChatbot, 'chatbot_id' | 'created_at' | 'updated_at'> & { teacher_id: string } = {
      name: body.name,
      description: body.description || undefined, 
      system_prompt: body.system_prompt,
      teacher_id: user.id,
      model: body.model || 'openai/gpt-4.1-nano',
      max_tokens: body.max_tokens === undefined || body.max_tokens === null ? 1000 : Number(body.max_tokens),
      temperature: body.temperature === undefined || body.temperature === null ? 0.7 : Number(body.temperature),
      enable_rag: body.bot_type === 'learning' ? (body.enable_rag || false) : false,
      bot_type: body.bot_type || 'learning',
      assessment_criteria_text: body.bot_type === 'assessment' ? body.assessment_criteria_text : null,
      welcome_message: body.welcome_message || null, 
    };
    if (chatbotDataToInsert.description === undefined) {
        delete chatbotDataToInsert.description; 
    }


    const { data: newChatbot, error: insertError } = await supabase
      .from('chatbots')
      .insert(chatbotDataToInsert)
      .select()
      .single();

    if (insertError) {
      console.error('Error creating chatbot:', insertError);
      if (insertError.code === '23505') {
         return NextResponse.json({ error: 'A chatbot with this name might already exist or another unique constraint was violated.' }, { status: 409 });
      }
      throw insertError;
    }

    return NextResponse.json(newChatbot, { status: 201 });
  } catch (error) {
    console.error('Error in POST /api/teacher/chatbots:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to create chatbot' },
      { status: 500 }
    );
  }
}


// DELETE Handler
// ... (DELETE Handler remains the same as you provided)
export async function DELETE(request: NextRequest) {
    const { searchParams } = new URL(request.url);
    const chatbotId = searchParams.get('chatbotId');

    if (!chatbotId) {
        return NextResponse.json({ error: 'Chatbot ID is required as a query parameter for deletion' }, { status: 400 });
    }
    console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Request received.`);

    const supabase = await createServerSupabaseClient();
    const adminSupabase = createAdminClient();

    try {
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        const { data: chatbot, error: fetchError } = await supabase
            .from('chatbots')
            .select('teacher_id, name')
            .eq('chatbot_id', chatbotId)
            .single();

        if (fetchError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error fetching chatbot: ${fetchError.message}`);
            if (fetchError.code === 'PGRST116') return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
            return NextResponse.json({ error: 'Failed to fetch chatbot details' }, { status: 500 });
        }
        if (!chatbot) {
            return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
        }
        if (chatbot.teacher_id !== user.id) {
            return NextResponse.json({ error: 'Not authorized to delete this chatbot' }, { status: 403 });
        }
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] User ${user.id} authorized to delete chatbot "${chatbot.name}".`);

        const documentsFolderPath = `${user.id}/${chatbotId}/`;
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Listing files in storage path: ${documentsFolderPath}`);
        const { data: filesInStorage, error: listError } = await adminSupabase.storage
            .from('documents')
            .list(documentsFolderPath);

        if (listError) {
            console.warn(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error listing files in storage for cleanup: ${listError.message}`);
        } else if (filesInStorage && filesInStorage.length > 0) {
            const filePathsToRemove = filesInStorage.map(file => `${documentsFolderPath}${file.name}`);
            if (filePathsToRemove.length > 0) {
                console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Removing ${filePathsToRemove.length} files from storage.`);
                const { error: removeFilesError } = await adminSupabase.storage.from('documents').remove(filePathsToRemove);
                if (removeFilesError) console.warn(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error removing files from storage: ${removeFilesError.message}`);
                else console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Successfully removed files from storage.`);
            }
        }

        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Deleting chatbot record from database.`);
        const { error: deleteChatbotError } = await adminSupabase
            .from('chatbots')
            .delete()
            .eq('chatbot_id', chatbotId);

        if (deleteChatbotError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error deleting chatbot from database: ${deleteChatbotError.message}`);
            throw deleteChatbotError;
        }
        console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Chatbot record deleted from database.`);

        try {
            console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Deleting vectors from Pinecone.`);
            await deleteChatbotVectors(chatbotId);
            console.log(`[API DELETE /chatbots?chatbotId=${chatbotId}] Pinecone vectors deletion initiated/completed.`);
        } catch (pineconeError) {
            console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] Error deleting vectors from Pinecone:`, pineconeError);
        }

        return NextResponse.json({ success: true, message: `Chatbot "${chatbot.name}" and associated data deleted.` });

    } catch (error) {
        console.error(`[API DELETE /chatbots?chatbotId=${chatbotId}] General error:`, error);
        return NextResponse.json({ error: error instanceof Error ? error.message : 'Failed to delete chatbot' }, { status: 500 });
    }
}// src/app/api/teacher/dashboard-stats/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

export async function GET() {
  console.log('\n--- [API GET /dashboard-stats] ---');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API STATS] Not authenticated.', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API STATS] User authenticated:', user.id);

    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError || !profile) {
      console.error('[API STATS] Profile fetch failed or not found:', profileError?.message);
      return NextResponse.json({ error: `Profile fetch issue: ${profileError?.message || 'Not found'}` }, { status: 500 });
    }
    if (profile.role !== 'teacher') {
      console.warn('[API STATS] User is not a teacher. Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (not a teacher)' }, { status: 403 });
    }
    console.log('[API STATS] User is teacher. Proceeding with stats.');
    
    // Fetch all stats concurrently
    const [
        chatbotsResult,
        roomsResult,
        activeRoomsResult,
        pendingConcernsResult
    ] = await Promise.all([
        supabase
            .from('chatbots')
            .select('chatbot_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id),
        supabase
            .from('rooms')
            .select('room_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id),
        supabase
            .from('rooms')
            .select('room_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id)
            .eq('is_active', true),
        supabase
            .from('flagged_messages')
            .select('flag_id', { count: 'exact', head: true })
            .eq('teacher_id', user.id)
            .eq('status', 'pending') // <<<< Count only PENDING concerns
    ]);

    // Error handling for each query (optional, but good for debugging)
    if (chatbotsResult.error) console.error('[API STATS] Error fetching chatbots count:', chatbotsResult.error.message);
    if (roomsResult.error) console.error('[API STATS] Error fetching total rooms count:', roomsResult.error.message);
    if (activeRoomsResult.error) console.error('[API STATS] Error fetching active rooms count:', activeRoomsResult.error.message);
    if (pendingConcernsResult.error) console.error('[API STATS] Error fetching pending concerns count:', pendingConcernsResult.error.message);

    const stats = {
      totalChatbots: chatbotsResult.count || 0,
      totalRooms: roomsResult.count || 0,
      activeRooms: activeRoomsResult.count || 0,
      pendingConcerns: pendingConcernsResult.count || 0, // <<<< Use the actual count
    };
    
    console.log('[API STATS] Returning stats:', stats);
    return NextResponse.json(stats);

  } catch (error: unknown) {
    const typedError = error as Error;
    console.error('[API STATS] CATCH BLOCK Error:', typedError.message);
    return NextResponse.json({ error: typedError.message || 'Failed to fetch dashboard stats' }, { status: 500 });
  }
}// src/app/api/teacher/documents/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import type { DocumentType, DocumentStatus } from '@/types/knowledge-base.types'; // MODIFIED: Added DocumentStatus
import { createAdminClient } from '@/lib/supabase/admin';
import { extractContentFromUrl } from '@/lib/scraping/content-extractor'; // MODIFIED: Import new utility

// Helper function to determine file type
function getFileTypeFromFile(file: File): DocumentType | null {
    const fileName = file.name;
    const extension = fileName.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'pdf': return 'pdf';
        case 'doc': case 'docx': return 'docx';
        case 'txt': return 'txt';
        // 'webpage' type is handled differently
        default: return null;
    }
}

// --- GET Handler: Fetch documents for a specific chatbot ---
export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const chatbotId = searchParams.get('chatbotId');

  if (!chatbotId) {
    return NextResponse.json({ error: 'Chatbot ID is required as a query parameter' }, { status: 400 });
  }
  console.log(`[API /documents GET] Request for chatbotId: ${chatbotId}`);

  try {
    const supabase = await createServerSupabaseClient(); // User-context client
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.log('[API /documents GET] Not authenticated');
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    // Verify user is a teacher and owns the chatbot
    const { data: chatbot, error: chatbotOwnerError } = await supabase
      .from('chatbots')
      .select('chatbot_id, teacher_id') // Select teacher_id for ownership check
      .eq('chatbot_id', chatbotId)
      .single(); // Use single to ensure it exists

    if (chatbotOwnerError || !chatbot) {
      console.log(`[API /documents GET] Chatbot not found for ID: ${chatbotId}`, chatbotOwnerError);
      return NextResponse.json({ error: 'Chatbot not found' }, { status: 404 });
    }
    if (chatbot.teacher_id !== user.id) {
        console.log(`[API /documents GET] User ${user.id} does not own chatbot ${chatbotId}. Owner: ${chatbot.teacher_id}`);
        return NextResponse.json({ error: 'Not authorized to access documents for this chatbot' }, { status: 403 });
    }

    // Get all documents for this chatbot
    const { data: documents, error: documentsError } = await supabase
      .from('documents')
      .select('*')
      .eq('chatbot_id', chatbotId)
      .order('created_at', { ascending: false });

    if (documentsError) {
      console.error('[API /documents GET] Error fetching documents from DB:', documentsError);
      return NextResponse.json({ error: 'Failed to fetch documents', details: documentsError.message }, { status: 500 });
    }

    return NextResponse.json(documents || []);

  } catch (error) {
    console.error('[API /documents GET] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to fetch documents due to an unexpected error' },
      { status: 500 }
    );
  }
}

// --- POST Handler: Upload a new document (file or URL) for a chatbot ---
export async function POST(request: NextRequest) {
  console.log("[API /documents POST] Document/URL add request received");
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    const url = formData.get('url') as string | null; // MODIFIED: Get URL from form data
    const chatbotId = formData.get('chatbotId') as string | null;

    if (!chatbotId) {
        return NextResponse.json({ error: 'Chatbot ID not provided in form data' }, { status: 400 });
    }
    if (!file && !url) {
        return NextResponse.json({ error: 'No file or URL provided' }, { status: 400 });
    }
    if (file && url) {
        return NextResponse.json({ error: 'Provide either a file or a URL, not both' }, { status: 400 });
    }

    console.log(`[API /documents POST] Processing for chatbot ID: ${chatbotId}`);

    // Verify user owns the chatbot
    const { data: chatbot, error: chatbotOwnerError } = await supabase
      .from('chatbots')
      .select('chatbot_id, teacher_id')
      .eq('chatbot_id', chatbotId)
      .single();

    if (chatbotOwnerError || !chatbot) {
      return NextResponse.json({ error: 'Chatbot not found for upload/add' }, { status: 404 });
    }
    if (chatbot.teacher_id !== user.id) {
        return NextResponse.json({ error: 'Not authorized to add documents to this chatbot' }, { status: 403 });
    }

    let documentRecordData;

    if (file) {
        // --- File Upload Logic (Existing) ---
        console.log(`[API /documents POST] Processing file: ${file.name}`);
        const fileType = getFileTypeFromFile(file);
        if (!fileType) return NextResponse.json({ error: 'Unsupported file type' }, { status: 400 });

        const MAX_FILE_SIZE_MB = 10;
        if (file.size > MAX_FILE_SIZE_MB * 1024 * 1024) {
            return NextResponse.json({ error: `File too large. Maximum size is ${MAX_FILE_SIZE_MB}MB.` }, { status: 413 });
        }

        const filePath = `${user.id}/${chatbotId}/${Date.now()}-${file.name.replace(/[^a-zA-Z0-9_.\-]/g, '_')}`;
        const buffer = await file.arrayBuffer();

        console.log(`[API /documents POST] Uploading to storage path: ${filePath}`);
        const { error: uploadError } = await supabase.storage
          .from('documents')
          .upload(filePath, buffer, { contentType: file.type, upsert: false });

        if (uploadError) {
          console.error("[API /documents POST] Storage upload error:", uploadError);
          return NextResponse.json({ error: `Failed to upload file to storage: ${uploadError.message}` }, { status: 500 });
        }
        console.log(`[API /documents POST] File uploaded to storage successfully.`);

        const { data: dbDocument, error: documentInsertError } = await supabase
          .from('documents')
          .insert({
            chatbot_id: chatbotId,
            file_name: file.name,
            file_path: filePath,
            file_type: fileType,
            file_size: file.size,
            status: 'uploaded' as DocumentStatus,
          })
          .select()
          .single();

        if (documentInsertError) {
          console.error("[API /documents POST] Document DB insert error (file):", documentInsertError);
          await supabase.storage.from('documents').remove([filePath]);
          return NextResponse.json({ error: `Failed to create document record: ${documentInsertError.message}` }, { status: 500 });
        }
        documentRecordData = dbDocument;
        console.log(`[API /documents POST] File document record created: ${documentRecordData.document_id}`);
    } else if (url) {
        // --- URL Processing Logic (New) ---
        console.log(`[API /documents POST] Processing URL: ${url}`);
        if (!/^https?:\/\//i.test(url)) {
            return NextResponse.json({ error: 'Invalid URL format. Must start with http:// or https://' }, { status: 400 });
        }

        const extractedData = await extractContentFromUrl(url);

        if (extractedData.error || !extractedData.textContent) {
            console.error(`[API /documents POST] Error extracting content from URL ${url}:`, extractedData.error);
            return NextResponse.json({ error: extractedData.error || 'Failed to extract content from URL. The page might be inaccessible or have no readable content.' }, { status: 400 });
        }
        
        // For webpages, file_path will store the original URL.
        // file_name will store the extracted title (or a truncated URL).
        // file_size will be the length of the extracted text.
        const fileNameForDb = extractedData.title.substring(0, 255); // Max length for file_name
        const fileSizeForDb = extractedData.textContent.length;

        const { data: dbDocument, error: documentInsertError } = await supabase
          .from('documents')
          .insert({
            chatbot_id: chatbotId,
            file_name: fileNameForDb,
            file_path: url, // Store the original URL as the "path"
            file_type: 'webpage' as DocumentType,
            file_size: fileSizeForDb,
            status: 'fetched' as DocumentStatus, // New status for successfully fetched URL content
          })
          .select()
          .single();

        if (documentInsertError) {
          console.error("[API /documents POST] Document DB insert error (URL):", documentInsertError);
          return NextResponse.json({ error: `Failed to create document record for URL: ${documentInsertError.message}` }, { status: 500 });
        }
        documentRecordData = dbDocument;
        console.log(`[API /documents POST] Webpage document record created: ${documentRecordData.document_id}`);
    } else {
        // This case should not be reached due to earlier checks, but as a safeguard:
        return NextResponse.json({ error: 'No file or URL provided (safeguard).' }, { status: 400 });
    }

    return NextResponse.json({
      document: documentRecordData,
      message: file ? 'File uploaded successfully. Processing can now be initiated.' : 'Webpage added successfully. Processing can now be initiated.'
    }, { status: 201 });

  } catch (error) {
    console.error('[API /documents POST] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to process request due to an unexpected error' },
      { status: 500 }
    );
  }
}


// --- DELETE Handler: Delete a specific document ---
export async function DELETE(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const documentId = searchParams.get('documentId');

  if (!documentId) {
    return NextResponse.json({ error: 'Document ID is required as a query parameter' }, { status: 400 });
  }
  console.log(`[API /documents DELETE] Request for documentId: ${documentId}`);

  try {
    const supabase = await createServerSupabaseClient(); 
    const adminSupabase = createAdminClient(); 
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: document, error: docFetchError } = await supabase
        .from('documents')
        .select('document_id, chatbot_id, file_path, file_type') // MODIFIED: Added file_type
        .eq('document_id', documentId)
        .single();

    if (docFetchError || !document) {
        console.log(`[API /documents DELETE] Document not found: ${documentId}`, docFetchError);
        return NextResponse.json({ error: 'Document not found' }, { status: 404 });
    }

    const { data: chatbot, error: chatbotFetchError } = await supabase
        .from('chatbots')
        .select('teacher_id')
        .eq('chatbot_id', document.chatbot_id)
        .single();
    
    if (chatbotFetchError || !chatbot || chatbot.teacher_id !== user.id) {
        console.log(`[API /documents DELETE] User ${user.id} unauthorized to delete document ${documentId} or chatbot not found.`);
        return NextResponse.json({ error: 'Unauthorized to delete this document or its parent chatbot not found' }, { status: 403 });
    }

    console.log(`[API /documents DELETE] Deleting document record ${documentId} from database.`);
    const { error: dbDeleteError } = await adminSupabase
      .from('documents')
      .delete()
      .eq('document_id', documentId);

    if (dbDeleteError) {
      console.error(`[API /documents DELETE] Error deleting document record ${documentId} from DB:`, dbDeleteError);
      return NextResponse.json({ error: 'Failed to delete document record from database', details: dbDeleteError.message }, { status: 500 });
    }
    console.log(`[API /documents DELETE] Document record ${documentId} deleted from database.`);

    // MODIFIED: Only delete from storage if it's not a 'webpage' type (where file_path is the URL)
    if (document.file_type !== 'webpage' && document.file_path) {
        console.log(`[API /documents DELETE] Deleting file from storage: ${document.file_path}`);
        const { error: storageError } = await adminSupabase.storage.from('documents').remove([document.file_path]);
        if (storageError) {
            console.error(`[API /documents DELETE] Error deleting file ${document.file_path} from storage:`, storageError);
        } else {
            console.log(`[API /documents DELETE] File ${document.file_path} deleted from storage.`);
        }
    } else if (document.file_type === 'webpage') {
        console.log(`[API /documents DELETE] Document type is 'webpage', skipping storage deletion for URL: ${document.file_path}`);
    }
    
    // TODO: Implement Pinecone vector deletion for document
    console.log(`[API /documents DELETE] TODO: Implement Pinecone vector deletion for document ${documentId}.`);


    return NextResponse.json({ success: true, message: 'Document deleted successfully' });

  } catch (error) {
    console.error('[API /documents DELETE] General Error:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Failed to delete document due to an unexpected error' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/magic-link/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function POST(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // Verify user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_code')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Generate a signup link with embedded room code
    const magicLink = `${process.env.NEXT_PUBLIC_APP_URL}/join?code=${room.room_code}`;

    return NextResponse.json({ 
      magicLink: magicLink,
      roomCode: room.room_code 
    });
  } catch (error) {
    console.error('Error generating magic link:', error);
    return NextResponse.json(
      { error: 'Failed to generate magic link' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/[roomId]/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';

interface RouteParams {
  params: Promise<{ roomId: string }>;
}

export async function PATCH(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { is_active } = await request.json();
    const params = await context.params;
    const roomId = params.roomId;

    // Update room status
    const { data: room, error } = await supabase
      .from('rooms')
      .update({ is_active })
      .eq('room_id', roomId)
      .eq('teacher_id', user.id) // Ensure only the room owner can update
      .select()
      .single();

    if (error) {
      throw error;
    }

    if (!room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    return NextResponse.json(room);
  } catch (error) {
    console.error('Error updating room:', error);
    return NextResponse.json(
      { error: 'Failed to update room' },
      { status: 500 }
    );
  }
}

export async function DELETE(request: Request, context: RouteParams) {
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const params = await context.params;
    const roomId = params.roomId;

    // First, check if the user owns this room
    const { data: room, error: roomError } = await supabase
      .from('rooms')
      .select('room_id')
      .eq('room_id', roomId)
      .eq('teacher_id', user.id)
      .single();

    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found' }, { status: 404 });
    }

    // Delete the room (this will cascade to related tables via foreign key constraints)
    const { error: deleteError } = await supabase
      .from('rooms')
      .delete()
      .eq('room_id', roomId)
      .eq('teacher_id', user.id);

    if (deleteError) {
      throw deleteError;
    }

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Error deleting room:', error);
    return NextResponse.json(
      { error: 'Failed to delete room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/rooms/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { generateRoomCode } from '@/lib/utils/room-codes';
import type { CreateRoomPayload, TeacherRoom } from '@/types/database.types';

// GET all rooms for the teacher
export async function GET() {
  console.log('[API GET /rooms] Received request.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API GET /rooms] User authenticated by getUser:', {
        id: user.id, 
        email: user.email, 
        aud: user.aud, // Should be 'authenticated'
        role: user.role // JWT role, typically 'authenticated'
    });

    console.log('[API GET /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileError) {
      console.error('[API GET /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileError, null, 2));
      console.warn('[API GET /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileError.message);
      return NextResponse.json({ error: `User profile not found or error fetching it. Details: ${profileError.message}` }, { status: 403 });
    }
    
    if (!profile) {
      console.warn('[API GET /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
      return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }

    console.log('[API GET /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API GET /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    
    console.log('[API GET /rooms] User is confirmed teacher. Fetching rooms.');
    
    const { data: rooms, error: fetchError } = await supabase
      .from('rooms')
      .select(`
        *,
        room_chatbots (
          chatbots ( chatbot_id, name )
        )
      `)
      .eq('teacher_id', user.id)
      .order('created_at', { ascending: false });

    if (fetchError) {
      console.error('[API GET /rooms] Error fetching rooms from DB:', fetchError);
      throw fetchError; // Let the outer catch handle it by re-throwing
    }
    console.log(`[API GET /rooms] Successfully fetched ${rooms?.length || 0} rooms.`);
    return NextResponse.json(rooms || []);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string }; // Cast with error properties
    console.error('[API GET /rooms] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    return NextResponse.json(
      { error: typedError?.message || 'Failed to fetch rooms' },
      { status: 500 }
    );
  }
}

// POST a new room
export async function POST(request: Request) {
  console.log('[API POST /rooms] Received request to create a new room.');
  try {
    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API POST /rooms] Not authenticated or authError from getUser:', authError);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    console.log('[API POST /rooms] User authenticated by getUser:', {
        id: user.id, 
        email: user.email, 
        aud: user.aud, // Should be 'authenticated'
        role: user.role // JWT role, typically 'authenticated'
    });
    
    console.log('[API POST /rooms] Attempting to fetch profile for user_id:', user.id);
    const { data: profile, error: profileFetchError } = await supabase
      .from('profiles')
      .select('role, school_id')
      .eq('user_id', user.id)
      .single();

    if (profileFetchError) {
        console.error('[API POST /rooms] PROFILE FETCH ERROR OBJECT:', JSON.stringify(profileFetchError, null, 2));
        console.warn('[API POST /rooms] Profile fetch failed for user:', user.id, 'Error message:', profileFetchError.message);
        return NextResponse.json({ error: `Error fetching user profile. Details: ${profileFetchError.message}` }, { status: 500 });
    }
    if (!profile) {
        console.error('[API POST /rooms] Profile data is null (but no error reported by Supabase) for user:', user.id);
        return NextResponse.json({ error: 'User profile not found (no data returned but no DB error).' }, { status: 403 });
    }
     console.log('[API POST /rooms] Profile fetched successfully:', profile);

    if (profile.role !== 'teacher') {
      console.warn('[API POST /rooms] User is not a teacher. Profile Role:', profile.role);
      return NextResponse.json({ error: 'Not authorized (user role is not teacher)' }, { status: 403 });
    }
    console.log('[API POST /rooms] User is confirmed teacher. Proceeding with room creation.');

    const body: CreateRoomPayload = await request.json();
    console.log('[API POST /rooms] Request body:', body);

    if (!body.room_name || !body.chatbot_ids || !Array.isArray(body.chatbot_ids) || body.chatbot_ids.length === 0) {
      console.warn('[API POST /rooms] Invalid request body: Missing room_name or chatbot_ids.');
      return NextResponse.json({ error: 'Room name and at least one chatbot ID are required' }, { status: 400 });
    }

    let roomCode = '';
    let isUnique = false;
    let attempts = 0;
    const MAX_ATTEMPTS = 10; 
    
    console.log('[API POST /rooms] Generating unique room code...');
    while (!isUnique && attempts < MAX_ATTEMPTS) {
      roomCode = generateRoomCode();
      const { data: existingRoom, error: codeCheckError } = await supabase
        .from('rooms')
        .select('room_code')
        .eq('room_code', roomCode)
        .maybeSingle(); 
      
      if (codeCheckError) {
        console.error('[API POST /rooms] Error checking room code uniqueness:', codeCheckError);
        throw codeCheckError;
      }
      if (!existingRoom) {
        isUnique = true;
      }
      attempts++;
    }

    if (!isUnique) {
        console.error('[API POST /rooms] Failed to generate a unique room code after multiple attempts.');
        throw new Error('Failed to generate a unique room code.');
    }
    console.log('[API POST /rooms] Unique room code generated:', roomCode);

    console.log('[API POST /rooms] Inserting new room into "rooms" table.');
    const { data: newRoom, error: roomInsertError } = await supabase
      .from('rooms')
      .insert({
        room_name: body.room_name,
        room_code: roomCode,
        teacher_id: user.id,
        school_id: profile.school_id, 
        is_active: true,
      })
      .select()
      .single();

    if (roomInsertError) {
      console.error('[API POST /rooms] Error inserting into "rooms" table:', roomInsertError);
      throw roomInsertError;
    }
    if (!newRoom) {
        console.error('[API POST /rooms] Room creation failed: newRoom data is null after insert.');
        throw new Error('Room creation returned no data.');
    }
    console.log('[API POST /rooms] Room inserted successfully. Room ID:', newRoom.room_id);

    console.log('[API POST /rooms] Preparing to insert into "room_chatbots" table.');
    const roomChatbotEntries = body.chatbot_ids.map(chatbotId => ({
      room_id: newRoom.room_id,
      chatbot_id: chatbotId,
    }));

    const { error: rcInsertError } = await supabase
      .from('room_chatbots')
      .insert(roomChatbotEntries);

    if (rcInsertError) {
      console.error('[API POST /rooms] Error inserting into "room_chatbots":', rcInsertError);
      console.log(`[API POST /rooms] Attempting to rollback room creation for room ID: ${newRoom.room_id} due to room_chatbots insert failure.`);
      const { error: deleteError } = await supabase.from('rooms').delete().eq('room_id', newRoom.room_id);
      if (deleteError) {
          console.error(`[API POST /rooms] CRITICAL: Failed to rollback room ${newRoom.room_id} after room_chatbots insert error:`, deleteError);
      } else {
          console.log(`[API POST /rooms] Successfully rolled back room ${newRoom.room_id}.`);
      }
      throw rcInsertError; 
    }
    console.log(`[API POST /rooms] Successfully inserted ${roomChatbotEntries.length} entries into "room_chatbots".`);
    
    console.log('[API POST /rooms] Fetching complete room data for response.');
    const { data: completeRoomData, error: fetchCompleteError } = await supabase
        .from('rooms')
        .select(`
            *,
            room_chatbots (
              chatbots ( chatbot_id, name )
            )
        `)
        .eq('room_id', newRoom.room_id)
        .single();

    if (fetchCompleteError) {
        console.error('[API POST /rooms] Error fetching complete room data after creation:', fetchCompleteError);
        throw fetchCompleteError;
    }
    if (!completeRoomData) {
        console.error('[API POST /rooms] Failed to fetch complete room data after creation, though room should exist.');
        throw new Error('Failed to retrieve newly created room details.');
    }

    console.log('[API POST /rooms] Room creation successful. Returning complete room data.');
    return NextResponse.json(completeRoomData as TeacherRoom, { status: 201 });

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string; constraint?: string };
    console.error('[API POST /rooms] CATCH BLOCK Error:', 
        typedError?.message, 
        'Code:', typedError?.code, 
        'Details:', typedError?.details
    );
    if (typedError?.code === '23505' && typedError?.constraint === 'rooms_room_code_key') {
        return NextResponse.json({ error: 'A room with this code already exists. This is highly unlikely and might indicate an issue with room code generation.' }, { status: 409 });
    }
    return NextResponse.json(
      { error: typedError?.message || 'Failed to create room' },
      { status: 500 }
    );
  }
}// src/app/api/teacher/concerns/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin'; // << IMPORT ADMIN CLIENT
import type { FlaggedMessage, ConcernStatus, Profile, Room, ChatMessage as DatabaseChatMessage } from '@/types/database.types';
import { PostgrestError, SupabaseClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

// Intermediate type - Simpler, as we'll fetch student profiles separately
type RawFlaggedMessage = FlaggedMessage & {
    // No 'student' field here initially
    room: Pick<Room, 'room_name'> | null;
    message: Pick<DatabaseChatMessage, 'content' | 'created_at' | 'metadata'> | null;
};

interface FlaggedConcernListDetails extends FlaggedMessage {
    student_name: string | null;
    student_email: string | null;
    room_name: string | null;
    message_content: string | null;
}
// ... (FlagDetailsResponse and getSingleConcernDetails can remain mostly as is, but getSingleConcernDetails will also use admin client for student profile)
interface FlagDetailsResponse extends FlaggedMessage {
    student: null;
    student_name: string | null;
    student_email: string | null;
    room_name: string;
    message_content: string;
    message: DatabaseChatMessage | null;
    surroundingMessages: DatabaseChatMessage[];
}


export async function GET(request: NextRequest) {
    console.log('[API GET /concerns] Received request.');
    try {
        const supabase = await createServerSupabaseClient(); // Standard client for user context
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) { /* ... auth checks ... */ 
            console.warn('[API GET /concerns] Not authenticated.');
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }
        const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', user.id)
            .single();
        if (profileError || !profile || profile.role !== 'teacher') {
            console.warn('[API GET /concerns] User profile/role issue.');
            return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
        }
        console.log(`[API GET /concerns] Authenticated teacher: ${user.id}`);

        const { searchParams } = new URL(request.url);
        const flagId = searchParams.get('flagId');
        
        if (flagId) {
            console.log(`[API GET /concerns] Fetching single concern details for flagId: ${flagId}`);
            // Modify getSingleConcernDetails to use admin client for student profile
            return await getSingleConcernDetails_V2(supabase, flagId, user.id); 
        }
        
        const statusFilter = searchParams.get('status');
        const limit = parseInt(searchParams.get('limit') || '10', 10);
        const page = parseInt(searchParams.get('page') || '0', 10);
        const offset = page * limit;

        console.log(`[API GET /concerns] Fetching concerns list. Status: ${statusFilter || 'all'}, Page: ${page}, Limit: ${limit}`);

        let countQuery = supabase
            .from('flagged_messages')
            .select('*', { count: 'exact', head: true })
            .eq('teacher_id', user.id);

        // Fetch flagged_messages with joins to rooms and chat_messages, but NOT profiles yet
        let dataQuery = supabase
            .from('flagged_messages')
            .select(`
                *, 
                room:rooms!fk_room(room_name),
                message:chat_messages!fk_message(content, created_at, metadata)
            `)
            .eq('teacher_id', user.id) // RLS on flagged_messages will handle this
            .order('created_at', { ascending: false })
            .range(offset, offset + limit - 1);

        if (statusFilter && ['pending', 'reviewing', 'resolved', 'false_positive'].includes(statusFilter)) {
            countQuery = countQuery.eq('status', statusFilter);
            dataQuery = dataQuery.eq('status', statusFilter);
        }

        const [countResult, dataResult] = await Promise.all([countQuery, dataQuery]);

        const { count, error: countError } = countResult;
        const { data: rawFlagsData, error: fetchError } = dataResult as { data: RawFlaggedMessage[] | null, error: PostgrestError | null };

        if (countError) console.warn('[API GET /concerns] Error fetching concerns count:', countError.message);
        if (fetchError) {
            console.error('[API GET /concerns] Error fetching base flagged messages data:', fetchError);
            throw new Error(`Failed to fetch flagged messages: ${fetchError.message}`);
        }

        if (!rawFlagsData || rawFlagsData.length === 0) {
            console.log('[API GET /concerns] No raw flags found.');
            return NextResponse.json({ concerns: [], pagination: { currentPage: page, pageSize: limit, totalCount: 0, totalPages: 0, hasMore: false } });
        }

        // Get unique student IDs from the fetched flags
        const studentIds = [...new Set(rawFlagsData.map(flag => flag.student_id).filter(id => id != null))] as string[];
        const studentProfilesMap: Map<string, Pick<Profile, 'full_name' | 'email'>> = new Map();

        if (studentIds.length > 0) {
            console.log('[API GET /concerns] Fetching profiles for student IDs:', studentIds);
            const adminSupabase = createAdminClient();
            const { data: profilesData, error: profilesError } = await adminSupabase
                .from('profiles')
                .select('user_id, full_name, email')
                .in('user_id', studentIds);

            if (profilesError) {
                console.error('[API GET /concerns] Admin client error fetching student profiles:', profilesError.message);
                // Proceed without student names if this fails, or handle error more gracefully
            } else if (profilesData) {
                profilesData.forEach(p => studentProfilesMap.set(p.user_id, { full_name: p.full_name, email: p.email }));
            }
        }

        // Map raw flags to the detailed response, adding student info
        const concerns: FlaggedConcernListDetails[] = rawFlagsData.map((flag: RawFlaggedMessage) => {
            const studentProfile = flag.student_id ? studentProfilesMap.get(flag.student_id) : null;
            return {
                ...flag,
                student_name: studentProfile?.full_name || 'Unknown Student',
                student_email: studentProfile?.email || null,
                room_name: flag.room?.room_name || 'Unknown Room',
                message_content: flag.message?.content || '[Message Content Unavailable]',
            };
        });

        const totalCount = count || 0;
        const hasMore = (offset + concerns.length) < totalCount;
        const totalPages = limit > 0 ? Math.ceil(totalCount / limit) : 0;

        console.log(`[API GET /concerns] Processed ${concerns.length} concerns for page ${page}, total: ${totalCount}`);
        return NextResponse.json({
            concerns,
            pagination: { currentPage: page, pageSize: limit, totalCount, totalPages, hasMore }
        });

    } catch (error) { /* ... error handling ... */ 
        console.error('[API GET /concerns] CATCH BLOCK Error:', error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'An internal error occurred while fetching concerns.' },
            { status: 500 }
        );
    }
}


// Modified getSingleConcernDetails to use Admin Client for student profile
async function getSingleConcernDetails_V2(
    supabaseUserClient: SupabaseClient<Database>, // User-context client for initial flag fetch
    flagId: string,
    teacherId: string
): Promise<NextResponse> {
    try {
        console.log(`[API getSingleConcernDetails_V2] Fetching details for concern flag ID: ${flagId}`);
        
        // Fetch the main flag data (without student profile yet)
        const { data: flag, error: flagError } = await supabaseUserClient
            .from('flagged_messages')
            .select(`
                *, 
                room:rooms!fk_room(room_name),
                message:chat_messages!fk_message(*)
            `)
            .eq('flag_id', flagId)
            .eq('teacher_id', teacherId) // Ensures teacher owns the flag
            .single();
            
        if (flagError) { /* ... error handling for flag fetch ... */ 
            console.error(`[API getSingleConcernDetails_V2] Error fetching flag ${flagId}:`, flagError);
            if (flagError.code === 'PGRST116') {
                 return NextResponse.json({ error: 'Concern not found or not authorized' }, { status: 404 });
            }
            throw flagError;
        }
        if (!flag) { return NextResponse.json({ error: 'Concern not found' }, { status: 404 }); }
        
        // Cast to a working type, student profile will be added
        const typedFlag = flag as unknown as (FlaggedMessage & { 
            room: Pick<Room, 'room_name'> | null; 
            message: DatabaseChatMessage | null;
        });

        let studentName: string | null = 'Unknown Student';
        let studentEmail: string | null = null;

        if (typedFlag.student_id) {
            const adminSupabase = createAdminClient();
            const { data: studentProfileData, error: studentProfileError } = await adminSupabase
                .from('profiles')
                .select('full_name, email')
                .eq('user_id', typedFlag.student_id)
                .single();
            if (studentProfileError) {
                console.warn(`[API getSingleConcernDetails_V2] Admin client error fetching student profile ${typedFlag.student_id}:`, studentProfileError.message);
            } else if (studentProfileData) {
                studentName = studentProfileData.full_name || studentName;
                studentEmail = studentProfileData.email || studentEmail;
            }
        }

        const response: FlagDetailsResponse = {
            ...typedFlag,
            student: null, // Not fetching the full student object in this structure anymore, using flattened names
            student_name: studentName,
            student_email: studentEmail,
            room_name: typedFlag.room?.room_name || 'Unknown Room',
            message_content: typedFlag.message?.content || '[Message Content Unavailable]',
            message: typedFlag.message, 
            surroundingMessages: [] // Populate this as before
        };
        
        // Fetch surrounding messages (logic remains similar, ensure chatMessageRoomId is correct)
        if (typedFlag.message && typedFlag.message.room_id && typedFlag.student_id) {
            const messageCreatedAt = typedFlag.message.created_at;
            const studentId = typedFlag.student_id;
            const chatMessageRoomId = typedFlag.message.room_id; // TEXT room_id from chat_messages
            const messageChatbotId = typedFlag.message.metadata?.chatbotId || null;

            const { data: messagesData, error: messagesError } = await supabaseUserClient // Use user client for chat history
                .from('chat_messages')
                .select<string, DatabaseChatMessage>("*") 
                .eq('room_id', chatMessageRoomId) 
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', messageChatbotId ? 'eq' : 'is', messageChatbotId || null)
                .lt('created_at', messageCreatedAt) 
                .order('created_at', { ascending: false })
                .limit(5); 
            
            const { data: messagesDataAfter, error: messagesErrorAfter } = await supabaseUserClient
                .from('chat_messages')
                .select<string, DatabaseChatMessage>("*")
                .eq('room_id', chatMessageRoomId) 
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', messageChatbotId ? 'eq' : 'is', messageChatbotId || null)
                .gt('created_at', messageCreatedAt) 
                .order('created_at', { ascending: true })
                .limit(5); 

            if (messagesError || messagesErrorAfter) {
                console.warn(`[API getSingleConcernDetails_V2] Error fetching conversation context for flag ${flagId}:`, messagesError || messagesErrorAfter);
            } else {
                const beforeMessages = (messagesData || []).reverse(); 
                const afterMessages = messagesDataAfter || [];
                const mainFlaggedMessageTyped = typedFlag.message as DatabaseChatMessage;
                response.surroundingMessages = [...beforeMessages, mainFlaggedMessageTyped, ...afterMessages].filter(Boolean);
            }
        }
        
        console.log(`[API getSingleConcernDetails_V2] Successfully fetched details for flag ${flagId}`);
        return NextResponse.json(response);
        
    } catch (error) { /* ... error handling ... */ 
        console.error(`[API getSingleConcernDetails_V2] CATCH for flag ${flagId}:`, error);
        return NextResponse.json(
            { error: error instanceof Error ? error.message : 'Failed to fetch concern details' },
            { status: 500 }
        );
    }
}

// PATCH handler remains the same, as it operates on flagged_messages directly
// and RLS for UPDATE on flagged_messages already checks teacher_id.
export async function PATCH(request: NextRequest) {
    console.log('[API PATCH /concerns] Received request.');
    try {
        const supabase = await createServerSupabaseClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            console.warn('[API PATCH /concerns] Not authenticated.');
            return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
        }

        const { data: profile } = await supabase.from('profiles').select('role').eq('user_id', user.id).single();
        if (!profile || profile.role !== 'teacher') {
            console.warn('[API PATCH /concerns] User not a teacher or profile error.');
            return NextResponse.json({ error: 'Not authorized' }, { status: 403 });
        }

        const body = await request.json();
        const { flagId, status, notes } = body;

        if (!flagId) {
            return NextResponse.json({ error: 'Flag ID is required' }, { status: 400 });
        }

        const validStatuses: ConcernStatus[] = ['pending', 'reviewing', 'resolved', 'false_positive'];
        if (!status || !validStatuses.includes(status as ConcernStatus)) {
            return NextResponse.json({ error: `Invalid status provided: ${status}` }, { status: 400 });
        }
        
        if (notes !== undefined && notes !== null && typeof notes !== 'string') {
            return NextResponse.json({ error: 'Invalid notes format, must be a string or null.' }, { status: 400 });
        }

        console.log(`[API PATCH /concerns] Updating flag ${flagId} by teacher ${user.id} to status: ${status}`);

        const updateData: Partial<FlaggedMessage> = {
            status: status as ConcernStatus,
            updated_at: new Date().toISOString(),
            reviewer_id: user.id,
            reviewed_at: new Date().toISOString(),
        };
        if (notes !== undefined) {
            updateData.notes = notes === '' ? null : notes;
        }

        const { data: updatedFlag, error: updateError } = await supabase
            .from('flagged_messages')
            .update(updateData)
            .eq('flag_id', flagId)
            .eq('teacher_id', user.id)
            .select()
            .single();

        if (updateError) {
            console.error(`[API PATCH /concerns] Error updating flag ${flagId}:`, updateError);
            if (updateError.code === 'PGRST116') {
                return NextResponse.json({ error: 'Update failed: Flag not found or permission denied' }, { status: 404 });
            }
            throw updateError;
        }

        if (!updatedFlag) {
            return NextResponse.json({ error: 'Flag not found or update failed post-operation' }, { status: 404 });
        }

        console.log(`[API PATCH /concerns] Flag ${flagId} updated successfully.`);
        return NextResponse.json(updatedFlag);

    } catch (error) { 
        console.error(`[API PATCH /concerns] CATCH BLOCK Error:`, error); 
        return NextResponse.json({ 
            error: error instanceof Error ? error.message : 'Failed to update concern status' 
        }, { status: 500 }); 
    }
}// src/app/api/teacher/room-details/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin'; // For fetching student profiles

export async function GET(request: NextRequest) {
  console.log('[API GET /teacher/room-details] Received request.');
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');

    if (!roomId) {
      console.warn('[API GET /teacher/room-details] roomId query parameter is missing.');
      return NextResponse.json({ error: 'Room ID is required' }, { status: 400 });
    }
    console.log(`[API GET /teacher/room-details] Processing for roomId: ${roomId}`);

    const supabase = await createServerSupabaseClient();
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      console.warn('[API GET /teacher/room-details] Not authenticated:', authError?.message);
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }

    const { data: teacherProfile, error: profileError } = await supabase
      .from('profiles')
      .select('role')
      .eq('user_id', user.id)
      .single();

    if (profileError || !teacherProfile) {
      console.warn(`[API GET /teacher/room-details] Profile not found or error for user ${user.id}:`, profileError?.message);
      return NextResponse.json({ error: 'User profile not found or error fetching it.' }, { status: 403 });
    }
    if (teacherProfile.role !== 'teacher') {
      console.warn(`[API GET /teacher/room-details] User ${user.id} is not a teacher. Role: ${teacherProfile.role}`);
      return NextResponse.json({ error: 'Not authorized (user is not a teacher)' }, { status: 403 });
    }
    console.log(`[API GET /teacher/room-details] User ${user.id} authenticated as teacher.`);

    // Fetch room details and verify ownership
    const { data: roomData, error: roomError } = await supabase
      .from('rooms')
      .select('*') // Select all room fields
      .eq('room_id', roomId)
      .eq('teacher_id', user.id) // RLS also enforces this, but explicit check is good
      .single();

    if (roomError || !roomData) {
      console.warn(`[API GET /teacher/room-details] Room ${roomId} not found or teacher ${user.id} not authorized:`, roomError?.message);
      return NextResponse.json({ error: 'Room not found or unauthorized' }, { status: 404 });
    }
    console.log(`[API GET /teacher/room-details] Room ${roomId} details fetched.`);

    // Fetch assigned chatbots
    const { data: roomChatbotsData, error: roomChatbotsError } = await supabase
      .from('room_chatbots')
      .select('chatbots (chatbot_id, name, description, bot_type)') // Include description and bot_type
      .eq('room_id', roomId);

    if (roomChatbotsError) {
      console.error(`[API GET /teacher/room-details] Error fetching chatbots for room ${roomId}:`, roomChatbotsError.message);
      // Don't fail the whole request, proceed with empty chatbots array
    }
    const assignedChatbots = roomChatbotsData?.map(rc => rc.chatbots).filter(Boolean) || [];
    console.log(`[API GET /teacher/room-details] Fetched ${assignedChatbots.length} assigned chatbots for room ${roomId}.`);


    // Fetch student memberships
    const { data: memberships, error: membershipError } = await supabase
      .from('room_memberships')
      .select('student_id, joined_at')
      .eq('room_id', roomId);

    if (membershipError) {
      console.error(`[API GET /teacher/room-details] Error fetching student memberships for room ${roomId}:`, membershipError.message);
      return NextResponse.json({ error: 'Failed to fetch student memberships' }, { status: 500 });
    }

    interface StudentInRoom {
        user_id: string;
        full_name: string;
        email: string;
        joined_at: string;
    }

    let studentsInRoom: StudentInRoom[] = [];
    if (memberships && memberships.length > 0) {
      const studentIds = memberships.map(m => m.student_id);
      console.log(`[API GET /teacher/room-details] Found ${studentIds.length} student IDs in room ${roomId}.`);

      const adminSupabase = createAdminClient();
      const { data: profilesData, error: profilesError } = await adminSupabase
        .from('profiles')
        .select('user_id, full_name, email')
        .in('user_id', studentIds);

      if (profilesError) {
        console.error(`[API GET /teacher/room-details] Admin client error fetching student profiles:`, profilesError.message);
        // Proceed, but student names/emails might be missing
      }

      studentsInRoom = memberships.map(membership => {
        const profile = profilesData?.find(p => p.user_id === membership.student_id);
        return {
          user_id: membership.student_id,
          full_name: profile?.full_name || 'Student', // Fallback name
          email: profile?.email || 'No email',       // Fallback email
          joined_at: membership.joined_at,
        };
      });
      console.log(`[API GET /teacher/room-details] Processed student profile data for room ${roomId}.`);
    } else {
      console.log(`[API GET /teacher/room-details] No student memberships found for room ${roomId}.`);
    }

    const responsePayload = {
      room: roomData,
      chatbots: assignedChatbots,
      students: studentsInRoom,
    };

    console.log(`[API GET /teacher/room-details] Successfully prepared data for room ${roomId}. Returning response.`);
    return NextResponse.json(responsePayload);

  } catch (error) {
    const typedError = error as Error & { code?: string; details?: string };
    console.error('[API GET /teacher/room-details] CATCH BLOCK Error:', typedError.message, 'Code:', typedError.code, 'Details:', typedError.details);
    return NextResponse.json(
      { error: typedError.message || 'Failed to fetch room details' },
      { status: 500 }
    );
  }
}// src/app/api/debug-room/route.ts
import { NextResponse } from 'next/server';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { createAdminClient } from '@/lib/supabase/admin';

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const roomId = searchParams.get('roomId');
    
    if (!roomId) {
      return NextResponse.json({ error: 'roomId parameter required' }, { status: 400 });
    }
    
    const supabase = await createServerSupabaseClient();
    const { data: { user } } = await supabase.auth.getUser();
    
    if (!user) {
      return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
    }
    
    // Use admin client to fetch room details
    const adminClient = createAdminClient();
    const { data: room, error: roomError } = await adminClient
      .from('rooms')
      .select('*')
      .eq('room_id', roomId)
      .single();
      
    if (roomError || !room) {
      return NextResponse.json({ error: 'Room not found', details: roomError }, { status: 404 });
    }
    
    // Get teacher profile using the room's teacher_id
    const { data: teacherProfile, error: profileError } = await adminClient
      .from('profiles')
      .select('*')
      .eq('user_id', room.teacher_id)
      .single();
      
    return NextResponse.json({
      room,
      teacherProfile,
      profileError,
      teacherIdInRoom: room.teacher_id,
      yourUserId: user.id,
      isMatch: room.teacher_id === user.id,
    });
  } catch {
    return NextResponse.json({ error: 'Failed to get room debug info' }, { status: 500 });
  }
}// src/app/page.tsx
'use client';

import { useEffect, useState } from 'react';
import styled, { useTheme } from 'styled-components'; // Added useTheme
import { useRouter } from 'next/navigation';
import { Container, Card, Button } from '@/styles/StyledComponents';
import { createClient } from '@/lib/supabase/client';
import type { User } from '@supabase/supabase-js';
import { APP_NAME, APP_DESCRIPTION } from '@/lib/utils/constants';

// Helper to lighten colors for gradients if needed (can be moved to a utils file)
// This is a very basic implementation. For production, consider a more robust color manipulation library or pre-calculated shades.
const lightenColor = (hex: string, percent: number): string => {
  hex = hex.replace(/^\s*#|\s*$/g, '');
  if (hex.length === 3) {
    hex = hex.replace(/(.)/g, '$1$1');
  }
  const num = parseInt(hex, 16);
  const amt = Math.round(2.55 * percent);
  const R = Math.min(255, (num >> 16) + amt);
  const G = Math.min(255, (num >> 8 & 0x00FF) + amt);
  const B = Math.min(255, (num & 0x0000FF) + amt);
  return `#${(0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1)}`;
};


const HomePage = styled.div`
  /* Keep overall background white for now, or set to a very light theme color if desired */
  background: ${({ theme }) => theme.colors.background};
  min-height: 100vh;
`;

const Hero = styled.section`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl} ${({ theme }) => theme.spacing.lg}; // Added horizontal padding
  // Using a subtle gradient from a very light version of primary to a very light version of blue (cyan)
  // Adjust percentages for desired subtlety. 
  // Ensure the text colors (Title, Subtitle) have good contrast.
  background: linear-gradient(135deg, 
    ${({ theme }) => lightenColor(theme.colors.primary, 45)}, // Very light purple
    ${({ theme }) => lightenColor(theme.colors.blue, 48)}    // Very light cyan
  );
  border-bottom: 1px solid ${({ theme }) => theme.colors.border}; // Optional: for a soft separation

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl} ${({ theme }) => theme.spacing.md};
  }
`;

const Title = styled.h1`
  color: ${({ theme }) => theme.colors.primaryDark}; // Darker primary for better contrast on light gradient
  font-size: 3rem;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  font-weight: 700; // Make it bolder

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    font-size: 2.5rem;
  }
`;

const Subtitle = styled.p`
  color: ${({ theme }) => theme.colors.text}; // Slightly darker for better contrast on light gradient
  font-size: 1.5rem;
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  max-width: 700px; // Constrain width for readability
  margin-left: auto;
  margin-right: auto;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    font-size: 1.2rem;
  }
`;

const CTAButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  justify-content: center;
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const ContentWrapper = styled(Container)` // Use Container for consistent padding
  padding-top: ${({ theme }) => theme.spacing.xxl};
  padding-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const Features = styled.section`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};
  /* Removed margin-top, ContentWrapper handles overall spacing */
`;

// Added $accentColor prop for dynamic styling
const FeatureCard = styled(Card)<{ $accentColor?: string }>`
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  border-top: 5px solid ${({ theme, $accentColor }) => $accentColor || theme.colors.primary};
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;

  &:hover {
    transform: translateY(-5px);
    box-shadow: ${({ theme }) => theme.shadows.lg};
  }
  
  h3 {
    // Use the accent color for the heading
    color: ${({ theme, $accentColor }) => $accentColor || theme.colors.primary};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    font-size: 1.3rem; // Slightly larger
  }
  
  p {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 1rem; // Slightly larger
  }
`;

// Optional: For displaying the Skolr logo image if you have it


export default function Home() {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);
  const [isRedirecting, setIsRedirecting] = useState(false); 
  const router = useRouter();
  const supabase = createClient();
  const theme = useTheme(); // Access the theme object for colors

  useEffect(() => {
    const checkUserAndRedirect = async () => {
      setLoading(true); 
      setIsRedirecting(false); 

      try {
        const { data: { user: currentUser } } = await supabase.auth.getUser(); 
        setUser(currentUser);
        
        if (currentUser) {
          setIsRedirecting(true); 
          
          const { data: profile, error: profileError } = await supabase
            .from('profiles')
            .select('role')
            .eq('user_id', currentUser.id)
            .single();

          if (profileError) {
            console.error('Error fetching profile on homepage:', profileError.message);
            setIsRedirecting(false); 
            setLoading(false);
            return;
          }
          
          if (profile?.role === 'teacher') {
            router.push('/teacher-dashboard');
          } else if (profile?.role === 'student') {
            router.push('/student/dashboard'); 
          } else {
            setIsRedirecting(false);
          }
        }
      } catch (error) {
        console.error('Error in checkUserAndRedirect on homepage:', error);
        setIsRedirecting(false);
      } finally {
        setLoading(false);
      }
    };

    checkUserAndRedirect();
  }, [router, supabase]);

  if (loading || isRedirecting) {
    return (
      <HomePage>
        <ContentWrapper> {/* Use ContentWrapper for consistent padding */}
          <Hero> {/* Hero still used for structure, but gradient is lighter */}
            <Title>{loading ? "Loading..." : APP_NAME}</Title>
          </Hero>
        </ContentWrapper>
      </HomePage>
    );
  }

  // Define accent colors for feature cards from your theme
  const featureCardAccents = [
    theme.colors.magenta, // #C848AF
    theme.colors.blue,    // #4CBEF3 (which is your theme.colors.blue, originally skolrCyan)
    theme.colors.green    // #7BBC44
  ];

  return (
    <HomePage>
      <Hero>
        {/* Optional: If you have the Skolr logo image */}
        {/* <LogoImageContainer>
          <Image 
            src="/logos/skolr-banner.png" // Replace with your actual logo path
            alt="Skolr"
            width={500} // Adjust
            height={150} // Adjust
            priority
          />
        </LogoImageContainer> */}
        <Title>{APP_NAME}</Title>
        <Subtitle>{APP_DESCRIPTION}</Subtitle>
        
        {!user && (
          <CTAButtons>
            <Button size="large" onClick={() => router.push('/auth?type=teacher_signup')}>
              Teacher Sign Up FREE
            </Button>
            {/* Optional: Add a separate, less prominent "Teacher Sign In" button if desired */}
            {/* For example:
            <Button size="large" variant="outline" onClick={() => router.push('/auth')}>
              Teacher Sign In
            </Button>
            */}
            <Button size="large" variant="secondary" onClick={() => router.push('/join')}>
              Student: Join Class
            </Button>
          </CTAButtons>
        )}
      </Hero>

      <ContentWrapper> {/* Wrap Features in ContentWrapper for padding */}
        <Features>
          <FeatureCard $accentColor={featureCardAccents[0]}>
            <h3>For Teachers</h3>
            <p>Create custom AI learning companions tailored to your classroom needs and curriculum.</p>
          </FeatureCard>
          <FeatureCard $accentColor={featureCardAccents[1]}>
            <h3>For Students</h3>
            <p>Engage interactively with AI assistants for support, practice, and deeper understanding.</p>
          </FeatureCard>
          <FeatureCard $accentColor={featureCardAccents[2]}>
            <h3>Smart & Safe</h3>
            <p>Benefit from RAG-powered knowledge, AI assessments, and integrated safety monitoring.</p>
          </FeatureCard>
        </Features>
      </ContentWrapper>
    </HomePage>
  );
}/* src/app/globals.css */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Inter, -apple-system, BlinkMacSystemFont, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

a {
  color: inherit;
  text-decoration: none;
}

@media (prefers-color-scheme: dark) {
  html {
    color-scheme: dark;
  }
}// src/app/providers.tsx
'use client';

import StyledComponentsRegistry from '@/lib/StyledComponentsRegistry';
import ThemeProvider from '@/components/ThemeProvider';

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <StyledComponentsRegistry>
      <ThemeProvider>
        {children}
      </ThemeProvider>
    </StyledComponentsRegistry>
  );
}// src/styles/GlobalStyles.ts
'use client';

import { createGlobalStyle } from 'styled-components';

export const GlobalStyles = createGlobalStyle`
  /* Use web-safe fonts for now - add Google Fonts to your layout.tsx instead */
  
  * {
    box-sizing: border-box;
    padding: 0;
    margin: 0;
  }
  
  html, body {
    max-width: 100vw;
    overflow-x: hidden;
    background-color: ${({ theme }) => theme.colors.background};
    color: ${({ theme }) => theme.colors.text};
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.6;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: ${({ theme }) => theme.fonts.heading};
    line-height: 1.2;
    color: ${({ theme }) => theme.colors.text};
    font-weight: 600;
  }
  
  h1 { font-size: 2.5rem; }
  h2 { font-size: 2rem; }
  h3 { font-size: 1.75rem; }
  h4 { font-size: 1.5rem; }
  h5 { font-size: 1.25rem; }
  h6 { font-size: 1rem; }
  
  p {
    margin-bottom: 1rem;
    line-height: 1.6;
  }
  
  a {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: none;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primaryLight};
    }
  }
  
  button {
    font-family: ${({ theme }) => theme.fonts.body};
    cursor: pointer;
    border: none;
    background: none;
    transition: all ${({ theme }) => theme.transitions.fast};
    
    &:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }
  }
  
  input, textarea, select {
    font-family: ${({ theme }) => theme.fonts.body};
    line-height: 1.5;
  }
  
  /* Custom scrollbar styles */
  ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  
  ::-webkit-scrollbar-track {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  ::-webkit-scrollbar-thumb {
    background: ${({ theme }) => theme.colors.border};
    border-radius: ${({ theme }) => theme.borderRadius.small};
  }
  
  ::-webkit-scrollbar-thumb:hover {
    background: ${({ theme }) => theme.colors.borderDark};
  }
  
  /* Focus styles */
  button:focus-visible,
  input:focus-visible,
  textarea:focus-visible,
  select:focus-visible {
    outline: 2px solid ${({ theme }) => theme.colors.focus};
    outline-offset: 2px;
  }
`;// src/styles/StyledComponents.ts
import styled, { css } from 'styled-components'; // Added css import
import Link from 'next/link'; // Import Link for the new StyledLink

export const Container = styled.div`
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0 ${({ theme }) => theme.spacing.md};
  }
`;

export const Card = styled.div<{ $accentColor?: string; $accentSide?: 'top' | 'left' }>` // Added optional accent props
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.xl};
  padding: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  border: 1px solid ${({ theme }) => theme.colors.border};
  position: relative; // Needed for pseudo-elements if we go that route, or direct border

  // Subtle accent border using the $accentColor prop or defaulting to a light primary
  // You can choose 'top' or 'left' (or add more)
  ${({ theme, $accentColor, $accentSide = 'top' }) => {
    const color = $accentColor || theme.colors.primary + '70'; // Default to semi-transparent primary
    if ($accentSide === 'top') {
      return css`
        border-top: 4px solid ${color};
      `;
    }
    if ($accentSide === 'left') {
      return css`
        border-left: 4px solid ${color};
      `;
    }
    return ''; // No accent border if side is not specified or matched
  }}


  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.lg};
  }
`;

export const Button = styled.button<{
    variant?: 'primary' | 'secondary' | 'outline' | 'danger' | 'magenta' | 'cyan' | 'text'; // Added magenta, cyan, text
    size?: 'small' | 'medium' | 'large';
  }>`
    background: ${({ theme, variant = 'primary' }) => {
      if (variant === 'primary') return theme.colors.primary;
      if (variant === 'secondary') return theme.colors.secondary;
      if (variant === 'danger') return theme.colors.red;
      if (variant === 'magenta') return theme.colors.magenta;
      if (variant === 'cyan') return theme.colors.blue; // Assuming theme.colors.blue is your skolrCyan
      return 'transparent'; // For 'outline', 'text', or default
    }};
    color: ${({ theme, variant = 'primary' }) => {
      if (variant === 'outline') return theme.colors.primary;
      if (variant === 'text') return theme.colors.primary; // Text buttons often use primary color
      // For solid backgrounds (primary, secondary, danger, magenta, cyan), text is usually white
      return 'white'; 
    }};
    border: ${({ theme, variant = 'primary' }) => { // Added default to 'primary' for variant
      if (variant === 'outline') return `2px solid ${theme.colors.primary}`;
      if (variant === 'danger') return `2px solid ${theme.colors.red}`;
      if (variant === 'magenta') return `2px solid ${theme.colors.magenta}`;
      if (variant === 'cyan') return `2px solid ${theme.colors.blue}`;
      // For 'primary', 'secondary', 'text' -> no border by default
      return 'none'; 
    }};
    padding: ${({ theme, size = 'medium', variant }) => {
      if (variant === 'text') return `${theme.spacing.xs} ${theme.spacing.sm}`; // Smaller padding for text buttons
      return size === 'small' ? `${theme.spacing.xs} ${theme.spacing.md}` :
             size === 'large' ? `${theme.spacing.md} ${theme.spacing.xl}` :
             `${theme.spacing.sm} ${theme.spacing.lg}`;
    }};
    border-radius: ${({ theme }) => theme.borderRadius.large};
    font-weight: 600; // Slightly bolder
    transition: all ${({ theme }) => theme.transitions.fast};
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1.2;
    text-decoration: none;

    &:hover:not(:disabled) {
      background: ${({ theme, variant = 'primary' }) => {
        if (variant === 'primary') return theme.colors.primaryDark;
        if (variant === 'secondary') return theme.colors.secondaryDark;
        if (variant === 'danger') return darken(theme.colors.red, 10); // Use darken helper
        if (variant === 'magenta') return darken(theme.colors.magenta, 10);
        if (variant === 'cyan') return darken(theme.colors.blue, 10);
        if (variant === 'outline') return theme.colors.primary; 
        if (variant === 'text') return theme.colors.backgroundDark; // Subtle background on hover for text
        return undefined;
      }};
      border-color: ${({ theme, variant = 'primary' }) => {
        if (variant === 'danger') return darken(theme.colors.red, 10);
        if (variant === 'magenta') return darken(theme.colors.magenta, 10);
        if (variant === 'cyan') return darken(theme.colors.blue, 10);
        if (variant === 'outline') return theme.colors.primary;
        return undefined;
      }};
      color: ${({ theme, variant = 'primary' }) => { // Added theme to access colors
        if (variant === 'outline') return 'white';
        if (variant === 'text') return theme.colors.primaryDark; // Darker text on hover for text button
        return 'white'; 
      }};
      transform: translateY(-1px);
      box-shadow: ${({ theme, variant }) => (variant !== 'text' ? theme.shadows.md : 'none')}; // No shadow for text buttons
    }

    &:active:not(:disabled) {
      transform: translateY(0);
      box-shadow: none;
    }

    &:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  `;

// Inherit from Button for consistency
export const SecondaryButton = styled(Button).attrs({ variant: 'secondary' })``;
export const OutlineButton = styled(Button).attrs({ variant: 'outline' })``;
export const DangerButton = styled(Button).attrs({ variant: 'danger' })``;
export const MagentaButton = styled(Button).attrs({ variant: 'magenta' })``; // New MagentaButton
export const CyanButton = styled(Button).attrs({ variant: 'cyan' })``;     // New CyanButton
export const TextButton = styled(Button).attrs({ variant: 'text' })``;       // New TextButton


export const FormGroup = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

export const Label = styled.label`
  display: block;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.9rem;
`;

export const Input = styled.input`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border}; // Thinner border for inputs
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  min-height: 44px;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colors.primary + '30'}; // Adjusted focus shadow
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const TextArea = styled.textarea`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border}; // Thinner border
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.6;
  transition: border-color ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  min-height: 100px;
  resize: vertical;

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colors.primary + '30'}; // Adjusted focus shadow
  }

  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }

   &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

export const Select = styled.select`
  width: 100%;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border}; // Thinner border
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  line-height: 1.5;
  transition: border-color ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};
  min-height: 44px;
  cursor: pointer;
  appearance: none;
  background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23${({ theme }) => theme.colors.textMuted.replace('#', '')}%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
  background-repeat: no-repeat;
  background-position: right ${({ theme }) => theme.spacing.md} center;
  background-size: 0.65em auto;
  padding-right: ${({ theme }) => `calc(${theme.spacing.md} * 2.5 + 1em)`};

  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
    outline: none;
    box-shadow: 0 0 0 3px ${({ theme }) => theme.colors.primary + '30'}; // Adjusted focus shadow
  }

  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
    background-color: ${({ theme }) => theme.colors.backgroundDark};
    background-image: none;
  }

  option {
    color: ${({ theme }) => theme.colors.text};
    background: ${({ theme }) => theme.colors.background};
  }
`;

export const Alert = styled.div<{ variant?: 'info' | 'success' | 'warning' | 'error' }>`
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  border-left: 4px solid;
  font-size: 0.9rem;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `
          background: ${theme.colors.green + '15'};
          border-color: ${theme.colors.green};
          color: ${darken(theme.colors.green, 25)}; // Darker text for better contrast
        `;
      case 'warning':
        return `
          background: ${theme.colors.secondary + '15'};
          border-color: ${theme.colors.secondary};
          color: ${darken(theme.colors.secondaryDark, 10)}; // Darker text
        `;
      case 'error':
        return `
          background: ${theme.colors.red + '15'};
          border-color: ${theme.colors.red};
          color: ${darken(theme.colors.red, 20)}; // Darker text
        `;
      default: // info (uses theme.colors.blue which is our skolrCyan)
        return `
          background: ${theme.colors.blue + '15'};
          border-color: ${theme.colors.blue};
          color: ${darken(theme.colors.blue, 25)}; // Darker text
        `;
    }
  }}
`;

export const Badge = styled.span<{ variant?: 'default' | 'success' | 'warning' | 'error' | 'magenta' | 'cyan' }>`
  display: inline-flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.round};
  font-size: 0.75rem;
  font-weight: 600;
  line-height: 1;
  text-transform: uppercase;
  letter-spacing: 0.05em;

  ${({ variant, theme }) => {
    switch (variant) {
      case 'success':
        return `background: ${theme.colors.green + '20'}; color: ${theme.colors.green};`;
      case 'warning':
        return `background: ${theme.colors.secondary + '20'}; color: ${theme.colors.secondaryDark};`;
      case 'error':
        return `background: ${theme.colors.red + '20'}; color: ${theme.colors.red};`;
      case 'magenta': // New magenta badge
        return `background: ${theme.colors.magenta + '20'}; color: ${theme.colors.magenta};`;
      case 'cyan':    // New cyan badge (uses theme.colors.blue)
        return `background: ${theme.colors.blue + '20'}; color: ${theme.colors.blue};`;
      default: // default uses primary
        return `background: ${theme.colors.primary + '20'}; color: ${theme.colors.primary};`;
    }
  }}
`;

// New StyledLink component
export const StyledLink = styled(Link)<{ $variant?: 'primary' | 'secondary' | 'magenta' | 'cyan' | 'default' }>`
  color: ${({ theme, $variant = 'primary' }) => {
    if ($variant === 'secondary') return theme.colors.secondaryDark;
    if ($variant === 'magenta') return theme.colors.magenta;
    if ($variant === 'cyan') return theme.colors.blue; // theme.colors.blue is skolrCyan
    if ($variant === 'default') return theme.colors.text;
    return theme.colors.primary;
  }};
  text-decoration: none;
  font-weight: 500;
  transition: color ${({ theme }) => theme.transitions.fast};

  &:hover {
    text-decoration: underline;
    color: ${({ theme, $variant = 'primary' }) => {
      if ($variant === 'secondary') return darken(theme.colors.secondaryDark, 10);
      if ($variant === 'magenta') return darken(theme.colors.magenta, 10);
      if ($variant === 'cyan') return darken(theme.colors.blue, 10);
      if ($variant === 'default') return theme.colors.primary; // Default text link hovers to primary
      return theme.colors.primaryDark;
    }};
  }
`;

// Helper function (can be moved to a utils file if used elsewhere)
const darken = (color: string, percent: number): string => {
  const num = parseInt(color.replace("#",""), 16),
    amt = Math.round(2.55 * percent),
    R = Math.max(0, (num >> 16) - amt),
    G = Math.max(0, (num >> 8 & 0x00FF) - amt),
    B = Math.max(0, (num & 0x0000FF) - amt);
  return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
};// src/styles/theme.ts
import { DefaultTheme } from 'styled-components';

// New Skolr Brand Colors (defined for clarity and easy reference)
const skolrPurple = '#985DD7';
const skolrCyan = '#4CBEF3';
const skolrMagenta = '#C848AF';
const skolrGreen = '#7BBC44';
const skolrCoral = '#FE4372';
const skolrOrange = '#FFB612';

// Helper function to generate lighter/darker shades (basic example, you might use a tool)
// This is a very simplistic way to generate shades. For best results, pick them manually or use a color tool.
const lighten = (color: string, percent: number): string => {
  const num = parseInt(color.replace("#",""), 16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) + amt,
    G = (num >> 8 & 0x00FF) + amt,
    B = (num & 0x0000FF) + amt;
  return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
};

const darken = (color: string, percent: number): string => {
  const num = parseInt(color.replace("#",""), 16),
    amt = Math.round(2.55 * percent),
    R = (num >> 16) - amt,
    G = (num >> 8 & 0x00FF) - amt,
    B = (num & 0x0000FF) - amt;
  return "#" + (0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1);
};


const theme: DefaultTheme = {
  colors: {
    // Primary colors
    primary: skolrPurple, 
    primaryLight: lighten(skolrPurple, 15), // Lighter purple (e.g., #b589e0)
    primaryDark: darken(skolrPurple, 15),  // Darker purple (e.g., #7a4bb5)
    
    // Secondary colors
    secondary: skolrOrange, 
    secondaryLight: lighten(skolrOrange, 10), // Lighter orange (e.g., #ffc74e)
    secondaryDark: darken(skolrOrange, 10),  // Darker orange (e.g., #e5a000)
    
    // Neutral colors (keeping these as the base for a light theme)
    background: '#FFFFFF', 
    backgroundDark: '#F5F5F5', 
    backgroundCard: '#F9FAFB', 
    text: '#1A1E2E', 
    textLight: '#5E6C7A', 
    textMuted: '#9CA3AF', 
    
    // Accent/Status colors
    green: skolrGreen, 
    red: skolrCoral, 
    blue: skolrCyan, // Using Cyan for info/blue context
    
    // Additional brand accent color
    magenta: skolrMagenta,
    
    // UI colors
    border: '#E5E7EB', 
    borderDark: '#D1D5DB', 
    focus: skolrPurple, // Focus ring color now matches new primary
    shadow: '0, 0, 0', 
  },
  
  fonts: {
    heading: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    body: "'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
    mono: "'SF Mono', 'Fira Code', Consolas, monospace",
  },
  
  spacing: {
    xs: '4px',
    sm: '8px',
    md: '16px',
    lg: '24px',
    xl: '32px',
    xxl: '48px',
  },
  
  borderRadius: {
    small: '6px',
    medium: '8px',
    large: '12px',
    xl: '16px',
    round: '50%',
  },
  
  shadows: {
    sm: '0 1px 2px rgba(0, 0, 0, 0.05)',
    md: '0 4px 6px rgba(0, 0, 0, 0.1)',
    lg: '0 10px 15px rgba(0, 0, 0, 0.1)',
    xl: '0 20px 25px rgba(0, 0, 0, 0.1)',
  },
  
  gradients: {
    primary: `linear-gradient(135deg, ${skolrPurple}, ${lighten(skolrPurple, 20)})`, // Updated
    secondary: `linear-gradient(135deg, ${skolrOrange}, ${lighten(skolrOrange, 15)})`, // Updated
  },
  
  breakpoints: {
    mobile: '480px',
    tablet: '768px',
    desktop: '1024px',
    wide: '1280px',
  },
  
  transitions: {
    fast: '0.15s ease',
    normal: '0.25s ease',
    slow: '0.35s ease',
  },
};

export default theme;// src/components/auth/MagicLink.tsx
'use client';

import { useState, useEffect, Suspense } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Alert } from '@/styles/StyledComponents';

const MagicCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
  text-align: center;
`;

const Title = styled.h1`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const SubText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
`;

const RoomCode = styled.div`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-size: 2rem;
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  margin: ${({ theme }) => theme.spacing.lg} 0;
  border: 3px dashed ${({ theme }) => theme.colors.primary};
  padding: ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  letter-spacing: 0.2em;
  background: ${({ theme }) => theme.colors.primary}10;
`;

function MagicLinkContent() {
  const [status, setStatus] = useState<'loading' | 'success' | 'error'>('loading');
  const [error, setError] = useState<string>('');
  const [roomCode, setRoomCode] = useState<string>('');
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const handleMagicLink = async () => {
      // Check if we're in the browser
      if (typeof window === 'undefined') return;

      const params = new URLSearchParams(window.location.search);
      // Get all possible parameters
      const code = params.get('token') || params.get('code');
      const roomCodeParam = params.get('room');
      
      if (!code || !roomCodeParam) {
        console.log('Missing parameters:', { code, roomCodeParam });
        setError('Invalid magic link: missing required parameters');
        setStatus('error');
        return;
      }

      setRoomCode(roomCodeParam);

      try {
        // Exchange code for session using client-side supabase only
        const { error: authError } = await supabase.auth.exchangeCodeForSession(code);
        if (authError) throw authError;

        // Get user data
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) throw userError || new Error('No user found');

        // Get room details
        const { data: room, error: roomError } = await supabase
          .from('rooms')
          .select('room_id, school_id')
          .eq('room_code', roomCodeParam)
          .single();

        if (roomError || !room) throw roomError || new Error('Room not found');

        // Create or update user profile
        const { error: profileError } = await supabase
          .from('profiles')
          .upsert(
            { 
              user_id: user.id,
              email: user.email || '',
              role: 'student',
              school_id: room.school_id 
            },
            { onConflict: 'user_id' }
          );

        if (profileError) throw profileError;

        // Join the room
        const { error: joinError } = await supabase
          .from('room_memberships')
          .insert({
            room_id: room.room_id,
            student_id: user.id
          });

        // Ignore duplicate errors
        if (joinError && !joinError.message.includes('duplicate')) {
          throw joinError;
        }

        setStatus('success');
        
        // Redirect to student dashboard after 2 seconds
        setTimeout(() => {
          router.push('/student');
        }, 2000);

      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to process magic link');
        setStatus('error');
      }
    };

    handleMagicLink();
  }, [router, supabase]);

  return (
    <MagicCard>
      <Title>Join Classroom</Title>
      
      {roomCode && (
        <RoomCode>{roomCode}</RoomCode>
      )}

      {status === 'loading' && (
        <SubText>Processing your invitation...</SubText>
      )}

      {status === 'success' && (
        <>
          <Alert variant="success">Successfully joined classroom!</Alert>
          <SubText>Redirecting to your dashboard...</SubText>
        </>
      )}

      {status === 'error' && (
        <>
          <Alert variant="error">{error}</Alert>
          <Button onClick={() => router.push('/auth')}>
            Go to Login
          </Button>
        </>
      )}
    </MagicCard>
  );
}

export default function MagicLink() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <MagicLinkContent />
    </Suspense>
  );
}// src/components/auth/AuthForm.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, FormGroup, Label, Input, Button as StyledButton, Alert, Select as StyledSelect } from '@/styles/StyledComponents';

const AuthCard = styled(Card)`
  max-width: 400px;
  margin: 4rem auto;
`;

const HelpText = styled.div`
  font-size: 0.95em;
  color: ${({ theme }) => theme.colors.textLight};
  margin-top: ${({ theme }) => theme.spacing.xs};
`;

const Title = styled.h1`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
`;

const InfoBox = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  padding: ${({ theme }) => theme.spacing.md};
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  
  p {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
  
  strong {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

interface AuthFormProps {
  type: 'login' | 'signup';
}

export default function AuthForm({ type }: AuthFormProps) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [fullName, setFullName] = useState('');
  const [countryCode, setCountryCode] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const router = useRouter();
  const searchParams = useSearchParams();
  const supabase = createClient();

  const isStudentSignup = searchParams?.get('type') === 'student';
  const redirectTo = searchParams?.get('redirect') || '/';

  const checkUser = useCallback(async () => {
    const { data: { user } } = await supabase.auth.getUser();
    if (user) {
      router.push(redirectTo);
    }
  }, [supabase, router, redirectTo]);

  useEffect(() => {
    checkUser();
  }, [checkUser]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (type === 'signup' && !fullName.trim()) {
      setError('Full name is required');
      return;
    }
    
    setLoading(true);
    setError('');

    try {
      if (type === 'signup') {
        const role = isStudentSignup ? 'student' : 'teacher';
        
        const signupData: { role: string; full_name: string; country_code?: string | null } = {
            role: role,
            full_name: fullName,
        };

        if (role === 'teacher') {
            signupData.country_code = countryCode.trim() || null;
        }
        
        const { error: signUpError } = await supabase.auth.signUp({
          email,
          password,
          options: {
            emailRedirectTo: `${window.location.origin}/auth/callback?redirect=${encodeURIComponent(redirectTo)}`,
            data: signupData
          },
        });
        
        if (signUpError) {
          console.error('Signup error details:', signUpError);
          throw signUpError;
        }
        
        if (isStudentSignup) {
          await new Promise(resolve => setTimeout(resolve, 1000));
          const { data: signInData, error: signInError } = await supabase.auth.signInWithPassword({
            email,
            password,
          });
          if (!signInError && signInData.user) {
            router.push(redirectTo);
          } else {
            setError('Account created! Please log in to continue.');
            setTimeout(() => {
              router.push(`/auth?type=login&redirect=${encodeURIComponent(redirectTo)}`);
            }, 3000);
          }
        } else { 
          alert('Check your email for the confirmation link! Please also check your spam folder.');
        }
      } else { 
        const { error: signInError } = await supabase.auth.signInWithPassword({
          email,
          password,
        });
        if (signInError) {
          throw signInError;
        }
        router.push(redirectTo);
        router.refresh();
      }
    } catch (error) {
      console.error('Auth error:', error);
      setError(error instanceof Error ? error.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  if (isStudentSignup && type === 'signup') {
    return (
      <AuthCard>
        <Title>Student Sign Up</Title>
        <InfoBox>
          <p><strong>For Students:</strong> Sign up here to join your classroom.</p>
        </InfoBox>
        {error && <Alert variant="error">{error}</Alert>}
        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="fullName">Full Name</Label>
            <Input
              id="fullName"
              type="text"
              value={fullName}
              onChange={(e) => setFullName(e.target.value)}
              placeholder="Enter your full name"
              required
            />
          </FormGroup>
          <FormGroup>
            <Label htmlFor="email">Email</Label>
            <Input
              id="email"
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              placeholder="Enter your email"
              required
            />
          </FormGroup>
          <FormGroup>
            <Label htmlFor="password">Password</Label>
            <Input
              id="password"
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Create a password"
              required
            />
          </FormGroup>
          <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
            {loading ? 'Creating Account...' : 'Sign Up as Student'}
          </StyledButton>
        </form>
      </AuthCard>
    );
  }

  return (
    <AuthCard>
      <Title>{type === 'login' ? 'Login' : 'Teacher Sign Up'}</Title>
      
      {type === 'signup' && ( 
        <InfoBox>
          <p><strong>For Teachers:</strong> Sign up here to create your teacher account.</p>
          {!isStudentSignup && ( 
             <p><strong>For Students:</strong> Ask your teacher for a join link to create your account.</p>
          )}
        </InfoBox>
      )}
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        {type === 'signup' && ( 
          <>
            <FormGroup>
              <Label htmlFor="fullName">Full Name</Label>
              <Input
                id="fullName"
                type="text"
                value={fullName}
                onChange={(e) => setFullName(e.target.value)}
                placeholder="Enter your full name"
                required
              />
            </FormGroup>
            {!isStudentSignup && ( 
                 <FormGroup>
                    <Label htmlFor="countryCode">Your Country (Optional)</Label>
                    <StyledSelect
                        id="countryCode"
                        name="countryCode"
                        value={countryCode}
                        onChange={(e) => setCountryCode(e.target.value)}
                    >
                        <option value="">Select Country</option>
                        <option value="US">United States</option>
                        <option value="GB">United Kingdom</option>
                        <option value="CA">Canada</option>
                        <option value="AU">Australia</option>
                        <option value="NZ">New Zealand</option>
                        {/* MODIFIED: Added AE */}
                        <option value="AE">United Arab Emirates</option> 
                        <option value="EU">EU (Other)</option> {/* Renamed EU slightly for clarity */}
                    </StyledSelect>
                    <HelpText>Selecting your country helps us provide localized safety resources for your students if a concern is flagged.</HelpText>
                 </FormGroup>
            )}
          </>
        )}
        <FormGroup>
          <Label htmlFor="email">Email</Label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            placeholder="Enter your email"
            required
          />
        </FormGroup>
        <FormGroup>
          <Label htmlFor="password">Password</Label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            placeholder="Enter your password"
            required
          />
        </FormGroup>
        <StyledButton type="submit" disabled={loading} style={{ width: '100%' }}>
          {loading ? 'Loading...' : type === 'login' ? 'Login' : 'Sign Up as Teacher'}
        </StyledButton>
      </form>
    </AuthCard>
  );
}// src/components/layout/Footer.tsx
'use client';

import styled from 'styled-components';
import { Container } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';

const FooterWrapper = styled.footer`
  background: ${({ theme }) => theme.colors.backgroundCard};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.xl} 0;
  margin-top: auto;
`;

const FooterContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    text-align: center;
  }
`;

const Copyright = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

const Links = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.lg};
  
  a {
    color: ${({ theme }) => theme.colors.textMuted};
    text-decoration: none;
    font-size: 0.875rem;
    transition: color ${({ theme }) => theme.transitions.fast};
    
    &:hover {
      color: ${({ theme }) => theme.colors.primary};
    }
  }
`;

export default function Footer() {
  const currentYear = new Date().getFullYear();
  
  return (
    <FooterWrapper>
      <Container>
        <FooterContent>
          <Copyright>
            © {currentYear} {APP_NAME}. All rights reserved.
          </Copyright>
          <Links>
            <a href="/privacy">Privacy Policy</a>
            <a href="/terms">Terms of Service</a>
            <a href="/help">Help Center</a>
          </Links>
        </FooterContent>
      </Container>
    </FooterWrapper>
  );
}// src/components/layout/Header.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { useEffect, useState } from 'react';
import { createClient } from '@/lib/supabase/client'; // Your client import
import { Container, Button } from '@/styles/StyledComponents';
import { APP_NAME } from '@/lib/utils/constants';
import type { User } from '@supabase/supabase-js';
import { usePathname } from 'next/navigation'; // Import usePathname for active link styling

const HeaderWrapper = styled.header`
  background: ${({ theme }) => theme.colors.background};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md} 0;
  position: sticky;
  top: 0;
  z-index: 100;
`;

const HeaderContent = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-wrap: wrap;
    gap: ${({ theme }) => theme.spacing.sm};
  }
`;

const Logo = styled(Link)`
  font-size: 1.5rem;
  font-weight: 700;
  color: ${({ theme }) => theme.colors.primary};
  text-decoration: none;
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  
  &:hover {
    color: ${({ theme }) => theme.colors.primaryDark};
  }
`;

const Nav = styled.nav`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    order: 3;
    width: 100%;
    justify-content: center;
    margin-top: ${({ theme }) => theme.spacing.sm};
    gap: ${({ theme }) => theme.spacing.md};
  }
`;

const NavLink = styled(Link)<{ $isActive?: boolean }>`
  color: ${({ theme, $isActive }) => $isActive ? theme.colors.primary : theme.colors.text};
  text-decoration: none;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  transition: all ${({ theme }) => theme.transitions.fast};
  font-weight: ${({ $isActive }) => $isActive ? '600' : '500'};
  background: ${({ theme, $isActive }) => $isActive ? (theme.colors.primary + '20') : 'transparent'};
  
  &:hover {
    background: ${({ theme, $isActive }) => $isActive ? (theme.colors.primary + '30') : theme.colors.backgroundDark};
    color: ${({ theme }) => theme.colors.primary};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.sm};
    flex: 1;
    text-align: center;
  }
`;

const UserSection = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    min-width: 100px; /* Ensure consistent space */
    justify-content: flex-end;
  }
`;

const HeaderButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    font-size: 0.9rem;
  }
`;

export default function Header() {
  const [user, setUser] = useState<User | null>(null);
  const [userRole, setUserRole] = useState<string | null>(null);
  const supabase = createClient(); // Supabase client initialized here
  const pathname = usePathname();

  // --- START OF CODE TO ADD/VERIFY ---
  useEffect(() => {
    // Expose supabase client to the window object FOR TESTING PURPOSES ONLY
    if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
      // @ts-expect-error // TypeScript might complain, ignore for testing
      window.supabaseClientInstance = supabase;
      console.log("Supabase client instance EXPOSED to window.supabaseClientInstance for testing.");
    }
  }, [supabase]); // Dependency array includes supabase
  // --- END OF CODE TO ADD/VERIFY ---

  useEffect(() => {
    const getUserInfo = async () => {
      const { data: { user: currentUser } } = await supabase.auth.getUser();
      setUser(currentUser);
      
      if (currentUser) {
        const { data: profile } = await supabase
          .from('profiles')
          .select('role')
          .eq('user_id', currentUser.id)
          .single();
        
        if (profile) {
          setUserRole(profile.role);
        } else {
          setUserRole(null);
        }
      } else {
        setUserRole(null);
      }
    };
    
    getUserInfo();

    const { data: { subscription } } = supabase.auth.onAuthStateChange((_event, session) => {
      const sessionUser = session?.user || null;
      setUser(sessionUser);
      
      if (sessionUser) {
        supabase
          .from('profiles')
          .select('role')
          .eq('user_id', sessionUser.id)
          .single()
          .then(({ data: profileData, error: profileError }) => {
            if (profileError) {
              console.warn("Error fetching profile on auth state change:", profileError.message);
              setUserRole(null);
              return;
            }
            if (profileData) {
              setUserRole(profileData.role);
            } else {
              setUserRole(null);
            }
          });
      } else {
        setUserRole(null);
      }
    });

    return () => {
      subscription.unsubscribe();
    };
  }, [supabase]); // supabase is already a dependency here

  const handleSignOut = async () => {
    await supabase.auth.signOut();
    window.location.href = '/'; 
  };

  const isLinkActive = (href: string) => {
    if (href === '/teacher-dashboard' || href === '/student/dashboard') {
        return pathname.startsWith(href);
    }
    return pathname === href;
  };

  return (
    <HeaderWrapper>
      <Container>
        <HeaderContent>
          <Logo href="/">
            {APP_NAME}
          </Logo>
          
          {user && userRole && (
            <Nav>
              {userRole === 'teacher' && (
                <NavLink href="/teacher-dashboard" $isActive={isLinkActive('/teacher-dashboard')}>
                  Dashboard
                </NavLink>
              )}
              {userRole === 'student' && (
                <NavLink href="/student/dashboard" $isActive={isLinkActive('/student/dashboard')}>
                  Dashboard 
                </NavLink>
              )}
            </Nav>
          )}
          
          <UserSection>
            {user ? (
              <HeaderButton variant="outline" onClick={handleSignOut}>
                Sign Out
              </HeaderButton>
            ) : (
              pathname !== '/auth' && (
                <HeaderButton as={Link} href="/auth">
                  Sign In
                </HeaderButton>
              )
            )}
          </UserSection>
        </HeaderContent>
      </Container>
    </HeaderWrapper>
  );
}// src/components/student/RoomList.tsx
'use client';

import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button } from '@/styles/StyledComponents';
import type { StudentRoom } from '@/types/student.types';

const RoomGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCard = styled(Card)`
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast};
  
  &:hover {
    transform: translateY(-2px);
  }
`;

const RoomHeader = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const RoomName = styled.h3`
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 1.25rem;
`;

const RoomDetails = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const ChatbotsList = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ChatbotInfo = styled.div`
  font-weight: 600;
  color: ${({ theme }) => theme.colors.text};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.div`
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  font-size: 0.875rem;
  
  &:last-child {
    margin-bottom: 0;
  }
  
  strong {
    color: ${({ theme }) => theme.colors.text};
  }
  
  p {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-top: ${({ theme }) => theme.spacing.xs};
  }
`;

const EmptyState = styled.div`
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  padding: ${({ theme }) => theme.spacing.sm};
  background: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
`;

const RoomFooter = styled.div`
  margin-top: auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
`;

const JoinedDate = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface RoomListProps {
  rooms: StudentRoom[];
}

export default function RoomList({ rooms }: RoomListProps) {
  return (
    <RoomGrid>
      {rooms.map((room) => (
        <RoomCard key={room.room_id}>
          <RoomHeader>
            <RoomName>{room.room_name}</RoomName>
            <RoomDetails>
              Room Code: <strong>{room.room_code}</strong>
            </RoomDetails>
          </RoomHeader>
          
          <ChatbotsList>
            {room.chatbots.length > 0 ? (
              <>
                <ChatbotInfo>
                  {room.chatbots.length} chatbot{room.chatbots.length > 1 ? 's' : ''}:
                </ChatbotInfo>
                {room.chatbots.map((chatbot) => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <strong>{chatbot.name}</strong>
                    {chatbot.description && (
                      <p>{chatbot.description}</p>
                    )}
                  </ChatbotItem>
                ))}
              </>
            ) : (
              <EmptyState>No chatbots assigned</EmptyState>
            )}
          </ChatbotsList>
          
          <RoomFooter>
            <JoinedDate>
              Joined: {new Date(room.joined_at || room.created_at).toLocaleDateString()}
            </JoinedDate>
            <Button 
              as={Link} 
              href={`/room/${room.room_id}`}
              size="medium"
              style={{ 
                minWidth: '120px',
                textAlign: 'center'
              }}
            >
              Enter Room
            </Button>
          </RoomFooter>
        </RoomCard>
      ))}
    </RoomGrid>
  );
}// src/components/student/JoinRoom.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, Input, Alert } from '@/styles/StyledComponents';
import { isValidRoomCode } from '@/lib/utils/room-codes';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const JoinCard = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0 0 ${({ theme }) => theme.spacing.sm} 0;
  color: ${({ theme }) => theme.colors.text};
`;

const Description = styled.p`
  color: ${({ theme }) => theme.colors.textLight};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Form = styled.form`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.lg};
`;

const RoomCodeInput = styled(Input)`
  text-align: center;
  text-transform: uppercase;
  font-size: 1.5rem;
  letter-spacing: 0.1em;
`;

const ButtonGroup = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
`;

interface JoinRoomProps {
  onClose: () => void;
  onSuccess: () => void;
}

export default function JoinRoom({ onClose, onSuccess }: JoinRoomProps) {
  const [roomCode, setRoomCode] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isCheckingAuth, setIsCheckingAuth] = useState(true);
  const router = useRouter();
  const supabase = createClient();

  useEffect(() => {
    const checkAuth = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setIsAuthenticated(true);
        }
      } catch (error) {
        console.error('Auth check error:', error);
      } finally {
        setIsCheckingAuth(false);
      }
    };
    
    checkAuth();
  }, [supabase]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);

    const formattedCode = roomCode.toUpperCase();

    if (!isValidRoomCode(formattedCode)) {
      setError('Invalid room code format');
      setIsLoading(false);
      return;
    }

    try {
      if (!isAuthenticated) {
        // If not authenticated, redirect to signup with room code
        router.push(`/auth?type=student&redirect=/join?code=${formattedCode}`);
        return;
      }

      const response = await fetch('/api/student/join-room', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ room_code: formattedCode }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to join room');
      }

      onSuccess();
      onClose();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to join room');
    } finally {
      setIsLoading(false);
    }
  };

  if (isCheckingAuth) {
    return (
      <Overlay>
        <JoinCard>
          <Header>
            <Title>Loading...</Title>
          </Header>
        </JoinCard>
      </Overlay>
    );
  }

  return (
    <Overlay>
      <JoinCard>
        <Header>
          <Title>Join Classroom</Title>
          <Description>
            {isAuthenticated 
              ? 'Enter the room code provided by your teacher'
              : 'You need to log in to join a classroom'
            }
          </Description>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <Form onSubmit={handleSubmit}>
          <RoomCodeInput
            type="text"
            value={roomCode}
            onChange={(e) => setRoomCode(e.target.value.toUpperCase())}
            placeholder="ROOM CODE"
            maxLength={6}
            required
          />
          
          <ButtonGroup>
            <Button 
              type="button" 
              variant="outline" 
              onClick={onClose}
              style={{ flex: 1 }}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isLoading}
              style={{ flex: 1 }}
            >
              {isLoading ? 'Joining...' : isAuthenticated ? 'Join Room' : 'Sign In'}
            </Button>
          </ButtonGroup>
        </Form>
      </JoinCard>
    </Overlay>
  );
}// src/components/student/ProfileCompletion.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';

const ProfileCard = styled(Card)`
  max-width: 500px;
  margin: 0 auto;
  padding: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h2`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.primary};
  text-align: center;
`;

const Description = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  color: ${({ theme }) => theme.colors.textLight};
`;

export default function ProfileCompletion({ onComplete }: { onComplete: () => void }) {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const supabase = createClient();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!firstName.trim() || !lastName.trim()) {
      setError('Please enter both first and last name');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const { data: { user } } = await supabase.auth.getUser();
      
      if (!user) {
        throw new Error('Not authenticated');
      }
      
      // Update profile with name information
      const { error: updateError } = await supabase
        .from('profiles')
        .update({
          name: `${firstName} ${lastName}`.trim(),
          // We could also add these fields if the database schema supports them
          // first_name: firstName,
          // last_name: lastName,
          updated_at: new Date().toISOString()
        })
        .eq('user_id', user.id);
      
      if (updateError) {
        throw updateError;
      }
      
      // Call the completion callback
      onComplete();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to update profile');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <ProfileCard>
      <Title>Complete Your Profile</Title>
      <Description>
        Please provide your name to complete your profile setup
      </Description>
      
      {error && <Alert variant="error">{error}</Alert>}
      
      <form onSubmit={handleSubmit}>
        <FormGroup>
          <Label htmlFor="firstName">First Name</Label>
          <Input
            id="firstName"
            value={firstName}
            onChange={(e) => setFirstName(e.target.value)}
            placeholder="Enter your first name"
            required
          />
        </FormGroup>
        
        <FormGroup>
          <Label htmlFor="lastName">Last Name</Label>
          <Input
            id="lastName"
            value={lastName}
            onChange={(e) => setLastName(e.target.value)}
            placeholder="Enter your last name"
            required
          />
        </FormGroup>
        
        <Button 
          type="submit" 
          disabled={isSubmitting}
          style={{ width: '100%' }}
        >
          {isSubmitting ? 'Saving...' : 'Complete Profile'}
        </Button>
      </form>
    </ProfileCard>
  );
}// src/components/shared/LoadingSpinner.tsx
'use client';

import styled, { keyframes } from 'styled-components';

const spin = keyframes`
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
`;

const SpinnerWrapper = styled.div`
  display: inline-flex;
  align-items: center;
  justify-content: center;
`;

const Spinner = styled.div<{ size?: 'small' | 'medium' | 'large' }>`
  width: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  height: ${({ size = 'medium' }) => 
    size === 'small' ? '16px' : 
    size === 'large' ? '32px' : 
    '24px'
  };
  border: 3px solid ${({ theme }) => theme.colors.border};
  border-top-color: ${({ theme }) => theme.colors.primary};
  border-radius: 50%;
  animation: ${spin} 1s linear infinite;
`;

interface LoadingSpinnerProps {
  size?: 'small' | 'medium' | 'large';
}

export default function LoadingSpinner({ size = 'medium' }: LoadingSpinnerProps) {
  return (
    <SpinnerWrapper>
      <Spinner size={size} />
    </SpinnerWrapper>
  );
}// src/components/shared/Chat.tsx
'use client';

import { useState, useEffect, useRef, useCallback } from 'react';
import styled from 'styled-components';
import { createClient } from '@/lib/supabase/client';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import ChatInput from '@/components/shared/ChatInput';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { ChatMessage, Chatbot } from '@/types/database.types'; // Chatbot type now includes welcome_message

// Constants from API route
const ASSESSMENT_TRIGGER_COMMAND = "/assess";

// Styled Components (remain the same as previous version)
const ChatContainer = styled(Card)`
  display: flex;
  flex-direction: column;
  height: calc(100vh - 200px); /* Adjust as needed */
  max-height: 800px;
  position: relative;
  padding: 0;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    height: calc(100vh - 150px);
    max-height: none;
    margin: 0;
    border-radius: 0;
    border: none;
    box-shadow: none;
  }
`;

const MessagesList = styled.div`
  flex: 1;
  overflow-y: auto;
  padding: ${({ theme }) => theme.spacing.lg};
  background: ${({ theme }) => theme.colors.background};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const StyledChatInputContainer = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  background: ${({ theme }) => theme.colors.backgroundCard};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const EmptyState = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  text-align: center;
  color: ${({ theme }) => theme.colors.textMuted};
  padding: ${({ theme }) => theme.spacing.xl};

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme }) => theme.colors.textLight};
  }
`;

const ErrorContainer = styled(Alert)`
  margin: ${({ theme }) => theme.spacing.md};
`;

const LoadingIndicator = styled.div`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  height: 100%;
`;


interface ChatProps {
  roomId: string;
  chatbot: Chatbot;
}

export default function Chat({ roomId, chatbot }: ChatProps) {
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isFetchingMessages, setIsFetchingMessages] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [fetchError, setFetchError] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const fetchedRef = useRef(false);
  const supabase = createClient();

  useEffect(() => {
    const getUserId = async () => {
      try {
        const { data: { user } } = await supabase.auth.getUser();
        if (user) {
          setUserId(user.id);
        } else {
          setFetchError("Authentication error. Please log in.");
        }
      } catch {
        setFetchError("Could not verify user. Please try refreshing.");
      }
    };
    getUserId();
  }, [supabase]);

  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, []);

  const fetchMessages = useCallback(async () => {
    if (!chatbot?.chatbot_id || !userId || !roomId) {
        setIsFetchingMessages(false);
        return;
    }
    setIsFetchingMessages(true);
    setFetchError(null);
    fetchedRef.current = true;
    try {
      const url = `/api/chat/${roomId}?chatbotId=${chatbot.chatbot_id}`;
      const response = await fetch(url);
      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Failed to parse error response');
        throw new Error(`Failed to fetch messages (status: ${response.status}) - ${errorText}`);
      }
      const data = await response.json();
      let fetchedMsgs = Array.isArray(data) ? (data as ChatMessage[]) : [];

      // MODIFIED: Prepend welcome message if it's a new chat and welcome message exists
      // Also check if the first message isn't already our special welcome message (to avoid duplicates on re-fetch/re-render)
      if (
        fetchedMsgs.length === 0 &&
        chatbot.welcome_message &&
        chatbot.welcome_message.trim() !== ''
      ) {
        const welcomeMsg: ChatMessage = {
          message_id: `welcome-${chatbot.chatbot_id}`, // Use a consistent ID for the welcome message
          room_id: roomId,
          user_id: chatbot.chatbot_id, // Attributed to the bot
          role: 'assistant',
          content: chatbot.welcome_message,
          created_at: new Date(0).toISOString(), // Ensures it's always first if sorted by date
          metadata: { chatbotId: chatbot.chatbot_id, isWelcomeMessage: true },
        };
        fetchedMsgs = [welcomeMsg]; // Show only welcome message if no other history
      }

      setMessages(fetchedMsgs);
      setTimeout(scrollToBottom, 100);
    } catch (err) {
      setFetchError(err instanceof Error ? err.message : 'Failed to load messages');
      fetchedRef.current = false;
    } finally {
      setIsFetchingMessages(false);
    }
  // MODIFIED: Added `chatbot.welcome_message` to dependencies of fetchMessages
  // This ensures fetchMessages is re-evaluated if the welcome message itself changes (e.g., teacher edits it)
  // and the component re-renders with the new chatbot prop.
  }, [roomId, chatbot?.chatbot_id, chatbot?.welcome_message, userId, scrollToBottom]);

  useEffect(() => {
    if (userId && chatbot?.chatbot_id && !fetchedRef.current) {
      fetchMessages();
    }
    // This cleanup logic for fetchedRef seems fine for re-fetching if chatbotId changes.
    const currentChatbotId = chatbot?.chatbot_id;
    return () => {
        if (currentChatbotId !== chatbot?.chatbot_id) {
            fetchedRef.current = false;
        }
    }
  }, [userId, chatbot?.chatbot_id, fetchMessages]);


  const handleRetryFetch = () => {
    fetchedRef.current = false; // Allow refetch
    fetchMessages();
  };

  const handleSendMessage = async (content: string) => {
    if (!content.trim() || isLoading || !userId || !chatbot?.chatbot_id || !roomId) return;

    setIsLoading(true);
    setError(null);
    const isAssessmentTrigger = chatbot.bot_type === 'assessment' && content.trim().toLowerCase() === ASSESSMENT_TRIGGER_COMMAND;

    const optimisticUserMessage: ChatMessage = {
      message_id: `local-user-${Date.now()}`,
      room_id: roomId,
      user_id: userId,
      role: 'user',
      content: content.trim(),
      created_at: new Date().toISOString(),
      metadata: { chatbotId: chatbot.chatbot_id }
    };

    // If the current first message is the welcome message, remove it before adding the user's message,
    // as the conversation has now truly started.
    setMessages(prev => {
        const currentMessages = [...prev];
        if (currentMessages.length === 1 && currentMessages[0].metadata?.isWelcomeMessage) {
            return [optimisticUserMessage];
        }
        return [...currentMessages, optimisticUserMessage];
    });


    // ... (rest of handleSendMessage for assessment trigger and regular chat streaming remains IDENTICAL to your provided code) ...
    if (isAssessmentTrigger) {
      const optimisticAssessmentPlaceholder: ChatMessage = {
        message_id: `local-assessment-placeholder-${Date.now()}`,
        room_id: roomId,
        user_id: "system-assessment",
        role: 'system',
        content: 'Processing your assessment request...',
        created_at: new Date().toISOString(),
        metadata: { chatbotId: chatbot.chatbot_id, isAssessmentPlaceholder: true }
      };
      setMessages(prev => [...prev, optimisticAssessmentPlaceholder]);
      setTimeout(scrollToBottom, 50);

      try {
        const response = await fetch(`/api/chat/${roomId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content: content.trim(),
            chatbot_id: chatbot.chatbot_id,
          }),
        });
        setMessages(prev => prev.filter(msg => msg.message_id !== optimisticAssessmentPlaceholder.message_id));
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ error: { message: 'Failed to parse API error response' } }));
          throw new Error(errorData.error?.message || `API error processing assessment (status: ${response.status})`);
        }
        const assessmentResult = await response.json();
        if (assessmentResult.type === "assessment_feedback") { // Assuming your API sends this type
          const feedbackMessage: ChatMessage = {
            message_id: assessmentResult.assessmentId || `local-assessment-feedback-${Date.now()}`,
            room_id: roomId,
            user_id: "system-feedback",
            role: 'system',
            content: assessmentResult.feedback, // And this content
            created_at: new Date().toISOString(),
            metadata: { chatbotId: chatbot.chatbot_id, isAssessmentFeedback: true, assessmentId: assessmentResult.assessmentId }
          };
          setMessages(prev => [...prev, feedbackMessage]);
          if (assessmentResult.assessmentId) {
              alert("Assessment feedback received! You can also view it in 'My Assessments'.");
          }
        } else if (assessmentResult.type === "assessment_pending") { // Handle pending message from API
            const pendingMessage: ChatMessage = {
                message_id: `local-assessment-pending-${Date.now()}`,
                room_id: roomId,
                user_id: "system-assessment",
                role: 'system',
                content: assessmentResult.message, // Use message from API
                created_at: new Date().toISOString(),
                metadata: { chatbotId: chatbot.chatbot_id, isAssessmentPlaceholder: true }
            };
            setMessages(prev => [...prev, pendingMessage]);
        } else {
          throw new Error("Unexpected response from assessment API.");
        }
      } catch (err) {
        console.error('Assessment processing error:', err);
        const errorMsg = err instanceof Error ? err.message : 'Failed to process assessment';
        setError(errorMsg);
        setMessages(prev => prev.filter(msg => msg.message_id !== optimisticUserMessage.message_id));
        setMessages(prev => [...prev, {...optimisticUserMessage, metadata: {...optimisticUserMessage.metadata, error: errorMsg }}]);
      } finally {
        setIsLoading(false);
        setTimeout(scrollToBottom, 50);
      }
      return;
    }

    const optimisticAssistantPlaceholder: ChatMessage = {
      message_id: `local-assistant-${Date.now()}`,
      room_id: roomId,
      user_id: "assistant-placeholder",
      role: 'assistant',
      content: 'Thinking...',
      created_at: new Date().toISOString(),
      metadata: { chatbotId: chatbot.chatbot_id }
    };
    setMessages(prev => [...prev, optimisticAssistantPlaceholder]);
    setTimeout(scrollToBottom, 50);

    try {
      const response = await fetch(`/api/chat/${roomId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: content.trim(),
          chatbot_id: chatbot.chatbot_id,
          model: chatbot.model
        }),
      });

      if (!response.ok || !response.body) {
        const errorData = await response.json().catch(() => ({ error: { message: 'Failed to parse API error response' } }));
        throw new Error(errorData.error?.message || `API error sending message (status: ${response.status})`);
      }

      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let streamedContent = '';
      let firstChunkReceived = false;

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

         if (!firstChunkReceived) {
            setMessages(prev => prev.map(msg =>
                msg.message_id === optimisticAssistantPlaceholder.message_id
                ? { ...msg, content: '' }
                : msg
            ));
            firstChunkReceived = true;
         }

        const chunk = decoder.decode(value, { stream: true });
        const lines = chunk.split('\n');

        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const data = line.substring(6);
            if (data.trim() === '[DONE]') continue;
            try {
              const parsedData = JSON.parse(data);
              if (parsedData.content) {
                streamedContent += parsedData.content;
                setMessages(prev => prev.map(msg =>
                  msg.message_id === optimisticAssistantPlaceholder.message_id
                    ? { ...msg, content: streamedContent }
                    : msg
                ));
                 scrollToBottom();
              }
            } catch (e) {
              console.error('Error parsing stream data chunk:', e, "Data:", data);
            }
          }
        }
      }
       setMessages(prev => prev.map(msg =>
        msg.message_id === optimisticAssistantPlaceholder.message_id
          ? { ...msg, content: streamedContent.trim(), updated_at: new Date().toISOString() } // Add updated_at
          : msg
       ).filter(msg => msg.message_id !== `welcome-${chatbot.chatbot_id}`)); // Remove welcome message if it was there

    } catch (err) {
      console.error('Chat send/receive error:', err);
      const errorMsg = err instanceof Error ? err.message : 'Failed to send or receive message';
      setError(errorMsg);
      // Remove optimistic messages on error
      setMessages(prev => prev.filter(msg =>
          msg.message_id !== optimisticUserMessage.message_id &&
          msg.message_id !== optimisticAssistantPlaceholder.message_id &&
          msg.message_id !== `welcome-${chatbot.chatbot_id}` // Also ensure welcome is removed if error occurs
      ));
       // Re-add user message with error indication
       setMessages(prev => [...prev, {...optimisticUserMessage, metadata: {...optimisticUserMessage.metadata, error: errorMsg}}]);
    } finally {
      setIsLoading(false);
      setTimeout(scrollToBottom, 50);
    }
  };

  return (
    <ChatContainer>
      {fetchError && (
        <ErrorContainer variant="error">
          Error loading messages: {fetchError}
          <Button onClick={handleRetryFetch} size="small" style={{ marginLeft: '10px' }}>Retry</Button>
        </ErrorContainer>
      )}

      <MessagesList>
        {/* MODIFIED: Logic for EmptyState or initial message */}
        {isFetchingMessages && messages.length === 0 ? (
           <LoadingIndicator><LoadingSpinner /> Loading messages...</LoadingIndicator>
        ) : !isFetchingMessages && messages.length === 0 && !fetchError && !(chatbot.welcome_message && chatbot.welcome_message.trim() !== '') ? (
          // Show EmptyState only if there are no messages AND no welcome message to display
          <EmptyState>
            <h3>Start your conversation with {chatbot.name}</h3>
            <p>Your chat history will appear here.</p>
            {chatbot.bot_type === 'assessment' && <p>Type <strong>{ASSESSMENT_TRIGGER_COMMAND}</strong> when you are ready for an assessment.</p>}
          </EmptyState>
        ) : (
          messages.map((message) => (
            <ChatMessageComponent
              key={message.message_id} // Assuming message_id is always unique now
              message={message}
              chatbotName={chatbot.name}
            />
          ))
        )}
        <div ref={messagesEndRef} />
      </MessagesList>

      <StyledChatInputContainer>
        <ChatInput
          onSend={handleSendMessage}
          isLoading={isLoading}
          error={error}
          onClearError={() => setError(null)}
          hint={chatbot.bot_type === 'assessment' ? `Type ${ASSESSMENT_TRIGGER_COMMAND} to submit for assessment.` : undefined}
        />
      </StyledChatInputContainer>
    </ChatContainer>
  );
}// src/components/shared/ChatMessage.tsx
'use client';

import styled, { css } from 'styled-components'; // Added css import
import ReactMarkdown, { Components } from 'react-markdown';
import remarkGfm from 'remark-gfm';
import type { ChatMessage as DbChatMessage } from '@/types/database.types'; // Renamed to avoid conflict

// --- Type Definitions ---\
interface ChatMessageProps {
  message: DbChatMessage; // Use the aliased type
  chatbotName: string;
}

type MessageMetadataWithFlags = {
    error?: unknown;
    isAssessmentFeedback?: boolean; // New flag
    isAssessmentPlaceholder?: boolean; // New flag
    [key: string]: unknown;
} | null | undefined;

// --- Styled Components ---
interface MessageWrapperProps {
  $isUser: boolean;
  $hasError: boolean;
}
const MessageWrapper = styled.div<MessageWrapperProps>`
  display: flex;
  justify-content: ${({ $isUser }) => $isUser ? 'flex-end' : 'flex-start'};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  opacity: ${({ $hasError }) => $hasError ? 0.7 : 1};
`;

interface MessageBubbleProps {
  $isUser: boolean;
  $hasError: boolean;
  $isAssessmentFeedback?: boolean; // New prop for styling
  $isAssessmentPlaceholder?: boolean; // New prop for styling
}
const MessageBubble = styled.div<MessageBubbleProps>`
  max-width: 80%;
  padding: ${({ theme }) => theme.spacing.md} ${({ theme }) => theme.spacing.lg};
  border-radius: ${({ theme, $isUser }) =>
    $isUser
      ? `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small} ${theme.borderRadius.xl}`
      : `${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.xl} ${theme.borderRadius.small}`
  };
  background: ${({ theme, $isUser, $isAssessmentFeedback, $isAssessmentPlaceholder }) => {
    if ($isAssessmentFeedback) return theme.colors.blue + '20'; // Light blue for feedback
    if ($isAssessmentPlaceholder) return theme.colors.backgroundDark;
    return $isUser ? theme.colors.primary : theme.colors.backgroundCard;
  }};
  color: ${({ theme, $isUser, $isAssessmentFeedback, $isAssessmentPlaceholder }) => {
    if ($isAssessmentFeedback) return theme.colors.blue; // Darker blue text
    if ($isAssessmentPlaceholder) return theme.colors.textMuted;
    return $isUser ? 'white' : theme.colors.text;
  }};
  box-shadow: ${({ theme }) => theme.shadows.sm};
  position: relative;
  border: 1px solid transparent; // Default border

  ${({ $hasError, theme }) => $hasError && `
      border-color: ${theme.colors.red};
   `}

  ${({ $isAssessmentFeedback, theme }) => $isAssessmentFeedback && css`
    border-color: ${theme.colors.blue};
    /* You could add an icon or other distinct styling here */
  `}
   ${({ $isAssessmentPlaceholder }) => $isAssessmentPlaceholder && css`
    font-style: italic;
  `}
`;

const MessageHeader = styled.div`
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const SenderName = styled.span`
  font-weight: 600;
  font-size: 0.875rem;
  opacity: 0.8;
`;

const Timestamp = styled.span`
  font-size: 0.75rem;
  opacity: 0.7;
`;

const MessageContent = styled.div<{ $isUser: boolean }>`
  line-height: 1.5;
  word-wrap: break-word;
  // ... (Markdown styling remains the same as previous version)
  h1, h2, h3, h4, h5, h6 { margin-top: ${({ theme }) => theme.spacing.md}; margin-bottom: ${({ theme }) => theme.spacing.sm}; font-weight: 600; line-height: 1.3; color: inherit; }
  h1 { font-size: 1.5em; } h2 { font-size: 1.3em; } h3 { font-size: 1.2em; }
  h4 { font-size: 1.1em; } h5 { font-size: 1em; } h6 { font-size: 0.9em; }
  p { margin-bottom: ${({ theme }) => theme.spacing.sm}; &:last-child { margin-bottom: 0; } }
  ul, ol { margin-bottom: ${({ theme }) => theme.spacing.sm}; padding-left: ${({ theme }) => theme.spacing.lg}; }
  li { margin-bottom: ${({ theme }) => theme.spacing.xs}; }
  blockquote { border-left: 4px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.5)' : theme.colors.border}; padding-left: ${({ theme }) => theme.spacing.md}; margin: ${({ theme }) => theme.spacing.sm} 0; font-style: italic; color: ${({ $isUser }) => $isUser ? 'rgba(255,255,255,0.9)' : 'inherit'}; opacity: 0.9; }
  pre.code-block-wrapper { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.05)'}; padding: ${({ theme }) => theme.spacing.sm}; border-radius: ${({ theme }) => theme.borderRadius.small}; margin: ${({ theme }) => theme.spacing.sm} 0; overflow-x: auto; code { background: none !important; padding: 0 !important; font-family: ${({ theme }) => theme.fonts.mono}; white-space: pre; font-size: 0.9em; color: inherit; } }
  code.inline-code { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.2)' : 'rgba(0,0,0,0.1)'}; padding: 2px 5px; border-radius: ${({ theme }) => theme.borderRadius.small}; font-family: ${({ theme }) => theme.fonts.mono}; font-size: 0.9em; }
  hr { border: none; height: 1px; background: ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; margin: ${({ theme }) => theme.spacing.md} 0; }
  table { border-collapse: collapse; margin: ${({ theme }) => theme.spacing.sm} 0; width: auto; border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; th, td { border: 1px solid ${({ theme, $isUser }) => $isUser ? 'rgba(255,255,255,0.3)' : theme.colors.border}; padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm}; } th { background: ${({ $isUser }) => $isUser ? 'rgba(0,0,0,0.1)' : 'rgba(0,0,0,0.05)'}; font-weight: 600; } }
  a { color: ${({ $isUser, theme }) => $isUser ? '#c1d9ff' : theme.colors.primaryDark}; text-decoration: underline; &:hover { text-decoration: none; } }
  ul.contains-task-list { list-style-type: none; padding-left: ${({ theme }) => theme.spacing.sm}; }
  li.task-list-item { display: flex; align-items: center; input[type="checkbox"] { margin-right: ${({ theme }) => theme.spacing.sm}; cursor: default; } }
`;

const ErrorIndicator = styled.div`
    font-size: 0.75rem;
    color: ${({ theme }) => theme.colors.red};
    margin-top: ${({ theme }) => theme.spacing.xs};
    font-style: italic;
`;
// --- End Styled Components ---

// --- Helper Function ---
function formatTimestamp(timestamp: string | undefined): string {
  // ... (formatTimestamp remains the same)
  if (!timestamp) return '';
  const date = new Date(timestamp);
  if (isNaN(date.getTime())) return '';
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  if (diffInSeconds < 5) return 'just now';
  if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
  if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
  if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
  if (now.getFullYear() === date.getFullYear()) {
    return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
  } else {
    return date.toLocaleDateString();
  }
}
// -----------------------

// --- React Markdown Custom Components (remain the same) ---
const markdownComponents: Components = {
    a: (props) => (<a {...props} target="_blank" rel="noopener noreferrer"/>),
    input: (props) => { const { checked, ...rest } = props; return (<input type="checkbox" checked={!!checked} disabled={true} readOnly {...rest}/> ); },
    code({ className, children, inline, ...props }: React.HTMLAttributes<HTMLElement> & { className?: string; children?: React.ReactNode; inline?: boolean; }) {
        const match = /language-(\w+)/.exec(className || '');
        const codeString = String(children).replace(/\n$/, '');
        const { style: _unused, ...restProps } = props;
        void _unused;
        return !inline ? (
            <pre className="code-block-wrapper" {...restProps}>
                <code className={match ? `language-${match[1]}` : undefined}>{codeString}</code>
            </pre>
        ) : (
            <code className={`inline-code ${className || ''}`} {...restProps}>{codeString}</code>
        );
    }
};
// --- End React Markdown Components ---

// --- Main Component ---
function ChatMessageDisplay({ message, chatbotName }: ChatMessageProps) {
    const isUser = message.role === 'user';
    
    const metadata = message.metadata as MessageMetadataWithFlags; // Use new type
    const hasError = !!metadata?.error;
    const errorMessage = hasError ? String(metadata.error) : null;
    const isAssessmentFeedback = !!metadata?.isAssessmentFeedback;
    const isAssessmentPlaceholder = !!metadata?.isAssessmentPlaceholder;

    let senderNameToDisplay = chatbotName;
    if (isUser) {
        senderNameToDisplay = 'You';
    } else if (isAssessmentFeedback || isAssessmentPlaceholder || message.role === 'system') {
        // For system messages or assessment feedback, use a generic name or the bot's name
        // If it's a placeholder or feedback, you might want a specific title like "Assessment System"
        senderNameToDisplay = isAssessmentFeedback ? `${chatbotName} (Assessment)` : (isAssessmentPlaceholder ? 'System' : chatbotName);
        if (message.user_id === 'system-assessment' || message.user_id === 'system-feedback') {
             // Let's refine this. If the message.role is 'system', it should be styled as such.
        }
    }


    return (
        <MessageWrapper $isUser={isUser} $hasError={hasError}>
            <MessageBubble
              $isUser={isUser}
              $hasError={hasError}
              $isAssessmentFeedback={isAssessmentFeedback}
              $isAssessmentPlaceholder={isAssessmentPlaceholder}
            >
                <MessageHeader>
                    <SenderName>{senderNameToDisplay}</SenderName>
                    <Timestamp>
                        {formatTimestamp(message.created_at)}
                    </Timestamp>
                </MessageHeader>
                <MessageContent $isUser={isUser}>
                    <ReactMarkdown
                        remarkPlugins={[remarkGfm]}
                        components={markdownComponents}
                    >
                        {message.content || ''}
                    </ReactMarkdown>
                </MessageContent>
                {hasError && (
                    <ErrorIndicator title={errorMessage || 'Failed to send message'}>
                       ⚠️ Failed to send
                    </ErrorIndicator>
                 )}
            </MessageBubble>
        </MessageWrapper>
    );
}
// --- End Main Component ---

export { ChatMessageDisplay as ChatMessage };// src/components/shared/ChatInput.tsx
'use client';

import { useState, KeyboardEvent } from 'react';
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';

// ... (InputContainer, InputForm, TextInput, SendButton, ErrorAlert styled components remain the same)

const InputForm = styled.form`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
  }
`;

const TextInput = styled.input`
  flex: 1;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 2px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.large};
  background: ${({ theme }) => theme.colors.background};
  color: ${({ theme }) => theme.colors.text};
  font-size: 1rem;
  transition: all ${({ theme }) => theme.transitions.fast};
  
  &:focus {
    border-color: ${({ theme }) => theme.colors.focus};
  }
  
  &::placeholder {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  
  &:disabled {
    opacity: 0.7;
    cursor: not-allowed;
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const SendButton = styled(Button)`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.xl};
  min-width: 100px;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const ErrorAlert = styled(Alert)`
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;


const InputHint = styled.p`
  font-size: 0.8rem; /* Slightly larger for better readability */
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.sm};
  text-align: left; /* Align to left, often better for hints near input */
  padding-left: ${({ theme }) => theme.spacing.xs};

  /* Default hint shown on mobile for Ctrl/Cmd+Enter */
  @media (min-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none; 
  }
`;

// Specific hint for assessment bots
const AssessmentHint = styled(InputHint)`
    display: block; /* Ensure it's always visible if provided */
    text-align: center; /* Center this specific hint */
    margin-bottom: -${({ theme }) => theme.spacing.xs}; /* Adjust spacing slightly */
`;


interface ChatInputProps {
  onSend: (content: string) => Promise<void>;
  isLoading: boolean;
  error: string | null;
  onClearError: () => void;
  hint?: string; // New optional hint prop
}

export default function ChatInput({ onSend, isLoading, error, onClearError, hint }: ChatInputProps) {
  const [message, setMessage] = useState('');

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!message.trim() || isLoading) return;

    const content = message.trim();
    setMessage(''); // Clear input immediately
    await onSend(content);
  };

  const handleKeyPress = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
      // Prevent default Enter behavior (like newline in some setups) if Ctrl/Meta is pressed
      e.preventDefault(); 
      handleSubmit(e as unknown as React.FormEvent); // Cast because original event is KeyboardEvent
    } else if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
      // If just Enter is pressed (and not Shift+Enter for newline)
      e.preventDefault(); 
      handleSubmit(e as unknown as React.FormEvent);
    }
  };

  return (
    // InputContainer styling has been removed from Chat.tsx and should be part of ChatInput itself if needed.
    // For now, assuming StyledChatInputContainer in Chat.tsx provides the main padding.
    <> 
      {error && (
        <ErrorAlert variant="error" onClick={onClearError} style={{marginBottom: '8px'}}>
          {error}
        </ErrorAlert>
      )}
      
      <InputForm onSubmit={handleSubmit}>
        <TextInput
          type="text"
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          onKeyPress={handleKeyPress}
          placeholder="Type your message..."
          disabled={isLoading}
        />
        <SendButton
          type="submit"
          disabled={isLoading || !message.trim()}
        >
          {isLoading ? 'Sending...' : 'Send'}
        </SendButton>
      </InputForm>

      {hint && <AssessmentHint>{hint}</AssessmentHint>}
      
      {/* General hint for mobile, could be combined or made more context-aware */}
      {!hint && (
         <InputHint>
            Press Enter to send. Use Shift+Enter for a new line.
         </InputHint>
      )}
    </>
  );
}// src/components/ThemeProvider.tsx
'use client';

import { ThemeProvider as StyledThemeProvider } from 'styled-components';
import theme from '@/styles/theme';
import { GlobalStyles } from '@/styles/GlobalStyles';

export default function ThemeProvider({ children }: { children: React.ReactNode }) {
  return (
    <StyledThemeProvider theme={theme}>
      <GlobalStyles />
      {children}
    </StyledThemeProvider>
  );
}// src/components/teacher/StudentChatHistory.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import { ChatMessage as ChatMessageComponent } from '@/components/shared/ChatMessage';
import type { ChatMessage as DatabaseChatMessage } from '@/types/database.types';

const HistoryContainer = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.xl};
`;

const FilterCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const FilterTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterForm = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    align-items: stretch;
  }
`;

const FilterControls = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
  }
`;

const StudentNameDisplay = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.primary};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }
`;

const Select = styled.select`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background: ${({ theme }) => theme.colors.background};
  min-width: 200px;
`;

const ConversationCard = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ConversationHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  padding-bottom: ${({ theme }) => theme.spacing.sm};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
`;

const ConversationInfo = styled.div`
  h4 {
    margin: 0;
    color: ${({ theme }) => theme.colors.text};
  }

  .timestamp {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
  }
`;

const MessagesList = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${({ theme }) => theme.spacing.md};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadMoreButton = styled(Button)`
  margin: ${({ theme }) => theme.spacing.md} auto;
  display: block;
`;

interface ChatbotOption {
  chatbot_id: string;
  name: string;
}

interface Conversation {
  chatbot_id: string | null;
  chatbot_name: string;
  started_at: string;
  messages: DatabaseChatMessage[];
}

interface StudentChatHistoryProps {
  roomId: string;
  studentId: string;
  studentName: string;
  chatbots: ChatbotOption[];
}

export default function StudentChatHistory({
  roomId,
  studentId,
  studentName,
  chatbots
}: StudentChatHistoryProps) {
  const [conversations, setConversations] = useState<Conversation[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [selectedChatbotFilter, setSelectedChatbotFilter] = useState<string>('');
  const [page, setPage] = useState(0);
  const [hasMore, setHasMore] = useState(false);

  const fetchConversations = useCallback(async (resetPage = true) => {
    const currentPageToFetch = resetPage ? 0 : page;

    if (resetPage) {
      setPage(0);
      setConversations([]);
    }

    setLoading(true);
    setError(null);

    try {
      // Use the new flattened API endpoint
      const baseUrl = typeof window !== 'undefined' ? window.location.origin : '';
      const url = new URL(`/api/teacher/student-chats`, baseUrl);
      
      // Add parameters as query parameters
      url.searchParams.append('roomId', roomId);
      url.searchParams.append('studentId', studentId);
      
      if (selectedChatbotFilter) {
        url.searchParams.append('chatbotId', selectedChatbotFilter);
      }

      // Add pagination params if your API supports them
      if (!resetPage && currentPageToFetch > 0) {
        url.searchParams.append('page', currentPageToFetch.toString());
        url.searchParams.append('limit', '10'); // Example limit
      }

      const response = await fetch(url.toString());

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({error: 'Failed to parse error response'}));
        throw new Error(errorData.error || 'Failed to fetch chat history');
      }

      const data = await response.json();

      if (resetPage) {
        setConversations(data.conversations || []);
      } else {
        setConversations(prev => [...prev, ...(data.conversations || [])]);
      }

      // Set has more if API returns pagination info
      setHasMore(data.pagination?.hasMore || false);

      if (!resetPage && data.conversations && data.conversations.length > 0) {
        setPage(currentPageToFetch + 1);
      } else if (resetPage) {
        setPage(0);
      }

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to load chat history');
    } finally {
      setLoading(false);
    }
  }, [roomId, studentId, selectedChatbotFilter, page]);

  useEffect(() => {
    // Initial fetch or fetch when filter changes
    fetchConversations(true);
  }, [roomId, studentId, selectedChatbotFilter, fetchConversations]);

  const handleLoadMore = () => {
    fetchConversations(false);
  };

  const handleChatbotChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
    setSelectedChatbotFilter(e.target.value);
  };

  const formatDate = (dateString: string) => {
    if (!dateString) return 'Unknown date';
    return new Date(dateString).toLocaleString();
  };

  return (
    <HistoryContainer>
      <FilterCard>
        <FilterTitle>Chat History</FilterTitle>
        <FilterForm>
          <StudentNameDisplay>
            Showing conversations for: {studentName}
          </StudentNameDisplay>
          <FilterControls>
            <Select
              value={selectedChatbotFilter}
              onChange={handleChatbotChange}
            >
              <option value="">All Chatbots</option>
              {chatbots.map(chatbot => (
                <option key={chatbot.chatbot_id} value={chatbot.chatbot_id}>
                  {chatbot.name}
                </option>
              ))}
            </Select>
          </FilterControls>
        </FilterForm>
      </FilterCard>

      {error && (
        <Alert variant="error">Error: {error}</Alert>
      )}

      {loading && conversations.length === 0 ? (
        <Card>
          <p>Loading conversations...</p>
        </Card>
      ) : conversations.length === 0 ? (
        <EmptyState>
          <h3>No conversations found</h3>
          <p>
            {selectedChatbotFilter
              ? `This student hasn't chatted with the selected chatbot yet.`
              : `This student hasn't chatted with any chatbots yet.`}
          </p>
        </EmptyState>
      ) : (
        <>
          {conversations.map((conversation, index) => {
            const chatbotNameForDisplay = conversation.chatbot_name || 'Unknown Chatbot';

            return (
              <ConversationCard key={`conv-${index}-${conversation.started_at}`}>
                <ConversationHeader>
                  <ConversationInfo>
                    <h4>{chatbotNameForDisplay}</h4>
                    <span className="timestamp">Started {formatDate(conversation.started_at)}</span>
                  </ConversationInfo>
                </ConversationHeader>

                <MessagesList>
                  {conversation.messages.map(message => (
                    <ChatMessageComponent
                      key={message.message_id}
                      message={message}
                      chatbotName={chatbotNameForDisplay}
                    />
                  ))}
                </MessagesList>
              </ConversationCard>
            );
          })}

          {hasMore && (
            <LoadMoreButton
              variant="outline"
              onClick={handleLoadMore}
              disabled={loading}
            >
              {loading ? 'Loading...' : 'Load More'}
            </LoadMoreButton>
          )}
        </>
      )}
    </HistoryContainer>
  );
}'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import { Card, Button, Alert, Badge } from '@/styles/StyledComponents'; // Added Alert and Badge
import ChatbotForm from '@/components/teacher/ChatbotForm';
import RoomForm from '@/components/teacher/RoomForm';
import RoomList from '@/components/teacher/RoomList';
import EditRoomModal from '@/components/teacher/EditRoomModal';
import ConcernsList from '@/components/teacher/ConcernsList'; // Import ConcernsList
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import Loader
import { createClient } from '@/lib/supabase/client';
import type { Chatbot, Room as BaseRoom } from '@/types/database.types'; // Use BaseRoom alias

// --- Styled Components (Keep as previously defined) ---
const DashboardContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: ${({ theme }) => theme.spacing.xl};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xxl};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  flex-wrap: wrap; /* Allow wrapping */
  gap: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    button {
      width: 100%;
    }
  }
`;

const SectionTitle = styled.h2`
  color: ${({ theme }) => theme.colors.text};
  font-size: 1.5rem;
  margin: 0; /* Remove default margin */
`;

const StatsCard = styled(Card)`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: pointer; // Make stats cards clickable if they link somewhere
  transition: transform 0.2s ease, box-shadow 0.2s ease;

   &:hover {
      transform: translateY(-2px);
      box-shadow: ${({ theme }) => theme.shadows.md};
   }

  h3 {
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
  }

  .value {
    font-size: 2rem;
    font-weight: 600;
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const ChatbotList = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    grid-template-columns: 1fr;
  }
`;

const ChatbotCard = styled(Card)`
  position: relative;
  display: flex;
  flex-direction: column;
  transition: transform ${({ theme }) => theme.transitions.fast}, box-shadow ${({ theme }) => theme.transitions.fast};

  &:hover {
    transform: translateY(-2px);
    box-shadow: ${({ theme }) => theme.shadows.md};
  }

  h3 {
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
  }

  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1;
    min-height: 2.5rem;

    @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
      min-height: auto;
    }
  }

  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.sm};
    margin-top: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap;
    justify-content: flex-start;

    button, a {
        flex-grow: 1;
        min-width: 100px;
        text-align: center;
    }

     @media (max-width: 550px) {
         button, a {
            width: 100%;
            flex-grow: 0;
         }
     }
  }

  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
`;


const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 450px;
  margin: 20px;
  position: relative;
  text-align: center;
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

// --- Define the Room type WITH joined data (Matching API Response) ---
interface RoomWithChatbots extends BaseRoom {
  room_chatbots: {
    chatbots: {
      chatbot_id: string;
      name: string;
    } | null;
  }[] | null;
}
// ---------------------------------------------------------------


interface DeleteModalProps {
  isOpen: boolean;
  itemType: 'Chatbot' | 'Room';
  itemName: string;
  onConfirm: () => Promise<void>; // Make confirm async
  onCancel: () => void;
  isDeleting: boolean;
}

function DeleteModal({ isOpen, itemType, itemName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;

  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete {itemType}</ModalTitle>
        <ModalText>
          Are you sure you want to delete the {itemType.toLowerCase()} &quot;
          <strong>{itemName}</strong>
          &quot;? This action cannot be undone and may affect associated data (e.g., student memberships, chat history).
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
             variant="secondary" // Use secondary as base, style for danger
             style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }}
             onClick={onConfirm} // Directly call the passed async handler
             disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : `Yes, Delete ${itemType}`}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

export default function Dashboard() {
  const [showChatbotForm, setShowChatbotForm] = useState(false);
  const [showRoomForm, setShowRoomForm] = useState(false);
  const [chatbots, setChatbots] = useState<Chatbot[]>([]);
  // --- FIX: Use the correct type for rooms state ---
  const [rooms, setRooms] = useState<RoomWithChatbots[]>([]);
  // --------------------------------------------------
  const [stats, setStats] = useState({
    totalChatbots: 0,
    totalRooms: 0,
    activeRooms: 0,
    pendingConcerns: 0,
  });
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    type: 'Chatbot' | 'Room';
    id: string | null;
    name: string;
  }>({ isOpen: false, type: 'Chatbot', id: null, name: '' });
   const [isDeleting, setIsDeleting] = useState(false);
  const [editingRoom, setEditingRoom] = useState<BaseRoom | null>(null); // Edit modal likely needs BaseRoom
  const supabase = createClient();
  const router = useRouter();

  const fetchDashboardData = useCallback(async () => {
    setError(null);

    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) {
        router.push('/auth');
        return;
      }

      // Fetch all data concurrently
      const [chatbotsRes, roomsRes, concernsRes] = await Promise.all([
        supabase.from('chatbots').select('*').eq('teacher_id', user.id),
        // --- FIX: Fetch rooms using the API route which handles the join ---
        fetch('/api/teacher/rooms').then(res => {
            if (!res.ok) throw new Error('Failed to fetch rooms');
            return res.json();
        }),
        // --------------------------------------------------------------------
        supabase.from('flagged_messages')
          .select('flag_id', { count: 'exact', head: true })
          .eq('teacher_id', user.id)
          .eq('status', 'pending')
      ]);

      // Process Chatbots
      if (chatbotsRes.error) throw new Error(`Failed to fetch chatbots: ${chatbotsRes.error.message}`);
      const chatbotsData = chatbotsRes.data || [];
      setChatbots(chatbotsData);

      // Process Rooms (data is already fetched via API)
      const roomsData: RoomWithChatbots[] = roomsRes || []; // Type assertion based on API response
      setRooms(roomsData);

       // Process Concerns Count
       if (concernsRes.error) throw new Error(`Failed to fetch concerns count: ${concernsRes.error.message}`);
       const pendingConcernsCount = concernsRes.count || 0;

      // Update Stats
      setStats({
        totalChatbots: chatbotsData.length,
        totalRooms: roomsData.length,
        activeRooms: roomsData.filter(room => room.is_active).length,
        pendingConcerns: pendingConcernsCount,
      });

    } catch (error) {
      console.error('Error fetching dashboard data:', error);
      setError(error instanceof Error ? error.message : 'Failed to load dashboard data.');
      // Reset state on error
      setChatbots([]);
      setRooms([]);
      setStats({ totalChatbots: 0, totalRooms: 0, activeRooms: 0, pendingConcerns: 0 });
    } finally {
      setLoading(false);
    }
  }, [supabase, router]); // Dependencies

  useEffect(() => {
    fetchDashboardData();
  }, [fetchDashboardData]);

  const handleChatbotCreated = () => {
    setShowChatbotForm(false);
    fetchDashboardData();
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    fetchDashboardData();
  };

  // Test Chatbot (unused function removed)

  const handleEditChatbot = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const openDeleteModal = (type: 'Chatbot' | 'Room', id: string, name: string) => {
    setDeleteModal({ isOpen: true, type, id, name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, type: 'Chatbot', id: null, name: '' });
  };

  // --- Combined Delete Handler ---
  const handleDeleteConfirm = async () => {
    if (!deleteModal.id || !deleteModal.type) return;

    setIsDeleting(true);
    setError(null);

    const { type, id } = deleteModal;
    const endpoint = type === 'Chatbot' ? `/api/teacher/chatbots/${id}` : `/api/teacher/rooms/${id}`;

    try {
        const response = await fetch(endpoint, { method: 'DELETE' });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || `Failed to delete ${type.toLowerCase()}`);
        }

        console.log(`${type} ${id} deleted successfully.`);
        closeDeleteModal();
        fetchDashboardData(); // Refresh dashboard
    } catch (error) {
        console.error(`Error deleting ${type}:`, error);
        setError(error instanceof Error ? error.message : `Failed to delete ${type}.`);
        // Keep modal open on error to show feedback if desired, or close:
        // closeDeleteModal();
    } finally {
        setIsDeleting(false);
    }
};


  const handleEditRoom = (room: BaseRoom) => { // Use BaseRoom for editing modal
    setEditingRoom(room);
  };

  const handleCloseEditRoom = () => {
    setEditingRoom(null);
  };

  const handleRoomEditSuccess = () => {
    setEditingRoom(null);
    fetchDashboardData();
  };

  // Get model display name (no changes)
    const getModelDisplayName = (model: string | undefined) => {
      if (!model) return 'Default Model';
      const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B A22B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash'
      };
      return modelNames[model] || model;
    };


  if (loading) {
    return <Card style={{ textAlign: 'center', padding: '40px' }}><LoadingSpinner /> Loading dashboard...</Card>;
  }

  return (
    <div>
        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        {/* Quick Stats Section */}
        <Section>
            <DashboardContainer>
            <StatsCard onClick={() => document.getElementById('chatbots-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Chatbots</h3>
                <div className="value">{stats.totalChatbots}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Total Rooms</h3>
                <div className="value">{stats.totalRooms}</div>
            </StatsCard>
            <StatsCard onClick={() => document.getElementById('rooms-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Active Rooms</h3>
                <div className="value">{stats.activeRooms}</div>
            </StatsCard>
            <StatsCard style={{ cursor: 'pointer' }} onClick={() => document.getElementById('concerns-section')?.scrollIntoView({ behavior: 'smooth' })}>
                <h3>Pending Concerns</h3>
                <div className="value" style={{ color: stats.pendingConcerns > 0 ? '#F87F7F' : undefined }}>
                    {stats.pendingConcerns}
                </div>
                 {stats.pendingConcerns > 0 && <Badge variant='error' style={{ marginTop: '8px' }}>Review Needed</Badge>}
            </StatsCard>
            </DashboardContainer>
        </Section>

      {/* Concerns Section */}
      <Section id="concerns-section">
            <SectionHeader>
                 <SectionTitle>Welfare Concerns</SectionTitle>
                 {/* Can add a direct link/button to a dedicated concerns page if needed */}
            </SectionHeader>
            <ConcernsList />
       </Section>


      {/* Chatbots Section */}
      <Section id="chatbots-section">
        <SectionHeader>
          <SectionTitle>Your Chatbots</SectionTitle>
          <Button onClick={() => setShowChatbotForm(true)}>
            + Create Chatbot
          </Button>
        </SectionHeader>

        {showChatbotForm && (
          <ChatbotForm
            onClose={() => setShowChatbotForm(false)}
            onSuccess={handleChatbotCreated}
          />
        )}

        {chatbots.length > 0 ? (
          <ChatbotList>
            {chatbots.map(chatbot => (
              <ChatbotCard key={chatbot.chatbot_id}>
                <h3>{chatbot.name}</h3>
                <p className="description">{chatbot.description || 'No description provided.'}</p>
                <div className="model-info">
                  Model: {getModelDisplayName(chatbot.model)}
                </div>
                <div className="actions">
                  <Button
                    size="small"
                    variant="outline"
                    onClick={() => handleEditChatbot(chatbot.chatbot_id)}
                    title="Edit chatbot configuration"
                  >
                    Configure
                  </Button>
                   <Button
                        as={Link}
                        size="small"
                        variant="outline"
                        href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/knowledge-base`}
                        title="Manage knowledge base documents"
                    >
                        Knowledge Base
                    </Button>
                   <Button
                        size="small"
                        variant="secondary"
                         style={{ backgroundColor: '#F87F7F', color: 'white', borderColor: '#F87F7F' }} // Danger style
                        onClick={() => openDeleteModal('Chatbot', chatbot.chatbot_id, chatbot.name)}
                        title="Delete this chatbot"
                    >
                        Delete
                    </Button>
                </div>
              </ChatbotCard>
            ))}
          </ChatbotList>
        ) : (
          <Card>
            <p>No chatbots created yet. Click &quot;+ Create Chatbot&quot; to get started!</p>
          </Card>
        )}
      </Section>

      {/* Rooms Section */}
      <Section id="rooms-section">
        <SectionHeader>
          <SectionTitle>Classroom Rooms</SectionTitle>
          <Button onClick={() => setShowRoomForm(true)} disabled={chatbots.length === 0}>
            + Create Room
          </Button>
           {chatbots.length === 0 && <Alert variant='info'>Create a chatbot before creating a room.</Alert>}
        </SectionHeader>

        {showRoomForm && (
          <RoomForm
            chatbots={chatbots}
            onClose={() => setShowRoomForm(false)}
            onSuccess={handleRoomCreated}
          />
        )}

        <RoomList
          rooms={rooms} // Pass the correctly typed rooms state
          onUpdate={fetchDashboardData}
          onEditRoom={handleEditRoom}
          onDeleteRoom={(room) => openDeleteModal('Room', room.room_id, room.room_name)} // Pass handler for delete button in list
        />
      </Section>

      {/* Delete Confirmation Modal */}
      <DeleteModal
        isOpen={deleteModal.isOpen}
        itemType={deleteModal.type}
        itemName={deleteModal.name}
        onConfirm={handleDeleteConfirm} // Use the combined handler
        onCancel={closeDeleteModal}
        isDeleting={isDeleting}
      />

      {/* Edit Room Modal */}
      {editingRoom && (
        <EditRoomModal
          room={editingRoom}
          chatbots={chatbots}
          onClose={handleCloseEditRoom}
          onSuccess={handleRoomEditSuccess}
        />
      )}
    </div>
  );
}// src/components/teacher/EmbeddingStatus.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { Card, Alert } from '@/styles/StyledComponents';
import { Document, ProcessingStats } from '@/types/knowledge-base.types';

const StatusContainer = styled(Card)`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h3`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const ProgressContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const ProgressBar = styled.div`
  height: 8px;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  margin-bottom: ${({ theme }) => theme.spacing.sm};
  overflow: hidden;
`;

const ProgressFill = styled.div<{ $progress: number; $hasErrors: boolean }>`
  height: 100%;
  width: ${({ $progress }) => `${$progress}%`};
  background-color: ${({ theme, $hasErrors }) => 
    $hasErrors ? theme.colors.secondary : theme.colors.green};
  transition: width 0.5s ease;
`;

const StatsContainer = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const StatCard = styled.div`
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.md};
  text-align: center;
`;

const StatValue = styled.div`
  font-size: 1.5rem;
  font-weight: 600;
  margin-bottom: ${({ theme }) => theme.spacing.xs};
  color: ${({ theme }) => theme.colors.text};
`;

const StatLabel = styled.div`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const StatusText = styled.div<{ $isComplete: boolean; $hasErrors: boolean }>`
  color: ${({ theme, $isComplete, $hasErrors }) => 
    $isComplete 
      ? $hasErrors ? theme.colors.secondary : theme.colors.green 
      : theme.colors.text};
  text-align: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

interface EmbeddingStatusProps {
  document: Document;
  chatbotId: string;
  onRefresh?: () => void;
}

export default function EmbeddingStatus({ 
  document, 
  chatbotId,
  onRefresh
}: EmbeddingStatusProps) {
  const [stats, setStats] = useState<ProcessingStats | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [pollingInterval, setPollingInterval] = useState<NodeJS.Timeout | null>(null);

  const fetchStatus = useCallback(async () => {
    try {
      const response = await fetch(
        `/api/teacher/chatbots/${chatbotId}/vectorize?documentId=${document.document_id}`
      );
      
      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.error || 'Failed to fetch processing status');
      }
      
      const data = await response.json();
      setStats(data.processingStats);
      
      // Update document with latest status
      if (data.document.status !== document.status && onRefresh) {
        onRefresh();
      }
      
      // If processing is complete, stop polling
      if (data.document.status === 'completed' || data.document.status === 'error') {
        if (pollingInterval) {
          clearInterval(pollingInterval);
          setPollingInterval(null);
        }
      }
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch processing status');
    } finally {
      setLoading(false);
    }
  }, [document.document_id, document.status, chatbotId, onRefresh, pollingInterval]);

  useEffect(() => {
    fetchStatus();
    
    // Set up polling for processing status
    if (document.status === 'processing' && !pollingInterval) {
      const interval = setInterval(fetchStatus, 5000); // Poll every 5 seconds
      setPollingInterval(interval);
    }
    
    return () => {
      if (pollingInterval) {
        clearInterval(pollingInterval);
      }
    };
  }, [document.status, fetchStatus, pollingInterval]);

  if (loading) {
    return (
      <StatusContainer>
        <p>Loading processing status...</p>
      </StatusContainer>
    );
  }

  if (error) {
    return (
      <StatusContainer>
        <Alert variant="error">{error}</Alert>
      </StatusContainer>
    );
  }

  if (!stats) {
    return (
      <StatusContainer>
        <p>No processing statistics available</p>
      </StatusContainer>
    );
  }

  const progressPercent = stats.totalChunks > 0
    ? Math.round((stats.processedChunks / stats.totalChunks) * 100)
    : 0;
  
  const hasErrors = stats.errorChunks > 0;
  const isComplete = document.status === 'completed' || 
                     (document.status === 'processing' && progressPercent === 100);

  return (
    <StatusContainer>
      <Header>
        <Title>Document Processing Status</Title>
      </Header>
      
      <ProgressContainer>
        <ProgressBar>
          <ProgressFill $progress={progressPercent} $hasErrors={hasErrors} />
        </ProgressBar>
        <StatusText 
          $isComplete={isComplete} 
          $hasErrors={hasErrors}
        >
          {document.status === 'error' ? 'Processing failed' :
           isComplete ? 'Processing complete' : 'Processing in progress'}
           {hasErrors && ' (with some errors)'}
           {document.status === 'processing' && ` - ${progressPercent}%`}
        </StatusText>
      </ProgressContainer>
      
      <StatsContainer>
        <StatCard>
          <StatValue>{stats.totalChunks}</StatValue>
          <StatLabel>Total Chunks</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.processedChunks}</StatValue>
          <StatLabel>Processed</StatLabel>
        </StatCard>
        <StatCard>
          <StatValue>{stats.errorChunks}</StatValue>
          <StatLabel>Errors</StatLabel>
        </StatCard>
      </StatsContainer>
      
      {document.error_message && (
        <Alert variant="error">Error: {document.error_message}</Alert>
      )}
    </StatusContainer>
  );
}// src/components/teacher/EditRoomModal.tsx
'use client';

import { useState, useEffect } from 'react';
import styled from 'styled-components';
import { Card, Button, Alert } from '@/styles/StyledComponents';
import type { Room, Chatbot } from '@/types/database.types';

// ... (styled components remain the same)
const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Section = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
`;

const SectionTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
`;


interface EditRoomModalProps {
  room: Room;
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function EditRoomModal({ room, chatbots, onClose, onSuccess }: EditRoomModalProps) {
  const [selectedChatbots, setSelectedChatbots] = useState<string[]>([]);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const fetchRoomChatbots = async () => {
      setIsLoading(true); // Ensure loading state is true at the start
      setError(null);
      try {
        // MODIFIED API CALL
        const response = await fetch(`/api/teacher/room-chatbots-associations?roomId=${room.room_id}`);
        if (!response.ok) {
            const errorData = await response.json().catch(() => ({ error: 'Failed to parse error from fetchRoomChatbots' }));
            throw new Error(errorData.error || 'Failed to fetch room chatbots');
        }
        
        const data = await response.json();
        setSelectedChatbots(data.map((rc: { chatbot_id: string }) => rc.chatbot_id));
      } catch (err) {
        console.error("EditRoomModal fetchRoomChatbots error:", err);
        setError(err instanceof Error ? err.message : 'Failed to load current chatbots for this room.');
      } finally {
        setIsLoading(false);
      }
    };

    if (room?.room_id) { // Ensure room_id is present
        fetchRoomChatbots();
    } else {
        setError("Room information is missing.");
        setIsLoading(false);
    }
  }, [room.room_id]); // Depend only on room.room_id

  const handleToggleChatbot = (chatbotId: string) => {
    setSelectedChatbots(prev => 
      prev.includes(chatbotId)
        ? prev.filter(id => id !== chatbotId)
        : [...prev, chatbotId]
    );
  };

  const handleSubmit = async () => {
    setIsSubmitting(true);
    setError(null);

    try {
      // MODIFIED API CALL
      const response = await fetch(`/api/teacher/room-chatbots-associations?roomId=${room.room_id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ chatbot_ids: selectedChatbots }),
      });

      if (!response.ok) {
        // Attempt to parse error JSON, but handle cases where it might not be JSON
        let errorMsg = 'Failed to update room chatbots';
        try {
            const errorData = await response.json();
            errorMsg = errorData.error || errorMsg;
        } catch {
            // If response is not JSON, use status text or a generic message
            errorMsg = `Failed to update room chatbots (status: ${response.status} ${response.statusText})`;
            console.error("PUT request failed with non-JSON response:", await response.text());
        }
        throw new Error(errorMsg);
      }
      // If you expect JSON on successful PUT, parse it here. Otherwise, just call onSuccess.
      // const successData = await response.json(); 
      // console.log("Room chatbots updated:", successData);
      onSuccess();
    } catch (err) {
      console.error("EditRoomModal handleSubmit error:", err);
      setError(err instanceof Error ? err.message : 'An unexpected error occurred while saving changes.');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Edit Room: {room.room_name}</Title>
          <CloseButton onClick={onClose}>×</CloseButton>
        </Header>

        {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

        <Section>
          <SectionTitle>Select Chatbots for this Room</SectionTitle>
          {isLoading ? (
            <div style={{textAlign: 'center', padding: '20px'}}>Loading chatbots...</div>
          ) : chatbots.length === 0 ? (
            <p>No chatbots available to assign. Please create a chatbot first.</p>
          ) : (
            <ChatbotList>
              {chatbots.map(chatbot => (
                <ChatbotItem key={chatbot.chatbot_id}>
                  <Checkbox
                    type="checkbox"
                    id={`cb-edit-${chatbot.chatbot_id}`}
                    checked={selectedChatbots.includes(chatbot.chatbot_id)}
                    onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                  />
                  <label htmlFor={`cb-edit-${chatbot.chatbot_id}`} style={{cursor: 'pointer', flexGrow: 1}}>
                    {chatbot.name}
                    {chatbot.description && (
                      <span style={{ marginLeft: '8px', color: '#777', fontSize: '0.9em' }}>
                        - {chatbot.description.length > 50 ? chatbot.description.substring(0, 50) + '...' : chatbot.description}
                      </span>
                    )}
                  </label>
                </ChatbotItem>
              ))}
            </ChatbotList>
          )}
        </Section>

        <Footer>
          <Button type="button" variant="outline" onClick={onClose} disabled={isSubmitting}>
            Cancel
          </Button>
          <Button 
            type="button" 
            onClick={handleSubmit} 
            disabled={isSubmitting || isLoading || (chatbots.length > 0 && selectedChatbots.length === 0 && !isLoading) }
            // Disable save if loading, submitting, or if chatbots are available but none are selected (unless still loading initial selection)
            title={chatbots.length > 0 && selectedChatbots.length === 0 && !isLoading ? "Select at least one chatbot" : undefined}
          >
            {isSubmitting ? 'Saving...' : 'Save Changes'}
          </Button>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/RoomList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import Link from 'next/link';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import type { Room as BaseRoom } from '@/types/database.types';

// --- Styled Components ---
const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; 
  }
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  min-width: 700px;
`;

const Th = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-weight: 600;
  text-transform: uppercase;
  font-size: 0.875rem;
  letter-spacing: 0.05em;
  white-space: nowrap;
`;

const Td = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  vertical-align: top;
`;

const ActionButtons = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  flex-wrap: wrap;
`;

const RoomCode = styled.span`
  font-family: ${({ theme }) => theme.fonts.mono};
  font-weight: 600;
  color: ${({ theme }) => theme.colors.primary};
  cursor: pointer;
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
  border-radius: ${({ theme }) => theme.borderRadius.small};
  display: inline-block;

  &:hover {
    text-decoration: underline;
    background-color: ${({ theme }) => theme.colors.border};
  }
`;

const RoomNameLink = styled(Link)`
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-weight: 500;
  transition: color ${({ theme }) => theme.transitions.fast};

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
    text-decoration: underline;
  }
`;

const EmptyState = styled(Card)` // EmptyState is a Card
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xxl};
  color: ${({ theme }) => theme.colors.textLight};
  /* The $accentColor prop will be passed here from the main return */

  h3 {
    margin-bottom: ${({ theme }) => theme.spacing.md};
    color: ${({ theme }) => theme.colors.text};
  }

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.xl};
  }
`;

const ModalOverlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
`;

const ModalContent = styled(Card)`
  width: 100%;
  max-width: 400px;
  margin: 20px;
  position: relative;
  text-align: center;
  border-top: none !important; // Ensure modal doesn't get section accent
`;

const ModalTitle = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const ModalText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  color: ${({ theme }) => theme.colors.textLight};
`;

const ModalActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  justify-content: center;
`;

const MobileCardList = styled.div`
  display: none; 

  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: flex; 
    flex-direction: column;
    gap: ${({ theme }) => theme.spacing.md};
    /* Add padding if Card wrapper is removed from return */
    padding: ${({ theme }) => theme.spacing.lg}; 
  }
`;

const MobileRoomCard = styled(Card)` 
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border} !important; // Override section accent for individual mobile cards
`;

const RoomCardHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: flex-start; 
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const RoomCardTitle = styled(Link)` 
  color: ${({ theme }) => theme.colors.text};
  text-decoration: none;
  font-weight: 600;
  font-size: 1.2rem;
  margin-right: ${({ theme }) => theme.spacing.sm}; 

  &:hover {
    color: ${({ theme }) => theme.colors.primary};
  }
`;

const RoomCardDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr; 
  gap: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.9rem;
`;

const DetailItem = styled.div`
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    font-weight: 500;
  }
  .value {
    color: ${({ theme }) => theme.colors.text};
    word-break: break-word; 
  }
`;

const MobileActions = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); 
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.md};
`;

interface RoomWithChatbots extends BaseRoom {
  room_chatbots: { 
    chatbots: { 
      chatbot_id: string;
      name: string;
    } | null; 
  }[] | null; 
}

// MODIFIED Props Interface
interface RoomListProps {
  rooms: RoomWithChatbots[]; 
  onUpdate: () => void;
  onEditRoom: (room: BaseRoom) => void; 
  onDeleteRoom: (room: BaseRoom) => void; 
  accentColor?: string; // Added optional accentColor prop
}

interface DeleteModalProps {
  isOpen: boolean;
  roomName: string;
  onConfirm: () => void;
  onCancel: () => void;
  isDeleting: boolean; 
}

function DeleteModal({ isOpen, roomName, onConfirm, onCancel, isDeleting }: DeleteModalProps) {
  if (!isOpen) return null;
  return (
    <ModalOverlay>
      <ModalContent>
        <ModalTitle>Delete Room</ModalTitle>
        <ModalText>
          Are you sure you want to delete the room &quot;<strong>{roomName}</strong>&quot;? This action cannot be undone and will remove all student memberships and associated data.
        </ModalText>
        <ModalActions>
          <Button variant="outline" onClick={onCancel} disabled={isDeleting}>
            Cancel
          </Button>
          <Button
            variant="magenta" 
            onClick={onConfirm}
            disabled={isDeleting}
          >
            {isDeleting ? 'Deleting...' : 'Yes, Delete Room'}
          </Button>
        </ModalActions>
      </ModalContent>
    </ModalOverlay>
  );
}

// MODIFIED Component Signature
export default function RoomList({ rooms, onUpdate, onEditRoom, onDeleteRoom, accentColor }: RoomListProps) {
  const [loadingState, setLoadingState] = useState<{ [key: string]: boolean }>({});
  const [deleteModal, setDeleteModal] = useState<{
    isOpen: boolean;
    roomId: string | null;
    roomName: string;
  }>({ isOpen: false, roomId: null, roomName: '' });
  const [isDeleting, setIsDeleting] = useState(false); 

  const toggleRoomStatus = async (roomId: string, currentStatus: boolean) => {
    setLoadingState(prev => ({ ...prev, [roomId]: true }));
    try {
      const response = await fetch(`/api/teacher/rooms/${roomId}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ is_active: !currentStatus }),
      });
      if (!response.ok) throw new Error('Failed to update room status');
      onUpdate();
    } catch (error) {
      console.error('Error updating room status:', error);
      alert(`Error: ${error instanceof Error ? error.message : 'Could not update room status.'}`);
    } finally {
      setLoadingState(prev => ({ ...prev, [roomId]: false }));
    }
  };

  const copyRoomCode = async (code: string) => {
    try {
      await navigator.clipboard.writeText(code);
      alert(`Room code "${code}" copied to clipboard!`);
    } catch (error) {
      console.error('Failed to copy room code:', error);
      alert('Failed to copy room code.');
    }
  };

  const generateMagicLink = async (roomId: string, roomCode: string) => {
    try {
      const joinLink = `${window.location.origin}/join?code=${roomCode}`;
      await navigator.clipboard.writeText(joinLink);
      alert(`Student join link copied to clipboard:\n${joinLink}`);
    } catch (error) {
      console.error('Error generating join link:', error);
      alert('Failed to generate join link.');
    }
  };

  const openDeleteModal = (room: BaseRoom) => {
    setDeleteModal({ isOpen: true, roomId: room.room_id, roomName: room.room_name });
  };

  const closeDeleteModal = () => {
    setDeleteModal({ isOpen: false, roomId: null, roomName: '' });
  };

  const handleDeleteRoomConfirm = async () => {
    if (!deleteModal.roomId) return;
    setIsDeleting(true); 
    try {
      await onDeleteRoom({ room_id: deleteModal.roomId, room_name: deleteModal.roomName } as BaseRoom);
      closeDeleteModal(); 
    } catch (error) {
      console.error('Error during delete confirmation:', error);
      alert(`Failed to delete room: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsDeleting(false); 
    }
  };

  const getChatbotCount = (room: RoomWithChatbots): number => {
    if (room.room_chatbots && Array.isArray(room.room_chatbots)) {
      return room.room_chatbots.filter(rc => rc && rc.chatbots).length;
    }
    return 0;
  };

  if (rooms.length === 0) {
    // Pass $accentColor to EmptyState Card
    return (
      <EmptyState $accentColor={accentColor} $accentSide="top"> 
        <h3>No Rooms Created</h3>
        <p>Create your first classroom room to get started!</p>
      </EmptyState>
    );
  }

  return (
    <>
      {/* The outermost element IS a Card, pass $accentColor and $accentSide to it */}
      <Card $accentColor={accentColor} $accentSide="top"> 
        <TableContainer>
          <Table>
            <thead>
              <tr>
                <Th>Room Name</Th>
                <Th>Room Code</Th>
                <Th>Chatbots</Th>
                <Th>Status</Th>
                <Th>Created</Th>
                <Th>Actions</Th>
              </tr>
            </thead>
            <tbody>
              {rooms.map((room) => {
                const chatbotCount = getChatbotCount(room);
                const isLoading = loadingState[room.room_id] || false; 

                return (
                  <tr key={room.room_id}>
                    <Td>
                      <RoomNameLink href={`/teacher-dashboard/rooms/${room.room_id}`} title={`View details for room: ${room.room_name}`}>
                        {room.room_name}
                      </RoomNameLink>
                    </Td>
                    <Td>
                      <RoomCode onClick={() => copyRoomCode(room.room_code)} title="Click to copy room code">
                        {room.room_code}
                      </RoomCode>
                    </Td>
                    <Td>
                      {chatbotCount > 0 ? `${chatbotCount} Attached` : 'None'}
                    </Td>
                    <Td>
                      <Badge variant={room.is_active ? 'success' : 'default'}>
                        {room.is_active ? 'Active' : 'Inactive'}
                      </Badge>
                    </Td>
                    <Td>
                      {new Date(room.created_at).toLocaleDateString()}
                    </Td>
                    <Td>
                      <ActionButtons>
                        <Button size="small" onClick={() => onEditRoom(room)} disabled={isLoading} title="Edit Chatbots for this Room">Edit</Button>
                        <Button size="small" variant="outline" onClick={() => generateMagicLink(room.room_id, room.room_code)} disabled={isLoading} title="Copy Student Join Link">Join Link</Button>
                        <Button size="small" variant={room.is_active ? 'secondary' : 'primary'} onClick={() => toggleRoomStatus(room.room_id, room.is_active)} disabled={isLoading} title={room.is_active ? 'Deactivate Room' : 'Activate Room'}>{isLoading ? '...' : room.is_active ? 'Deactivate' : 'Activate'}</Button>
                        <Button size="small" variant="magenta" onClick={() => openDeleteModal(room)} disabled={isLoading} title="Delete Room">Delete</Button>
                      </ActionButtons>
                    </Td>
                  </tr>
                );
              })}
            </tbody>
          </Table>
        </TableContainer>

        <MobileCardList>
          {rooms.map((room) => {
             const chatbotCount = getChatbotCount(room);
             const isLoading = loadingState[room.room_id] || false;
             return (
                <MobileRoomCard key={`mobile-${room.room_id}`}> 
                  <RoomCardHeader>
                    <RoomCardTitle href={`/teacher-dashboard/rooms/${room.room_id}`} title={`View details for room: ${room.room_name}`}>
                      {room.room_name}
                    </RoomCardTitle>
                    <Badge variant={room.is_active ? 'success' : 'default'}>
                      {room.is_active ? 'Active' : 'Inactive'}
                    </Badge>
                  </RoomCardHeader>
                  <RoomCardDetails>
                    <DetailItem>
                      <span className="label">Code:</span>
                      <RoomCode className="value" onClick={() => copyRoomCode(room.room_code)} title="Click to copy room code">
                        {room.room_code}
                      </RoomCode>
                    </DetailItem>
                    <DetailItem>
                      <span className="label">Chatbots:</span>
                      <span className="value">{chatbotCount > 0 ? `${chatbotCount} Attached` : 'None'}</span>
                    </DetailItem>
                    <DetailItem>
                      <span className="label">Created:</span>
                      <span className="value">{new Date(room.created_at).toLocaleDateString()}</span>
                    </DetailItem>
                  </RoomCardDetails>
                  <MobileActions>
                    <Button size="small" onClick={() => onEditRoom(room)} disabled={isLoading}>Edit</Button>
                    <Button size="small" variant="outline" onClick={() => generateMagicLink(room.room_id, room.room_code)} disabled={isLoading}>Join Link</Button>
                    <Button size="small" variant={room.is_active ? 'secondary' : 'primary'} onClick={() => toggleRoomStatus(room.room_id, room.is_active)} disabled={isLoading}>{isLoading ? '...' : room.is_active ? 'Deactivate' : 'Activate'}</Button>
                    <Button size="small" variant="magenta" onClick={() => openDeleteModal(room)} disabled={isLoading}>Delete</Button>
                  </MobileActions>
                </MobileRoomCard>
             );
          })}
        </MobileCardList>
      </Card>

      <DeleteModal
        isOpen={deleteModal.isOpen}
        roomName={deleteModal.roomName}
        onConfirm={handleDeleteRoomConfirm}
        onCancel={closeDeleteModal}
        isDeleting={isDeleting} 
      />
    </>
  );
}// src/components/teacher/TeacherNav.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { usePathname } from 'next/navigation';

const NavWrapper = styled.nav`
  background-color: ${({ theme }) => theme.colors.backgroundCard};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  box-shadow: ${({ theme }) => theme.shadows.sm};

  ul {
    list-style: none;
    padding: 0;
    margin: 0;
    display: flex;
    gap: ${({ theme }) => theme.spacing.md};
    flex-wrap: wrap; // Allow wrapping on smaller screens
  }

  li a {
    text-decoration: none;
    color: ${({ theme }) => theme.colors.textLight};
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    font-weight: 500;
    transition: all ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.backgroundDark};
    }

    &.active {
      color: ${({ theme }) => theme.colors.primary};
      background-color: ${({ theme }) => theme.colors.primary + '20'}; // Light primary background
    }
  }
`;

const navItems = [
  { href: '/teacher-dashboard', label: 'Overview' },
  { href: '/teacher-dashboard/chatbots', label: 'Chatbots' },
  { href: '/teacher-dashboard/rooms', label: 'Rooms' },
  { href: '/teacher-dashboard/concerns', label: 'Concerns' },
  // { href: '/teacher-dashboard/students', label: 'Students' }, // Future
  // { href: '/teacher-dashboard/settings', label: 'Settings' }, // Future
];

export default function TeacherNav() {
  const pathname = usePathname();

  return (
    <NavWrapper>
      <ul>
        {navItems.map((item) => (
          <li key={item.href}>
            <Link href={item.href} className={pathname === item.href ? 'active' : ''}>
              {item.label}
            </Link>
          </li>
        ))}
      </ul>
    </NavWrapper>
  );
}// src/components/teacher/DocumentUploader.tsx
'use client';

import { useState, useRef, ChangeEvent, DragEvent } from 'react'; // Added specific event types
import styled from 'styled-components';
import { Button, Alert } from '@/styles/StyledComponents';
import type { DocumentType } from '@/types/knowledge-base.types'; // Ensure this path is correct

const UploaderContainer = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const UploadArea = styled.div<{ $isDragging: boolean }>`
  border: 2px dashed ${({ theme, $isDragging }) => 
    $isDragging ? theme.colors.primary : theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.xl};
  text-align: center;
  transition: all ${({ theme }) => theme.transitions.fast};
  background-color: ${({ theme, $isDragging }) => 
    $isDragging ? `${theme.colors.primary}10` : theme.colors.backgroundCard};
  
  &:hover {
    border-color: ${({ theme }) => theme.colors.primary};
    background-color: ${({ theme }) => `${theme.colors.primary}05`};
  }
  cursor: pointer;
`;

const FileInput = styled.input`
  display: none;
`;

const UploadIcon = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 2rem;
  color: ${({ theme }) => theme.colors.textMuted};
`;

const UploadText = styled.p`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FileTypeInfo = styled.p`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const SelectedFileContainer = styled.div` // Renamed from SelectedFile to avoid conflict
  margin-top: ${({ theme }) => theme.spacing.md};
  display: flex;
  align-items: center;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.md};
  background-color: ${({ theme }) => theme.colors.backgroundDark};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const FileName = styled.span`
  flex: 1;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`;

const FileSize = styled.span`
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
`;

interface DocumentUploaderProps {
  chatbotId: string;
  onUploadSuccess: () => void; // Callback after successful upload
}

export default function DocumentUploader({ chatbotId, onUploadSuccess }: DocumentUploaderProps) {
  const [selectedFile, setSelectedFile] = useState<File | null>(null);
  const [isDragging, setIsDragging] = useState(false);
  const [isUploading, setIsUploading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const handleDragOver = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    setIsDragging(false);
    const files = e.dataTransfer.files;
    if (files && files.length > 0) {
      validateAndSetFile(files[0]);
    }
  };

  const validateAndSetFile = (file: File) => {
    setError(null);
    setSuccessMessage(null);
    const validTypes: DocumentType[] = ['pdf', 'docx', 'txt'];
    const extension = file.name.split('.').pop()?.toLowerCase();

    if (!extension || (!validTypes.includes(extension as DocumentType) && extension !== 'doc')) {
      setError('Invalid file type. Please upload PDF, Word (.doc, .docx), or TXT.');
      setSelectedFile(null);
      return;
    }
    const maxSize = 10 * 1024 * 1024; // 10MB
    if (file.size > maxSize) {
      setError('File too large. Maximum size is 10MB.');
      setSelectedFile(null);
      return;
    }
    setSelectedFile(file);
  };

  const handleUpload = async () => {
    if (!selectedFile) return;

    setIsUploading(true);
    setError(null);
    setSuccessMessage(null);

    const formData = new FormData();
    formData.append('file', selectedFile);
    formData.append('chatbotId', chatbotId); // << MODIFICATION: Add chatbotId to FormData

    try {
      // << MODIFICATION: Change API endpoint >>
      const response = await fetch('/api/teacher/documents', {
        method: 'POST',
        body: formData,
      });

      const data = await response.json();
      if (!response.ok) {
        throw new Error(data.error || 'Failed to upload document');
      }
      
      setSuccessMessage(data.message || 'Document uploaded successfully!');
      setSelectedFile(null); 
      if (fileInputRef.current) {
        fileInputRef.current.value = ""; // Reset file input
      }
      onUploadSuccess(); // Call parent callback
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred during upload.');
    } finally {
      setIsUploading(false);
    }
  };

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
  };

  return (
    <UploaderContainer>
      {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}
      {successMessage && <Alert variant="success" style={{ marginBottom: '16px' }}>{successMessage}</Alert>}
      
      <UploadArea
        $isDragging={isDragging}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        onDrop={handleDrop}
        onClick={() => fileInputRef.current?.click()}
      >
        <FileInput
          type="file"
          ref={fileInputRef}
          onChange={handleFileChange}
          accept=".pdf,.doc,.docx,.txt"
        />
        <UploadIcon>📄</UploadIcon> {/* Replace with actual icon if you have one */}
        <UploadText>{isDragging ? 'Drop your file here' : 'Click or drag file to upload'}</UploadText>
        <FileTypeInfo>Supported: PDF, DOC, DOCX, TXT (Max 10MB)</FileTypeInfo>
        {!selectedFile && (
            <Button size="small" variant="outline" type="button" onClick={(e) => { e.stopPropagation(); fileInputRef.current?.click();}}>
                Browse Files
            </Button>
        )}
      </UploadArea>

      {selectedFile && (
        <>
          <SelectedFileContainer>
            <FileName title={selectedFile.name}>{selectedFile.name}</FileName>
            <FileSize>{formatFileSize(selectedFile.size)}</FileSize>
            <Button
              size="small"
              variant="outline"
              onClick={(e) => { e.stopPropagation(); setSelectedFile(null); if(fileInputRef.current) fileInputRef.current.value = ""; setError(null);}}
              type="button"
            >
              Remove
            </Button>
          </SelectedFileContainer>
          
          <Button
            onClick={handleUpload}
            disabled={isUploading}
            style={{ marginTop: '16px', width: '100%' }}
            type="button"
          >
            {isUploading ? 'Uploading...' : `Upload ${selectedFile.name}`}
          </Button>
        </>
      )}
    </UploaderContainer>
  );
}// src/components/teacher/StatsCard.tsx
'use client';

import styled, { DefaultTheme } from 'styled-components'; // Ensure DefaultTheme is imported
import { Card } from '@/styles/StyledComponents';

// Make sure this interface matches what DashboardOverview expects and provides
export interface StatsCardProps { 
  title: string;
  value: string | number;
  onClick?: () => void;
  icon?: React.ReactNode;
  variant?: 'default' | 'warning' | 'danger' | 'magenta' | 'cyan' | 'green' | 'orange_secondary'; 
}

// Helper function to get the actual color from the variant
const getVariantColor = (theme: DefaultTheme, variant: StatsCardProps['variant']): string => {
  switch (variant) {
    case 'danger': 
      return theme.colors.red;      // skolrCoral (#FE4372)
    case 'warning': 
      return theme.colors.secondary;// skolrOrange (#FFB612) 
    case 'magenta': 
      return theme.colors.magenta;  // skolrMagenta (#C848AF)
    case 'cyan': 
      return theme.colors.blue;     // skolrCyan (#4CBEF3) - as theme.colors.blue is mapped to this
    case 'green': 
      return theme.colors.green;    // skolrGreen (#7BBC44)
    case 'orange_secondary': // This explicitly uses the secondary color (skolrOrange)
      return theme.colors.secondary; 
    case 'default': // Explicitly handle default
    default: // Fallback
      return theme.colors.primary;  // skolrPurple (#985DD7)
  }
};

// Make sure the $variant prop passed from the component is correctly typed here
const StyledStatsCard = styled(Card)<{ $clickable: boolean; $variant: StatsCardProps['variant'] }>`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.lg};
  cursor: ${({ $clickable }) => ($clickable ? 'pointer' : 'default')};
  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
  
  /* Ensure this line is using the $variant prop passed to StyledStatsCard */
  border-top: 5px solid ${({ theme, $variant }) => getVariantColor(theme, $variant)};

  &:hover {
    transform: ${({ $clickable }) => ($clickable ? 'translateY(-3px)' : 'none')};
    box-shadow: ${({ $clickable, theme }) => ($clickable ? theme.shadows.md : theme.shadows.sm)};
  }

  .icon {
    font-size: 1.8rem;
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    color: ${({ theme, $variant }) => getVariantColor(theme, $variant)};
  }
  
  h3 { // Title
    color: ${({ theme }) => theme.colors.textMuted};
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: ${({ theme }) => theme.spacing.xs};
    font-weight: 500;
  }

  .value {
    font-size: 2.2rem;
    font-weight: 600;
    color: ${({ theme, $variant }) => getVariantColor(theme, $variant)};
    line-height: 1.2;
  }
`;

export default function StatsCard({ title, value, onClick, icon, variant = 'default' }: StatsCardProps) {
  // The 'variant' prop received here is passed as '$variant' to StyledStatsCard
  return (
    <StyledStatsCard onClick={onClick} $clickable={!!onClick} $variant={variant}>
      {icon && <div className="icon">{icon}</div>}
      <h3>{title}</h3>
      <div className="value">{value}</div>
    </StyledStatsCard>
  );
}// src/components/teacher/ChatbotForm.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import {
    Card,
    Button,
    FormGroup,
    Label,
    Input,
    TextArea,
    Alert,
    Select as StyledSelect
} from '@/styles/StyledComponents';
// No direct import of CreateChatbotPayload here as it's for the API route, not this component directly

// Define BotTypeEnum locally for form state
type BotType = 'learning' | 'assessment';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 650px;
  margin: 20px;
  position: relative;
  display: flex;
  flex-direction: column;
  max-height: 90vh;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    width: 100%;
    min-height: 100vh;
    max-height: 100vh;
    border-radius: 0;
    box-shadow: none;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.lg};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  flex-shrink: 0;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const Title = styled.h2`
  margin: 0;
  font-size: 1.4rem;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.75rem;
  padding: 0;
  line-height: 1;

  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const FormContent = styled.div`
  padding: ${({ theme }) => theme.spacing.lg};
  overflow-y: auto;
  flex-grow: 1;

  &::-webkit-scrollbar {
    width: 6px;
  }
  &::-webkit-scrollbar-thumb {
    background-color: ${({ theme }) => theme.colors.borderDark};
    border-radius: 3px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }


  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
  }
`;


const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  padding: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  flex-shrink: 0;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
    padding: ${({ theme }) => theme.spacing.md};
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px;
  }
`;

const HelpText = styled.p`
  font-size: 0.875rem;
  color: ${({ theme }) => theme.colors.textMuted};
  margin-top: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
`;

const AssessmentCriteriaSection = styled(FormGroup)`
  border: 1px solid ${({ theme }) => theme.colors.border};
  padding: ${({ theme }) => theme.spacing.md};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  background-color: ${({ theme }) => theme.colors.background};
`;

const RubricInfoText = styled(HelpText)`
  font-style: italic;
  margin-top: ${({ theme }) => theme.spacing.md};
`;


interface ChatbotFormData {
  name: string;
  description: string;
  system_prompt: string;
  model: string;
  max_tokens?: number;
  temperature?: number;
  enable_rag: boolean;
  bot_type: BotType;
  assessment_criteria_text: string;
  welcome_message: string; // <--- ADDED
}

interface ChatbotFormProps {
  onClose: () => void;
  onSuccess: (chatbotId: string) => void;
}

export default function ChatbotForm({ onClose, onSuccess }: ChatbotFormProps) {
  const [formData, setFormData] = useState<ChatbotFormData>({
    name: '',
    description: '',
    system_prompt: '',
    model: 'openai/gpt-4.1-nano',
    max_tokens: 1000,
    temperature: 0.7,
    enable_rag: false,
    bot_type: 'learning',
    assessment_criteria_text: '',
    welcome_message: '', // <--- ADDED initial value
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    // The payload sent to /api/teacher/chatbots should match CreateChatbotPayload
    const payload = {
      name: formData.name,
      description: formData.description || undefined,
      system_prompt: formData.system_prompt,
      model: formData.model,
      max_tokens: (formData.max_tokens === undefined || formData.max_tokens === null || isNaN(formData.max_tokens) || String(formData.max_tokens).trim() === '') ? null : Number(formData.max_tokens),
      temperature: (formData.temperature === undefined || formData.temperature === null || isNaN(formData.temperature) || String(formData.temperature).trim() === '') ? null : Number(formData.temperature),
      enable_rag: formData.bot_type === 'learning' ? formData.enable_rag : false,
      bot_type: formData.bot_type,
      assessment_criteria_text: formData.bot_type === 'assessment' ? (formData.assessment_criteria_text || null) : null,
      welcome_message: formData.welcome_message.trim() || null, // <--- ADDED (send null if empty)
    };


    try {
      const response = await fetch('/api/teacher/chatbots', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload), // This payload should match CreateChatbotPayload
      });

      const responseData = await response.json();

      if (!response.ok) {
        throw new Error(responseData.error || 'Failed to create chatbot');
      }

      onSuccess(responseData.chatbot_id);

    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create chatbot');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleChange = (
    e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    const { name, value, type } = e.target;

    if (type === 'checkbox') {
        const { checked } = e.target as HTMLInputElement;
        setFormData(prev => ({
            ...prev,
            [name]: checked,
        }));
    } else {
        // For welcome_message, allow empty string in state for controlled input,
        // it will be converted to null in handleSubmit if empty.
        setFormData(prev => ({
            ...prev,
            [name]: (name === 'max_tokens' || name === 'temperature') && value !== '' ? Number(value) : value,
        }));
    }
  };


  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create New Chatbot</Title>
          <CloseButton onClick={onClose} aria-label="Close modal">×</CloseButton>
        </Header>

        <FormContent>
          {error && <Alert variant="error" style={{ marginBottom: '16px' }}>{error}</Alert>}

          <form onSubmit={handleSubmit} id="chatbotCreateForm">
            {/* ... other FormGroups for name, bot_type, assessment_criteria, description, system_prompt ... */}
            <FormGroup>
              <Label htmlFor="name">Chatbot Name</Label>
              <Input
                id="name"
                name="name"
                value={formData.name}
                onChange={handleChange}
                placeholder="e.g., History Helper, Vocab Quizzer"
                required
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="bot_type">Bot Type</Label>
              <StyledSelect
                id="bot_type"
                name="bot_type"
                value={formData.bot_type}
                onChange={handleChange}
              >
                <option value="learning">Learning Bot</option>
                <option value="assessment">Assessment Bot</option>
              </StyledSelect>
              <HelpText>
                Choose &apos;Learning&apos; for general interaction or &apos;Assessment&apos; to evaluate student responses against criteria.
              </HelpText>
            </FormGroup>

            {formData.bot_type === 'assessment' && (
              <AssessmentCriteriaSection>
                <Label htmlFor="assessment_criteria_text">Define Assessment Rubric / Criteria</Label>
                <TextArea
                  id="assessment_criteria_text"
                  name="assessment_criteria_text"
                  value={formData.assessment_criteria_text}
                  onChange={handleChange}
                  rows={5}
                  placeholder="Clearly describe what the AI should assess. For example:
1. Accuracy of answers to key concepts.
2. Clarity of student's explanations.
3. Use of specific examples or evidence.
4. Critical thinking demonstrated."
                  required={formData.bot_type === 'assessment'}
                />
                <HelpText>
                  This text will guide the AI in evaluating student responses. Be specific.
                </HelpText>
                <RubricInfoText>
                  For more complex rubrics, you will be able to upload a document (e.g., PDF, DOCX) with detailed criteria after creating the bot (on the chatbot&apos;s configuration page). For now, please provide a text-based summary here.
                </RubricInfoText>
              </AssessmentCriteriaSection>
            )}

            <FormGroup>
              <Label htmlFor="description">Description (optional)</Label>
              <Input
                id="description"
                name="description"
                value={formData.description}
                onChange={handleChange}
                placeholder="A brief summary of what this chatbot does"
              />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="system_prompt">System Prompt (AI&apos;s Persona & Core Instructions)</Label>
              <TextArea
                id="system_prompt"
                name="system_prompt"
                value={formData.system_prompt}
                onChange={handleChange}
                placeholder={
                  formData.bot_type === 'assessment'
                  ? "e.g., You are an assessment assistant. Engage the student based on the provided topic. Do not provide answers directly but guide them if they struggle. After the interaction, your analysis will be based on teacher criteria."
                  : "e.g., You are a friendly and helpful history tutor for Grade 10 students."
                }
                required
                rows={formData.bot_type === 'assessment' ? 3 : 5}
              />
              <HelpText>
                  This defines the AI&apos;s general behavior.
                  {formData.bot_type === 'assessment' && " For Assessment Bots, assessment-specific instructions are primarily driven by the Assessment Criteria you define above."}
              </HelpText>
            </FormGroup>

            {/* ADDED Welcome Message Field */}
            <FormGroup>
              <Label htmlFor="welcome_message">Welcome Message (Optional)</Label>
              <TextArea
                id="welcome_message"
                name="welcome_message"
                value={formData.welcome_message}
                onChange={handleChange}
                rows={3}
                placeholder="e.g., Hello! I'm your [topic] assistant. How can I help you today?"
              />
              <HelpText>
                This will be the first message the student sees from the bot.
              </HelpText>
            </FormGroup>
            {/* END ADDED Welcome Message Field */}

            <FormGroup>
              <Label htmlFor="model">AI Model (for Chatting)</Label>
              <StyledSelect
                  id="model"
                  name="model"
                  value={formData.model}
                  onChange={handleChange}
              >
                  <option value="openai/gpt-4.1-nano">OpenAI GPT-4.1 Nano</option>
                  <option value="google/gemini-2.5-flash-preview">Gemini 2.5 Flash Preview</option>
                  <option value="x-ai/grok-3-mini-beta">Grok 3 Mini Beta (Paid)</option>
                  <option value="qwen/qwen3-235b-a22b">Qwen3 235B A22B (Free)</option>
              </StyledSelect>
              <HelpText>
                  This model is used for the chatbot&apos;s direct replies to students. The assessment evaluation will use a dedicated model (Qwen3 235B by default for now).
              </HelpText>
            </FormGroup>

            {formData.bot_type === 'learning' && (
              <FormGroup>
                  <Label htmlFor="enable_rag">Knowledge Base (RAG)</Label>
                  <div style={{ display: 'flex', alignItems: 'center', gap: '8px'}}>
                      <input
                          id="enable_rag"
                          name="enable_rag"
                          type="checkbox"
                          checked={formData.enable_rag}
                          onChange={handleChange}
                          style={{ width: '1.15em', height: '1.15em', cursor: 'pointer' }}
                      />
                      <span>Enable RAG: Allow chatbot to use uploaded documents to answer questions.</span>
                  </div>
                  <HelpText>
                      If enabled, you can upload documents to this chatbot&apos;s knowledge base after creation (on the chatbot&apos;s configuration page).
                  </HelpText>
              </FormGroup>
            )}

            <FormGroup>
              <Label htmlFor="max_tokens">Max Tokens (Chat Response Length)</Label>
              <Input id="max_tokens" name="max_tokens" type="number" value={formData.max_tokens || ''} onChange={handleChange} placeholder="Default: 1000" />
            </FormGroup>

            <FormGroup>
              <Label htmlFor="temperature">Temperature (Chat Creativity)</Label>
              <Input id="temperature" name="temperature" type="number" value={formData.temperature || ''} onChange={handleChange} min="0" max="2" step="0.1" placeholder="Default: 0.7"/>
              <HelpText>0.0 = most deterministic, 2.0 = most creative. Default is 0.7 for the chatbot&apos;s replies.</HelpText>
            </FormGroup>
          </form>
        </FormContent>

        <Footer>
          <ActionButton type="button" variant="outline" onClick={onClose}>
            Cancel
          </ActionButton>
          <ActionButton type="submit" form="chatbotCreateForm" disabled={isSubmitting}>
            {isSubmitting ? 'Creating...' : 'Create Chatbot'}
          </ActionButton>
        </Footer>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/ConcernsList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react';
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button, Badge, Select as StyledSelect } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner';
import type { ConcernStatus, FlaggedMessage } from '@/types/database.types';

// --- Styled Components ---
const ListContainer = styled(Card)` // This is the Card we want to pass the accent to
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  /* The $accentColor prop will be handled by the base Card component */
`;

const Title = styled.h2`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const FilterControls = styled.div`
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  align-items: center;
  flex-wrap: wrap;
`;

const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; 
  border-collapse: collapse;
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md}; 
  border-bottom: 2px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  white-space: nowrap;
  vertical-align: bottom;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
  font-size: 0.875rem;
  vertical-align: top;
`;

const MessagePreview = styled.div`
  max-width: 200px; 
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  color: ${({ theme }) => theme.colors.textLight};
  font-style: italic;
`;

interface ConcernBadgeProps {
  $level: number; 
}

const ConcernBadge = styled(Badge)<ConcernBadgeProps>`
  background: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red + '20'; 
    if ($level >= 3) return theme.colors.secondary + '20';
    return theme.colors.blue + '20'; 
  }};

  color: ${({ theme, $level }) => {
    if ($level >= 4) return theme.colors.red;
    if ($level >= 3) return theme.colors.secondaryDark; 
    return theme.colors.blue;
  }};
  font-weight: 500;
`;

interface StatusBadgeProps {
  $status: ConcernStatus; 
}

const StatusBadge = styled(Badge)<StatusBadgeProps>`
   background: ${({ theme, $status }) => {
       switch ($status) {
           case 'resolved': return theme.colors.green + '20';
           case 'false_positive': return theme.colors.textMuted + '20';
           case 'reviewing': return theme.colors.secondary + '20';
           case 'pending': return theme.colors.red + '20';
           default: return theme.colors.backgroundDark;
       }
   }};
   color: ${({ theme, $status }) => {
        switch ($status) {
           case 'resolved': return theme.colors.green;
           case 'false_positive': return theme.colors.textMuted;
           case 'reviewing': return theme.colors.secondaryDark;
           case 'pending': return theme.colors.red;
           default: return theme.colors.textLight;
       }
   }};
   font-weight: 500;
`;


const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textLight};
  display: flex;
  align-items: center;
  justify-content: center;
  gap: ${({ theme }) => theme.spacing.md};
  min-height: 100px; 
`;

const PaginationControls = styled.div`
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: ${({ theme }) => theme.spacing.lg};
    gap: ${({ theme }) => theme.spacing.md};
`;

interface ConcernDetails extends FlaggedMessage {
    student_name: string | null;
    room_name: string | null;
    message_content: string | null;
}

function getConcernTypeText(type: string): string {
    if (!type) return 'Unknown';
    return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
}

function getConcernLevelText(level: number): string {
    if (level >= 5) return 'Critical';
    if (level >= 4) return 'High';
    if (level >= 3) return 'Significant';
    if (level >= 2) return 'Moderate';
    if (level >= 1) return 'Minor';
    return 'Low';
}

function getStatusText(status: ConcernStatus): string {
    switch (status) {
        case 'pending': return 'Pending';
        case 'reviewing': return 'Reviewing';
        case 'resolved': return 'Resolved';
        case 'false_positive': return 'False Positive';
        default: return status || 'Unknown';
    }
}

// --- MODIFIED Props Interface ---
interface ConcernsListProps {
  limit?: number; 
  accentColor?: string; // Added optional accentColor prop
}

// --- MODIFIED Component Signature to accept accentColor ---
export default function ConcernsList({ limit, accentColor }: ConcernsListProps) {
    const [concerns, setConcerns] = useState<ConcernDetails[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [statusFilter, setStatusFilter] = useState<string>('pending'); 
    const [pagination, setPagination] = useState({ currentPage: 0, hasMore: false, totalCount: 0 });
    const router = useRouter();

    const fetchConcerns = useCallback(async (page = 0, filter = statusFilter, isNewFilter = false) => {
        setLoading(true); 
        if (isNewFilter) {
             setConcerns([]); 
             setPagination(prev => ({ ...prev, currentPage: 0, hasMore: false })); 
        }
        setError(null);

        try {
            const itemsPerPage = limit || 10; 
            const url = new URL('/api/teacher/concerns', window.location.origin);
            url.searchParams.append('page', page.toString());
            url.searchParams.append('limit', itemsPerPage.toString());
            if (filter) {
                url.searchParams.append('status', filter);
            }

            const response = await fetch(url.toString());

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error || `Failed to fetch concerns (status: ${response.status})`);
            }

            const data = await response.json();
            setConcerns(prev => (page > 0 && !isNewFilter) ? [...prev, ...(data.concerns || [])] : (data.concerns || []));
            setPagination({
                 currentPage: data.pagination?.currentPage ?? 0,
                 hasMore: data.pagination?.hasMore ?? false,
                 totalCount: data.pagination?.totalCount ?? 0,
            });
        } catch (err) {
            setError(err instanceof Error ? err.message : 'Error loading concerns');
            setConcerns([]); 
            setPagination({ currentPage: 0, hasMore: false, totalCount: 0 }); 
        } finally {
            setLoading(false);
        }
    }, [limit, statusFilter]); 

    useEffect(() => {
        fetchConcerns(0, statusFilter, true); 
    }, [fetchConcerns, statusFilter]); 


    const handleViewConversation = (concern: ConcernDetails) => {
        router.push(`/teacher-dashboard/concerns/${concern.flag_id}`);
    };

    const handleFilterChange = (e: React.ChangeEvent<HTMLSelectElement>) => {
        const newFilter = e.target.value;
        setStatusFilter(newFilter);
    };

    const handleLoadMore = () => {
        if (!loading && pagination.hasMore) {
            fetchConcerns(pagination.currentPage + 1, statusFilter, false); 
        }
    };

    const renderContent = () => {
        if (loading && concerns.length === 0) { 
            return <LoadingState><LoadingSpinner /> Loading concerns...</LoadingState>;
        }

        if (error) {
            return <Alert variant="error">{error}</Alert>;
        }

        if (concerns.length === 0) {
            return (
            <EmptyState>
                <p>No concerns {statusFilter ? `with status "${getStatusText(statusFilter as ConcernStatus)}"` : ''} found.</p>
            </EmptyState>
            );
        }

        return (
            <>
                <TableContainer>
                    <Table>
                        <thead>
                            <tr>
                                <TableHeader>Student</TableHeader>
                                <TableHeader>Room</TableHeader>
                                <TableHeader>Concern Type</TableHeader>
                                <TableHeader>Level</TableHeader>
                                <TableHeader>Message Preview</TableHeader>
                                <TableHeader>Date Flagged</TableHeader>
                                <TableHeader>Status</TableHeader>
                                <TableHeader>Actions</TableHeader>
                            </tr>
                        </thead>
                        <tbody>
                            {concerns.map((concern) => (
                                <tr key={concern.flag_id}>
                                    <TableCell>{concern.student_name || 'N/A'}</TableCell>
                                    <TableCell>{concern.room_name || 'N/A'}</TableCell>
                                    <TableCell>{getConcernTypeText(concern.concern_type)}</TableCell>
                                    <TableCell>
                                        <ConcernBadge $level={concern.concern_level}>
                                            {getConcernLevelText(concern.concern_level)} ({concern.concern_level})
                                        </ConcernBadge>
                                    </TableCell>
                                    <TableCell>
                                        <MessagePreview title={concern.message_content || ''}>
                                            {concern.message_content || '[N/A]'}
                                        </MessagePreview>
                                    </TableCell>
                                    <TableCell>
                                        {new Date(concern.created_at).toLocaleString()}
                                    </TableCell>
                                    <TableCell>
                                        <StatusBadge $status={concern.status}>
                                            {getStatusText(concern.status)}
                                        </StatusBadge>
                                    </TableCell>
                                    <TableCell>
                                        <Button
                                            size="small"
                                            onClick={() => handleViewConversation(concern)}
                                        >
                                            Review
                                        </Button>
                                    </TableCell>
                                </tr>
                            ))}
                        </tbody>
                    </Table>
                </TableContainer>

                {!limit && pagination.hasMore && ( 
                 <PaginationControls>
                     <Button onClick={handleLoadMore} variant="outline" disabled={loading}>
                         {loading ? 'Loading...' : 'Load More Concerns'}
                     </Button>
                 </PaginationControls>
                )}
            </>
        );
    };

    return (
        <ListContainer $accentColor={accentColor} $accentSide="top"> {/* MODIFIED: Passed props to Card */}
            {!limit && (
                <>
                    <Title>Student Welfare Concerns</Title>
                    <FilterControls>
                        <label htmlFor="status-filter">Filter by status:</label>
                        <StyledSelect 
                            id="status-filter"
                            value={statusFilter}
                            onChange={handleFilterChange}
                            disabled={loading}
                        >
                            <option value="pending">Pending</option>
                            <option value="reviewing">Reviewing</option>
                            <option value="resolved">Resolved</option>
                            <option value="false_positive">False Positive</option>
                            <option value="">All</option>
                        </StyledSelect>
                        {!loading && <span>Total Found: {pagination.totalCount}</span>}
                    </FilterControls>
                 </>
            )}
            {renderContent()}
        </ListContainer>
    );
}// src/components/teacher/DashboardOverview.tsx
'use client';

import { useState, useEffect, useCallback } from 'react'; // MODIFIED: Added useCallback
import styled from 'styled-components';
import StatsCard from './StatsCard'; 
import { Button, Alert, Card } from '@/styles/StyledComponents'; 
import { useRouter } from 'next/navigation';
import Link from 'next/link'; // MODIFIED: Added Link for the "Create one now" message
import LoadingSpinner from '@/components/shared/LoadingSpinner'; 
import RoomForm from '@/components/teacher/RoomForm'; 
import ChatbotList from '@/components/teacher/ChatbotList'; // MODIFIED: Make sure this is imported
import type { Chatbot } from '@/types/database.types'; 

const OverviewWrapper = styled.div`
  /* Add any specific wrapper styles if needed */
`;

const StatsGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
`;

const Section = styled(Card)` 
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  padding: ${({ theme }) => theme.spacing.lg};
`;

const SectionHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;
  gap: ${({ theme }) => theme.spacing.sm};
`;

const SectionTitle = styled.h2`
  font-size: 1.5rem;
  color: ${({ theme }) => theme.colors.text};
  margin: 0;
`;

const QuickActionsContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.md};
  flex-wrap: wrap;

  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column;
    button {
      width: 100%;
    }
  }
`;

interface DashboardStats {
  totalChatbots: number;
  totalRooms: number;
  activeRooms: number;
  pendingConcerns: number;
}

export default function DashboardOverview() {
  const [stats, setStats] = useState<DashboardStats | null>(null);
  const [loadingStats, setLoadingStats] = useState(true);
  const [statsError, setStatsError] = useState<string | null>(null);
  const [showRoomForm, setShowRoomForm] = useState(false); 
  const [availableChatbots, setAvailableChatbots] = useState<Chatbot[]>([]); 
  const [loadingChatbots, setLoadingChatbots] = useState(false); 
  // MODIFIED: State for recent chatbots to display in overview
  const [recentChatbots, setRecentChatbots] = useState<Chatbot[]>([]);
  const [loadingRecentChatbots, setLoadingRecentChatbots] = useState(true);


  const router = useRouter();

  // MODIFIED: Separated fetching logic slightly
  const fetchDashboardStats = useCallback(async () => {
    setLoadingStats(true);
    // Don't reset statsError here if chatbots are also loading, let chatbot fetch handle its part
    try {
      const statsResponse = await fetch('/api/teacher/dashboard-stats');
      if (!statsResponse.ok) {
        const errorData = await statsResponse.json().catch(() => ({}));
        throw new Error(errorData.error || `Failed to fetch stats (status ${statsResponse.status})`);
      }
      const statsData: DashboardStats = await statsResponse.json();
      setStats(statsData);
    } catch (err) {
      console.error("Error fetching dashboard stats:", err);
      const errorMessage = err instanceof Error ? err.message : 'Could not load dashboard statistics.';
      setStatsError(prev => prev ? `${prev}\n${errorMessage}` : errorMessage);
      setStats(null);
    } finally {
      setLoadingStats(false);
    }
  }, []);

  const fetchTeacherChatbots = useCallback(async (isForQuickActions = false) => {
    if (isForQuickActions) {
      setLoadingChatbots(true);
    } else {
      setLoadingRecentChatbots(true);
    }
    // Don't reset statsError here
    try {
      const chatbotsResponse = await fetch('/api/teacher/chatbots'); // Fetches all chatbots
      if (!chatbotsResponse.ok) {
        const errorData = await chatbotsResponse.json().catch(() => ({}));
        const errorMsg = errorData.error || `Failed to fetch chatbots (status ${chatbotsResponse.status})`;
        console.error(errorMsg);
        setStatsError(prev => prev ? `${prev}\n${errorMsg}` : errorMsg);
        if (isForQuickActions) setAvailableChatbots([]); else setRecentChatbots([]);
        return;
      }
      const chatbotsData: Chatbot[] = await chatbotsResponse.json();
      if (isForQuickActions) {
        setAvailableChatbots(chatbotsData);
      } else {
        // For overview, maybe show most recent 3-4 or filter them differently
        setRecentChatbots(chatbotsData.slice(0, 4)); // Example: show first 4
        if (availableChatbots.length === 0) { // Also populate availableChatbots if not already fetched
            setAvailableChatbots(chatbotsData);
        }
      }
    } catch (err) {
      console.error("Error fetching chatbots:", err);
      const errorMsg = err instanceof Error ? err.message : 'Could not load chatbots.';
      setStatsError(prev => prev ? `${prev}\n${errorMsg}` : errorMsg);
      if (isForQuickActions) setAvailableChatbots([]); else setRecentChatbots([]);
    } finally {
      if (isForQuickActions) setLoadingChatbots(false); else setLoadingRecentChatbots(false);
    }
  }, [availableChatbots.length]); // Rerun if availableChatbots length changes (e.g., from empty)

  useEffect(() => {
    fetchDashboardStats();
    fetchTeacherChatbots(false); // Fetch for recent chatbots list
    // If availableChatbots is needed for quick actions and not populated by recent fetch
    if(availableChatbots.length === 0) {
        fetchTeacherChatbots(true); // Fetch for quick actions if not already populated
    }
  }, [fetchDashboardStats, fetchTeacherChatbots, availableChatbots.length]); // Added availableChatbots.length

  const handleCreateNewChatbot = () => {
    router.push('/teacher-dashboard/chatbots/new/edit'); 
  };

  const handleRoomCreated = () => {
    setShowRoomForm(false);
    alert("Room created successfully!");
    fetchDashboardStats(); // Refresh stats which includes room counts
  };

  // MODIFIED: Placeholder handlers for ChatbotList in overview
  const handleEditChatbotOverview = (chatbotId: string) => {
    router.push(`/teacher-dashboard/chatbots/${chatbotId}/edit`);
  };

  const handleDeleteChatbotOverview = async (chatbotId: string, chatbotName: string) => {
    if (window.confirm(`Are you sure you want to delete "${chatbotName}"? This will navigate you to the main chatbots page to confirm further.`)) {
      // Or, directly call the delete API and refresh data here if preferred
      // For now, just navigate to the main chatbots page where full delete logic exists
      router.push('/teacher-dashboard/chatbots');
      // To make it fully functional here, you'd replicate the delete logic from ManageChatbotsPage
      // and call fetchTeacherChatbots(false) and fetchDashboardStats() on success.
      alert(`Deletion for "${chatbotName}" would be handled on the main chatbots page or via a shared hook/service.`);
    }
  };


  if (loadingStats || loadingRecentChatbots) { 
    return (
        <Card style={{ textAlign: 'center', padding: '40px' }}>
            <LoadingSpinner size="large" />
            <p style={{marginTop: '16px'}}>Loading dashboard overview...</p>
        </Card>
    );
  }

  if (statsError && !stats && recentChatbots.length === 0) {
    return (
        <Alert variant="error" style={{ marginBottom: '16px' }}>
            {statsError}
            <Button onClick={() => window.location.reload()} size="small" style={{marginLeft: '10px'}}>Retry</Button>
        </Alert>
    );
  }
  
  return (
    <OverviewWrapper>
      {statsError && <Alert variant="error" style={{ marginBottom: '16px' }}>{statsError}</Alert>}

      {stats && (
        <StatsGrid>
          <StatsCard
            title="Pending Concerns"
            value={stats.pendingConcerns}
            onClick={() => router.push('/teacher-dashboard/concerns')}
            variant={stats.pendingConcerns > 0 ? 'danger' : 'green'}
          />
          <StatsCard
            title="Active Rooms"
            value={stats.activeRooms}
            onClick={() => router.push('/teacher-dashboard/rooms')}
            variant="cyan" 
          />
          <StatsCard
            title="My Chatbots"
            value={stats.totalChatbots}
            onClick={() => router.push('/teacher-dashboard/chatbots')}
            variant="magenta" 
          />
          <StatsCard
            title="Total Rooms"
            value={stats.totalRooms}
            onClick={() => router.push('/teacher-dashboard/rooms')} 
            variant="orange_secondary" 
          />
        </StatsGrid>
      )}

      <Section $accentSide="top" $accentColor="magenta">
        <SectionHeader>
          <SectionTitle>Quick Actions</SectionTitle>
        </SectionHeader>
        <QuickActionsContainer>
          <Button onClick={handleCreateNewChatbot}>
            + Create New Chatbot
          </Button>
          <Button
            onClick={() => setShowRoomForm(true)}
            disabled={loadingChatbots || availableChatbots.length === 0}
            title={availableChatbots.length === 0 && !loadingChatbots ? "Create a chatbot before creating a room" : "Create New Room"}
          >
            {loadingChatbots ? "Loading Chatbots..." : "+ Create New Room"}
          </Button>
        </QuickActionsContainer>
        {availableChatbots.length === 0 && !loadingChatbots && !statsError?.includes("Failed to load chatbots for Room Creation.") && (
            <Alert variant='info' style={{marginTop: '16px'}}>
                You need to create at least one chatbot before you can create a classroom room using the quick action.
            </Alert>
        )}
      </Section>

      {/* MODIFIED: Section to display recent chatbots */}
      <Section $accentSide="top" $accentColor="blue">
        <SectionHeader>
          <SectionTitle>My Recent Chatbots</SectionTitle>
          {stats && stats.totalChatbots > recentChatbots.length && (
            <Button variant="outline" size="small" onClick={() => router.push('/teacher-dashboard/chatbots')}>
              View All ({stats.totalChatbots})
            </Button>
          )}
        </SectionHeader>
        {loadingRecentChatbots && recentChatbots.length === 0 ? (
            <div style={{textAlign: 'center', padding: '20px'}}><LoadingSpinner /> Loading chatbots...</div>
        ) : recentChatbots.length > 0 ? (
          <ChatbotList
            chatbots={recentChatbots} 
            onEdit={handleEditChatbotOverview}
            onDelete={handleDeleteChatbotOverview}
            viewMode="card" // MODIFIED: Provide the viewMode prop, defaulting to 'card' for overview
          />
        ) : (
          <p>No chatbots created yet. <Link href="/teacher-dashboard/chatbots/new/edit" style={{textDecoration: 'underline', fontWeight: '500'}}>Create one now!</Link></p>
        )}
      </Section>


      {showRoomForm && (
        <RoomForm
          chatbots={availableChatbots} 
          onClose={() => setShowRoomForm(false)}
          onSuccess={handleRoomCreated}
        />
      )}
    </OverviewWrapper>
  );
}// src/components/teacher/StudentList.tsx
'use client';

import { useState, useEffect, useCallback } from 'react'; // Added useCallback
import styled from 'styled-components';
import { useRouter } from 'next/navigation';
import { Card, Alert, Button } from '@/styles/StyledComponents';
import LoadingSpinner from '@/components/shared/LoadingSpinner'; // Import a spinner

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.xl};
`;

const Title = styled.h3`
  margin-bottom: ${({ theme }) => theme.spacing.md};
  color: ${({ theme }) => theme.colors.text};
`;

const Table = styled.table`
  width: 100%;
  border-collapse: collapse;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: none; 
  }
`;

const TableHeader = styled.th`
  text-align: left;
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.textLight};
  font-size: 0.875rem;
`;

const TableCell = styled.td`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  color: ${({ theme }) => theme.colors.text};
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;

const LoadingState = styled(EmptyState)` // Reuse EmptyState style for consistency
    display: flex;
    align-items: center;
    justify-content: center;
    gap: ${({ theme }) => theme.spacing.sm};
`;


const MobileList = styled.div`
  display: none;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    display: block;
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const StudentName = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.875rem;
  
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
    margin-right: ${({ theme }) => theme.spacing.md};
  }
  
  .value {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
`;

interface Student {
  user_id: string;
  name: string;
  email: string;
  joined_at: string | null;
  // message_count: number; // Removed as API doesn't provide it yet
  // last_activity: string | null; // Removed
}

interface StudentListProps {
  roomId: string;
}

export default function StudentList({ roomId }: StudentListProps) {
  const [students, setStudents] = useState<Student[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const router = useRouter();

  const fetchStudents = useCallback(async () => {
    console.log(`[StudentList] Fetching students for roomId: ${roomId}`);
    setLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/teacher/students?roomId=${roomId}`);
      
      if (!response.ok) {
        let errorMessage = `Failed to fetch students (status ${response.status})`;
        try {
          const errorData = await response.json();
          errorMessage = errorData.error || errorMessage;
        } catch {
          // Failed to parse error JSON
        }
        console.error(`[StudentList] API error: ${errorMessage}`);
        throw new Error(errorMessage);
      }
      
      const data = await response.json();
      console.log('[StudentList] Students data received:', data);
      setStudents(Array.isArray(data) ? data : []);
    } catch (err) {
      console.error('[StudentList] Catch block error fetching students:', err);
      setError(err instanceof Error ? err.message : 'Could not load student data.');
      setStudents([]); // Clear students on error
    } finally {
      console.log('[StudentList] Setting loading to false.');
      setLoading(false);
    }
  }, [roomId]); // roomId is the dependency

  useEffect(() => {
    if (roomId) { // Only fetch if roomId is available
        fetchStudents();
    } else {
        console.warn("[StudentList] RoomId is missing, not fetching students.");
        setLoading(false); // Don't hang in loading state if no roomId
    }
  }, [roomId, fetchStudents]); // fetchStudents is stable due to useCallback

  const formatDate = (dateString: string | null) => {
    if (!dateString) return 'N/A';
    try {
        return new Date(dateString).toLocaleString();
    } catch {
        return 'Invalid Date';
    }
  };

  const handleViewChats = (studentId: string) => {
    router.push(`/room/${roomId}/student/${studentId}`);
  };

  if (loading) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <LoadingState><LoadingSpinner size="small" /> Loading student data...</LoadingState>
      </ListContainer>
    );
  }

  // Error display takes precedence over empty state if an error occurred
  if (error) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <Alert variant="error">
          Error: {error}
          <Button size="small" onClick={fetchStudents} style={{ marginLeft: '10px' }}>
            Retry
          </Button>
        </Alert>
      </ListContainer>
    );
  }

  if (students.length === 0) {
    return (
      <ListContainer>
        <Title>Students</Title>
        <EmptyState>
          <p>No students have joined this room yet, or data could not be loaded.</p>
          <Button size="small" onClick={fetchStudents} style={{ marginTop: '10px' }}>
            Refresh List
          </Button>
        </EmptyState>
      </ListContainer>
    );
  }

  return (
    <ListContainer>
      <Title>Students ({students.length})</Title>
      
      <Table>
        {/* ... (thead remains the same) ... */}
        <thead>
          <tr>
            <TableHeader>Name</TableHeader>
            <TableHeader>Email</TableHeader>
            <TableHeader>Joined</TableHeader>
            <TableHeader>Actions</TableHeader>
          </tr>
        </thead>
        <tbody>
          {students.map((student) => (
            <tr key={student.user_id}>
              <TableCell>{student.name}</TableCell>
              <TableCell>{student.email}</TableCell>
              <TableCell>{formatDate(student.joined_at)}</TableCell>
              <TableCell>
                <Button
                  size="small"
                  onClick={() => handleViewChats(student.user_id)}
                >
                  View Chats
                </Button>
              </TableCell>
            </tr>
          ))}
        </tbody>
      </Table>
      
      <MobileList>
        {students.map((student) => (
          <MobileCard key={student.user_id}>
            <MobileHeader>
              <StudentName>{student.name}</StudentName>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Email:</span>
              <span className="value">{student.email}</span>
              <span className="label">Joined:</span>
              <span className="value">{formatDate(student.joined_at)}</span>
            </MobileDetails>
            <MobileActions>
              <Button
                size="small"
                onClick={() => handleViewChats(student.user_id)}
                style={{ width: '100%' }}
              >
                View Chats
              </Button>
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/teacher/ChatbotList.tsx
'use client';

import Link from 'next/link';
import styled from 'styled-components';
import { Card, Button, Badge } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

// Card View Styled Components (Existing)
const ListGrid = styled.div`
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: ${({ theme }) => theme.spacing.lg};
  margin-top: ${({ theme }) => theme.spacing.lg};
`;

const StyledChatbotCard = styled(Card)<{ $cardAccentColor?: string }>`
  position: relative;
  display: flex;
  flex-direction: column;
  ${({ $cardAccentColor }) => 
    $cardAccentColor && `border-top: 4px solid ${$cardAccentColor};`}

  a > h3 { 
    color: ${({ theme }) => theme.colors.text};
    margin-bottom: ${({ theme }) => theme.spacing.sm};
    font-size: 1.25rem;
    text-decoration: none;
    display: block; 
    transition: color ${({ theme }) => theme.transitions.fast};

    &:hover {
      color: ${({ theme }) => theme.colors.primary};
      text-decoration: underline;
    }
  }
  
  p.description {
    color: ${({ theme }) => theme.colors.textLight};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    flex-grow: 1; 
    min-height: 40px; 
  }
  .model-info {
    font-size: 0.875rem;
    color: ${({ theme }) => theme.colors.textMuted};
    background: ${({ theme }) => theme.colors.backgroundDark};
    padding: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.sm};
    border-radius: ${({ theme }) => theme.borderRadius.small};
    margin-bottom: ${({ theme }) => theme.spacing.md};
    display: inline-block;
  }
  .actions {
    display: flex;
    gap: ${({ theme }) => theme.spacing.md};
    margin-top: auto; 
    padding-top: ${({ theme }) => theme.spacing.md}; 
    flex-wrap: no-wrap; 
    
    button { 
        flex-grow: 1; 
        flex-basis: calc(50% - ${({ theme }) => `calc(${theme.spacing.md} / 2)`});
        max-width: calc(50% - ${({ theme }) => `calc(${theme.spacing.md} / 2)`});
        text-align: center; 

         @media (max-width: 380px) { 
            flex-basis: 100%; 
            max-width: 100%;
            &:not(:last-child) {
              margin-bottom: ${({ theme }) => theme.spacing.sm};
            }
         }
    }
  }
`;

// Styled Components for Table/List View
const TableContainer = styled.div`
  width: 100%;
  overflow-x: auto;
  margin-top: ${({ theme }) => theme.spacing.lg};
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
`;

const Table = styled.table`
  width: 100%;
  min-width: 800px; 
  border-collapse: collapse;
  
  th, td {
    padding: ${({ theme }) => theme.spacing.md};
    text-align: left;
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    vertical-align: middle;
  }

  th {
    background-color: ${({ theme }) => theme.colors.backgroundCard};
    color: ${({ theme }) => theme.colors.textLight};
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    white-space: nowrap;
  }

  td {
    font-size: 0.9rem;
  }

  tr:last-child td {
    border-bottom: none;
  }
  
  .description-cell {
    max-width: 250px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
`;

const ActionButtonsContainer = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  align-items: center;
`;

const getModelDisplayName = (model: string | undefined) => {
    if (!model) return 'Default Model';
    const modelNames: Record<string, string> = {
        'x-ai/grok-3-mini-beta': 'Grok 3 Mini',
        'qwen/qwen3-235b-a22b': 'Qwen3 235B',
        'google/gemini-2.5-flash-preview': 'Gemini 2.5 Flash',
        'openai/gpt-4.1-nano': 'GPT-4.1 Nano', 
    };
    return modelNames[model] || model;
};

// Ensure this interface is EXPORTED
export interface ChatbotListProps {
  chatbots: Chatbot[];
  onEdit: (chatbotId: string) => void;
  onDelete: (chatbotId: string, chatbotName: string) => void; 
  viewMode: 'card' | 'list';
}

export default function ChatbotList({ chatbots, onEdit, onDelete, viewMode }: ChatbotListProps) {

  if (chatbots.length === 0) {
    return <Card><p>No chatbots found.</p></Card>;
  }

  const formatDate = (dateString: string | undefined) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleDateString();
  };

  if (viewMode === 'list') {
    return (
      <TableContainer>
        <Table>
          <thead>
            <tr>
              <th>Name</th>
              <th>Type</th>
              <th>Description</th>
              <th>Model</th>
              <th>RAG</th>
              <th>Last Modified</th>
              <th>Actions</th>
            </tr>
          </thead>
          <tbody>
            {chatbots.map((chatbot) => (
              <tr key={chatbot.chatbot_id}>
                <td>
                  <Link href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/test-chat`} title={`Test chat with ${chatbot.name}`}>
                    {chatbot.name}
                  </Link>
                </td>
                <td>
                  <Badge variant={chatbot.bot_type === 'assessment' ? 'warning' : 'default'}>
                    {chatbot.bot_type ? chatbot.bot_type.charAt(0).toUpperCase() + chatbot.bot_type.slice(1) : 'N/A'}
                  </Badge>
                </td>
                <td className="description-cell" title={chatbot.description || undefined}>
                  {chatbot.description || '-'}
                </td>
                <td>{getModelDisplayName(chatbot.model)}</td>
                <td>
                  <Badge variant={chatbot.enable_rag ? 'success' : 'default'}>
                    {chatbot.enable_rag ? 'Enabled' : 'Disabled'}
                  </Badge>
                </td>
                <td>{formatDate(chatbot.updated_at || chatbot.created_at)}</td>
                <td>
                  <ActionButtonsContainer>
                    <Button
                      size="small"
                      variant="outline"
                      onClick={() => onEdit(chatbot.chatbot_id)}
                    >
                      Edit
                    </Button>
                    <Button
                      size="small"
                      variant="magenta"
                      onClick={() => onDelete(chatbot.chatbot_id, chatbot.name)}
                    >
                      Delete
                    </Button>
                  </ActionButtonsContainer>
                </td>
              </tr>
            ))}
          </tbody>
        </Table>
      </TableContainer>
    );
  }

  return (
    <ListGrid>
      {chatbots.map((chatbot) => {
        return (
          <StyledChatbotCard 
              key={chatbot.chatbot_id}
          >
            <Link href={`/teacher-dashboard/chatbots/${chatbot.chatbot_id}/test-chat`} title={`Test chat with ${chatbot.name}`}>
              <h3>{chatbot.name}</h3>
            </Link>
            <p className="description">{chatbot.description || 'No description provided.'}</p>
            <div className="model-info">
              Model: {getModelDisplayName(chatbot.model)}
            </div>
            <div className="actions">
              <Button
                size="small"
                variant="outline" 
                onClick={() => onEdit(chatbot.chatbot_id)}
                title="Edit chatbot settings and knowledge base"
              >
                Edit
              </Button>
              <Button
                  size="small"
                  variant="magenta"
                  onClick={() => onDelete(chatbot.chatbot_id, chatbot.name)}
                  title="Delete this chatbot"
              >
                  Delete
              </Button>
            </div>
          </StyledChatbotCard>
        );
      })}
    </ListGrid>
  );
}'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, FormGroup, Label, Input, Alert } from '@/styles/StyledComponents';
import type { Chatbot } from '@/types/database.types';

const Overlay = styled.div`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
  padding: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: 0;
    align-items: flex-start;
    overflow-y: auto;
  }
`;

const FormCard = styled(Card)`
  width: 100%;
  max-width: 600px;
  margin: 20px;
  position: relative;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    margin: 0;
    max-height: 100%;
    min-height: 100vh;
    border-radius: 0;
    overflow-y: auto;
  }
`;

const Header = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.lg};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    position: sticky;
    top: 0;
    background: ${({ theme }) => theme.colors.backgroundCard};
    padding: ${({ theme }) => theme.spacing.sm} 0;
    z-index: 5;
  }
`;

const Title = styled.h2`
  margin: 0;
  color: ${({ theme }) => theme.colors.text};
`;

const CloseButton = styled.button`
  background: none;
  border: none;
  color: ${({ theme }) => theme.colors.textLight};
  cursor: pointer;
  font-size: 1.5rem;
  
  &:hover {
    color: ${({ theme }) => theme.colors.text};
  }
`;

const Footer = styled.div`
  display: flex;
  justify-content: flex-end;
  gap: ${({ theme }) => theme.spacing.md};
  margin-top: ${({ theme }) => theme.spacing.xl};
  padding-top: ${({ theme }) => theme.spacing.lg};
  border-top: 1px solid ${({ theme }) => theme.colors.border};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    flex-direction: column-reverse;
  }
`;

const ChatbotList = styled.div`
  max-height: 300px;
  overflow-y: auto;
  border: 1px solid ${({ theme }) => theme.colors.border};
  border-radius: ${({ theme }) => theme.borderRadius.medium};
  padding: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    max-height: 200px;
  }
`;

const ChatbotItem = styled.label`
  display: flex;
  align-items: center;
  padding: ${({ theme }) => theme.spacing.sm};
  cursor: pointer;
  
  &:hover {
    background: ${({ theme }) => theme.colors.backgroundDark};
  }
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    padding: ${({ theme }) => theme.spacing.md};
    min-height: 44px; // Better for touch inputs
  }
`;

const Checkbox = styled.input`
  margin-right: ${({ theme }) => theme.spacing.md};
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 20px;
    height: 20px;
  }
`;

const ChatbotName = styled.span`
  flex: 1;
`;

const ChatbotDescription = styled.span`
  margin-left: ${({ theme }) => theme.spacing.sm};
  color: ${({ theme }) => theme.colors.textMuted};
  font-size: 0.875rem;
  
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    display: none;
  }
`;

const ActionButton = styled(Button)`
  @media (max-width: ${({ theme }) => theme.breakpoints.mobile}) {
    width: 100%;
    min-height: 48px; // Better for touch inputs
  }
`;

interface RoomFormProps {
  chatbots: Chatbot[];
  onClose: () => void;
  onSuccess: () => void;
}

export default function RoomForm({ chatbots, onClose, onSuccess }: RoomFormProps) {
  const [formData, setFormData] = useState({
    room_name: '',
    chatbot_ids: [] as string[],
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);

    try {
      const response = await fetch('/api/teacher/rooms', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create room');
      }

      onSuccess();
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to create room');
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    setFormData(prev => ({
      ...prev,
      room_name: e.target.value,
    }));
  };

  const handleToggleChatbot = (chatbotId: string) => {
    setFormData(prev => ({
      ...prev,
      chatbot_ids: prev.chatbot_ids.includes(chatbotId)
        ? prev.chatbot_ids.filter(id => id !== chatbotId)
        : [...prev.chatbot_ids, chatbotId]
    }));
  };

  return (
    <Overlay>
      <FormCard>
        <Header>
          <Title>Create Classroom Room</Title>
          <CloseButton onClick={onClose}>&times;</CloseButton>
        </Header>

        {error && <Alert variant="error">{error}</Alert>}

        <form onSubmit={handleSubmit}>
          <FormGroup>
            <Label htmlFor="room_name">Room Name</Label>
            <Input
              id="room_name"
              name="room_name"
              value={formData.room_name}
              onChange={handleNameChange}
              placeholder="Enter room name"
              required
            />
          </FormGroup>

          <FormGroup>
            <Label>Select Chatbots</Label>
            {chatbots.length === 0 ? (
              <Alert variant="warning">
                You need to create a chatbot before you can create a room.
              </Alert>
            ) : (
              <ChatbotList>
                {chatbots.map(chatbot => (
                  <ChatbotItem key={chatbot.chatbot_id}>
                    <Checkbox
                      type="checkbox"
                      checked={formData.chatbot_ids.includes(chatbot.chatbot_id)}
                      onChange={() => handleToggleChatbot(chatbot.chatbot_id)}
                    />
                    <ChatbotName>{chatbot.name}</ChatbotName>
                    {chatbot.description && (
                      <ChatbotDescription>
                        - {chatbot.description}
                      </ChatbotDescription>
                    )}
                  </ChatbotItem>
                ))}
              </ChatbotList>
            )}
          </FormGroup>

          <Footer>
            <ActionButton type="button" variant="outline" onClick={onClose}>
              Cancel
            </ActionButton>
            <ActionButton 
              type="submit" 
              disabled={isSubmitting || chatbots.length === 0 || formData.chatbot_ids.length === 0}
            >
              {isSubmitting ? 'Creating...' : 'Create Room'}
            </ActionButton>
          </Footer>
        </form>
      </FormCard>
    </Overlay>
  );
}// src/components/teacher/DocumentList.tsx
'use client';

import { useState } from 'react';
import styled from 'styled-components';
import { Card, Button, Badge, Alert } from '@/styles/StyledComponents';
import type { Document as KnowledgeDocument, DocumentStatus, DocumentType } from '@/types/knowledge-base.types'; // MODIFIED: Added DocumentType

const ListContainer = styled(Card)`
  margin-top: ${({ theme }) => theme.spacing.lg};
  margin-bottom: ${({ theme }) => theme.spacing.xl};
  overflow-x: auto; 
`;

const Table = styled.table`
  width: 100%;
  min-width: 700px; 
  border-collapse: collapse; 
  
  th, td {
    text-align: left;
    padding: ${({ theme }) => theme.spacing.sm} ${({ theme }) => theme.spacing.md};
    border-bottom: 1px solid ${({ theme }) => theme.colors.border};
    vertical-align: middle; 
  }

  th {
    color: ${({ theme }) => theme.colors.textLight};
    font-size: 0.8rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    white-space: nowrap; 
  }

  td {
    color: ${({ theme }) => theme.colors.text};
    font-size: 0.875rem;
  }

  .actions-cell {
    width: 1%; 
    white-space: nowrap;
  }
  
  .filename-cell { // MODIFIED: Added for better filename display
    max-width: 250px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;

const MobileList = styled.div`
  display: none; 
  @media (max-width: ${({ theme }) => theme.breakpoints.tablet}) {
    /* display: block; */
  }
`;

const MobileCard = styled.div`
  padding: ${({ theme }) => theme.spacing.md};
  border-bottom: 1px solid ${({ theme }) => theme.colors.border};
  &:last-child {
    border-bottom: none;
  }
`;

const MobileHeader = styled.div`
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: ${({ theme }) => theme.spacing.sm};
`;

const FileNameMobile = styled.div`
  font-weight: 500;
  color: ${({ theme }) => theme.colors.text};
  word-break: break-all;
`;

const MobileDetails = styled.div`
  display: grid;
  grid-template-columns: auto 1fr;
  gap: ${({ theme }) => theme.spacing.xs} ${({ theme }) => theme.spacing.md};
  margin-bottom: ${({ theme }) => theme.spacing.md};
  font-size: 0.8rem;
  .label {
    color: ${({ theme }) => theme.colors.textMuted};
  }
  .value {
    color: ${({ theme }) => theme.colors.text};
    word-break: break-all;
  }
`;

const MobileActions = styled.div`
  display: flex;
  gap: ${({ theme }) => theme.spacing.sm};
  margin-top: ${({ theme }) => theme.spacing.sm};
  flex-wrap: wrap;
  button {
    flex-grow: 1;
    min-width: 100px;
  }
`;

const EmptyState = styled.div`
  text-align: center;
  padding: ${({ theme }) => theme.spacing.xl};
  color: ${({ theme }) => theme.colors.textMuted};
`;


// MODIFIED: getStatusBadgeVariant to include 'fetched' status
const getStatusBadgeVariant = (status: DocumentStatus): 'success' | 'warning' | 'error' | 'default' => {
    switch (status) {
      case 'completed': return 'success';
      case 'processing': return 'default';
      case 'error': return 'error';
      case 'uploaded': return 'warning';
      case 'fetched': return 'warning'; // 'fetched' can also be warning or default
      default: return 'default';
    }
};


interface DocumentListProps {
  documents: KnowledgeDocument[];
  onProcessDocument: (documentId: string) => Promise<void>;
  onDeleteDocument: (documentId: string) => Promise<void>;
  onViewStatus: (documentId: string) => void;
}

export default function DocumentList({
  documents,
  onProcessDocument,
  onDeleteDocument,
  onViewStatus
}: DocumentListProps) {
  const [processingId, setProcessingId] = useState<string | null>(null);
  const [deletingId, setDeletingId] = useState<string | null>(null);
  const [actionError, setActionError] = useState<string | null>(null);

  const formatDate = (dateString: string) => {
    if (!dateString) return 'N/A';
    return new Date(dateString).toLocaleString();
  };

  // MODIFIED: formatFileSize to handle webpage type (size is text length)
  const formatFileSize = (bytes: number, fileType: DocumentType): string => {
    if (fileType === 'webpage') {
        // For webpages, 'bytes' is actually character count of extracted text
        if (bytes === 0) return 'No text extracted';
        return `${bytes.toLocaleString()} chars`;
    }
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + ['Bytes', 'KB', 'MB', 'GB', 'TB'][i];
  };

  // MODIFIED: getStatusLabel to include 'fetched'
  const getStatusLabel = (status: DocumentStatus): string => {
    const labels: Record<DocumentStatus, string> = {
      uploaded: 'Uploaded',
      processing: 'Processing',
      completed: 'Completed',
      error: 'Error',
      fetched: 'Fetched', // New label
    };
    return labels[status] || status;
  };

  const handleProcess = async (documentId: string) => {
    setProcessingId(documentId);
    setActionError(null);
    try {
      await onProcessDocument(documentId);
    } catch (err) {
      setActionError(err instanceof Error ? err.message : "Failed to start processing.");
    } finally {
      setProcessingId(null);
    }
  };

  const handleDelete = async (documentId: string, documentName: string) => {
    if (!window.confirm(`Are you sure you want to delete the document "${documentName}"? This action cannot be undone.`)) {
        return;
    }
    setDeletingId(documentId);
    setActionError(null);
    try {
      await onDeleteDocument(documentId);
    } catch (err) {
      setActionError(err instanceof Error ? err.message : "Failed to delete document.");
    } finally {
      setDeletingId(null);
    }
  };

  if (documents.length === 0) {
    return (
      <ListContainer>
        <EmptyState>
          <p>No documents have been added to this chatbot&apos;s knowledge base yet.</p>
        </EmptyState>
      </ListContainer>
    );
  }

  const renderActions = (doc: KnowledgeDocument) => (
    <>
      {/* MODIFIED: Allow processing for 'fetched' status as well */}
      {(doc.status === 'uploaded' || doc.status === 'fetched') && (
        <Button
          size="small"
          onClick={() => handleProcess(doc.document_id)}
          disabled={processingId === doc.document_id}
          title="Process this document/webpage for RAG"
        >
          {processingId === doc.document_id ? 'Starting...' : 'Process'}
        </Button>
      )}
      {(doc.status === 'processing' || doc.status === 'completed' || doc.status === 'error') && (
        <Button
          size="small"
          variant="outline"
          onClick={() => onViewStatus(doc.document_id)}
          title="View detailed processing status"
        >
          View Status
        </Button>
      )}
      <Button
        size="small"
        variant="danger" 
        onClick={() => handleDelete(doc.document_id, doc.file_name)}
        disabled={deletingId === doc.document_id}
        title="Delete this document/webpage"
      >
        {deletingId === doc.document_id ? 'Deleting...' : 'Delete'}
      </Button>
    </>
  );

  return (
    <ListContainer>
      {actionError && <Alert variant="error" style={{ marginBottom: '16px'}}>{actionError}</Alert>}
      <Table>
        <thead>
          <tr>
            <th>Name / URL</th> 
            <th>Type</th>
            <th>Size / Content Length</th>
            <th>Status</th>
            <th>Added</th>
            <th className="actions-cell">Actions</th>
          </tr>
        </thead>
        <tbody>
          {documents.map((doc) => (
            <tr key={doc.document_id}>
              {/* MODIFIED: Display filename for files, and file_path (URL) for webpages */}
              <td className="filename-cell" title={doc.file_type === 'webpage' ? doc.file_path : doc.file_name}>
                {doc.file_type === 'webpage' ? 
                  <a href={doc.file_path} target="_blank" rel="noopener noreferrer" title={`Open: ${doc.file_path}`}>
                    {doc.file_name} {/* file_name for webpage is its title */}
                  </a>
                  : doc.file_name
                }
              </td>
              <td>{doc.file_type.toUpperCase()}</td>
              {/* MODIFIED: Pass file_type to formatFileSize */}
              <td>{formatFileSize(doc.file_size, doc.file_type)}</td>
              <td>
                <Badge variant={getStatusBadgeVariant(doc.status)}>
                  {getStatusLabel(doc.status)}
                </Badge>
              </td>
              <td>{formatDate(doc.created_at)}</td>
              <td className="actions-cell">
                <div style={{ display: 'flex', gap: '8px' }}>
                  {renderActions(doc)}
                </div>
              </td>
            </tr>
          ))}
        </tbody>
      </Table>

      <MobileList>
        {documents.map((doc) => (
          <MobileCard key={`mobile-${doc.document_id}`}> {/* MODIFIED: Added unique key prefix for mobile */}
            <MobileHeader>
              {/* MODIFIED: Mobile display for filename/URL */}
              <FileNameMobile title={doc.file_type === 'webpage' ? doc.file_path : doc.file_name}>
                {doc.file_type === 'webpage' ? 
                  <a href={doc.file_path} target="_blank" rel="noopener noreferrer">
                    {doc.file_name}
                  </a>
                  : doc.file_name
                }
              </FileNameMobile>
              <Badge variant={getStatusBadgeVariant(doc.status)}>
                {getStatusLabel(doc.status)}
              </Badge>
            </MobileHeader>
            <MobileDetails>
              <span className="label">Type:</span>
              <span className="value">{doc.file_type.toUpperCase()}</span>
              <span className="label">Size:</span>
              {/* MODIFIED: Pass file_type to formatFileSize for mobile */}
              <span className="value">{formatFileSize(doc.file_size, doc.file_type)}</span>
              <span className="label">Added:</span>
              <span className="value">{formatDate(doc.created_at)}</span>
              {doc.error_message && (
                <>
                    <span className="label" style={{color: 'red'}}>Error:</span>
                    <span className="value" style={{color: 'red', whiteSpace: 'normal'}}>{doc.error_message}</span>
                </>
              )}
            </MobileDetails>
            <MobileActions>
                {renderActions(doc)}
            </MobileActions>
          </MobileCard>
        ))}
      </MobileList>
    </ListContainer>
  );
}// src/components/ErrorBoundary.tsx
'use client';

import React, { Component, ErrorInfo } from 'react';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    void error;
    return { hasError: true };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return this.props.fallback || <h1>Sorry.. there was an error</h1>;
    }

    return this.props.children;
  }
}// src/lib/scraping/content-extractor.ts
import { JSDOM } from 'jsdom';
import { Readability } from '@mozilla/readability';
import fetch from 'node-fetch'; // Using node-fetch for server-side consistency

interface ExtractedWebPageContent {
  title: string;
  textContent: string;
  excerpt?: string;
  url: string;
  error?: string; // To capture any errors during fetching or parsing
}

// Function to fetch and parse robots.txt
async function isUrlScrapingAllowed(targetUrl: string, userAgent: string = 'SkolrBot/1.0'): Promise<boolean> {
  try {
    const urlObj = new URL(targetUrl);
    const robotsUrl = `${urlObj.protocol}//${urlObj.hostname}/robots.txt`;
    console.log(`[ContentExtractor] Fetching robots.txt from: ${robotsUrl}`);

    const response = await fetch(robotsUrl, {
      headers: { 'User-Agent': userAgent },
    });

    if (!response.ok) {
      console.log(`[ContentExtractor] robots.txt not found or non-200 status (${response.status}) for ${urlObj.hostname}. Assuming allowed.`);
      return true; // If robots.txt is missing or inaccessible, often implies scraping is allowed
    }

    const robotsTxt = await response.text();
    const lines = robotsTxt.split('\n');
    let specificAgentRules = false;
    let generalAgentRules = false;
    let relevantRules: string[] = [];

    // Check for rules specific to our user agent
    for (const line of lines) {
      if (line.toLowerCase().startsWith(`user-agent: ${userAgent.toLowerCase()}`)) {
        specificAgentRules = true;
        relevantRules = []; // Start collecting rules for this agent
        continue;
      }
      if (line.toLowerCase().startsWith('user-agent: *')) {
        generalAgentRules = true;
        if (!specificAgentRules) relevantRules = []; // Start collecting rules for general agent if no specific ones yet
        continue;
      }
      if (specificAgentRules && line.toLowerCase().startsWith('disallow:')) {
        relevantRules.push(line.substring('disallow:'.length).trim());
      } else if (generalAgentRules && !specificAgentRules && line.toLowerCase().startsWith('disallow:')) {
        relevantRules.push(line.substring('disallow:'.length).trim());
      }
    }
    
    // If User-agent: * is present but no User-agent: SkolrBot/1.0, then User-agent: * rules apply.
    // If both are present, User-agent: SkolrBot/1.0 rules take precedence.

    const path = urlObj.pathname || '/';
    for (const rule of relevantRules) {
      if (rule === '/') { // Disallows everything
          if (path.startsWith(rule)) {
            console.log(`[ContentExtractor] Scraping disallowed by rule: Disallow: ${rule} for path: ${path}`);
            return false;
          }
      } else if (rule && path.startsWith(rule)) {
        console.log(`[ContentExtractor] Scraping disallowed by rule: Disallow: ${rule} for path: ${path}`);
        return false;
      }
    }
    console.log(`[ContentExtractor] Scraping allowed for ${targetUrl} based on robots.txt rules.`);
    return true;
  } catch (error) {
    console.error(`[ContentExtractor] Error fetching or parsing robots.txt for ${targetUrl}:`, error);
    return true; // Fail open: if robots.txt can't be processed, assume allowed but log error
  }
}


export async function extractContentFromUrl(url: string): Promise<ExtractedWebPageContent> {
  console.log(`[ContentExtractor] Attempting to extract content from URL: ${url}`);
  try {
    // 1. Check robots.txt
    const allowed = await isUrlScrapingAllowed(url);
    if (!allowed) {
      const errorMessage = `Scraping disallowed by robots.txt for ${url}`;
      console.warn(`[ContentExtractor] ${errorMessage}`);
      return {
        title: url,
        textContent: '',
        url: url,
        error: errorMessage,
      };
    }

    // 2. Fetch the webpage with timeout using AbortController
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 15000); // 15-second timeout

    let response;
    try {
      response = await fetch(url, {
        headers: {
          'User-Agent': 'SkolrBot/1.0 (+https://skolr.com/bot)', // Be a good bot citizen
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
        },
        signal: controller.signal,
      });
    } finally {
      clearTimeout(timeoutId);
    }

    if (!response.ok) {
      const errorMessage = `Failed to fetch URL: ${url}. Status: ${response.status} ${response.statusText}`;
      console.error(`[ContentExtractor] ${errorMessage}`);
      return { title: url, textContent: '', url, error: errorMessage };
    }

    const html = await response.text();
    console.log(`[ContentExtractor] Successfully fetched HTML for ${url}. Length: ${html.length}`);

    // 3. Parse HTML with JSDOM
    const dom = new JSDOM(html, { url }); // Providing the URL helps Readability resolve relative links if needed
    const document = dom.window.document;

    // 4. Use Readability to extract main content
    const reader = new Readability(document);
    const article = reader.parse();

    if (!article || !article.textContent) {
      console.warn(`[ContentExtractor] Readability could not parse main content for ${url}. Falling back to body.textContent.`);
      // Fallback: try to get all text content if Readability fails
      const bodyText = document.body?.textContent?.replace(/\s\s+/g, ' ').trim() || '';
      const titleFromTag = document.title || url;
      if (!bodyText) {
        const errorMessage = `Failed to extract any meaningful text content from ${url}.`;
        console.error(`[ContentExtractor] ${errorMessage}`);
        return { title: titleFromTag, textContent: '', url, error: errorMessage };
      }
      console.log(`[ContentExtractor] Using fallback text content for ${url}. Length: ${bodyText.length}`);
      return {
        title: titleFromTag,
        textContent: bodyText,
        url: url,
      };
    }

    console.log(`[ContentExtractor] Successfully extracted content using Readability for ${url}. Title: ${article.title}`);
    return {
      title: article.title || url, // Use URL as fallback title
      textContent: article.textContent.replace(/\s\s+/g, ' ').trim(), // Clean up whitespace
      excerpt: article.excerpt ?? undefined,
      url: url,
    };

  } catch (error) {
    const errorMessage = `Error processing URL ${url}: ${error instanceof Error ? error.message : String(error)}`;
    console.error(`[ContentExtractor] ${errorMessage}`, error);
    return {
      title: url,
      textContent: '',
      url: url,
      error: errorMessage,
    };
  }
}// src/lib/openrouter/client.ts
import type { ChatMessage } from '@/types/database.types';

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

export interface OpenRouterConfig {
  model: string;
  temperature?: number;
  maxTokens?: number;
}

export interface OpenRouterResponse {
  choices: {
    message: {
      content: string;
    };
  }[];
  usage?: {
    total_tokens: number;
  };
}

export async function sendChatCompletion(
  messages: ChatMessage[],
  config: OpenRouterConfig
): Promise<OpenRouterResponse> {
  const response = await fetch(OPENROUTER_API_URL, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
      'Content-Type': 'application/json',
      'HTTP-Referer': process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
      'X-Title': 'ClassBots AI',
    },
    body: JSON.stringify({
      model: config.model,
      messages: messages.map(msg => ({
        role: msg.role,
        content: msg.content,
      })),
      temperature: config.temperature || 0.7,
      max_tokens: config.maxTokens || 1000,
    }),
  });

  if (!response.ok) {
    const errorData = await response.json();
    console.error('OpenRouter error details:', errorData);
    throw new Error(`OpenRouter API error: ${errorData.error?.message || response.statusText}`);
  }

  return response.json();
}// src/lib/utils/room-codes.ts
const CHARACTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
const CODE_LENGTH = 6;

export function generateRoomCode(): string {
  let code = '';
  for (let i = 0; i < CODE_LENGTH; i++) {
    const randomIndex = Math.floor(Math.random() * CHARACTERS.length);
    code += CHARACTERS[randomIndex];
  }
  return code;
}

export function isValidRoomCode(code: string): boolean {
  if (code.length !== CODE_LENGTH) {
    return false;
  }
  
  const regex = new RegExp(`^[${CHARACTERS}]{${CODE_LENGTH}}$`);
  return regex.test(code);
}// src/lib/utils/constants.ts

// App Constants
export const APP_NAME = 'Skolr'; // CHANGED
export const APP_DESCRIPTION = 'Chat Smarter. Learn Faster.'; // UPDATED

// Route Constants
export const ROUTES = {
  HOME: '/',
  AUTH: '/auth',
  TEACHER_DASHBOARD: '/teacher-dashboard',
  STUDENT: '/student', // This now redirects to /student/dashboard
  STUDENT_DASHBOARD: '/student/dashboard', // Explicitly add if needed
  CHAT: (roomId: string) => `/chat/${roomId}`,
  API: {
    TEACHER: {
      CHATBOTS: '/api/teacher/chatbots',
      ROOMS: '/api/teacher/rooms',
      // Add new API routes as they are created
      ROOM_CHATBOT_ASSOCIATIONS: '/api/teacher/room-chatbots-associations',
      ROOM_DETAILS: '/api/teacher/room-details',
      STUDENT_ROOM_DETAILS: '/api/teacher/student-room-details',
    },
    STUDENT: {
      ROOMS: '/api/student/rooms', // Might be deprecated if dashboard API covers it
      JOIN_ROOM: '/api/student/join-room',
      DASHBOARD_DATA: '/api/student/dashboard-data',
      ASSESSMENT_DETAIL: (assessmentId: string) => `/api/student/assessment-detail?assessmentId=${assessmentId}`,
      // ASSESSMENT_REFLECTION: (assessmentId: string) => `/api/student/assessments/${assessmentId}/reflect`, // Kept commented out
    },
    CHAT: (roomId: string) => `/api/chat/${roomId}`,
  },
} as const;

// Default Chatbot Config
export const DEFAULT_CHATBOT_CONFIG = {
  model: 'openai/gpt-4.1-nano', 
  maxTokens: 1500,
  temperature: 0.7,
} as const;

// Message Roles
export const MESSAGE_ROLES = {
  USER: 'user',
  ASSISTANT: 'assistant',
  SYSTEM: 'system',
} as const;

// User Roles
export const USER_ROLES = {
  TEACHER: 'teacher',
  STUDENT: 'student',
} as const;

// Local Storage Keys
export const STORAGE_KEYS = {
  THEME: 'classbots-theme', // Consider changing to 'skolr-theme'
  LAST_ROOM: 'classbots-last-room', // Consider changing
} as const;// src/lib/document-processing/extractor.ts
import * as pdfParse from 'pdf-parse/lib/pdf-parse.js';
import mammoth from 'mammoth';
import { DocumentType } from '@/types/knowledge-base.types';

/**
 * Extract text from different document types
 */
export async function extractTextFromFile(
  fileBuffer: Buffer,
  fileType: DocumentType
): Promise<string> {
  try {
    switch (fileType) {
      case 'pdf':
        return extractFromPdf(fileBuffer);
      case 'docx':
        return extractFromDocx(fileBuffer);
      case 'txt':
        return extractFromTxt(fileBuffer);
      default:
        throw new Error(`Unsupported file type: ${fileType}`);
    }
  } catch (error) {
    console.error(`Error extracting text from ${fileType} file:`, error);
    throw new Error(`Failed to extract text from ${fileType} file: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF files
 */
async function extractFromPdf(fileBuffer: Buffer): Promise<string> {
  try {
    // Use a minimal options object to avoid looking for test files
    const options = {
      // No version testing, no page rendering
      max: 0,
      pagerender: null
    };
    
    const data = await pdfParse(fileBuffer, options);
    return data.text;
  } catch (error) {
    console.error('Error extracting text from PDF:', error);
    throw error;
  }
}

/**
 * Extract text from DOCX files
 */
async function extractFromDocx(fileBuffer: Buffer): Promise<string> {
  try {
    const result = await mammoth.extractRawText({ buffer: fileBuffer });
    return result.value;
  } catch (error) {
    console.error('Error extracting text from DOCX:', error);
    throw error;
  }
}

/**
 * Extract text from TXT files
 */
function extractFromTxt(fileBuffer: Buffer): Promise<string> {
  return Promise.resolve(fileBuffer.toString('utf-8'));
}// src/lib/document-processing/processor.ts
import { extractTextFromFile } from './extractor';
import { splitTextIntoChunks, estimateTokenCount } from './chunker';
import { generateEmbeddings } from '@/lib/openai/embeddings';
import { upsertVectors } from '@/lib/pinecone/utils';
import { createServerSupabaseClient } from '@/lib/supabase/server';
import { Document, DocumentChunk, DocumentStatus, DocumentType } from '@/types/knowledge-base.types'; // MODIFIED: Added DocumentType
import { extractContentFromUrl } from '@/lib/scraping/content-extractor'; // MODIFIED: Import new utility

// Mock embedding function for fallback - using 1536 dimensions for OpenAI
function createMockEmbedding(): number[] {
  // Create a random vector - 1536 dimensions for OpenAI compatibility
  return Array(1536).fill(0).map(() => (Math.random() * 2) - 1);
}

/**
 * Process a document by extracting text, chunking, and generating embeddings
 */
export async function processDocument(document: Document): Promise<void> {
  console.log(`[PROCESSOR] Starting document processing for doc ID: ${document.document_id}, name: ${document.file_name}, type: ${document.file_type}`);
  const supabase = await createServerSupabaseClient();

  try {
    // Update document status to processing
    await supabase
      .from('documents')
      .update({ status: 'processing' as DocumentStatus, updated_at: new Date().toISOString() })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Status set to processing.`);

    let extractedText: string;

    // MODIFIED: Handle text extraction based on document type
    if (document.file_type === 'webpage') {
      console.log(`[PROCESSOR ${document.document_id}] Extracting content from URL: ${document.file_path}`);
      const webContent = await extractContentFromUrl(document.file_path); // file_path holds the URL
      if (webContent.error || !webContent.textContent) {
        throw new Error(`Failed to extract content from URL ${document.file_path}: ${webContent.error || 'No text content found'}`);
      }
      extractedText = webContent.textContent;
      console.log(`[PROCESSOR ${document.document_id}] Extracted ${extractedText.length} characters from URL.`);
      // Optionally, update document_size if it wasn't set correctly at creation
      if (document.file_size !== extractedText.length) {
        await supabase.from('documents').update({ file_size: extractedText.length }).eq('document_id', document.document_id);
      }
    } else {
      // Existing logic for file-based documents
      console.log(`[PROCESSOR ${document.document_id}] Downloading file from storage: ${document.file_path}`);
      const { data: fileData, error: fileError } = await supabase
        .storage
        .from('documents')
        .download(document.file_path);

      if (fileError || !fileData) {
        throw new Error(`Failed to download file ${document.file_path}: ${fileError?.message}`);
      }
      console.log(`[PROCESSOR ${document.document_id}] File downloaded successfully.`);

      console.log(`[PROCESSOR ${document.document_id}] Extracting text from file type: ${document.file_type}`);
      // We know document.file_type cannot be 'webpage' here, so direct cast is safer
      extractedText = await extractTextFromFile(
        Buffer.from(await fileData.arrayBuffer()),
        document.file_type as Exclude<DocumentType, 'webpage'> 
      );
      console.log(`[PROCESSOR ${document.document_id}] Extracted ${extractedText.length} characters from file.`);
    }

    // Split text into chunks
    console.log(`[PROCESSOR ${document.document_id}] Splitting text into chunks.`);
    const chunks = splitTextIntoChunks(extractedText);
    console.log(`[PROCESSOR ${document.document_id}] Created ${chunks.length} chunks.`);

    if (chunks.length === 0) {
        console.warn(`[PROCESSOR ${document.document_id}] No chunks generated. Document might be empty or too small.`);
        await supabase
          .from('documents')
          .update({ status: 'completed' as DocumentStatus, error_message: 'No content to process.', updated_at: new Date().toISOString() })
          .eq('document_id', document.document_id);
        return;
    }

    // Create chunk records in database
    console.log(`[PROCESSOR ${document.document_id}] Creating database records for chunks.`);
    const chunkRecords: Partial<DocumentChunk>[] = chunks.map((chunkText, index) => ({
      document_id: document.document_id,
      chunk_index: index,
      chunk_text: chunkText,
      token_count: estimateTokenCount(chunkText),
      status: 'pending'
    }));

    const { data: insertedChunks, error: chunksError } = await supabase
      .from('document_chunks')
      .insert(chunkRecords)
      .select();

    if (chunksError) {
      throw new Error(`Failed to insert chunks: ${chunksError.message}`);
    }
    if (!insertedChunks || insertedChunks.length === 0) {
        throw new Error("No chunks were inserted into the database, though chunks were generated.");
    }
    console.log(`[PROCESSOR ${document.document_id}] Inserted ${insertedChunks.length} chunk records.`);

    // SAFER APPROACH: Process chunks in smaller batches for OpenAI embeddings
    const openAIbatchSize = 20;
    let usingMockEmbeddings = false;
    let embeddings: number[][] = [];

    console.log(`[PROCESSOR ${document.document_id}] Generating embeddings in batches of ${openAIbatchSize}.`);
    for (let i = 0; i < chunks.length; i += openAIbatchSize) {
      const batchChunksText = chunks.slice(i, i + openAIbatchSize);
      console.log(`[PROCESSOR ${document.document_id}] Processing OpenAI batch ${Math.floor(i/openAIbatchSize) + 1}/${Math.ceil(chunks.length/openAIbatchSize)} (${batchChunksText.length} chunks)`);

      try {
        const batchEmbeddings = await generateEmbeddings(batchChunksText);
        embeddings = [...embeddings, ...batchEmbeddings];
      } catch (embedError) {
        console.error(`[PROCESSOR ${document.document_id}] Error generating embeddings for batch, falling back to mock:`, embedError);
        usingMockEmbeddings = true;
        const mockBatchEmbeddings = batchChunksText.map(() => createMockEmbedding());
        embeddings = [...embeddings, ...mockBatchEmbeddings];

        await supabase
          .from('documents')
          .update({
            error_message: `Warning: Using mock embeddings for some chunks. OpenAI API error: ${embedError instanceof Error ? embedError.message : String(embedError)}`
          })
          .eq('document_id', document.document_id);
      }
      if (chunks.length > openAIbatchSize) {
        // Avoid hitting rate limits too quickly if there are many batches
        await new Promise(resolve => setTimeout(resolve, 500)); 
      }
    }
    console.log(`[PROCESSOR ${document.document_id}] Generated ${embeddings.length} embeddings. ${usingMockEmbeddings ? '(Used MOCK embeddings for some)' : '(Used REAL embeddings)'}`);

    // Build vectors array
    const preparedVectors = [];
    for (let i = 0; i < embeddings.length; i++) {
      const chunkId = insertedChunks[i]?.chunk_id;
      if (!chunkId) {
        console.error(`[PROCESSOR ${document.document_id}] Mismatch: No chunk_id for embedding at index ${i}. Skipping this vector.`);
        continue;
      }
      
      preparedVectors.push({
        id: chunkId,
        values: embeddings[i],
        metadata: {
          chatbotId: document.chatbot_id,
          documentId: document.document_id,
          chunkId: chunkId,
          text: chunks[i], // The actual chunk text
          fileName: document.file_name, // For webpages, this is the title or URL
          fileType: document.file_type, // Will be 'webpage' for URLs
          isMockEmbedding: usingMockEmbeddings ? "true" : "false"
        }
      });
    }

    if (preparedVectors.length === 0 && chunks.length > 0) {
        console.error(`[PROCESSOR ${document.document_id}] No vectors prepared for Pinecone, though chunks exist. This indicates an issue with chunk_id mapping.`);
        throw new Error("Failed to prepare vectors for Pinecone due to chunk ID mismatch.");
    }
    console.log(`[PROCESSOR ${document.document_id}] Prepared ${preparedVectors.length} vectors for Pinecone.`);

    let vectorsUpsertedSuccessfully = false;
    if (preparedVectors.length > 0) { // MODIFIED: Only upsert if there are vectors
        try {
          console.log(`[PROCESSOR ${document.document_id}] Upserting ${preparedVectors.length} vectors to Pinecone via SDK.`);
          await upsertVectors(preparedVectors);
          vectorsUpsertedSuccessfully = true;
          console.log(`[PROCESSOR ${document.document_id}] Successfully upserted vectors to Pinecone.`);
        } catch (pineconeError) {
            console.error(`[PROCESSOR ${document.document_id}] Error upserting vectors to Pinecone:`, pineconeError);
        }
    } else {
        console.log(`[PROCESSOR ${document.document_id}] No vectors to upsert to Pinecone.`);
        // If there were chunks but no vectors prepared, it's an error handled above.
        // If there were no chunks initially, this part is skipped.
        // If RAG is based on chunks, and no chunks, then "completed" is okay if no other error.
        if (chunks.length === 0) vectorsUpsertedSuccessfully = true; 
    }


    console.log(`[PROCESSOR ${document.document_id}] Updating chunk statuses in DB.`);
    for (const insertedChunk of insertedChunks) { // This loop will only run if chunks were inserted
        const vectorAttempted = preparedVectors.find(v => v.id === insertedChunk.chunk_id);
        const chunkStatus = vectorsUpsertedSuccessfully && vectorAttempted ? 'embedded' : 'error';
        
        await supabase
            .from('document_chunks')
            .update({
                status: chunkStatus,
                embedding_id: (chunkStatus === 'embedded' && vectorAttempted) ? insertedChunk.chunk_id : null // Set embedding_id only if successfully embedded
            })
            .eq('chunk_id', insertedChunk.chunk_id);
    }
    console.log(`[PROCESSOR ${document.document_id}] Chunk statuses updated.`);

    // Determine final document status
    const finalDocStatus = vectorsUpsertedSuccessfully ? 'completed' : 'error';
    let finalErrorMessage = vectorsUpsertedSuccessfully ? null : 'Failed to upsert vectors to Pinecone.';
    if (usingMockEmbeddings && vectorsUpsertedSuccessfully) { // If mock embeddings were used but upsert was "successful"
        finalErrorMessage = (finalErrorMessage ? finalErrorMessage + " " : "") + "Warning: Some or all embeddings are MOCK data.";
    }
    if (chunks.length === 0 && !document.error_message) { // If no chunks and no prior error, consider it completed (nothing to process)
         // Status already set to completed above for this case. Message already set.
    }


    await supabase
      .from('documents')
      .update({
        status: finalDocStatus as DocumentStatus,
        error_message: finalErrorMessage, // This might overwrite "No content to process." if an error occurs later.
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document final status set to ${finalDocStatus}. Processing finished.`);

  } catch (error) {
    console.error(`[PROCESSOR ${document.document_id}] Critical error during processing:`, error);
    await supabase
      .from('documents')
      .update({
        status: 'error' as DocumentStatus,
        error_message: error instanceof Error ? error.message : 'Unknown critical error during processing',
        updated_at: new Date().toISOString()
      })
      .eq('document_id', document.document_id);
    console.log(`[PROCESSOR ${document.document_id}] Document status updated to ERROR due to critical failure.`);
  }
}// src/lib/document-processing/chunker.ts

/**
 * Split text into chunks of approximately the specified size with overlap
 * @param text The full text to split
 * @param maxChunkSize Maximum size of each chunk in characters
 * @param overlap Number of characters to overlap between chunks
 * @returns Array of text chunks
 */
export function splitTextIntoChunks(
  text: string,
  maxChunkSize: number = 1000,
  overlap: number = 200
): string[] {
  // Validate parameters
  if (maxChunkSize <= 0) {
    console.error("[CHUNKER] maxChunkSize must be positive. Using default 1000.");
    maxChunkSize = 1000;
  }
  if (overlap < 0) {
    console.error("[CHUNKER] overlap cannot be negative. Using default 0.");
    overlap = 0;
  }
  // Ensure overlap is less than maxChunkSize to guarantee progress
  if (overlap >= maxChunkSize) {
    console.warn(`[CHUNKER] Overlap (${overlap}) is greater than or equal to maxChunkSize (${maxChunkSize}). Adjusting overlap to ensure progress.`);
    overlap = Math.max(0, Math.floor(maxChunkSize / 2) -1); // Ensure it's strictly less
  }

  const cleanedText = text
    .replace(/\s+/g, " ") // Normalize whitespace
    .replace(/\n{2,}/g, "\n") // Reduce multiple newlines to single (or adjust if double is preferred)
    .trim();

  if (cleanedText.length === 0) {
    return [];
  }

  if (cleanedText.length <= maxChunkSize) {
    return [cleanedText];
  }

  const chunks: string[] = [];
  let startIndex = 0;
  let safetyBreak = 0; // To prevent accidental infinite loops during development
  const maxIterations = Math.ceil(cleanedText.length / (maxChunkSize - overlap)) + 10; // Generous estimate

  while (startIndex < cleanedText.length && safetyBreak < maxIterations) {
    safetyBreak++;
    let endIndex = Math.min(startIndex + maxChunkSize, cleanedText.length);

    // If not at the end, try to find a better breakpoint
    if (endIndex < cleanedText.length) {
      let idealEnd = endIndex;
      // Try to break at a paragraph end (double newline, now single due to cleaning)
      // Search backwards from idealEnd, but not too far back (e.g., within last 30% of chunk)
      const searchStartPara = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.3));
      const paragraphBreak = cleanedText.lastIndexOf("\n", idealEnd);
      if (paragraphBreak > searchStartPara && paragraphBreak > startIndex) {
        idealEnd = paragraphBreak + 1; // Include the newline
      } else {
        // Try to break at a sentence end (period followed by space)
        // Search backwards from idealEnd
        const searchStartSentence = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.2));
        const sentenceBreak = cleanedText.lastIndexOf(". ", idealEnd);
        if (sentenceBreak > searchStartSentence && sentenceBreak > startIndex) {
          idealEnd = sentenceBreak + 1; // Include the period
        } else {
          // Try to break at a space
          const searchStartSpace = Math.max(startIndex, idealEnd - Math.floor(maxChunkSize * 0.1));
          const spaceBreak = cleanedText.lastIndexOf(" ", idealEnd);
          if (spaceBreak > searchStartSpace && spaceBreak > startIndex) {
            idealEnd = spaceBreak + 1; // Include the space
          }
          // If no good break found, stick with Math.min(startIndex + maxChunkSize, cleanedText.length)
        }
      }
      endIndex = idealEnd;
    }

    const chunk = cleanedText.substring(startIndex, endIndex).trim();
    if (chunk.length > 0) { // Only push non-empty chunks
      chunks.push(chunk);
    }

    // Calculate the next starting point
    // Ensure startIndex always moves forward by at least (maxChunkSize - overlap)
    // unless it's the last chunk
    const nextStart = endIndex - overlap;

    // If nextStart isn't advancing past the current startIndex, it means chunks are too small or overlap is too big
    // This check ensures progress. If endIndex is already at the end, this loop will terminate.
    if (nextStart <= startIndex && endIndex < cleanedText.length) {
        // Force advancement if stuck, this could happen if maxChunkSize is very small or overlap is almost maxChunkSize
        // Or if the breakpoint logic consistently brings endIndex back too far.
        // A simple forced advancement might be to just move past the current chunk with minimal overlap.
        console.warn(`[CHUNKER] Potential stall detected. Forcing startIndex advancement. startIndex: ${startIndex}, endIndex: ${endIndex}, overlap: ${overlap}, nextStart: ${nextStart}`);
        startIndex = endIndex; // Effectively makes next chunk start where this one ended (no overlap if stalled)
                              // Or, for a more robust solution with overlap:
                              // startIndex = Math.max(startIndex + 1, endIndex - overlap);
    } else {
        startIndex = nextStart;
    }

    if (startIndex < 0) startIndex = 0; // Should not happen with validated overlap
  }

  if (safetyBreak >= maxIterations) {
    console.error("[CHUNKER] Safety break triggered, possible infinite loop. Returning collected chunks.", chunks.length);
  }

  // Filter out any potential empty strings again, just in case
  return chunks.filter(c => c.length > 0);
}

/**
 * Simple estimate of token count based on character count
 * @param text The text to estimate tokens for
 * @returns Estimated token count
 */
export function estimateTokenCount(text: string): number {
  // Rough estimate: ~4 characters per token for English text
  return Math.ceil(text.length / 4);
}// src/lib/supabase/middleware.ts
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export async function updateSession(request: NextRequest) {
  const response = NextResponse.next(); // Changed from let to const

  const supabase = createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return request.cookies.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value,
            ...options, // Use the full options object
          });
        },
        remove(name: string, options: CookieOptions) {
          response.cookies.set({
            name,
            value: '',
            ...options, // Use the full options object
            maxAge: 0,
          });
        },
      },
    }
  );

  await supabase.auth.getUser();

  return response;
}// src/lib/supabase/admin.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@/types/database.types';

export const createAdminClient = () => {
  // Log the environment variables to verify they exist (redact part of the key for security)
  const serviceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY || '';
  console.log('Admin client initialization:');
  console.log(`- URL: ${process.env.NEXT_PUBLIC_SUPABASE_URL}`);
  console.log(`- Service key exists: ${serviceRoleKey.length > 0 ? 'YES' : 'NO'}`);
  
  return createClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      auth: {
        persistSession: false,
        autoRefreshToken: false,
      },
      // These headers ensure the service role bypasses RLS
      global: {
        headers: {
          'X-Client-Info': 'admin-supabase-js',
          'Authorization': `Bearer ${process.env.SUPABASE_SERVICE_ROLE_KEY}`
        }
      }
    }
  );
};// src/lib/supabase/client.ts
import { createBrowserClient } from '@supabase/ssr';
import type { Database } from '@/types/database.types';

export const createClient = () =>
  createBrowserClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );// src/lib/supabase/server.ts
import { createServerClient } from '@supabase/ssr';
import { cookies } from 'next/headers';
import type { Database } from '@/types/database.types';
import type { CookieOptions } from '@supabase/ssr';

export const createServerSupabaseClient = async () => {
  const cookieStore = await cookies();

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value;
        },
        set(name: string, value: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value,
            ...options
          });
        },
        remove(name: string, options: CookieOptions) {
          cookieStore.set({
            name,
            value: '',
            ...options,
            maxAge: 0
          });
        },
      },
    }
  );
};// src/lib/safety/monitoring.ts
import type { Room, Database } from '@/types/database.types'; // Removed unused Profile import
import { createAdminClient } from '@/lib/supabase/admin';
import { SupabaseClient } from '@supabase/supabase-js';
import { sendTeacherAlert } from '@/lib/safety/alerts';
// Import the JSON data
import HELPLINE_DATA_JSON from './data/helplines.json'; // Ensure this path is correct and the file exists

// OpenRouter Configuration
const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';
const SAFETY_CHECK_MODEL = 'google/gemini-2.5-flash-preview';
const CONCERN_THRESHOLD = 3;

// Keywords organized by category - FULL LIST AS PROVIDED
const CONCERN_KEYWORDS: Record<string, string[]> = {
  self_harm: [
    'hate myself', 'don\'t want to live', 'don\'t want to be alive', 'don\'t want to be here', 'don\'t want to exist',
    'not worth going on', 'no point in living', 'no point going on', 'rather be dead', 'should end it',
    'should end it all', 'end it all', 'give up', 'giving up', 'take my own life', 'take my life',
    'harming myself', 'harm myself', 'hurting myself', 'cut myself', 'cutting myself', 'disappear forever',
    'everyone better off without me', 'they\'d be better off without me', 'they would be better off without me',
    'leave this world', 'escape this world', 'stop existing', 'tired of being alive', 'tired of existing',
    'too much pain', 'can\'t take it anymore', 'life is too hard', 'life isn\'t worth it', 'never wake up',
    'wish I wouldn\'t wake up', 'make the pain stop', 'no hope left', 'nowhere to turn', 'plan to kill',
    'how to end', 'easier if I wasn\'t here', 'easier if I was gone', 'want to die', 'wanna die',
    'kill myself', 'suicidal'
  ],
  bullying: [
    'bullied', 'bully', 'bullying', 'they hate me', 'everyone hates me', 'laughed at me', 'laugh at me',
    'excluded', 'leave me out', 'leaving me out', 'no friends', 'don\'t have friends', 'nobody likes me',
    'no one likes me', 'call me names', 'called me names', 'push me around', 'pushed me', 'shove me',
    'shoved me', 'making threats', 'threatened me', 'online bullying', 'cyberbullying', 'posting about me',
    'spreading rumors', 'spreading rumours', 'spreading lies', 'everyone talks about me', 'made fun of',
    'mock me', 'mocking me', 'rejected by everyone', 'being isolated', 'no one talks to me',
    'nobody talks to me', 'they ignore me', 'everyone ignores me', 'being targeted', 'pick on me',
    'won\'t leave me alone', 'always after me', 'ganging up on me', 'scared to go to school',
    'don\'t want to go to school', 'afraid at school', 'scared at school'
  ],
  abuse: [
    'hurt me', 'hurting me', 'hitting me', 'hit by', 'kicks me', 'kicking me', 'pushed me', 'pushes me',
    'throws things at me', 'threw things at me', 'threw something at me', 'yells at me', 'yelling at me',
    'screams at me', 'screaming at me', 'threatens me', 'threatening me', 'controls me', 'controlling me',
    'not allowed to', 'won\'t let me', 'keeps me from', 'locked me in', 'locks me in', 'touches me',
    'touched me', 'uncomfortable touching', 'hurt by someone', 'afraid of them', 'afraid to go home',
    'scared to go home', 'not safe at home', 'don\'t feel safe around', 'being punished',
    'punishes me unfairly', 'treated badly', 'treats me badly', 'calls me stupid', 'calls me worthless',
    'makes me feel worthless', 'makes me feel bad', 'punched me', 'punches me', 'slapped me', 'slaps me',
    'bruises from', 'left bruises', 'threatened to hurt me if I told', 'can\'t tell anyone'
  ],
  depression: [
    'hate my life', 'no one cares', 'nobody cares', 'nobody loves me', 'no one loves me', 'feel empty',
    'feeling empty', 'feel nothing', 'feels like nothing matters', 'nothing matters', 'what\'s the point',
    'feel worthless', 'feeling worthless', 'don\'t feel anything', 'don\'t know what to do',
    'can\'t see a future', 'lost all hope', 'lost hope', 'given up', 'feel like a failure', 'am a failure',
    'everything is dark', 'darkness closing in', 'can\'t get out of bed', 'can\'t face the day',
    'crying all the time', 'crying myself to sleep', 'never happy', 'always feeling down', 'feel so alone',
    'completely alone', 'no one understands', 'nobody understands', 'don\'t enjoy anything',
    'nothing makes me happy', 'too sad to function', 'too sad to do anything', 'life is meaningless',
    'unable to feel joy', 'can\'t sleep', 'can\'t eat', 'can\'t concentrate', 'mind feels foggy',
    'exhausted all the time', 'overwhelmed by sadness', 'drowning in sadness'
  ],
  family_issues: [
    'parents always fighting', 'parents always argue', 'parents hate each other', 'home is not safe',
    'scared at home', 'afraid at home', 'can\'t stand being home', 'hate being home', 'nowhere to go',
    'might get kicked out', 'might be kicked out', 'threatened to kick me out', 'parent drinking',
    'parent drunk', 'parents drunk', 'drinking problem', 'drug problem', 'parents using drugs',
    'parent using drugs', 'not enough food', 'going hungry', 'no food at home', 'can\'t sleep at home',
    'parents separated', 'parents separating', 'parents broke up', 'parents splitting up',
    'losing our house', 'lost our house', 'might be homeless', 'could be homeless',
    'moving in with relatives', 'have to move', 'parent lost job', 'no money for', 'can\'t afford',
    'parent in jail', 'parent arrested', 'no one takes care of me', 'have to take care of myself',
    'have to take care of my siblings', 'parent is sick', 'parent is ill', 'parent in hospital',
    'no electricity', 'utilities shut off', 'water shut off'
  ],
};

// Type for the imported JSON data
type HelplineEntry = { name: string; phone?: string; website?: string; text_to?: string; text_msg?: string; short_desc: string };
type HelplineData = Record<string, HelplineEntry[]>;
const ALL_HELPLINES: HelplineData = HELPLINE_DATA_JSON as HelplineData;

export function initialConcernCheck(message: string): {
  hasConcern: boolean;
  concernType?: string;
} {
  if (!message || typeof message !== 'string' || message.trim() === '') {
    return { hasConcern: false };
  }
  const lowerMessage = message.toLowerCase();
  for (const [category, keywords] of Object.entries(CONCERN_KEYWORDS)) {
    for (const keyword of keywords) {
        const escapedKeyword = keyword.toLowerCase().replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        const regex = new RegExp(`\\b${escapedKeyword}\\b`);
        if (regex.test(lowerMessage)) {
            console.log(`[InitialCheck] Keyword MATCH! Category: ${category}, Keyword: "${keyword}"`);
            return { hasConcern: true, concernType: category };
        }
    }
  }
  if (lowerMessage.includes('hate myself') && (lowerMessage.includes('not worth') || lowerMessage.includes('don\'t know what to do'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  if ((lowerMessage.includes('not worth') || lowerMessage.includes('no point')) && (lowerMessage.includes('going on') || lowerMessage.includes('living') || lowerMessage.includes('anymore'))) {
    return { hasConcern: true, concernType: 'self_harm' };
  }
  return { hasConcern: false };
}

export async function verifyConcern(
  message: string,
  concernType: string,
  recentMessages: Array<{ role: 'user' | 'assistant' | 'system'; content: string }> = [],
  countryCode: string | null
): Promise<{
  isRealConcern: boolean;
  concernLevel: number;
  analysisExplanation: string;
  aiGeneratedAdvice?: string;
}> {
  // --- START OF ADDED CONSOLE LOGS FOR DEBUGGING ---
  console.log(`[VerifyConcern DEBUG] Function called. Received countryCode: "${countryCode}" (Type: ${typeof countryCode})`);
  // --- END OF ADDED CONSOLE LOGS FOR DEBUGGING ---

  let contextString = '';
  if (recentMessages.length > 0) {
    contextString = "\n\nRecent Conversation History (most recent last):\n";
    recentMessages.slice(-3).forEach(msg => {
      const roleLabel = msg.role === 'user' ? 'Student' : (msg.role === 'assistant' ? 'Assistant' : 'System');
      contextString += `${roleLabel}: ${msg.content}\n`;
    });
  }

  const effectiveCountryCode = countryCode?.toUpperCase() || 'DEFAULT';
  // --- ADDED CONSOLE LOG ---
  console.log(`[VerifyConcern DEBUG] Effective country code for helpline lookup: "${effectiveCountryCode}"`);

  const countrySpecificHelplines: HelplineEntry[] = ALL_HELPLINES[effectiveCountryCode] || ALL_HELPLINES.DEFAULT;
  // --- ADDED CONSOLE LOG ---
  console.log(`[VerifyConcern DEBUG] Selected countrySpecificHelplines for "${effectiveCountryCode}" (first 3 entries):`, JSON.stringify(countrySpecificHelplines.slice(0,3), null, 2));


  let conciseHelplineDataForPrompt = "";
  const helplinesToList = countrySpecificHelplines.slice(0, 2); 

  if (helplinesToList.length > 0) {
    conciseHelplineDataForPrompt = "Relevant Support Contacts (use ONLY these for the student's country):\n";
    helplinesToList.forEach(line => {
      conciseHelplineDataForPrompt += `* ${line.name}`;
      if (line.phone) {
        conciseHelplineDataForPrompt += ` - Phone: ${line.phone}`;
      } else if (line.text_to && line.text_msg) {
        conciseHelplineDataForPrompt += ` - Text: ${line.text_msg} to ${line.text_to}`;
      } else if (line.website) {
        const shortWebsite = line.website.length > 20 ? line.website.substring(0, 17) + "..." : line.website;
        conciseHelplineDataForPrompt += ` - Website: ${shortWebsite}`;
      }
      conciseHelplineDataForPrompt += "\n";
    });
  } else { 
       conciseHelplineDataForPrompt = "Please reach out to a trusted adult or local emergency services if you need help or are in danger.\n";
  }
  
  // --- ADDED CONSOLE LOG ---
  console.log(`[VerifyConcern DEBUG] conciseHelplineDataForPrompt string for LLM:\n${conciseHelplineDataForPrompt}`);

  const teacherAwarenessMandatorySentence = "Remember, your teacher can see this conversation and is here to support you. Please feel comfortable reaching out to them or another trusted adult if you need help.";

  const promptParts = [
    `You are an AI safety assistant. Your task is to review a student's chat message for a specific concern and provide guidance if necessary.`,
    `Concern Category Identified by Keywords: ${concernType.replace(/_/g, ' ')}`,
    contextString,
    `Student's Message: "${message}"`,
    `\nTasks:`,
    `1.  **Analysis for Teacher (Internal):**`,
    `    a.  **isRealConcern**: (boolean: true/false) Is the concern genuine?`,
    `    b.  **concernLevel**: (number 0-5) If genuine, assess severity.`,
    `    c.  **analysisExplanation**: (string) Briefly explain for the teacher (1-2 sentences).\n`,
    `2.  **Message for Student (aiGeneratedAdvice):**`,
    `    If \`isRealConcern\` is true AND \`concernLevel\` is 2 or higher, compose a **VERY SHORT (max 3-4 sentences total, including helplines), empathetic, and DIRECT message**. This message MUST:`,
    `    a.  Start with a brief, caring acknowledgment (e.g., "I hear that you're going through a tough time," or "It sounds like you're feeling [X]."). This should be one sentence.`,
    `    b.  **Include this exact sentence VERBATIM**: "${teacherAwarenessMandatorySentence}"`,
    `    c.  **Then, you MUST list ONLY the specific support contacts shown between the START and END markers below. Do NOT add any other helplines or general advice beyond this provided list for this section. Present them as a simple list**:`,
    `        ---START OF PROVIDED HELPLINES---`,
    `        ${conciseHelplineDataForPrompt.trim()}`,
    `        ---END OF PROVIDED HELPLINES---`,
    `    d.  End with a very short supportive closing (e.g., "Please reach out." or "Help is available."). This should be one sentence.`,
    `    e.  The entire message must be very succinct and focused. Do not add any extra information not explicitly requested.\n`,
    `Respond ONLY with a valid JSON object with these exact keys:`,
    `"isRealConcern": boolean,`,
    `"concernLevel": number,`,
    `"analysisExplanation": string,`,
    `"aiGeneratedAdvice": string (Omit this key or set to null if conditions in Task 2 are not met, or if you cannot follow the student message constraints exactly.)`
  ];
  const promptForModel = promptParts.join('\n');
  // --- ADDED CONSOLE LOG ---
  console.log(`[VerifyConcern DEBUG] Full promptForModel being sent to LLM (first 700 chars to see helpline injection):\n${promptForModel.substring(0,700)}...`);


  try {
    const response = await fetch(OPENROUTER_API_URL, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': process.env.NEXT_PUBLIC_APP_URL || process.env.OPENROUTER_SITE_URL || 'http://localhost:3000',
          'X-Title': 'ClassBots AI - Safety Verification',
        },
        body: JSON.stringify({
          model: SAFETY_CHECK_MODEL,
          messages: [ { role: "user", content: promptForModel } ],
          temperature: 0.2,
          max_tokens: 300, 
          response_format: { type: "json_object" }
        }),
      });

    if (!response.ok) {
        const errorBody = await response.text();
        console.error(`[VerifyConcern] OpenRouter Error: Status ${response.status}`, errorBody);
        throw new Error(`OpenRouter API error (status ${response.status}) during safety verification.`);
    }

    const responseData = await response.json();
    const rawResponseContent = responseData.choices?.[0]?.message?.content;

    if (!rawResponseContent) {
      throw new Error("OpenRouter response for safety verification was empty or missing content.");
    }
     // --- ADDED CONSOLE LOG ---
    console.log(`[VerifyConcern DEBUG] Raw LLM response content:\n${rawResponseContent}`);


    let analysisResult;
    try {
        const jsonMatch = rawResponseContent.match(/```json\s*([\s\S]*?)\s*```/);
        if (jsonMatch && jsonMatch[1]) {
            analysisResult = JSON.parse(jsonMatch[1]);
        } else {
             const directJsonMatch = rawResponseContent.match(/\{[\s\S]*\}/);
            if (directJsonMatch && directJsonMatch[0]) {
                 analysisResult = JSON.parse(directJsonMatch[0]);
            } else {
                try {
                    analysisResult = JSON.parse(rawResponseContent);
                } catch (innerParseError) {
                    console.error("[VerifyConcern] Final attempt to parse rawResponseContent as JSON failed:", rawResponseContent, innerParseError);
                    throw new Error("No valid JSON found in LLM response for safety verification after multiple attempts.");
                }
            }
        }
    } catch (parseError) {
         console.error("[VerifyConcern] Failed to parse JSON from safety model:", rawResponseContent, parseError);
         let fallbackAdvice = `I understand this might be a difficult time. ${teacherAwarenessMandatorySentence}\n\nPlease consider reaching out to a trusted adult.`;
         const defaultHelplines = ALL_HELPLINES.DEFAULT || [];
         if (defaultHelplines.length > 0) {
             fallbackAdvice += "\nHere are some general resources:\n";
             defaultHelplines.slice(0,2).forEach(line => {
                fallbackAdvice += `* ${line.name}`;
                if (line.phone) fallbackAdvice += `: ${line.phone}`;
                else if (line.text_to && line.text_msg) fallbackAdvice += ` (Text ${line.text_msg} to ${line.text_to})`;
                else if (line.website) fallbackAdvice += ` (${line.website})`;
                fallbackAdvice += `\n`;
             });
         }
         fallbackAdvice += "Help is available.";
         return {
             isRealConcern: true, 
             concernLevel: 3,
             analysisExplanation: `Safety model response was not valid JSON. Raw snippet: ${String(rawResponseContent).substring(0, 150)}... Review manually.`,
             aiGeneratedAdvice: fallbackAdvice
         };
    }

    const isRealConcern = typeof analysisResult.isRealConcern === 'boolean' ? analysisResult.isRealConcern : false;
    const concernLevel = typeof analysisResult.concernLevel === 'number'
      ? Math.max(0, Math.min(5, Math.round(analysisResult.concernLevel)))
      : (isRealConcern ? 3 : 0);
    const analysisExplanation = typeof analysisResult.analysisExplanation === 'string'
      ? analysisResult.analysisExplanation.trim()
      : "AI analysis explanation was not provided or in an invalid format.";
    
    let aiGeneratedAdvice: string | undefined = undefined;
    if (isRealConcern && concernLevel >= 2 && typeof analysisResult.aiGeneratedAdvice === 'string' && analysisResult.aiGeneratedAdvice.trim() !== "") {
        aiGeneratedAdvice = analysisResult.aiGeneratedAdvice.trim();
        if (aiGeneratedAdvice && !aiGeneratedAdvice.includes(teacherAwarenessMandatorySentence)) {
            console.warn("[VerifyConcern] LLM advice generated but missed the mandatory teacher awareness sentence. Prepending it.");
            aiGeneratedAdvice = `${teacherAwarenessMandatorySentence}\n${aiGeneratedAdvice}`;
        }
    } else if (isRealConcern && concernLevel >= 2) {
        console.warn("[VerifyConcern] LLM met conditions for advice but 'aiGeneratedAdvice' field was missing or empty. Constructing concise default advice.");
        let defaultAdvice = `I understand this may be a tough moment. ${teacherAwarenessMandatorySentence}\n\nHere are some resources that might help:\n`;
        const helplinesForDefaultForStudent = countrySpecificHelplines.slice(0, 2); // Use the already filtered list
        if (helplinesForDefaultForStudent.length > 0) {
            helplinesForDefaultForStudent.forEach(line => { 
                defaultAdvice += `* ${line.name}`;
                if (line.phone) defaultAdvice += `: ${line.phone}`;
                else if (line.text_to && line.text_msg) defaultAdvice += ` (Text ${line.text_msg} to ${line.text_to})`;
                else if (line.website) defaultAdvice += ` (${line.website})`;
                defaultAdvice += "\n";
            });
        } else { 
            ALL_HELPLINES.DEFAULT.slice(0,2).forEach(line => { // Fallback to generic default if countrySpecific was empty
                 defaultAdvice += `* ${line.name}`;
                if (line.phone) defaultAdvice += `: ${line.phone}`;
                else if (line.text_to && line.text_msg) defaultAdvice += ` (Text ${line.text_msg} to ${line.text_to})`;
                else if (line.website) defaultAdvice += ` (${line.website})`;
                defaultAdvice += "\n";
            });
        }
        defaultAdvice += "Please reach out for support.";
        aiGeneratedAdvice = defaultAdvice;
    }

    console.log(`[VerifyConcern] LLM Analysis: isReal=${isRealConcern}, level=${concernLevel}, explanation="${analysisExplanation}", adviceProvided=${!!aiGeneratedAdvice}`);
    return { isRealConcern, concernLevel, analysisExplanation, aiGeneratedAdvice };

  } catch (error) {
    console.error('[VerifyConcern] Error during OpenRouter call or processing:', error);
    let defaultFallbackAdvice = `It's important to reach out if you're struggling. ${teacherAwarenessMandatorySentence}\n\nHere are some general resources:\n`;
    const defaultHelplinesOnCatch = ALL_HELPLINES.DEFAULT || [];
    defaultHelplinesOnCatch.slice(0,2).forEach(line => {
        defaultFallbackAdvice += `* ${line.name}`;
        if (line.phone) defaultFallbackAdvice += `: ${line.phone}`;
        else if (line.text_to && line.text_msg) defaultFallbackAdvice += ` (Text ${line.text_msg} to ${line.text_to})`;
        else if (line.website) defaultFallbackAdvice += ` (${line.website})`;
        defaultFallbackAdvice += "\n";
    });
    defaultFallbackAdvice += "Help is available.";
    return {
      isRealConcern: true, 
      concernLevel: 3,
      analysisExplanation: `Concern verification process failed: ${error instanceof Error ? error.message : 'Unknown LLM call error'}. Flagged for manual review.`,
      aiGeneratedAdvice: defaultFallbackAdvice
    };
  }
}

export async function checkMessageSafety(
    supabaseUserContextClient: SupabaseClient<Database>,
    messageContent: string,
    messageId: string,
    studentId: string,
    room: Room,
    countryCode: string | null 
): Promise<void> {
    // Added the debug log here, as requested in the previous step, to see what checkMessageSafety receives
    console.log(`[Safety Check] START - MsgID: ${messageId}, Student: ${studentId}, Room: ${room.room_id}, Teacher: ${room.teacher_id}, Received Country Code by checkMessageSafety: "${countryCode}"`);
    try {
        const adminClient = createAdminClient();
        const { data: currentMessageData, error: fetchMsgError } = await supabaseUserContextClient
            .from('chat_messages')
            .select('created_at, metadata')
            .eq('message_id', messageId)
            .single();

        if (fetchMsgError || !currentMessageData) {
             console.error(`[Safety Check] Failed to fetch current message ${messageId}:`, fetchMsgError);
             return;
        }

        const { hasConcern, concernType } = initialConcernCheck(messageContent);
        console.log(`[Safety Check] Initial Keyword Check: hasConcern=${hasConcern}, concernType=${concernType || 'N/A'}`);

        if (hasConcern && concernType) {
            const chatbotIdForContext = currentMessageData.metadata?.chatbotId || null;
            const { data: contextMessagesData } = await adminClient
                .from('chat_messages')
                .select('role, content')
                .eq('room_id', room.room_id)
                .eq('user_id', studentId)
                .filter('metadata->>chatbotId', chatbotIdForContext ? 'eq' : 'is', chatbotIdForContext)
                .lt('created_at', currentMessageData.created_at)
                .order('created_at', { ascending: false })
                .limit(4);
            const recentMessagesForSafetyLLM = (contextMessagesData || [])
                .map(m => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content || '' }))
                .reverse();
            
            const { isRealConcern, concernLevel, analysisExplanation, aiGeneratedAdvice } = await verifyConcern(
                messageContent,
                concernType,
                recentMessagesForSafetyLLM,
                countryCode 
            );

            if (isRealConcern && concernLevel >= CONCERN_THRESHOLD) {
                const { data: teacherProfile } = await adminClient.from('profiles').select('email').eq('user_id', room.teacher_id).single();
                const { data: studentProfile } = await adminClient.from('profiles').select('full_name').eq('user_id', studentId).single();
                const studentName = studentProfile?.full_name || `Student (ID: ${studentId.substring(0, 6)}...)`;
                const { data: insertedFlag, error: flagInsertError } = await adminClient.from('flagged_messages').insert({
                    message_id: messageId, student_id: studentId, teacher_id: room.teacher_id,
                    room_id: room.room_id, concern_type: concernType, concern_level: concernLevel,
                    analysis_explanation: analysisExplanation, status: 'pending',
                }).select('flag_id').single();

                if (flagInsertError) { console.error(`[Safety Check] FAILED to insert flag:`, flagInsertError.message); return; }
                
                const newFlagId = insertedFlag!.flag_id;
                console.log(`[Safety Check] Flag ${newFlagId} inserted for message ${messageId}.`);
                if (teacherProfile?.email) {
                    const viewUrl = `${process.env.NEXT_PUBLIC_APP_URL}/teacher-dashboard/concerns/${newFlagId}`;
                    await sendTeacherAlert(teacherProfile.email,studentName,room.room_name || `Room (ID: ${room.room_id.substring(0,6)})`,concernType,concernLevel,messageContent,viewUrl);
                } else { console.warn(`[Safety Check] Teacher email for ${room.teacher_id} not found. Cannot send alert for flag ${newFlagId}.`);}
            } else { console.log(`[Safety Check] Concern level ${concernLevel} < threshold ${CONCERN_THRESHOLD} or not real.`); }

            if (aiGeneratedAdvice && aiGeneratedAdvice.trim() !== "") {
                console.log(`[Safety Check] Inserting AI-generated advice for student ${studentId} in room ${room.room_id}`);
                const { error: adviceInsertError } = await adminClient
                    .from('chat_messages')
                    .insert({
                        room_id: room.room_id,
                        user_id: studentId, 
                        role: 'system',    
                        content: aiGeneratedAdvice,
                        metadata: {
                            chatbotId: currentMessageData.metadata?.chatbotId || null, 
                            isSystemSafetyResponse: true, 
                            originalConcernType: concernType,
                            originalConcernLevel: concernLevel
                        },
                    });
                if (adviceInsertError) {
                    console.error(`[Safety Check] FAILED to insert AI advice message:`, adviceInsertError.message);
                } else {
                    console.log(`[Safety Check] Successfully inserted AI advice message.`);
                }
            }

        } else { console.log(`[Safety Check] No initial concern for message ${messageId}.`); }
    } catch (error) { console.error(`[Safety Check] CRITICAL ERROR for msg ${messageId}:`, error); }
    console.log(`[Safety Check] END - Checked message ID: ${messageId}`);
}{
  "US": [
    { "name": "Childhelp USA", "phone": "1-800-422-4453", "website": "childhelp.org", "short_desc": "Child abuse prevention & treatment" },
    { "name": "National Suicide & Crisis Lifeline", "phone": "988", "website": "988lifeline.org", "short_desc": "24/7 crisis support" },
    { "name": "Crisis Text Line", "text_to": "741741", "text_msg": "HOME", "short_desc": "Text support for any crisis" },
    { "name": "The Trevor Project", "phone": "1-866-488-7386", "website": "thetrevorproject.org", "short_desc": "For LGBTQ youth" }
  ],
  "CA": [
    { "name": "Kids Help Phone", "phone": "1-800-668-6868", "website": "kidshelpphone.ca", "short_desc": "24/7 youth support (text CONNECT to 686868)" },
    { "name": "Talk Suicide Canada", "phone": "1-833-456-4566", "website": "talksuicide.ca", "short_desc": "Suicide prevention & support (text 45645)" },
    { "name": "Canadian Centre for Child Protection", "website": "protectchildren.ca", "short_desc": "Child safety resources" }
  ],
  "GB": [
    { "name": "Childline", "phone": "0800 1111", "website": "childline.org.uk", "short_desc": "Support for children & young people" },
    { "name": "NSPCC Helpline", "phone": "0808 800 5000", "website": "nspcc.org.uk", "short_desc": "If you're worried about a child" },
    { "name": "Samaritans", "phone": "116 123", "website": "samaritans.org", "short_desc": "Emotional support, 24/7" },
    { "name": "Papyrus HOPELINEUK", "phone": "0800 068 4141", "website": "papyrus-uk.org", "short_desc": "Suicide prevention for under 35s" }
  ],
  "IE": [
    { "name": "Childline (ISPCC)", "phone": "1800 66 66 66", "website": "childline.ie", "short_desc": "24/7 support for children (text 'LIST' to 50101)" },
    { "name": "Samaritans Ireland", "phone": "116 123", "website": "samaritans.org/ireland/", "short_desc": "Emotional support, 24/7" },
    { "name": "Pieta House", "phone": "1800 247247", "website": "pieta.ie", "short_desc": "Suicide & self-harm crisis centre (text HELP to 51444)" }
  ],
  "FR": [
    { "name": "Allo Enfance en Danger", "phone": "119", "website": "allo119.gouv.fr", "short_desc": "National child protection helpline (24/7)" },
    { "name": "Suicide Écoute", "phone": "01 45 39 40 00", "website": "suicide-ecoute.fr", "short_desc": "Suicide prevention helpline" },
    { "name": "Net Ecoute (e-Enfance)", "phone": "3018", "website": "e-enfance.org/numero-3018/", "short_desc": "Protection for children online (cyberbullying, etc.)" }
  ],
  "ES": [
    { "name": "ANAR (Ayuda a Niños y Adolescentes en Riesgo)", "phone": "900 20 20 10", "website": "anar.org", "short_desc": "Help for children & adolescents at risk (24/7)" },
    { "name": "Teléfono de la Esperanza", "phone": "717 003 717", "website": "telefonodelaesperanza.org", "short_desc": "Crisis support line" }
  ],
  "IT": [
    { "name": "Telefono Azzurro", "phone": "19696", "website": "azzurro.it", "short_desc": "Child helpline (24/7)" },
    { "name": "Telefono Amico Italia", "phone": "02 2327 2327", "website": "telefonoamico.it", "short_desc": "Emotional support helpline (check hours)" }
  ],
  "PT": [
    { "name": "SOS Criança (IAC)", "phone": "116 111", "website": "iacrianca.pt", "short_desc": "Child helpline (check hours)" },
    { "name": "Voz de Apoio", "phone": "225 50 60 70", "website": "vozdeapoio.pt", "short_desc": "Emotional support helpline (check hours)" }
  ],
  "DE": [
    { "name": "Nummer gegen Kummer (Kinder- und Jugendtelefon)", "phone": "116 111", "website": "nummergegenkummer.de", "short_desc": "Helpline for children & youth (Mon-Sat)" },
    { "name": "TelefonSeelsorge", "phone": "0800 111 0 111", "website": "telefonseelsorge.de", "short_desc": "Crisis support (24/7)" }
  ],
  "GR": [
    { "name": "The Smile of the Child (National Helpline for Children SOS)", "phone": "1056", "website": "hamogelo.gr", "short_desc": "Child helpline (24/7)" },
    { "name": "KLIMAKA (Suicide Prevention)", "phone": "1018", "website": "klimaka.org.gr", "short_desc": "24/7 suicide prevention line" }
  ],
  "AU": [
    { "name": "Kids Helpline", "phone": "1800 55 1800", "website": "kidshelpline.com.au", "short_desc": "Counselling for young people 5-25 (24/7)" },
    { "name": "Lifeline Australia", "phone": "13 11 14", "website": "lifeline.org.au", "short_desc": "24/7 crisis support & suicide prevention" },
    { "name": "eSafety Commissioner", "website": "esafety.gov.au", "short_desc": "Online safety help & reporting" }
  ],
  "AE": [
    { "name": "Child Protection Centre (Ministry of Interior)", "phone": "116111", "website": "moi-cpc.ae", "short_desc": "Child protection helpline" },
    { "name": "Dubai Foundation for Women and Children", "phone": "800111", "website": "dfwac.ae", "short_desc": "Support for women & children (violence/abuse)" }
  ],
  "DEFAULT": [
    { "name": "Your Local Emergency Services", "short_desc": "Contact if in immediate danger (e.g., 911, 112, 999, 000)." },
    { "name": "A Trusted Adult", "short_desc": "Speak to a teacher, school counselor, parent, or another family member." },
    { "name": "Befrienders Worldwide", "website": "befrienders.org", "short_desc": "Find a crisis support center in your region." }
  ]
}// src/lib/safety/alerts.ts - Replace the existing function
import { sendEmail } from '@/lib/email/resend';  // Import the new function
import { APP_NAME } from '@/lib/utils/constants';

// Keep helper functions the same
export function getConcernTypeDisplayName(type: string): string {
  if (!type) return 'Unknown Concern';
  return type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

export function getConcernLevelDisplayName(level: number): string {
  if (level >= 5) return 'Critical';
  if (level >= 4) return 'High';
  if (level >= 3) return 'Significant';
  if (level >= 2) return 'Moderate';
  if (level >= 1) return 'Minor';
  return 'Low';
}

export async function sendTeacherAlert(
  teacherEmail: string,
  studentName: string,
  roomName: string,
  concernType: string,
  concernLevel: number,
  messageContent: string,
  viewUrl: string
): Promise<boolean> {
  // Basic validation
  if (!teacherEmail || !studentName || !roomName || !concernType || concernLevel < 0 || !messageContent || !viewUrl) {
    console.error('Missing required information for sending teacher alert');
    return false;
  }

  // Generate email content
  const concernTypeName = getConcernTypeDisplayName(concernType);
  const concernLevelName = getConcernLevelDisplayName(concernLevel);
  const subject = `[${APP_NAME}] ${concernLevelName} ${concernTypeName} Alert for Student: ${studentName}`;
  const displayedMessage = messageContent.replace(/</g, "&lt;").replace(/>/g, "&gt;");

  const html = `
    <!DOCTYPE html>
    <html>
    <head>
      <style>
        body { font-family: sans-serif; line-height: 1.6; color: #333; }
        h2 { color: #6B50B7; }
        h3 { color: #4A3889; }
        ul { list-style: none; padding: 0; }
        li { margin-bottom: 5px; }
        strong { font-weight: bold; }
        blockquote {
          border-left: 4px solid #E5E7EB;
          padding-left: 15px;
          margin-left: 0;
          color: #555;
          background-color: #F9FAFB;
          padding: 10px;
        }
        a.button {
          display: inline-block;
          padding: 12px 24px;
          background-color: #6B50B7;
          color: white !important;
          text-decoration: none;
          border-radius: 6px;
          font-weight: bold;
          text-align: center;
        }
         a.button:hover {
             background-color: #4A3889;
         }
      </style>
    </head>
    <body>
      <h2>${APP_NAME} - Student Welfare Alert</h2>
      <p>A message from a student in one of your classrooms has been automatically flagged for a potential welfare concern based on its content.</p>
      <p>Please review the details below and the conversation context as soon as possible.</p>

      <h3>Alert Details:</h3>
      <ul>
        <li><strong>Student:</strong> ${studentName}</li>
        <li><strong>Classroom:</strong> ${roomName}</li>
        <li><strong>Concern Type:</strong> ${concernTypeName}</li>
        <li><strong>Assessed Level:</strong> ${concernLevelName} (Level ${concernLevel})</li>
        <li><strong>Time Detected:</strong> ${new Date().toLocaleString()}</li>
      </ul>

      <h3>Flagged Message:</h3>
      <blockquote>
        <p>${displayedMessage}</p>
      </blockquote>

      <p>Click the button below to view the full conversation context and manage this alert:</p>
      <p style="text-align: center;">
        <a href="${viewUrl}" class="button">Review Concern Now</a>
      </p>
      <hr style="border: none; border-top: 1px solid #eee; margin: 20px 0;">
      <p style="font-size: 0.9em; color: #777;">This is an automated message from ${APP_NAME}. Please do not reply directly to this email.</p>
    </body>
    </html>
  `;

  // Use the Resend API to send the email
  return await sendEmail(
    teacherEmail,
    subject,
    html,
    `${APP_NAME} Safety`
  );
}// src/lib/pinecone/utils.ts
import { index, pinecone } from './client';
import { RecordMetadata } from '@pinecone-database/pinecone';

interface ChunkMetadata extends RecordMetadata {
  chatbotId: string;
  documentId: string;
  chunkId: string;
  text: string;
  fileName: string;
  fileType: string;
}

/**
 * Upsert vectors into Pinecone with enhanced error handling
 * @param vectors Array of vectors with their IDs and metadata
 */
export async function upsertVectors(
  vectors: { 
    id: string, 
    values: number[], 
    metadata: ChunkMetadata 
  }[]
) {
  // Validate that Pinecone is initialized
  if (!index || !pinecone) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    throw new Error('Pinecone client not initialized. Check API key and environment variables.');
  }

  try {
    // Use a smaller batch size to avoid timeouts
    const batchSize = 25; // Reduced from 50 to 25
    
    console.log(`Upserting ${vectors.length} vectors in batches of ${batchSize}`);
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      try {
        // Add retries for resilience
        let retries = 0;
        const maxRetries = 3;
        let success = false;
        
        while (!success && retries < maxRetries) {
          try {
            await index.upsert(batch);
            success = true;
            console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
          } catch (retryError) {
            retries++;
            console.warn(`Retry ${retries}/${maxRetries} failed:`, retryError);
            
            // Print detailed error information
            if (retryError instanceof Error) {
              console.warn('Error message:', retryError.message);
              
              // Log the first part of HTML responses for debugging
              if (retryError.message.includes('<!DOCTYPE')) {
                const htmlStart = retryError.message.substring(0, 200);
                console.warn('HTML error detected in response:', htmlStart);
                
                // Check for specific error signatures
                if (retryError.message.includes('401') || 
                    retryError.message.includes('unauthorized') || 
                    retryError.message.includes('authentication')) {
                  console.error('AUTHENTICATION ERROR: Check your Pinecone API key');
                }
              }
            }
            
            if (retries < maxRetries) {
              // Exponential backoff: 1s, 2s, 4s, etc.
              const delay = Math.pow(2, retries) * 1000;
              console.log(`Waiting ${delay}ms before retry...`);
              await new Promise(resolve => setTimeout(resolve, delay));
            }
          }
        }
        
        if (!success) {
          throw new Error(`Failed to upsert batch after ${maxRetries} retries`);
        }
      } catch (batchError) {
        console.error(`Error upserting batch ${Math.floor(i/batchSize) + 1}:`, batchError);
        
        // Try upserting one by one as a fallback with additional retry logic
        console.log("Trying to upsert vectors one by one...");
        for (const vector of batch) {
          try {
            let individualRetries = 0;
            const maxIndividualRetries = 2;
            
            while (individualRetries < maxIndividualRetries) {
              try {
                await index.upsert([vector]);
                break; // Success, exit retry loop
              } catch (singleRetryError) {
                individualRetries++;
                console.warn(`Individual vector retry ${individualRetries}/${maxIndividualRetries} failed:`, singleRetryError);
                
                if (individualRetries >= maxIndividualRetries) {
                  console.error(`Failed to upsert vector ${vector.id} after ${maxIndividualRetries} retries`);
                } else {
                  // Wait before retry
                  await new Promise(resolve => setTimeout(resolve, 500));
                }
              }
            }
          } catch (singleError) {
            console.error(`Failed to upsert vector ${vector.id}:`, singleError);
          }
        }
      }
      
      // Add a slightly longer delay between batches to avoid rate limits
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    console.log(`Completed upserting vectors to Pinecone`);
    return true;
  } catch (error) {
    console.error('Error in upsertVectors:', error);
    
    // Provide more detailed error information
    if (error instanceof Error) {
      if (error.message.includes('<!DOCTYPE')) {
        console.error('Received HTML response instead of JSON. This typically indicates:');
        console.error('1. Authentication failure (check your API key)');
        console.error('2. Network proxy interference');
        console.error('3. Service endpoint issues');
        
        // Extract status code if present in HTML
        const statusMatch = error.message.match(/<title>(\d+)[^<]*<\/title>/);
        if (statusMatch && statusMatch[1]) {
          console.error(`Status code found in HTML: ${statusMatch[1]}`);
        }
      }
    }
    
    throw new Error(`Failed to upsert vectors: ${error instanceof Error ? error.message : String(error)}`);
  }
}

// Rest of the functions remain the same...

export async function queryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return [];
  }

  try {
    const results = await index.query({
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    
    return results.matches;
  } catch (error) {
    console.error('Error querying vectors:', error);
    return []; // Return empty array instead of throwing
  }
}

export async function deleteDocumentVectors(documentId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        documentId: { $eq: documentId }
      }
    });
    console.log(`Successfully deleted vectors for document ${documentId}`);
  } catch (error) {
    console.error('Error deleting vectors:', error);
    throw new Error('Failed to delete vectors');
  }
}

export async function deleteChatbotVectors(chatbotId: string) {
  if (!index) {
    console.error('Pinecone client not initialized. Check your API key and environment variables.');
    return;
  }

  try {
    await index.deleteMany({
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    });
    console.log(`Successfully deleted all vectors for chatbot ${chatbotId}`);
  } catch (error) {
    console.error('Error deleting chatbot vectors:', error);
    throw new Error('Failed to delete chatbot vectors');
  }
}// src/lib/pinecone/direct-api.ts
/**
 * This file implements direct fetch-based API calls to Pinecone
 * to bypass any issues with the Pinecone SDK
 */

// Use node-fetch for compatibility
import fetch from 'node-fetch';

interface PineconeVector {
  id: string;
  values: number[];
  metadata?: Record<string, unknown>;
}

interface PineconeResponse {
  status: number;
  statusText: string;
  data?: unknown;
  error?: string;
}

// Add specific interface for query response
interface PineconeQueryResponse extends PineconeResponse {
  data?: {
    matches?: Array<{
      id: string;
      score: number;
      metadata: Record<string, unknown>;
    }>;
  };
}

/**
 * Make a direct API call to Pinecone with detailed logging
 */
async function callPineconeAPI(
  endpoint: string,
  method: 'GET' | 'POST' | 'DELETE' = 'GET',
  body?: unknown
): Promise<PineconeResponse> {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is missing');
    return {
      status: 401,
      statusText: 'Unauthorized',
      error: 'API key is missing'
    };
  }
  
  const url = `https://api.pinecone.io/v1/indexes/${indexName}${endpoint}`;
  
  console.log(`Making ${method} request to Pinecone: ${url}`);
  
  try {
    // Make the API call with fetch
    const response = await fetch(url, {
      method,
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': apiKey
      },
      body: body ? JSON.stringify(body) : undefined
    });
    
    console.log(`Pinecone API response status: ${response.status} ${response.statusText}`);
    
    // Handle non-JSON responses
    const contentType = response.headers.get('content-type');
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json();
      return {
        status: response.status,
        statusText: response.statusText,
        data
      };
    } else {
      // Handle HTML or other non-JSON responses
      const text = await response.text();
      console.error('Received non-JSON response from Pinecone:');
      console.error(`Status: ${response.status} ${response.statusText}`);
      console.error(`Content-Type: ${contentType}`);
      console.error(`Response (first 200 chars): ${text.substring(0, 200)}`);
      
      if (text.includes('<!DOCTYPE')) {
        // Parse out any error message from HTML
        const titleMatch = text.match(/<title>([^<]+)<\/title>/);
        const messageMatch = text.match(/<p>([^<]+)<\/p>/);
        
        const errorTitle = titleMatch ? titleMatch[1] : 'Unknown error';
        const errorMessage = messageMatch ? messageMatch[1] : text.substring(0, 100);
        
        return {
          status: response.status,
          statusText: response.statusText,
          error: `HTML response: ${errorTitle} - ${errorMessage}`
        };
      }
      
      return {
        status: response.status,
        statusText: response.statusText,
        error: `Non-JSON response: ${text.substring(0, 100)}`
      };
    }
  } catch (error) {
    console.error('Error making Pinecone API call:', error);
    return {
      status: 500,
      statusText: 'Internal Error',
      error: error instanceof Error ? error.message : String(error)
    };
  }
}

/**
 * Upsert vectors directly to Pinecone
 */
export async function directUpsertVectors(vectors: PineconeVector[]): Promise<boolean> {
  try {
    // Split vectors into smaller batches
    const batchSize = 20;
    let allSuccessful = true;
    
    for (let i = 0; i < vectors.length; i += batchSize) {
      const batch = vectors.slice(i, i + batchSize);
      console.log(`Upserting batch ${Math.floor(i/batchSize) + 1}/${Math.ceil(vectors.length/batchSize)}`);
      
      const result = await callPineconeAPI('/vectors/upsert', 'POST', {
        vectors: batch
      });
      
      if (result.status >= 400 || result.error) {
        console.error(`Error upserting batch: ${result.error || result.statusText}`);
        allSuccessful = false;
        
        // Try single vector upserts as fallback
        console.log('Attempting individual vector upserts as fallback...');
        
        for (const vector of batch) {
          const singleResult = await callPineconeAPI('/vectors/upsert', 'POST', {
            vectors: [vector]
          });
          
          if (singleResult.status >= 400 || singleResult.error) {
            console.error(`Failed to upsert vector ${vector.id}: ${singleResult.error || singleResult.statusText}`);
          } else {
            console.log(`Successfully upserted vector ${vector.id}`);
          }
        }
      } else {
        console.log(`Successfully upserted batch ${Math.floor(i/batchSize) + 1}`);
      }
      
      // Add a delay between batches
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    return allSuccessful;
  } catch (error) {
    console.error('Error in directUpsertVectors:', error);
    return false;
  }
}

/**
 * Query vectors directly from Pinecone
 */
export async function directQueryVectors(
  queryVector: number[],
  chatbotId: string,
  topK: number = 5
) {
  try {
    // Query vectors directly from Pinecone
    const result = await callPineconeAPI('/query', 'POST', {
      vector: queryVector,
      topK,
      includeMetadata: true,
      filter: {
        chatbotId: { $eq: chatbotId }
      }
    }) as PineconeQueryResponse;
    
    if (result.status >= 400 || result.error) {
      console.error(`Error querying vectors: ${result.error || result.statusText}`);
      return [];
    }
    
    // Now TypeScript knows that result.data?.matches exists
    return result.data?.matches || [];
  } catch (error) {
    console.error('Error in directQueryVectors:', error);
    return [];
  }
}

/**
 * Delete vectors for a specific document directly from Pinecone
 */
export async function directDeleteDocumentVectors(documentId: string): Promise<boolean> {
  try {
    const result = await callPineconeAPI('/vectors/delete', 'POST', {
      filter: {
        documentId: { $eq: documentId }
      }
    });
    
    if (result.status >= 400 || result.error) {
      console.error(`Error deleting document vectors: ${result.error || result.statusText}`);
      return false;
    }
    
    return true;
  } catch (error) {
    console.error('Error in directDeleteDocumentVectors:', error);
    return false;
  }
}

/**
 * Check Pinecone API connectivity and report detailed status
 */
export async function checkPineconeStatus(): Promise<{
  isConnected: boolean;
  details: string;
  stats?: unknown;
}> {
  try {
    const result = await callPineconeAPI('/describe_index_stats');
    
    if (result.status >= 400 || result.error) {
      return {
        isConnected: false,
        details: result.error || `API error: ${result.status} ${result.statusText}`
      };
    }
    
    return {
      isConnected: true,
      details: 'Successfully connected to Pinecone',
      stats: result.data
    };
  } catch (error) {
    return {
      isConnected: false,
      details: error instanceof Error ? error.message : String(error)
    };
  }
}// src/lib/pinecone/client.ts
import { Pinecone } from '@pinecone-database/pinecone';

// More robust way to check environment variables
const getPineconeConfig = () => {
  const apiKey = process.env.PINECONE_API_KEY;
  const indexName = process.env.PINECONE_INDEX_NAME || 'classbots-knowledge';
  
  if (!apiKey) {
    console.error('PINECONE_API_KEY is not defined in environment variables');
  }
  
  console.log("Pinecone Configuration:");
  console.log(`- API Key exists: ${!!apiKey}`);
  console.log(`- Index Name: ${indexName}`);
  
  return { apiKey, indexName };
};

// Create client with proper error handling
let pineconeClient: Pinecone | null = null;
let indexClient: ReturnType<Pinecone['index']> | null = null;

try {
  const { apiKey, indexName } = getPineconeConfig();
  
  if (apiKey) {
    pineconeClient = new Pinecone({
      apiKey,
    });
    
    // Get the index for our embeddings
    indexClient = pineconeClient.index(indexName);
    console.log("Pinecone client initialized successfully");
  } else {
    console.error("Failed to initialize Pinecone client: Missing API key");
  }
} catch (error) {
  console.error("Error initializing Pinecone client:", error);
}

export const pinecone = pineconeClient;
export const index = indexClient;// src/lib/StyledComponentsRegistry.tsx
'use client';

import { useState } from 'react';
import { useServerInsertedHTML } from 'next/navigation';
import { ServerStyleSheet, StyleSheetManager } from 'styled-components';

export default function StyledComponentsRegistry({
  children,
}: {
  children: React.ReactNode;
}) {
  // Only create stylesheet once with lazy initial state
  const [styledComponentsStyleSheet] = useState(() => new ServerStyleSheet());

  useServerInsertedHTML(() => {
    const styles = styledComponentsStyleSheet.getStyleElement();
    styledComponentsStyleSheet.instance.clearTag();
    return <>{styles}</>;
  });

  if (typeof window !== 'undefined') return <>{children}</>;

  return (
    <StyleSheetManager sheet={styledComponentsStyleSheet.instance}>
      {children}
    </StyleSheetManager>
  );
}// src/lib/email/resend.ts
import { Resend } from 'resend';

const resendApiKey = process.env.SMTP_PASSWORD || '';  // Reuse your existing API key
const resend = new Resend(resendApiKey);

export async function sendEmail(
  to: string,
  subject: string,
  html: string,
  fromName: string = 'ClassBots Safety',
  fromEmail: string = 'onboarding@resend.dev'
): Promise<boolean> {
  try {
    console.log(`Sending email via Resend API to ${to}`);
    
    const { data, error } = await resend.emails.send({
      from: `${fromName} <${fromEmail}>`,
      to: to,
      subject: subject,
      html: html,
    });
    
    if (error) {
      console.error('Resend API Error:', error);
      return false;
    }
    
    console.log('Email sent successfully with Resend API', data);
    return true;
  } catch (error) {
    console.error('Error sending email with Resend API:', error);
    return false;
  }
}// src/lib/openai/embeddings.ts
import openai from './client';

/**
 * Generate embeddings for a text using OpenAI's embedding model
 * @param text The text to generate embeddings for
 * @returns An array of floating point numbers representing the embedding
 */
export async function generateEmbedding(text: string): Promise<number[]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: text,
      encoding_format: "float",
    });

    return response.data[0].embedding;
  } catch (error) {
    console.error('Error generating embedding:', error);
    throw new Error('Failed to generate embedding');
  }
}

/**
 * Generate embeddings for multiple texts in a batch
 * @param texts Array of texts to generate embeddings for
 * @returns Array of embedding arrays
 */
export async function generateEmbeddings(texts: string[]): Promise<number[][]> {
  try {
    const response = await openai.embeddings.create({
      model: "text-embedding-3-small",
      input: texts,
      encoding_format: "float",
    });

    return response.data.map(item => item.embedding);
  } catch (error) {
    console.error('Error generating embeddings:', error);
    throw new Error('Failed to generate embeddings');
  }
}// src/lib/openai/client.ts
import { OpenAI } from 'openai';

// Initialize the OpenAI client with API key from environment variables
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export default openai;